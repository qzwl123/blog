{"meta":{"title":"秃头王","subtitle":"","description":"","author":"John Doe","url":"https://tutouwang.vercel.app","root":"/"},"pages":[{"title":"","date":"2021-03-10T02:48:59.102Z","updated":"2021-03-10T02:47:10.545Z","comments":true,"path":"404.html","permalink":"https://tutouwang.vercel.app/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-03-10T02:39:15.459Z","updated":"2021-03-10T02:39:15.459Z","comments":true,"path":"about/index.html","permalink":"https://tutouwang.vercel.app/about/index.html","excerpt":"","text":"啊吧啊吧啊吧！！！"},{"title":"所有分类","date":"2021-03-10T02:43:26.017Z","updated":"2021-03-10T02:43:26.017Z","comments":true,"path":"categories/index.html","permalink":"https://tutouwang.vercel.app/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-03-10T02:44:59.392Z","updated":"2021-03-10T02:44:59.392Z","comments":true,"path":"tags/index.html","permalink":"https://tutouwang.vercel.app/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-10T02:46:22.827Z","updated":"2021-03-10T02:46:22.827Z","comments":true,"path":"mylist/index.html","permalink":"https://tutouwang.vercel.app/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"并查集","slug":"并查集","date":"2021-03-27T10:08:15.000Z","updated":"2021-03-27T10:43:22.250Z","comments":true,"path":"2021/03/27/并查集/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/27/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集(Union Find)并查集主要讲的就是连通性问题 比如说现在咱们这个教学楼，被大水淹了比如说一楼和其它楼层都被大水淹了，就唯独咱们教室没有，可以说明什么，咱们现在就是与世隔绝了，之后呢就被大水淹没的个个楼层水是不是都可以来回走，比如流到了咱们教室恰巧关上了们，之后水就没流进来，说明什么咱们现在是与这个教学楼的一间教室都不连图，如果说咱们与隔壁是连通的，而且咱们隔壁还被大水淹没了，你说咱们这屋是不是也被淹没了。 若某个家族人员过于庞大，要判断两个是否是亲戚，确实不容易，给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。 树形结构在春秋战国时期有各种思想学术流派的成就，有 孔子 墨子 老子 还有谁比如 韩非子等等 从我们当前图中我门可以看出我们有几个连同块 有3个对把 比如说有一天 2 号 跟 4号 打起来来了说你写的东西不如我，（这里有个规定就是说徒弟一定不如师傅）完了4号本身就是1号的徒弟肯定不如2号 当然 4号有师傅 之后4号找到自己的师傅 1 号 说今天我被人羞辱了对吧那当师傅的肯定不能做事不管对吧 之后一看 说这2号也老孔的徒弟一看这不是就是一个师傅么那就别报仇了 让 4 号 给 2 号认个错 就是下次的时候我们可以怎么看 就是先知道自己的师傅的师傅是谁对吧 在看你要找的人的师傅的师傅（这师傅可能还有师傅所有要找到最后一个师傅）是谁 如果他们最后的师傅都是同一个人那他们是不是就是一家人属于同一个师傅 （可以说明他们在通一课树中说明它们俩个连同） 其实我们在连同性中不在乎连接成什么样子谁是谁的徒弟我只在乎他们能不能连同最后的祖师，祖师爷是不是同一个人 这个两个点能不能连同 Ps 比如 （1， 2） 为一个集合 数组表示 （1，4） （4，7） 这里代表两个集合链接，这里链接的时候你说是 1 当作根节点还是 4 当作根节点 1 其实是无所谓的。这里假定 4为根节点我们可以得到 图 这两个点的连同不仅仅是两个点的连同而是两个集合的连通（其实他们都属一个个体） 比如你的爸和你妈是两个姓对吧 他们在没结婚之前是什么，两个家的人就可以比作什么两个集合，之后他们结婚了 是只有他俩是一家人么 不是吧 是两家人，这就好比我们两个点的链接。 我们可以用数组表示 初始化把每个点所在的集合初始化为其自身。 初始化加粗 为下标 我们可以用用它自身去初始化（也可以用 -1 但是后期在优化的时候会有点麻烦） 0 1 2 3 0 1 2 3 4 5 6 7 4 5 6 7 0 1 2 3 0 4 2 3 4 5 6 7 4 5 6 4 竞赛阶段我们会用到的算法 find union123456789101112131415161718// 朴素int find_root(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;// 查找--优化int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x]; // return x == parent[x] ? x : parent[x] = find_root(parent[x], parent); // return parent[x] = (x == parent[x] ? x : find_root(parent[x], parent));&#125; 123456789101112131415161718192021// 合并void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; // parent[x_root] = y_root; // 原先代码 // 安秩合并 if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; return ; &#125; mark = 1; return ;&#125; 路径压缩–按秩合并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int mark = 0;// 初始化void inital(int n, int parent[], int height[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; height[i] = 0; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x]; // &#125;// 路径压缩--非递归版int find_root1(int x, int parent[]) &#123; int k = x; while (parent[k] != k) &#123; k = parent[k]; &#125; while (x != k) &#123; int temp = parent[x]; parent[x] = k; x = temp; &#125; return k;&#125;void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; // parent[x_root] = y_root; // 原先代码 // 按秩合并 if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; return ; &#125; mark = 1; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10], height[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; inital(m, parent, height); for (int i = 0; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(x, y, parent, height); &#125; if (mark) cout &lt;&lt; &quot;有环！&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;无环！&quot; &lt;&lt; endl; return 0;&#125; 路径压缩是怎么实现的 检测是否存在环我们如何去检测一个图是否存在环环路 如下 我们有 0️⃣ 1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 把每个点看成单个集合比如我们相连（0 ，1） （1，2） （1，3）（2，4）（2，3） 我们在合并时候需要先查询一下他们是否属于同一集合，如果不属于同一集合我才能合并，反之要是它们在合并就会构成回路。 如果不考虑链接红色两点，合并集合之后是{0，1，2，3，4} 我们可以得到站在任意点到达另一任意点。不构成环 如果说我们在已连接中任意选择两个去链接他一定会成环对吧。🔶 比如红色两点链接，我们可以看到 1， 2， 3 点形成了环。 形成环路 我们怎么知道他是成环了呢我们把 1 当做根结点 ，0， 2，4，3 都属于 1 的孩子或者是孙子 当你去链接 （2， 3）时候你会发现他们都属于 1 下就如我们刚才所说 🔶因为我们知道两个集合在合并的时候一定会先去找根节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int mark = 0;int parent[MAX_N + 10];// 初始化void inital(int n, int parent[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; &#125; return ;&#125;int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;void merge(int x, int y, int parent[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; parent[x_root] = y_root; return ; &#125; mark = 1; return ;&#125;int main() &#123; int n, m; // 组数 最大值 cin &gt;&gt; n &gt;&gt; m; inital(m, parent); for (int i = 0; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(x, y, parent); &#125; if (mark) cout &lt;&lt; &quot;有环！&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;无环！&quot; &lt;&lt; endl; return 0;&#125; 并查集–数据结构实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;struct UnionSet &#123; int *parent;&#125;;// 初始化UnionSet *init(int n) &#123; UnionSet *U = (UnionSet *)malloc(sizeof(UnionSet)); U-&gt;parent = (int *)malloc(sizeof(int) * (n + 1)); for (int i = 1; i &lt;= n; i++) &#123; U-&gt;parent[i] = i; &#125; return U;&#125;int find_root(UnionSet *U, int x) &#123; if (U-&gt;parent[x] != x) &#123; return find_root(U, U-&gt;parent[x]); &#125; return x;&#125;void merge(UnionSet *U, int x, int y) &#123; int x_root = find_root(U, x); int y_root = find_root(U, y); if (x_root != y_root) &#123; U-&gt;parent[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); UnionSet *U = init(n); // 进行 M 次操作 for (int i = 1; i &lt;= m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); switch(a) &#123; case 1: merge(U, b, c); break; // 合并操作 case 2: printf(&quot;%s\\n&quot;, find_root(U, b) == find_root(U, c) ? &quot;Yes&quot; : &quot;No&quot;); &#125; &#125; return 0;&#125; 例题–题解海贼 #71 朋友圈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/************************************************************************* &gt; File Name: 海贼_#71并查集_路径压缩优化.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年01月18日 星期一 15时33分00秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e4;// 初始化void initialization(int n, int parent[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;// 朴素算法int find_root1(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;void merge(int x, int y, int parent[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; parent[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; initialization(n, parent); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if (a == 1) &#123; // 添加 merge(b, c, parent); &#125; else &#123; // 查看 if (find_root(b, parent) - find_root(c, parent)) &#123; printf(&quot;No\\n&quot;); &#125; else printf(&quot;Yes\\n&quot;); &#125; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/************************************************************************* &gt; File Name: 海贼_#71并查集_路径压缩_安秩合并_优化.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年01月18日 星期一 21时33分00秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e4;// 初始化 void initialization(int n, int parent[], int height[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; // 开始树高为 0 height[i] = 0; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;// 朴素算法int find_root1(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; &#125; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10], height[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; initialization(n, parent, height); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if (a == 1) &#123; // 添加 merge(b, c, parent, height); &#125; else &#123; // 查看 if (find_root(b, parent) - find_root(c, parent)) &#123; printf(&quot;No\\n&quot;); &#125; else printf(&quot;Yes\\n&quot;); &#125; &#125; return 0;&#125; 洛谷 P1551 亲戚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int arr[MAX_N];void initial(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; arr[i] = i; &#125;&#125;int find(int x) &#123; if (arr[x] != x) &#123; x = find(arr[x]); &#125; return arr[x];&#125;void merge(int x, int y) &#123; int x_root = find(x); int y_root = find(y); if (x_root != y_root) &#123; arr[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; initial(n); while (m--) &#123; int mi, mj; cin &gt;&gt; mi &gt;&gt; mj; merge(mi, mj); &#125; while (p--) &#123; int mi, mj; cin &gt;&gt; mi &gt;&gt; mj; if (find(mi) == find(mj)) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://tutouwang.vercel.app/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"蓝桥杯省赛_B组组_十届","slug":"蓝桥杯省赛_B组组_十届","date":"2021-03-21T09:07:43.000Z","updated":"2021-03-21T09:30:56.062Z","comments":true,"path":"2021/03/21/蓝桥杯省赛_B组组_十届/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/21/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B_B%E7%BB%84%E7%BB%84_%E5%8D%81%E5%B1%8A/","excerpt":"","text":"试题A:平方序列","categories":[{"name":"蓝桥杯历届真题","slug":"蓝桥杯历届真题","permalink":"https://tutouwang.vercel.app/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"排序合集","slug":"排序合集","date":"2021-03-14T01:48:14.000Z","updated":"2021-04-03T07:38:30.808Z","comments":true,"path":"2021/03/14/排序合集/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/14/%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/","excerpt":"","text":"怎么区分稳定还是不稳定如果在原序列里面两个数是相同的，那么排完序位置没有发生变化那么 这个排序就是稳定的，如果发生变化那么这个排序就是不稳定的。 冒泡排序（稳定） 考虑冒泡排序的复杂度，对于拥有N个字母的字符串，最多需要交换 N*(N - 1) / 2 次（完全逆序） 快速排序（不稳定）随机快速排序过程 确定分界点（也叫选择基准数）：$q[L], q[(L + R) / 2], q[R]$ 调整区间： 递归：处理左右两端排序，如果左右两侧都排序好了在合并一起那么就是一个有序的序列了 （暴力）版 可以先开辟两个空的数组 a[] 和 b[] 在 L 到 R 区间内扫描一遍 把 &gt;= x 和 &lt;= x 的数拆分出来放到 a, b 数组 $q[L - R] $ $q[i] &lt;= x, q[i] - &gt; a[]$ // q[i] &lt;= x 就它放到 a 数组里面 $q[i] &gt;= x, q[i] -&gt; b[]$ // q[i] &gt;= x 就它放到 b 数组里面 $a[] -&gt; q[], b[]-&gt;q[]$ //在把 a，b 数组数据在合并到 q 数组里面 （基础）版我们可以定义两个指针从线段两侧往中间走只要（i &lt; j) 红色i 蓝色j，如果红色指针要小于基准数那么i++, 如果红色指针要大于基准数了，那么判断j指针数是否大于基准值如果大于那么j++, 如果小于那么 交换i, j 指针。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/************************************************************************* &gt; File Name: Demo15.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2021年03月16日 星期二 20时37分05秒 ************************************************************************/#include&lt;stdio.h&gt;#define MAX_N 100000#define swap(a, b) &#123;\\ a ^= b, b ^= a, a ^= b;\\&#125;int q[MAX_N + 10];void quick_sort(int l, int r) &#123; if (l &gt;= r) return ; // 如果下面递归左右 选的是j的话 基准指数一定不能选 q[r] 要不然回发生边界问题 int x = q[l], i = l - 1, j = r + 1; while (i &lt; j) &#123; do i++; while (q[i] &lt; x); do j--; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); &#125; // 遍历左侧 quick_sort(l, j); // 遍历右侧 quick_sort(j + 1, r); return ;&#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, q + i); &#125; quick_sort(0, n - 1); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, q[i]); &#125; return 0;&#125; 归并排序（稳定） 确定分界点 mid(L + R) / 2 (这里的分界点是数组下标的位置)而快排是随机确定数组里面数。 递归排序左右两面。 归并（把排序好的左右两侧合并到一起）。","categories":[{"name":"算法基础","slug":"算法基础","permalink":"https://tutouwang.vercel.app/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"ACwin104_货仓选址","slug":"ACwin104_货仓选址","date":"2021-03-13T09:39:11.000Z","updated":"2021-03-13T13:12:12.671Z","comments":true,"path":"2021/03/13/ACwin104_货仓选址/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/13/ACwin104_%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80/","excerpt":"","text":"原题链接 题目：在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN。 现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。 为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。 输入格式第一行输入整数 N。 第二行 N 个整数 A1∼ AN 输出格式输出一个整数，表示距离之和的最小值。 数据范围$1≤N≤1000001≤N≤100000$$0 ≤ Ai ≤ 400000 ≤ Ai ≤ 40000$ 输入样例：1246 2 9 1 输出样例：112 解题思路:那面如何选择中位数仓库x如果当n等于奇数那么中间的数就是中位数，如果n是偶数那么现在中间两个其实一都可以。 首先考虑在坐标轴上建立仓库$x$如图 假设货仓在中间可得$|a - x| + |b - x| &gt;= |a - b|$，$|a - x|$就是a 到 x的距离 同理 $|b - x|、 |a - b|$ 如果货仓在最左侧或者最右侧情况，那么可以看出$|x - a|$的距离就走了两遍所有放在中间才是最优解。 第一种做法：12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#define MAX_N 100000int f[MAX_N + 10];int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, f + i); &#125; std::sort(f, f + n); int res = 0; for (int i = 0; i &lt; n; i++) &#123; res += abs(f[i] - f[n &gt;&gt; 1]); &#125; printf(&quot;%d\\n&quot;, res); return 0;&#125;","categories":[{"name":"ACwin题解","slug":"ACwin题解","permalink":"https://tutouwang.vercel.app/categories/ACwin%E9%A2%98%E8%A7%A3/"},{"name":"中位数","slug":"ACwin题解/中位数","permalink":"https://tutouwang.vercel.app/categories/ACwin%E9%A2%98%E8%A7%A3/%E4%B8%AD%E4%BD%8D%E6%95%B0/"}],"tags":[{"name":"中位数","slug":"中位数","permalink":"https://tutouwang.vercel.app/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"}]},{"title":"背包九讲","slug":"背包九讲","date":"2021-03-07T04:21:06.000Z","updated":"2021-06-03T06:59:38.973Z","comments":true,"path":"2021/03/07/背包九讲/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/07/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","excerpt":"","text":"动态规划 动态规划（Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息 学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题）， 再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归 的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少 计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查 表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 在大家看完什么是动态规划后就是说我们在之前也做题中可能也遇到过动态规划的题比如斐波那契数列 如 1，1， 2， 3… 就是这个 2 怎么来的就是 1 + 1 = 2 之后 3 的下一项是什么？就是 2 + 3 = 5 也就是说 3 的下一项就是 5 之后下几项就是 8，13，21…就会得到这组序列 我们如果相求第n斐波那契数列可以得到转移公式 $Fib(n) = Fib(n - 1) + Fib(n - 2);$ (Fib(1) = 1 和 Fib(2) = 1是由题目给出的，n &gt; 2 ) 完整的斐波那契数列 加上出口就是 n = 1 or n = 2 返回 1 , 就是说我们这里为什么提出这个斐波那契数列呢就是我们在递归时候，我们呢会发现他的递归式中会出现重叠的子问题，为什么会这么说我来计算一下斐波那契数列 第 5 项 Fib(5) 可得出如下 假如说我们用数组去求解Fib(6) 是不就可以直接用之前求Fib(5) + Fib(4) 的 直接得到 Fib(6) 这样我是不是就可以省去求重叠子问题的时间，这样我们的时间复杂度就从o(2^n^) 变成 o(n)(当然这个时间复杂度也是能弄记忆化搜索优化的)。 例题 01 背包 只又 2 种选择一种选一种不选。 洛谷 P1048 采药 完全背包 每件物品可以无限选（只要不超过背包的总体积）。 洛谷 P1616 疯狂的采药 多重背包 每个物品有相应的个数。 洛谷 P1776 宝物筛选 混合背包 基于以上上面三种背包。 洛谷 P1833 樱花 二维费用背包 类比以一维费用01背包，推广二维费用01背包。 洛谷 P1507 NASA的食物计划 分组背包 有 n 组物品 每组物品有若干个，同一组内互相冲突，同一组最多只能选一个或者不选 洛谷 P1757 通天之分组背包 有依赖的背包 类似捆绑销售 买附必须买主，买主可以不买附 洛谷 P1064 金明的预算方案 背包九讲0-1背包题目：有一天小鲁同学在家里学习算法，小鲁的妈妈就叫这个铲屎官小鲁去收拾一下，但是小鲁很不想去就说我在学习算法，小鲁的妈妈就说你要是在不去我就把你一起也铲出去，小鲁就想被你铲除去还不如我自己走，这样小鲁就回到了自己的房间，打破了储存已久的小猪储存罐🐖。 小鲁的背包可容纳下总重量为 20（ s ） 他需要带尽可能多的钱走。（没种钱可以重复的选取没有上限）。 简单的说： 有N件物品和一个容量为T的背包。第i件物品的费用是t[i]，价值是v[i]。求解将哪些物品装入背包可使价值总和最大。 下标 重量（w） 价值 （v） 1 2 3 2 3 4 3 4 5 4 5 8 5 9 10 这里为什么不用贪心而用动态规划？ 首先贪心他是局部最优解，而我所讲的动态规划可以达到全局最优解。 基本思路： 首先我们考虑什么，取不取第 n 件物品？ 取 $-&gt; n - 1$ 个物品，背包大小 $s - w[n]$ 不取$ -&gt; n - 1$ 个物品，背包大小 s 定义状态：$dp[i][j]$ 表示考虑前 i 个物品，背包大小 $0 -&gt; j $, 获得最大价值。 转移方程：$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])$ 代码实现：无优化-代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;#define MAX_N 1000int dp[MAX_N + 10][MAX_N + 10];int t[MAX_N + 10], v[MAX_N + 10];void backpack(int k, int T) &#123; for (int i = 1; i &lt;= k; i++) &#123; for (int j = 1; j &lt;= T; j++) &#123; if (t[i] &gt; j) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; int Y = dp[i - 1][j - t[i]] + v[i]; int T = dp[i - 1][j]; dp[i][j] = Y &gt; T ? Y : T; // dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); &#125; &#125; &#125;&#125;int main() &#123; int T, n; cin &gt;&gt; T &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; t[i] &gt;&gt; v[i]; &#125; backpack(n, T); cout &lt;&lt; dp[n][T];&#125; 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;const int MAX_N = 1e3;int n, m;int f[MAX_N + 10][MAX_N + 10], w[MAX_N + 10], v[MAX_N + 10];int main() &#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; w[i] &gt;&gt; v[i]; &#125; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; f[i][j] = f[i - 1][j]; if(j &gt;= w[i]) f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]); &#125; &#125; cout &lt;&lt; f[m][n] &lt;&lt; endl; return 0;&#125; 优化-代码12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;#define MAX_N 1000int dp[MAX_N];int T[MAX_N], V[MAX_N];void backpack(int k, int s) &#123; for (int i = 1; i &lt;= k; i++) &#123; for (int j = s; j &gt;= T[i]; j--) &#123; dp[j] = max(dp[j], dp[j - T[i]] + V[i]); &#125; &#125; return ;&#125;int main() &#123; int t, n; cin &gt;&gt; t &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; T[i] &gt;&gt; V[i]; &#125; backpack(n, t); cout &lt;&lt; dp[t]; return 0;&#125; 上面朴素算法时间复杂度与空间复杂度皆为 O(t*n) 其中时间复杂度不能再优化, 而空间复杂度可以 优化为O(t), 下面我们来讲解如何优化到一维数组 细节问题 1 我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。如果是第一种问法，要求恰好装满背包，那么在初始化时除了f[0]为0其它f[1..V]均设为-∞，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。 2 如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f[0..V]全部设为0。为什么呢？ 3 可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的（相当于没装东西），其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。这个小技巧完全可以推广到其它类型的背包问题，后面也就不再对进行状态转移之前的初始化进行讲解。 完全背包题目：有N种物品和一个容量为T的背包，每种物品都有无限件可用。第i种物品的费用是t[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路：和 01背包很相似 转移方程相同 转移方程：$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])$ 与 01背包的区别–第二个循环 01背包 在更新时候倒序因为是需要用之前元素 代码实现：无优化-代码123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;long long dp[MAX_N + 10][MAX_N +10];long long t[MAX_N + 10], v[MAX_N + 10];void backpack(int k, int s) &#123; for (int i = 1; i &lt;= k; i++) &#123; for (int j = 1; j &lt;= s; j++) &#123; if (j &lt; t[i]) dp[i][j] = dp[i - 1][j]; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - t[i]] + v[i]); &#125; &#125; &#125; return ;&#125;int main() &#123; int T, n; cin &gt;&gt; T &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; t[i] &gt;&gt; v[i]; &#125; backpack(n, T); cout &lt;&lt; dp[n][T] &lt;&lt; endl; return 0;&#125; 优化-代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e7;long long B[MAX_N + 10];int t[MAX_N + 10], v[MAX_N + 10];void backpack(int k, int s) &#123; for (int i = 1; i &lt;= k; i++) &#123; for (int j = t[i]; j &lt;= s; j++) &#123; B[j] = max(B[j], B[j - t[i]] + v[i]); &#125; &#125; return ;&#125;int main() &#123; int T, n; cin &gt;&gt; T &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; t[i] &gt;&gt; v[i]; &#125; backpack(n, T); cout &lt;&lt; B[T] &lt;&lt; endl; return 0;&#125; 多重背包题目：有N种物品和一个容量为s的背包。第i种物品最多有m[i]件可用，每件费用是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路：这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有m[i]+1种策略：取0件，取1件……取n[i]件。令f[i][j]表示前i种物品恰放入一个容量为v的背包的最大权值。 则转移方程： $dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * w] + k * v);$ 代码实现：无优化-代码1234567891011121314151617181920212223242526// 多重背包 朴素 算法#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e3;int dp[MAX_N + 10][MAX_N + 10];int main() &#123; int n, s; cin &gt;&gt; n &gt;&gt; s; for (int i = 1; i &lt;= n; i++) &#123; // 价值 重量 组数 int v, w, m; cin &gt;&gt; v &gt;&gt; w &gt;&gt; m; for (int j = s; j &gt;= w; j--) &#123; // 背包容量 for (int k = 0; k &lt;= m &amp;&amp; j &gt;= k * w; k++) &#123; // 决策 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * w] + k * v); &#125; &#125; &#125; cout &lt;&lt; dp[n][s] &lt;&lt; endl; return 0;&#125; 转化为01背包问题 另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成log(m)件01背包中的物品. 但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想. 二进制优化 假设有50个苹果，现在要取n个苹果(n≤50），如何取?朴素的做法应该是将苹果一个一个拿出来，直到n个苹果被取出来。再假设有50个苹果和6只箱子，利用箱子进行某些预备工作，可以在每个箱子中放2(k≥0)个苹果，也就是1、2、4、8、16、19（剩余的数），取任意n个苹果时，只要推出忆只箱子就可以了。 lg45÷lg2=1.6532125÷0.301029996=5.49185 优化-代码123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e5;int dp[MAX_N + 10];int ww[MAX_N + 10], vv[MAX_N + 10], mm[MAX_N + 10];int main () &#123; int n, s, count = 1, v, w, m; cin &gt;&gt; n &gt;&gt; s; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v &gt;&gt; w &gt;&gt; m; for (int j = 1; j &lt;= m; j &lt;&lt;= 1) &#123; ww[count] = j * w; vv[count++] = j * v; m -= j; &#125; // 处理 二进制拆分不了的 if (m) &#123; ww[count] = m * w; vv[count++] = m * v; &#125; &#125; // 01 背包 模板 for (int i = 1; i &lt; count; i++) &#123; for (int j = s; j &gt;= ww[i]; j--) &#123; dp[j] = max(dp[j], dp[j - ww[i]] + vv[i]); &#125; &#125; cout &lt;&lt; dp[s] &lt;&lt; endl; return 0;&#125; 混合背包题目：如果将 01背包、完全背包、多重背包、混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背1包）。应该怎么求解呢？ 基本思路： 01背包与完全背包的混合 我只需要考虑到在01背包和完全背包中给出的代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可. 12345678if // 如果是 01 背包 for (int j = s; j &gt;= w[i] j--) &#123; dp[j] = max(dp[j], dp[j - w[i]] + v[i]); &#125;else // 如果是 完全背包 for (int j = w[i]; j &lt;= s; j++) &#123; dp[j] = max(dp[j], dp[j - w[i]] + v[i]); &#125; 再加上多重背包 如果再加上有的物品最多可以取有限次，我们就可以用二进制拆分来把多重背包转换成01背包 1234567891011// m = 物品最多能取的个数for (int j = 1; j &lt;= m; j &lt;&lt;= 1) &#123; ww[count] = j * w; vv[count++] = j * v; m -= j;&#125;// 处理 二进制拆分不了的if (m) &#123; ww[count] = m * w; vv[count++] = m * v;&#125; 题解-代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e5;int dp[MAX_N + 10], ww[MAX_N + 10], vv[MAX_N + 10], mark[MAX_N + 10];int main() &#123; int T, t1, t11, t2, t22, n, count = 1; scanf(&quot;%d:%d %d:%d %d&quot;, &amp;t1, &amp;t11, &amp;t2, &amp;t22, &amp;n); T = (t2 * 60 + t22) - (t1 * 60 + t11); for (int i = 1; i &lt;= n; i++) &#123; int w, v, m; cin &gt;&gt; w &gt;&gt; v &gt;&gt; m; if (!m) &#123; ww[count] = w; vv[count] = v; // 标记为 0 代表可以重复观看 完全背包 mark[count++] = 0; &#125; else &#123; // 二进制拆分转换 01背包 for (int j = 1; j &lt;= m; j &lt;&lt;= 1) &#123; ww[count] = j * w; vv[count] = j * v; // 标记为 1 代表每棵树只能看或者不看 01背包 mark[count++] = 1; m -= j; &#125; // 因为二进制拆分 只能是 1 2 4 8 16 32 比如 m = 10 二进制拆分之后还会余下 1 下面 if 就是解决那个多余出来的 if (m) &#123; ww[count] = m * w; vv[count] = m * v; mark[count++] = 1; &#125; &#125; &#125; // 实现 01背包 和 完全背包 模板就行了 for (int i = 1; i &lt; count; i++) &#123; if (mark[i]) &#123; // 如果 mark[i] == 1 就执行 01背包 for (int j = T; j &gt;= ww[i]; j--) &#123; dp[j] = max(dp[j], dp[j - ww[i]] + vv[i]); &#125; &#125; else &#123; for (int j = ww[i]; j &lt;= T; j++) &#123; dp[j] = max(dp[j], dp[j - ww[i]] + vv[i]); &#125; &#125; &#125; cout &lt;&lt; dp[T] &lt;&lt; endl; return 0;&#125; 二维费用背包题目：二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和Q。物品的价值为v[i]。 基本思路：费用加了一维，只需状态也加一维即可。设dp[i][j][k]表示前i件物品付出两种代价分别为m和w时可获得的最大价值。 状态转移方程就是：$f [i][j][k]=max{f[i-1][j][k],f[i-1][f-a[i]][k-b[i]]+v[i]}$。 如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量m和w采用顺序的循环。 大概就是 由一维01背包费用推广二维01背包费用还可以推广三维，四维，…..N维。 当物品有如完全背包问题时采用逆序的循环。 当物品有如多重背包问题时拆分物品。 题解-代码：1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e3;int dp[MAX_N + 10][MAX_N + 10];int main() &#123; int V, Q, n; cin &gt;&gt; V &gt;&gt; Q &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; int m, w, v; cin &gt;&gt; m &gt;&gt; w &gt;&gt; v; for (int j = V; j &gt;= m; j--) &#123; for (int k = Q; k &gt;= w; k--) &#123; dp[j][k] = max(dp[j][k], dp[j - m][k - w] + v); &#125; &#125; &#125; cout &lt;&lt; dp[V][Q] &lt;&lt; endl; return 0;&#125; 分组的背包问题题目：有N件物品和一个容量为S的背包。第i件物品的费用是w[i]，价值是v[i]，组别g[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件或者不选,如果同属于v[i]组一共有m个那最多就有m + 1种选法。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路：$dp[i][j]$ 表前 i 组物品，能放下容量为j的背包的最大价值。 朴素算法 对第 i 组物品，容量为 j 的背包，有 m + 1种选法。 $max(dp[i-1][j], dp[i - 1][j - w[1]], dp[i - 1][j - w[2]]…dp[i - 1][j - w[m]])$ 这里基本就是01背包模板直接用01背包优化版的板子就可以了。 题解-代码：123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e3;int dp[MAX_N + 10];int w[MAX_N + 10], v[MAX_N + 10], g[MAX_N + 10], gg[MAX_N + 10][MAX_N + 10];int main() &#123; int n, s, nn = 0; cin &gt;&gt; s &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; int t; scanf(&quot;%d%d%d&quot;, &amp;w[i], &amp;v[i], &amp;t); nn = max(t, nn); g[t]++; gg[t][g[t]] = i; &#125; // 枚举 nn 个组 for (int i = 1; i &lt;= nn; i++) &#123; for (int j = s; j &gt;= 0; j--) &#123; // 背包容量 for (int k = 0; k &lt;= g[i]; k++) &#123; // 决策 if (j &gt;= w[gg[i][k]]) // 不选从 k - 1 个物品中选择一个价值最大的 dp[j] = max(dp[j], dp[j - w[gg[i][k]]] + v[gg[i][k]]); &#125; &#125; &#125; cout &lt;&lt; dp[s] &lt;&lt; endl; return 0;&#125; 问背包容量与决策循环是否可以调换？ 不能 因为更新$dp[j]$时用到$dp[i][j - w[k]]$的值，$dp[j- w[k]]$与$dp[i-1][j-w[k]]$ 有依赖的背包基本思路：这种背包问题的物品间存在某种“依赖”的关系。也就是说，物品 i 依赖于物品 j， 表示若选物品 i，则必须选物品 j。为了简化起见，我们先设没有某个物品既依赖于别 的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。 这个问题由 NOIP2006 中“金明的预算方案”一题扩展而来。遵从该题的提法，将 不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题 的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。 就好比如 你大一学的c\\c++语言完了大二才能学数据结构，就是你不能直接学数据结构要先学完c\\c++这就是依赖关系 可看上面例题 看题, 我们在选择时候会有5种情况： 选或者不选 选 、只选这个主件 不选、直接考虑下一个 选这个主件 选这个主件、并且选附件1 选这个主件、并且选附件2 选这个主件、 并且选附件1和附件2 例题-代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e6;int dp[MAX_N + 10];int w[MAX_N + 10], v[MAX_N + 10], g[MAX_N + 10][3], mark[MAX_N + 10];int main() &#123; int n, s; scanf(&quot;%d%d&quot;, &amp;s, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int p, q; scanf(&quot;%d%d%d&quot;, &amp;w[i], &amp;p, &amp;q); mark[i] = q; v[i] = w[i] * p; if (q) &#123; g[q][0]++; g[q][g[q][0]] = i; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if(mark[i] != 0) continue; for (int j = s; j &gt;= w[i]; j--) &#123; // 1、不选 或者 只选择主件 dp[j] = max(dp[j], dp[j - w[i]] + v[i]); // 2、选择第一个附件 if (j &gt;= w[g[i][1]] + w[i] &amp;&amp; g[i][1] != 0) &#123; dp[j] = max(dp[j], dp[j - w[i] - w[g[i][1]]] + v[i] + v[g[i][1]]); &#125; // 3、选择第二个附件 if (j &gt;= w[g[i][2]] + w[i] &amp;&amp; g[i][2] != 0) &#123; dp[j] = max(dp[j], dp[j - w[i] - w[g[i][2]]] + v[i] + v[g[i][2]]); &#125; // 4、两个附件都选 if (j &gt;= w[g[i][1]] + w[g[i][2]] + w[i] &amp;&amp; g[i][1] != 0 &amp;&amp; g[i][2] != 0) &#123; dp[j] = max(dp[j], dp[j - w[i] - w[g[i][1]] - w[g[i][2]]] + v[i] + v[g[i][1]]+ v[g[i][2]]); &#125; &#125; &#125; cout &lt;&lt; dp[s] &lt;&lt; endl; return 0;&#125; 泛化物品 (了解)定义考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的 费用而变化。这就是泛化物品的概念。 更严格的定义之。在背包容量为 V 的背包问题中，泛化物品是一个定义域为 0 . . . V 中的整数的函数 h，当分配给它的费用为 v 时，能得到的价值就是 h(v)。 这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组 h[0 . . . V ]，给它 费用 v，可得到价值 h[v]。 一个费用为 c 价值为 w 的物品，如果它是 01 背包中的物品，那么把它看成泛化物 品，它就是除了 h(c) = w 外，其它函数值都为 0 的一个函数。如果它是完全背包中的 物品，那么它可以看成这样一个函数，仅当 v 被 c 整除时有 h(v) = w · v c，其它函数值 均为 0。如果它是多重背包中重复次数最多为 m 的物品，那么它对应的泛化物品的函 数有 h(v) = w · v c 仅当 v 被 c 整除且 v c ≤ n，其它情况函数值均为 0。 一个物品组可以看作一个泛化物品 h。对于一个 0 . . . V 中的 v，若物品组中不存在 费用为 v 的物品，则 h(v) = 0，否则 h(v) 取值为所有费用为 v 的物品的最大价值。6中 每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。 视频","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://tutouwang.vercel.app/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"背包九讲","slug":"背包九讲","permalink":"https://tutouwang.vercel.app/tags/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tutouwang.vercel.app/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"蓝桥杯省赛 B组 十一届 第二场","slug":"蓝桥杯省赛_B组_十一届_第二场","date":"2021-03-06T04:21:06.000Z","updated":"2021-03-10T03:22:59.156Z","comments":true,"path":"2021/03/06/蓝桥杯省赛_B组_十一届_第二场/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B_B%E7%BB%84_%E5%8D%81%E4%B8%80%E5%B1%8A_%E7%AC%AC%E4%BA%8C%E5%9C%BA/","excerpt":"","text":"蓝桥杯省赛 B组 十一届 第二场试题A:门牌制作 答案：624 1234567891011121314151617181920212223242526/************************************************************************* &gt; File Name: 十一届—试题A门牌制作.cppz &gt; Author: &gt; Mail: &gt; Created Time: 2021年02月28日 星期日 16时31分53秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;const int MAX_N = 2020;int f[MAX_N + 10];int main() &#123; int n = 0; for (int i = 1; i &lt;= 2020; i++) &#123; int t = i; while (t) &#123; if (t % 10 == 2) n++; t /= 10; &#125; &#125; cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; 试题B:既约分数 答案：2481215 12345678910111213141516171819202122 /************************************************************************* &gt; File Name: 十一届—试题B既约分数.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年02月28日 星期日 19时46分32秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n = 0; for (int i = 1; i &lt;= 2020; i++) &#123; for (int j = 1; j &lt;= 2020; j++) &#123; if(__gcd(i, j) == 1) n++; &#125; &#125; cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; 试题C:蛇形填数 题解思路：有题目可以得出， 红色偶数是斜着向下，蓝色奇数是斜着向上由此可以写出代码。 答案：761 123456789101112131415161718192021222324252627282930313233343536/************************************************************************* &gt; File Name: 蛇形填数.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年02月28日 星期日 20时08分21秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;const int MAX_N = 40;int f[MAX_N][MAX_N];int main() &#123; int n = 1; for (int i = 1; i &lt;= MAX_N; i++) &#123; if (i &amp; 1) &#123; // 奇数的情况 for (int x = i, y = 1; x &gt;= 1 &amp;&amp; y &lt;= i; x--, y++) &#123; f[x][y] = n++; &#125; &#125; else &#123; for (int x = 1, y = i; x &lt;= i &amp;&amp; y &gt;= 1; x++, y--) &#123; f[x][y] = n++; &#125; &#125; &#125; for (int i = 1; i &lt;= 20; i++) &#123; for (int j = 1; j &lt;= 20; j++) &#123; cout &lt;&lt; f[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 试题D:跑步锻炼 答案：8879 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/************************************************************************* &gt; File Name: 跑步锻炼.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年03月01日 星期一 13时00分05秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;// 列出所有月份之后 在特殊处理 2 月int m[13] = &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;int leap_year(int x) &#123; if ((x % 4 == 0 &amp;&amp; x % 100 != 0) || x % 400 == 0) return 1; return 0;&#125;int main() &#123; int s = 0; int mark = 6; // 这里题目给出 2000 年 至 2020 年 因为题目给出 2020年不是整月所以就单处理一下 for (int i = 2000; i &lt; 2020; i++) &#123; if (leap_year(i)) m[2] = 29; else m[2] = 28; for (int j = 1; j &lt;= 12; j++) &#123; for (int k = 1; k &lt;= m[j]; k++) &#123; if (mark % 7 == 1 || k == 1) s += 2; else s++; mark++; &#125; &#125; &#125; // 闰年 29 平年 28 if (leap_year(2020)) m[2] = 29; else m[2] = 28; for (int i = 1; i &lt;= 9; i++) &#123; for (int j = 1; j &lt;= m[i]; j++) &#123; if (mark % 7 == 1 || j == 1) s += 2; else s++; mark++; &#125; &#125; // 题目要求 只道 10 月 1 日 由于还是 月初 所以加上 + 2 cout &lt;&lt; s + 2; return 0;&#125; 试题E:七段码 答案：80 来源于网上一个大佬 枚举出所有情况的做法 $$上面是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一 个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分$$ 试题F:成绩统计 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main() &#123; int n; int E = 0, G = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; int t; cin &gt;&gt; t; if (t &gt; 60) G++; if (t &gt; 85) E++; &#125; int t = E * 100.0 / n + 0.5; int t1 = G * 100.0 / n + 0.5; printf(&quot;%d%%\\n%d%%&quot;, t1, t); return 0;&#125;","categories":[{"name":"蓝桥杯历届真题","slug":"蓝桥杯历届真题","permalink":"https://tutouwang.vercel.app/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯历届真题","slug":"蓝桥杯历届真题","permalink":"https://tutouwang.vercel.app/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98/"},{"name":"算法基础","slug":"算法基础","permalink":"https://tutouwang.vercel.app/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"ACwin题解","slug":"ACwin题解","permalink":"https://tutouwang.vercel.app/categories/ACwin%E9%A2%98%E8%A7%A3/"},{"name":"中位数","slug":"ACwin题解/中位数","permalink":"https://tutouwang.vercel.app/categories/ACwin%E9%A2%98%E8%A7%A3/%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tutouwang.vercel.app/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://tutouwang.vercel.app/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"中位数","slug":"中位数","permalink":"https://tutouwang.vercel.app/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"name":"背包九讲","slug":"背包九讲","permalink":"https://tutouwang.vercel.app/tags/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tutouwang.vercel.app/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]}