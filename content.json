{"meta":{"title":"秃头王","subtitle":"","description":"","author":"John Doe","url":"https://tutouwang.vercel.app","root":"/"},"pages":[{"title":"","date":"2021-03-10T02:48:59.102Z","updated":"2021-03-10T02:47:10.545Z","comments":true,"path":"404.html","permalink":"https://tutouwang.vercel.app/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-03-10T02:39:15.459Z","updated":"2021-03-10T02:39:15.459Z","comments":true,"path":"about/index.html","permalink":"https://tutouwang.vercel.app/about/index.html","excerpt":"","text":"啊吧啊吧啊吧！！！"},{"title":"","date":"2021-03-10T02:46:22.827Z","updated":"2021-03-10T02:46:22.827Z","comments":true,"path":"mylist/index.html","permalink":"https://tutouwang.vercel.app/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-11-07T14:27:04.766Z","updated":"2021-03-10T02:43:26.017Z","comments":true,"path":"categories/index.html","permalink":"https://tutouwang.vercel.app/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-03-10T02:44:59.392Z","updated":"2021-03-10T02:44:59.392Z","comments":true,"path":"tags/index.html","permalink":"https://tutouwang.vercel.app/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"栈与队列","slug":"栈与队列","date":"2022-01-16T01:45:23.000Z","updated":"2022-01-16T01:45:23.663Z","comments":true,"path":"2022/01/16/栈与队列/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/16/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"链表","slug":"链表","date":"2022-01-15T02:32:20.000Z","updated":"2022-01-15T09:54:55.425Z","comments":true,"path":"2022/01/15/链表/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/15/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"链表单向链表结点组成部分 数据域 - data 指针域 - next / 后继 插入 - 结点 把待插入数据创建成一个结点 把待插入结点指向新建结点的next 把待插入结点前一个结点的next指向新建结点 代码演示 - 单向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/************************************************************************* &gt; File Name: 链表.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月15日 星期六 11时09分25秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define COLOR_HL(a, b) &quot;\\033[1;&quot; #b &quot;m&quot; a &quot;\\033[0m&quot;#define GREEN_HL(a) COLOR_HL(a, 32)typedef struct ListNode &#123; int data; struct ListNode *next;&#125; ListNode;typedef struct List &#123; // 虚拟头 ListNode head; int length;&#125; List;ListNode *getNewNode(int);List *getLinkList();void clear_node(ListNode *);void clear(List *);int insert(List*, int, int);int erase(List *, int);void reverse(List *);ListNode* getNewNode(int val) &#123; // sizeof ListNode 可以不加括号 可能是在c语言中不行 ListNode *p = (ListNode *) malloc(sizeof (ListNode)); p-&gt;data = val; p-&gt;next = NULL; return p;&#125;List *getLinkList() &#123; List *l = (List *)malloc(sizeof(List)); l-&gt;head.next = NULL; l-&gt;length = 0; return l;&#125;void clear_node(ListNode *node) &#123; if(node == NULL) return ; free(node); return ;&#125;void clear(List * l) &#123; if(l == NULL) return ; ListNode *p = l-&gt;head.next; ListNode *t = NULL; if(p != NULL) &#123; t = p-&gt;next; clear_node(p); p = t; &#125; free(l); return ;&#125;int insert(List *l, int ind, int val) &#123; if(l == NULL) return 0; if(ind &lt; 0 || ind &gt; l-&gt;length) return 0; ListNode *p = getNewNode(val); ListNode *h = &amp;(l-&gt;head); while(ind--) h = h-&gt;next; p-&gt;next = h-&gt;next; h-&gt;next = p; l-&gt;length++; return 1;&#125;int erase(List *l, int ind) &#123; if(l == NULL) return 0; if(ind &lt; 0 || ind &gt;= l-&gt;length) return 0; ListNode *h = &amp;(l-&gt;head); // 这里说明一下为什么不 直接 h-&gt;next = h-&gt;next-&gt;next; // 1. 这个操作是合法的 但是要这样操作的就会发生内存泄漏 // 2. 所有我们这里需要一个临时变量 t 来存储待删除结点 之后好free掉 ListNode *t = NULL; while(ind--) h = h-&gt;next; t = h-&gt;next; h-&gt;next = t-&gt;next; l-&gt;length--; clear_node(t); return 1;&#125;void output(List *l) &#123; if(l == NULL) return ; printf(&quot;List(%d) : &quot;, l-&gt;length); ListNode *h = l-&gt;head.next; while(h != NULL) &#123; printf(&quot;%d-&gt;&quot;, h-&gt;data); h = h-&gt;next; &#125; printf(&quot;NULL\\n\\n&quot;);&#125;void reverse(List *l) &#123; if(l == NULL) return ; ListNode *h = l-&gt;head.next; l-&gt;head.next = NULL; ListNode *t = NULL; while(h != NULL) &#123; t = h-&gt;next; t = l-&gt;head.next; l-&gt;head.next = h; h = t; &#125; return ;&#125;int main() &#123; srand(time(0)); // 20 次测试 #define MAX_OP 20 List *l = getLinkList(); for(int i = 0; i &lt; MAX_OP; i++) &#123; int val = rand() % 100; int ind = rand() % (l-&gt;length + 3) - 1; // 想变大插入概率 可以把 2 变成 4 // case 0 1 2 3 int op = rand() % 3; switch(op) &#123; case 0: &#123; printf(&quot;erase a iterm at %d from List = %d \\n&quot;, ind, erase(l, ind)); break; &#125; case 1: &#123; printf(&quot;insert %d at %d to List = %d \\n&quot;, val, ind, insert(l, ind, val)); break; &#125; case 2: &#123; printf(GREEN_HL(&quot;reverse the list ! \\n&quot;)); reverse(l); break; &#125; &#125; output(l); &#125; #undef MAX_OP clear(l); return 0;&#125; 单线循环链表 头- -&gt; 尾","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://tutouwang.vercel.app/tags/%E9%93%BE%E8%A1%A8/"},{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"顺序表","slug":"顺序表","date":"2022-01-14T03:11:14.000Z","updated":"2022-01-14T14:00:01.720Z","comments":true,"path":"2022/01/14/顺序表/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/14/%E9%A1%BA%E5%BA%8F%E8%A1%A8/","excerpt":"","text":"数据结构 = 结构定义 + 结构操作cppreference https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5 顺序表 - 线性结构：一对一1.什么是顺序表？ 是一个更高级的数组 结构定义： 一片连续存储空间 可以存储任意类型值 (类型需要一致，int、char、结构体…) (data_type) 顺序表大小 (size) 顺序表以存储个数 (length) 结构操作： 插入元素 (insert) 如果第一个满足只执行1不满足可以直接执行 2 可以通过整理 直接用2来实现 如果代插入数据i 等于i == length 那么直接在后面添加length++ 在待插入位置i 把i + 1 后数据全部向后移动一位,并且legth++ 删除元素 (clear) 待删位置 i 把i + 1之后位置的数据向前移动一位 覆盖掉 length-- 新知识1234567891011121314151617181920212223242526272829#include &lt;stdlib.h&gt; // malloc 需要头文件#include &lt;stdio.h&gt;#demine MAX_N 20/* 函数中 // int arr[n + 1]; // 栈区 在Linux系统中只有 8M 很小 * malloc 动态开辟空间 如果不用需要主动释放 返回值是一块连续的地址(逻辑上) void* * calloc 参数size为申请地址的单元元素长度，nmemb为元素个数，即在内存中申请nmemb *size字节大小的连续地址空间， 并赋值0-相当于自带初始化； * realloc 给一个已经分配了地址的指针重新分配空间，参数ptr为原有的空间地址，size为重新申请的地址长度； * free 释放 **/int main() &#123; // 函数 malloc int *v = (int *) malloc(sizeof(int) * MAX_N); free(v); v = NULL; // 函数 calloc int *v1 = (int *) calloc(20, MAX_N * sizeof(int)); free(v); v = NULL; // 函数 realloc 在 malloc 基础上 // 数字数量大于当前 malloc 大小 重新分配 int *v = (int *) malloc(sizeof(int) * MAX_N); v = (int *) realloc (v, 5 * sizeof(int) * MAX_N); free(v); v = NULL; return 0;&#125; 代码演示-顺序表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/************************************************************************* &gt; File Name: 顺序表.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月14日 星期五 12时03分03秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define COLOR(a, b) &quot;\\033[&quot; #b &quot;m&quot; a&quot;\\033[0m&quot;#define GREEN(a) COLOR(a, 32)#define RED(a) COLOR(a, 31)typedef int Type;typedef struct Vector &#123; Type *data; int size, length;&#125; Vec;Vec *init(int n) &#123; // int arr[n + 1]; // 栈区 在Linux系统中只有 8M 很小 Vec *v = (Vec *)malloc(sizeof(Vec)); v-&gt;data = (Type *)malloc(sizeof(Type) * n); v-&gt;size = n; v-&gt;length = 0; return v;&#125;void clear(Vec *v) &#123; if(v == NULL) return ; // 如果内存申请失败 free(v-&gt;data); // 申请了2个空间 free(v); return ;&#125;// 扩容int expand(Vec *v) &#123; int extr_size = v-&gt;size; Type *p; while(extr_size) &#123; p = (Type *)realloc(v-&gt;data, sizeof(Type) * (v-&gt;size + extr_size)); if(p != NULL) break; extr_size &gt;&gt;= 1; &#125; if(p == NULL) &#123; printf(RED(&quot;扩容失败\\n&quot;)); return 0; &#125; v-&gt;size += extr_size; v-&gt;data = p; printf(GREEN(&quot;当前容量 : %d -- 扩容到 : %d\\n&quot;), v-&gt;size - extr_size, v-&gt;size); return 1;&#125;int insert(Vec *v, int ind, Type val) &#123; // ind 需要插入的位置 if(v == NULL) return 0; if(ind &lt; 0 || ind &gt; v-&gt;length) return 0; if(v-&gt;length == v-&gt;size) &#123; if(!expand(v)) return 0; &#125; for(int i = v-&gt;length; i &gt; ind; i--) &#123; v-&gt;data[i] = v-&gt;data[i - 1]; &#125; v-&gt;data[ind] = val; v-&gt;length +=1; return 1;&#125;int erase(Vec *v, int ind) &#123; if(v == NULL) return 0; if(ind &lt; 0 || ind &gt;= v-&gt;length) return 0; for(int i = ind + 1; i &lt; v-&gt;length; i++) &#123; v-&gt;data[i - 1] = v-&gt;data[i]; &#125; v-&gt;length--; return 1;&#125;void output(Vec *v) &#123; if(v == NULL) return ; printf(&quot;Vector(%d) :[&quot;, v-&gt;length); for(int i = 0; i &lt; v-&gt;length; i++) &#123; i &amp;&amp; printf(&quot;,&quot;); printf(&quot;%d&quot;, v-&gt;data[i]); &#125; printf(&quot;]\\n&quot;); return ;&#125;int main() &#123; #define MAX_N 20 Vec *v = init(1); srand(time(0)); for(int i = 0; i &lt; MAX_N; i++) &#123; int op = rand() % 2; int ind = rand() % (v-&gt;length + 3) - 1; int val = rand() % 100; switch(op) &#123; case 0: printf(&quot;insert %d at %d to Vector = %d \\n&quot;, val, ind, insert(v, ind, val)); break; case 1: printf(&quot;erase a iterm at %d from Vector = %d\\n&quot;, ind, erase(v, ind)); break; &#125; output(v), printf(&quot;\\n&quot;); &#125; clear(v); #undef MAX_N return 0;&#125;","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"StackReverse","slug":"StackReverse","date":"2022-01-06T02:14:14.000Z","updated":"2022-01-06T02:39:44.531Z","comments":true,"path":"2022/01/06/StackReverse/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/06/StackReverse/","excerpt":"","text":"Stack - 翻转1234567891011121314151617181920212223242526272829303132333435363738394041424344/************************************************************************* &gt; File Name: stackRecerse.cpp &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月06日 星期四 10时15分16秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;void reverseStack(stack&lt;string&gt; &amp;f, string &amp;res) &#123; // 当然这里 string res 也可以写成另一个 栈 这里这个引用会加点速 if(!f.empty()) &#123; string t = f.top(); f.pop(); reverseStack(f, res); res += t + &quot; &quot;; &#125; return ;&#125;int main() &#123; stack&lt;string&gt; f, f1; f.push(&quot;a&quot;); f.push(&quot;b&quot;); f.push(&quot;c&quot;); f.push(&quot;d&quot;); f.push(&quot;e&quot;); f.push(&quot;f&quot;); f1 = f; while(!f1.empty()) &#123; cout &lt;&lt; f1.top() &lt;&lt; &quot; &quot;; f1.pop(); &#125; cout &lt;&lt; endl; string res; reverseStack(f, res); cout &lt;&lt; res; return 0;&#125;xxxxxxxxxx int /************************************************************************* &gt; File Name: stackRecerse.cpp &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月06日 星期四 10时15分16秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;void reverseStack(stack&lt;string&gt; &amp;f, string &amp;res) &#123; // 当然这里 string res 也可以写成另一个 栈 这里这个引用会加点速 if(!f.empty()) &#123; string t = f.top(); f.pop(); reverseStack(f, res); res += t + &quot; &quot;; &#125; return ;&#125;int main() &#123; stack&lt;string&gt; f, f1; f.push(&quot;a&quot;); f.push(&quot;b&quot;); f.push(&quot;c&quot;); f.push(&quot;d&quot;); f.push(&quot;e&quot;); f.push(&quot;f&quot;); f1 = f; while(!f1.empty()) &#123; cout &lt;&lt; f1.top() &lt;&lt; &quot; &quot;; f1.pop(); &#125; cout &lt;&lt; endl; string res; reverseStack(f, res); cout &lt;&lt; res; return 0;&#125;","categories":[],"tags":[]},{"title":"将b进制数转化成十进制","slug":"将b进制数转化成十进制","date":"2022-01-05T12:38:52.000Z","updated":"2022-01-05T13:55:02.407Z","comments":true,"path":"2022/01/05/将b进制数转化成十进制/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/05/%E5%B0%86b%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E5%8C%96%E6%88%90%E5%8D%81%E8%BF%9B%E5%88%B6/","excerpt":"","text":"秦九韶算法-将b进制数转化成十进制有二进制1010 取出 第一位 1 1 * 2 + 0 = 2 10 * 2 + 1 == 2 * 2 + 1 10 = 5 5 * 2 + 0 = 10 有二进制1010 二进制转换成十进制:基数乘以权,然后相加 $$ 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0$$ $$ = ((1 * 2 + 0) * 2 + 1 ) * 2 + 0$$ 123456int get(string s, b) &#123; int res = 0; for(auto c : s) res = res * b + c- &#x27;0&#x27;; return res;&#125;","categories":[],"tags":[]},{"title":"继承","slug":"继承","date":"2021-11-19T11:50:51.000Z","updated":"2021-12-24T13:57:00.325Z","comments":true,"path":"2021/11/19/继承/","link":"","permalink":"https://tutouwang.vercel.app/2021/11/19/%E7%BB%A7%E6%89%BF/","excerpt":"","text":"继承123456789// 派生类 B 基类 Aclass B&#123;public : &#125;;// class A : public B &#123; &#125;; 继承权限影响的什么 类外对于访问子类对继承父类的方法和属性的访问权限 继承的好处： 代码的复用性 逻辑上的递进关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172/************************************************************************* &gt; File Name: 继承.cpp &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2021年11月19日 星期五 19时55分12秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;#define BEGINS(x) namespace x &#123; // namesoace of x#define ENDS(x) &#125; // namespace of xBEGINS(test1)class Base &#123;public : int x;protected : int y;private : int z;&#125;;class public_Bace : public Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected //z = 2; // no, z private &#125;&#125;;class protected_Bace : protected Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected //z = 2; // no, z private &#125;&#125;;class private_Bace : private Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected // z = 2; // no, z private &#125;&#125;;int main() &#123; public_Bace a; // 都是继承父类的方法 // 继承 + x 在父类中的权限 = 表现出来的 a.x = 3; // ok, putback + public = public // a.y = 4; // no, public + protected = protected // a.z = 5; // no, public + private = private protected_Bace b; // b.x = 3; // no, protected + public = protected // b.y = 4; // no, protected + protected = protected // b.z = 5; // no, protected + private = private private_Bace c; // c.x = 3; // no, private + public = private // c.y = 4; // no, private + protected = private // c.z = 5; // no, private + private = private return 0;&#125;ENDS(test1)BEGINS(test2)class Base &#123;public : Base(string name) : class_name(name)&#123;&#125; int x; string class_name;private : int y;&#125;;class A : public Base &#123;public: A() : Base(&quot;class_A&quot;)&#123;&#125;&#125;;class B : public Base &#123;public: B() : Base(&quot;class_B&quot;)&#123;&#125;&#125;;class C : public Base &#123;public: C() : Base(&quot;class_C&quot;)&#123;&#125;&#125;;void func(Base &amp;b) &#123; cout &lt;&lt; &quot;nput class : &quot; &lt;&lt; b.class_name &lt;&lt; endl; return ;&#125;int main() &#123; A a; B b; C c; // 隐式类型转换 子类 -&gt; 父类 func(a); func(b); func(c); cout &lt;&lt; &quot;sizeof(Base) = &quot; &lt;&lt; sizeof(Base) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(A) = &quot; &lt;&lt; sizeof(A) &lt;&lt; endl; return 0;&#125;ENDS(test2)BEGINS(test3)class Base &#123;public : Base(string name) : class_name(name)&#123;&#125; int x; string class_name;private : int y;&#125;;class A : public Base &#123;public: A() : Base(&quot;class_A&quot;)&#123;&#125;&#125;;class B : public Base &#123;public: B() : Base(&quot;class_B&quot;)&#123;&#125;&#125;;class C : public Base &#123;public: C() : Base(&quot;class_C&quot;)&#123;&#125;&#125;;void func(Base *b) &#123; cout &lt;&lt; &quot;nput class : &quot; &lt;&lt; b-&gt;class_name &lt;&lt; endl; return ;&#125;int main() &#123; A a; B b; C c; // 子类的地址也是可以转换成父类的地址 func(&amp;a); func(&amp;b); func(&amp;c); return 0;&#125;ENDS(test3)int main() &#123; // test1::main(); // test2::main(); test3::main(); return 0;&#125; 继承-构造函数构造顺序与析构顺序一定是相反的 先构造一定后析构 先析构子类的属性后析构父类的属性 菱形继承-多继承是不是所有的面向对象语言都允许多继承? 不是 C#、java 是不允许多继承的 A ( run () ) B ( run () ) C ( run () ) D ( run () ) 菱形继承有些场景是可以编译通过但是输出不确定 先是完成 基类构造 在完成 派生类构造 拷贝&amp;赋值–继承先完成父类的拷贝行为 在完成子类的拷贝行为 拷贝行为 拷贝构造函数：显示调用父类拷贝构造 赋值运算符：显示调用父类的赋值运算函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232/************************************************************************* &gt; File Name: 继承.cpp &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2021年11月19日 星期五 19时55分12秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;#define BEGINS(x) namespace x &#123; // namesoace of x#define ENDS(x) &#125; // namespace of xBEGINS(test1)class Base &#123;public : int x;protected : int y;private : int z;&#125;;class public_Bace : public Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected //z = 2; // no, z private &#125;&#125;;class protected_Bace : protected Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected //z = 2; // no, z private &#125;&#125;;class private_Bace : private Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected // z = 2; // no, z private &#125;&#125;;int main() &#123; public_Bace a; // 都是继承父类的方法 // 继承 + x 在父类中的权限 = 表现出来的 a.x = 3; // ok, putback + public = public // a.y = 4; // no, public + protected = protected // a.z = 5; // no, public + private = private protected_Bace b; // b.x = 3; // no, protected + public = protected // b.y = 4; // no, protected + protected = protected // b.z = 5; // no, protected + private = private private_Bace c; // c.x = 3; // no, private + public = private // c.y = 4; // no, private + protected = private // c.z = 5; // no, private + private = private return 0;&#125;ENDS(test1)BEGINS(test2)class Base &#123;public : Base(string name) : class_name(name)&#123;&#125; int x; string class_name;private : int y;&#125;;class A : public Base &#123;public: A() : Base(&quot;class_A&quot;)&#123;&#125;&#125;;class B : public Base &#123;public: B() : Base(&quot;class_B&quot;)&#123;&#125;&#125;;class C : public Base &#123;public: C() : Base(&quot;class_C&quot;)&#123;&#125;&#125;;void func(Base &amp;b) &#123; cout &lt;&lt; &quot;nput class : &quot; &lt;&lt; b.class_name &lt;&lt; endl; return ;&#125;int main() &#123; A a; B b; C c; // 隐式类型转换 子类 -&gt; 父类 func(a); func(b); func(c); cout &lt;&lt; &quot;sizeof(Base) = &quot; &lt;&lt; sizeof(Base) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(A) = &quot; &lt;&lt; sizeof(A) &lt;&lt; endl; return 0;&#125;ENDS(test2)BEGINS(test3)class Base &#123;public : Base(string name) : class_name(name)&#123;&#125; int x; string class_name;private : int y;&#125;;class A : public Base &#123;public: A() : Base(&quot;class_A&quot;)&#123;&#125;&#125;;class B : public Base &#123;public: B() : Base(&quot;class_B&quot;)&#123;&#125;&#125;;class C : public Base &#123;public: C() : Base(&quot;class_C&quot;)&#123;&#125;&#125;;void func(Base *b) &#123; cout &lt;&lt; &quot;nput class : &quot; &lt;&lt; b-&gt;class_name &lt;&lt; endl; return ;&#125;int main() &#123; A a; B b; C c; // 子类的地址也是可以转换成父类的地址 func(&amp;a); func(&amp;b); func(&amp;c); return 0;&#125;ENDS(test3)// 父类子类的构造顺序BEGINS(test4)class ATTR_BASE &#123;public: ATTR_BASE(string name) : name(name)&#123; cout &lt;&lt; &quot;construct &quot; &lt;&lt; name &lt;&lt; endl; &#125; ~ATTR_BASE() &#123; cout &lt;&lt; &quot;destructor&quot; &lt;&lt; name &lt;&lt; endl; &#125; string name;&#125;;class ATTR1 : public ATTR_BASE&#123;public : ATTR1(string name) : ATTR_BASE(name) &#123;&#125;&#125;;class ATTR2 : public ATTR_BASE&#123;public : ATTR2(string name) : ATTR_BASE(name) &#123;&#125;&#125;;class Base &#123;public: Base() : attr1(&quot;attr1 in Base&quot;), attr2(&quot;attr2 in Base&quot;) &#123; cout &lt;&lt; &quot;Base constructor done&quot; &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; &quot;Base destructor don&quot; &lt;&lt; endl; &#125;private : ATTR1 attr1; ATTR2 attr2;&#125;;// Base 派生类class A : public Base &#123;public : A() : attr1(&quot;attr1 in A&quot;), attr2(&quot;attr2 in A&quot;)&#123; cout &lt;&lt; &quot;A constructor don&quot; &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;A destructor don&quot; &lt;&lt; endl; &#125;private : ATTR1 attr1; ATTR2 attr2;&#125;;int main() &#123; A a; return 0;&#125;ENDS(test4)int main() &#123; // test1::main(); // test2::main(); // test3::main(); test4::main(); return 0;&#125; 构造析构顺序 拷贝构造拷贝构造行为方式 ： 默认的 ： 默认调用每一个属性的拷贝函数默认的调用父类的拷贝函数","categories":[],"tags":[]},{"title":"静态链接库-静态链接库","slug":"静态链接库","date":"2021-11-14T11:49:27.000Z","updated":"2021-11-18T13:26:31.094Z","comments":true,"path":"2021/11/14/静态链接库/","link":"","permalink":"https://tutouwang.vercel.app/2021/11/14/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/","excerpt":"","text":"命名规则Linux Linux : libxxxx.so lib : 前缀（固定） xxxx : 库的名字，自己起 .so ： 后缀（固定） 在Linux下是一个可执行文件 Windwos Windows ： libxxxx.dll 静态链接库把所有.c文件 进行编译、汇编 不进行链接 1gcc -c test1.c test1.c test2.c test3.c r 插入 c 创建 s建立索引 lib库的名称.a 1ar rcs libcalc.a add.o sub.o mult.o gcc main.c -o app -I ./头文件 动态库的制作gcc 得到 .o文件 ， 得到和位置无关的代码 1gcc -c -fpic&#x2F;-fpIC a.c b.c gcc 得到动态库 1gcc -shared a.o b.o -o libxxxx.so","categories":[],"tags":[]},{"title":"自己实现一个sort","slug":"自己实现一个sort","date":"2021-11-11T12:08:06.000Z","updated":"2021-11-12T09:36:08.945Z","comments":true,"path":"2021/11/11/自己实现一个sort/","link":"","permalink":"https://tutouwang.vercel.app/2021/11/11/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAsort/","excerpt":"","text":"STL_sort 模板解析手动实现sort123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428/************************************************************************* &gt; File Name: Sort.cpp &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2021年11月10日 星期三 20时30分05秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;time.h&gt;#include &lt;functional&gt;using namespace std;// MAX_N == 存放数组大小，n == 循环右边边界const int MAX_N = 100, n = 20;#define BEGINS(x) namespace x &#123;#define ENDS(x) &#125; // end of namespace x// 初始化_BEGINESvoid init(int *f) &#123; for(int i = 0; i &lt; n; i++) *(f + i) = rand() % 10; return ;&#125;void output(int *first, int *last, const char *msg) &#123; cout &lt;&lt; msg; while(first != last) &#123; cout &lt;&lt; *first &lt;&lt; &quot; &quot;; ++first; &#125; cout &lt;&lt; endl; return ;&#125;// 初始化_ENDS// STL_自带sort_使用BEGINS(test1)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test1)// 手动实现sort firstEditionBEGINS(test2)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;void sort(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; if(first &gt;= last) return ; int *x = first, *y = last - 1, z = *first; while(x &lt; y) &#123; // while(x &lt; y &amp;&amp; *y &gt;= z) y--; while(x &lt; y &amp;&amp; cmp(z, *y)) y--; if(x &lt; y) *(x++) = *y; // while(x &lt; y &amp;&amp; *x &lt;= z) x++; while(x &lt; y &amp;&amp; cmp(*x, z)) x++; if(x &lt; y) *(y--) = *x; &#125; *x = z; sort(first, x, cmp); sort(x + 1, last, cmp); return ;&#125;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test2)// 手动实现sort secondEdition 单边递归法BEGINS(test3)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;void sort(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; if(first &gt;= last) return ; while(first &lt; last) &#123; int *x = first, *y = last - 1, z = *first; while(x &lt; y) &#123; while(x &lt; y &amp;&amp; cmp(z, *y)) y--; if(x &lt; y) *(x++) = *y; while(x &lt; y &amp;&amp; cmp(*x, z)) x++; if(x &lt; y) *(y--) = *x; &#125; *x = z; sort(first, x, cmp); first = x + 1; &#125; return ;&#125;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test3)// 手动实现sort secondEdition 单边递归法_无监督BEGINS(test4)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;void sort(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; while(first &lt; last) &#123; int *x = first, *y = last - 1, z = *first; do &#123; while(cmp(*x, z)) x++; while(cmp(z, *y)) y--; if(x &lt;= y) &#123; swap(*x, *y); x++, y--; &#125; &#125; while(x &lt;= y); sort(x, last, cmp); last = y + 1; &#125; return ;&#125;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test4)// 手动实现sort secondEdition 单边递归法_无监督_插入排序BEGINS(test5)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;const int threshold = 16;void intro_loop(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; while(last - first &gt; threshold) &#123; int *x = first, *y = last - 1, z = *first; do &#123; while(cmp(*x, z)) x++; while(cmp(z, *y)) y--; if(x &lt;= y) &#123; swap(*x, *y); x++, y--; &#125; &#125; while(x &lt;= y); sort(x, last, cmp); last = y + 1; &#125; return ;&#125;void insertion_sort(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; int *ind = first; // 找到最小值 for(int *i = first + 1; i &lt; last; ++i) &#123; if(cmp(*i, *ind)) ind = i; &#125; while(ind != first) &#123; swap(*ind, *(ind - 1)); --ind; &#125; for(int *i = first + 2; i &lt; last; ++i) &#123; int *j = i; while(cmp(*j, *(j - 1))) &#123; swap(*j, *(j - 1)); --j; &#125; &#125; return ;&#125;void sort(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; intro_loop(first, last, cmp); insertion_sort(first, last, cmp); return ;&#125;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test5)// 手动实现sort secondEdition 单边递归法_无监督_插入排序_随机迭代器(指针对象)BEGINS(test6)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;const int threshold = 16;class RandomIter&#123;public : RandomIter(int *ptr) : ptr(ptr)&#123;&#125; int &amp;operator*() &#123;return *ptr; &#125; RandomIter operator-(int x) &#123;return RandomIter(ptr - x); &#125; RandomIter operator+(int x) &#123;return RandomIter(ptr + x); &#125; int operator-(const RandomIter &amp;iter) &#123;return ptr - iter.ptr; &#125; // 前 ++ operator++() // 后 ++ operator++(int) RandomIter &amp;operator++() &#123; ++ptr; return *this; &#125;; RandomIter &amp;operator--() &#123; --ptr; return *this; &#125;; bool operator&lt;(const RandomIter &amp;iter) const &#123; return this-&gt;ptr &lt; iter.ptr; &#125; bool operator&gt;(const RandomIter &amp;iter) const &#123; return iter &lt; *this; &#125; bool operator&lt;=(const RandomIter &amp;iter) const &#123; return !(iter &lt; *this); &#125; bool operator&gt;=(const RandomIter &amp;iter) const &#123; return !(*this &lt; iter); &#125; bool operator==(const RandomIter &amp;iter) const &#123; return !(iter &lt; *this) &amp;&amp; !(*this &lt; iter); &#125; bool operator!=(const RandomIter &amp;iter) &#123; return !(iter == *this); &#125;private : int *ptr;&#125;;void intro_loop(RandomIter first, RandomIter last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; while(last - first &gt; threshold) &#123; RandomIter x = first, y = last - 1; int z = *first; do &#123; while(cmp(*x, z)) ++x; while(cmp(z, *y)) --y; if(x &lt;= y) &#123; swap(*x, *y); ++x, --y; &#125; &#125; while(x &lt;= y); intro_loop(x, last, cmp); last = y + 1; &#125; return ;&#125;void insertion_sort(RandomIter first, RandomIter last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; RandomIter ind = first; // 找到最小值 for(RandomIter i = first + 1; i &lt; last; ++i) &#123; if(cmp(*i, *ind)) ind = i; &#125; while(ind != first) &#123; swap(*ind, *(ind - 1)); --ind; &#125; for(RandomIter i = first + 2; i &lt; last; ++i) &#123; RandomIter j = i; while(cmp(*j, *(j - 1))) &#123; swap(*j, *(j - 1)); --j; &#125; &#125; return ;&#125;void sort(RandomIter first, RandomIter last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; intro_loop(first, last, cmp); insertion_sort(first, last, cmp); return ;&#125;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test6)int main() &#123; // test1::main(); // test2::main(); // test3::main(); // test4::main(); // test5::main(); test6::main(); return 0;&#125;","categories":[],"tags":[]},{"title":"Windows子系统搭建Vim","slug":"Windows子系统搭建Vim","date":"2021-11-07T14:01:42.000Z","updated":"2021-11-17T00:52:54.328Z","comments":true,"path":"2021/11/07/Windows子系统搭建Vim/","link":"","permalink":"https://tutouwang.vercel.app/2021/11/07/Windows%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BAVim/","excerpt":"","text":"注意：本文档没有任何问题，请仔细阅读文档，按步骤完成，不要轻易质疑文档的正确性；遇到问题，请大家先仔细阅读屏幕输出，不要直接提问 Windows10下Linux子系统1、启用开发者模式设置-更新和安全-针对开发人员-开发人员模式-等待完成（可以不开） 2、设置-程序和功能-启用或关闭windows功能-适用于Linux的Windows子系统-确定-等待安装完成并重启PC 3、安装Linux打开windows10的应用商店，搜索ubuntu，选择需要的版本点击-获取 我这里选择的是ubuntu20.04，点击获取后等待安装完成 4、启动在开始菜单中找到安装的ubuntu点击启动，第一次启动需要设置用户和密码按照提示设置即可。 安装系统后的环境准备添加普通用户（如已添加普通用户，跳转到下一步配置sshd） 在Linux使用过程中，应尽量避免使用root用户直接使用系统，请使用下面的步骤创建一个新用户 添加新用户 12adduser new_user #根据自己的真实需求修改new_user#这里是创建一个新的用户，用户名不要用new_user 将新用户添加到sudo组中 1usermod -G sudo new_user 使用su命令切换到新用户 1su - new_user 添加新用户之后，请在xshell中重新添加一个新用户的连接，以后直接使用新用户登录系统 ↓↓↓ ==请注意，从这里开始，所有的操作都是用普通用户做的== ↑↑↑ 配置sshd Vim的简单使用，请百度 使用命令sudo vim /etc/ssh/sshd_config打开sshd的配置文件，找到ClientAliveInterval和ClientAliveCountMax并将其修改为（如果没有直接添加即可）：60 3 重启sshd服务 1sudo service sshd restart 如果上述命令报错，大致内容为sshd这个服务不存在的话，就执行sudo service ssh restart 以下所有配置，都是为了优化终端，提升使用效率，如果你已经能独立对bash，zsh，vim等进行配置优化，可自行选择方案，无需完全按照这个方案 GitHub访问优化 请进入这个网址：点击这里 找到图中的IP1 在上面的网站上搜索github.com,找到IP2 使用命令sudo vim /etc/hosts打开hosts文件，并在最后加入以下信息 12199.232.69.194 github.global.ssl.fastly.net140.82.112.4 github.com 保存并退出 ###配置Vim（使用新添加的用户操作） 在后续的学习过程中，会使用vim写程序 Vim配置推荐 - ma6174（不用打开这个官方网站） 更新apt源信息 1sudo apt update 配置vim，执行下面命令配置安装vim sudo apt-get install git 12wget 47.93.11.51:88/install_vim.shbash install_vim.sh sudo apt-get remove vim-common vim的配置因为需要安装较多插件，所以需要等较多时间，大家耐心等待 zsh的安装及配置 安装zsh // 主题 1sudo apt install zsh 修改默认shell为zsh // 应该是修改主题 1chsh -s /bin/zsh 安装oh-my-zsh // 1234sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;##如果不成功，请执行下面两条命令，成功了就不需要做下面两条wget 47.93.11.51:88/install_zsh.shbash install_zsh.sh 安装zsh-syntax-highlighting // 代码高亮插件 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 使用命令vim .zshrc打开.zshrc文件，找到plugins=()这一行，将zsh-syntax-highlighting添加进去 1plugins=(git zsh-syntax-highlighting) 安装其他插件 1234567##命令自动补全插件mkdir ~/.oh-my-zsh/plugins/incrwget http://mimosa-pudica.net/src/incr-0.2.zsh -O ~/.oh-my-zsh/plugins/incr/incr.plugin.zsh##命令自动推荐，根据历史记录git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions##目录自动跳转插件sudo apt install autojump 使用命令vim .zshrc，打开后在最后插入以下内容： 123456789#设置终端颜色，提示符，及上一条指令返回码提示autoload -U colors &amp;&amp; colorsPROMPT=&quot;%&#123;$fg[red]%&#125;%n%&#123;$reset_color%&#125;@%&#123;$fg[blue]%&#125;%m %&#123;$fg[yellow]%&#125;%1~ %&#123;$reset_color%&#125;%# &quot;RPROMPT=&quot;[%&#123;$fg[yellow]%&#125;%?%&#123;$reset_color%&#125;]&quot;# Useful support for interacting with Terminal.app or other terminal programs[ -r &quot;/etc/zshrc_$TERM_PROGRAM&quot; ] &amp;&amp; . &quot;/etc/zshrc_$TERM_PROGRAM&quot;source ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.plugin.zshsource /usr/share/autojump/autojump.shsource ~/.oh-my-zsh/plugins/incr/incr*.zsh 注意，复制后可能会因为Vim的配置导致以上内容被注释，也就是在前面加上了#,如果有的话，删掉就行。 ctags安装与配置 使用以下命令安装ctags 1sudo apt install ctags 执行以下命令 1ctags -I __THROW -I __attribute_pure__ -I __nonnull -I __attribute__ --file-scope=yes --langmap=c:+.h --languages=c,c++ --links=yes --c-kinds=+p --c++-kinds=+p --fields=+iaS --extra=+q -f ~/.vim/systags /usr/include/* /usr/include/x86_64-linux-gnu/sys/* /usr/include/x86_64-linux-gnu/bits/* /usr/include/arpa/* 使用命令vim .vimrc编辑.vimrc，在最后添加以下内容 1set tags+=~/.vim/systags 安装glibc-doc 使用以下命令安装 1sudo apt install glibc-doc Vim下字体修改windows + r打开运行输入regedit 找到这个 1计算机\\HKEY_CURRENT_USER\\Console\\C:_Program Files_WindowsApps_CanonicalGroupLimited.Ubuntu20.04onWindows_2004.2021.825.0_x64__79rhkp1fndgsc_ubuntu2004.exe 这里是我更新之后的个个版本(每次更新都需要重新设置一下字体) 在右侧添加新建一个Dword键 CodePage是用来设置终端代码页的选项，65001是UTF-8，这个可以支持各种字体。这是关键。 保存，退出，再次打开Ubuntu，就可以自由的设置喜欢的字体了，连VIM也一并搞定。 自己设置的是 Cascadia Code 字体还挺好用的~","categories":[{"name":"教程","slug":"教程","permalink":"https://tutouwang.vercel.app/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://tutouwang.vercel.app/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"并查集","slug":"并查集","date":"2021-03-27T10:08:15.000Z","updated":"2021-03-27T10:43:22.250Z","comments":true,"path":"2021/03/27/并查集/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/27/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集(Union Find)并查集主要讲的就是连通性问题 比如说现在咱们这个教学楼，被大水淹了比如说一楼和其它楼层都被大水淹了，就唯独咱们教室没有，可以说明什么，咱们现在就是与世隔绝了，之后呢就被大水淹没的个个楼层水是不是都可以来回走，比如流到了咱们教室恰巧关上了们，之后水就没流进来，说明什么咱们现在是与这个教学楼的一间教室都不连图，如果说咱们与隔壁是连通的，而且咱们隔壁还被大水淹没了，你说咱们这屋是不是也被淹没了。 若某个家族人员过于庞大，要判断两个是否是亲戚，确实不容易，给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。 树形结构在春秋战国时期有各种思想学术流派的成就，有 孔子 墨子 老子 还有谁比如 韩非子等等 从我们当前图中我门可以看出我们有几个连同块 有3个对把 比如说有一天 2 号 跟 4号 打起来来了说你写的东西不如我，（这里有个规定就是说徒弟一定不如师傅）完了4号本身就是1号的徒弟肯定不如2号 当然 4号有师傅 之后4号找到自己的师傅 1 号 说今天我被人羞辱了对吧那当师傅的肯定不能做事不管对吧 之后一看 说这2号也老孔的徒弟一看这不是就是一个师傅么那就别报仇了 让 4 号 给 2 号认个错 就是下次的时候我们可以怎么看 就是先知道自己的师傅的师傅是谁对吧 在看你要找的人的师傅的师傅（这师傅可能还有师傅所有要找到最后一个师傅）是谁 如果他们最后的师傅都是同一个人那他们是不是就是一家人属于同一个师傅 （可以说明他们在通一课树中说明它们俩个连同） 其实我们在连同性中不在乎连接成什么样子谁是谁的徒弟我只在乎他们能不能连同最后的祖师，祖师爷是不是同一个人 这个两个点能不能连同 Ps 比如 （1， 2） 为一个集合 数组表示 （1，4） （4，7） 这里代表两个集合链接，这里链接的时候你说是 1 当作根节点还是 4 当作根节点 1 其实是无所谓的。这里假定 4为根节点我们可以得到 图 这两个点的连同不仅仅是两个点的连同而是两个集合的连通（其实他们都属一个个体） 比如你的爸和你妈是两个姓对吧 他们在没结婚之前是什么，两个家的人就可以比作什么两个集合，之后他们结婚了 是只有他俩是一家人么 不是吧 是两家人，这就好比我们两个点的链接。 我们可以用数组表示 初始化把每个点所在的集合初始化为其自身。 初始化加粗 为下标 我们可以用用它自身去初始化（也可以用 -1 但是后期在优化的时候会有点麻烦） 0 1 2 3 0 1 2 3 4 5 6 7 4 5 6 7 0 1 2 3 0 4 2 3 4 5 6 7 4 5 6 4 竞赛阶段我们会用到的算法 find union123456789101112131415161718// 朴素int find_root(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;// 查找--优化int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x]; // return x == parent[x] ? x : parent[x] = find_root(parent[x], parent); // return parent[x] = (x == parent[x] ? x : find_root(parent[x], parent));&#125; 123456789101112131415161718192021// 合并void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; // parent[x_root] = y_root; // 原先代码 // 安秩合并 if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; return ; &#125; mark = 1; return ;&#125; 路径压缩–按秩合并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int mark = 0;// 初始化void inital(int n, int parent[], int height[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; height[i] = 0; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x]; // &#125;// 路径压缩--非递归版int find_root1(int x, int parent[]) &#123; int k = x; while (parent[k] != k) &#123; k = parent[k]; &#125; while (x != k) &#123; int temp = parent[x]; parent[x] = k; x = temp; &#125; return k;&#125;void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; // parent[x_root] = y_root; // 原先代码 // 按秩合并 if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; return ; &#125; mark = 1; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10], height[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; inital(m, parent, height); for (int i = 0; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(x, y, parent, height); &#125; if (mark) cout &lt;&lt; &quot;有环！&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;无环！&quot; &lt;&lt; endl; return 0;&#125; 路径压缩是怎么实现的 检测是否存在环我们如何去检测一个图是否存在环环路 如下 我们有 0️⃣ 1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 把每个点看成单个集合比如我们相连（0 ，1） （1，2） （1，3）（2，4）（2，3） 我们在合并时候需要先查询一下他们是否属于同一集合，如果不属于同一集合我才能合并，反之要是它们在合并就会构成回路。 如果不考虑链接红色两点，合并集合之后是{0，1，2，3，4} 我们可以得到站在任意点到达另一任意点。不构成环 如果说我们在已连接中任意选择两个去链接他一定会成环对吧。🔶 比如红色两点链接，我们可以看到 1， 2， 3 点形成了环。 形成环路 我们怎么知道他是成环了呢我们把 1 当做根结点 ，0， 2，4，3 都属于 1 的孩子或者是孙子 当你去链接 （2， 3）时候你会发现他们都属于 1 下就如我们刚才所说 🔶因为我们知道两个集合在合并的时候一定会先去找根节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int mark = 0;int parent[MAX_N + 10];// 初始化void inital(int n, int parent[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; &#125; return ;&#125;int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;void merge(int x, int y, int parent[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; parent[x_root] = y_root; return ; &#125; mark = 1; return ;&#125;int main() &#123; int n, m; // 组数 最大值 cin &gt;&gt; n &gt;&gt; m; inital(m, parent); for (int i = 0; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(x, y, parent); &#125; if (mark) cout &lt;&lt; &quot;有环！&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;无环！&quot; &lt;&lt; endl; return 0;&#125; 并查集–数据结构实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;struct UnionSet &#123; int *parent;&#125;;// 初始化UnionSet *init(int n) &#123; UnionSet *U = (UnionSet *)malloc(sizeof(UnionSet)); U-&gt;parent = (int *)malloc(sizeof(int) * (n + 1)); for (int i = 1; i &lt;= n; i++) &#123; U-&gt;parent[i] = i; &#125; return U;&#125;int find_root(UnionSet *U, int x) &#123; if (U-&gt;parent[x] != x) &#123; return find_root(U, U-&gt;parent[x]); &#125; return x;&#125;void merge(UnionSet *U, int x, int y) &#123; int x_root = find_root(U, x); int y_root = find_root(U, y); if (x_root != y_root) &#123; U-&gt;parent[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); UnionSet *U = init(n); // 进行 M 次操作 for (int i = 1; i &lt;= m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); switch(a) &#123; case 1: merge(U, b, c); break; // 合并操作 case 2: printf(&quot;%s\\n&quot;, find_root(U, b) == find_root(U, c) ? &quot;Yes&quot; : &quot;No&quot;); &#125; &#125; return 0;&#125; 例题–题解海贼 #71 朋友圈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/************************************************************************* &gt; File Name: 海贼_#71并查集_路径压缩优化.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年01月18日 星期一 15时33分00秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e4;// 初始化void initialization(int n, int parent[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;// 朴素算法int find_root1(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;void merge(int x, int y, int parent[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; parent[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; initialization(n, parent); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if (a == 1) &#123; // 添加 merge(b, c, parent); &#125; else &#123; // 查看 if (find_root(b, parent) - find_root(c, parent)) &#123; printf(&quot;No\\n&quot;); &#125; else printf(&quot;Yes\\n&quot;); &#125; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/************************************************************************* &gt; File Name: 海贼_#71并查集_路径压缩_安秩合并_优化.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年01月18日 星期一 21时33分00秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e4;// 初始化 void initialization(int n, int parent[], int height[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; // 开始树高为 0 height[i] = 0; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;// 朴素算法int find_root1(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; &#125; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10], height[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; initialization(n, parent, height); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if (a == 1) &#123; // 添加 merge(b, c, parent, height); &#125; else &#123; // 查看 if (find_root(b, parent) - find_root(c, parent)) &#123; printf(&quot;No\\n&quot;); &#125; else printf(&quot;Yes\\n&quot;); &#125; &#125; return 0;&#125; 洛谷 P1551 亲戚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int arr[MAX_N];void initial(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; arr[i] = i; &#125;&#125;int find(int x) &#123; if (arr[x] != x) &#123; x = find(arr[x]); &#125; return arr[x];&#125;void merge(int x, int y) &#123; int x_root = find(x); int y_root = find(y); if (x_root != y_root) &#123; arr[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; initial(n); while (m--) &#123; int mi, mj; cin &gt;&gt; mi &gt;&gt; mj; merge(mi, mj); &#125; while (p--) &#123; int mi, mj; cin &gt;&gt; mi &gt;&gt; mj; if (find(mi) == find(mj)) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://tutouwang.vercel.app/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"蓝桥杯省赛_B组组_十届","slug":"蓝桥杯省赛_B组组_十届","date":"2021-03-21T09:07:43.000Z","updated":"2021-03-21T09:30:56.062Z","comments":true,"path":"2021/03/21/蓝桥杯省赛_B组组_十届/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/21/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B_B%E7%BB%84%E7%BB%84_%E5%8D%81%E5%B1%8A/","excerpt":"","text":"试题A:平方序列","categories":[{"name":"蓝桥杯历届真题","slug":"蓝桥杯历届真题","permalink":"https://tutouwang.vercel.app/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"排序合集","slug":"排序合集","date":"2021-03-14T01:48:14.000Z","updated":"2021-04-03T07:38:30.808Z","comments":true,"path":"2021/03/14/排序合集/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/14/%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/","excerpt":"","text":"怎么区分稳定还是不稳定如果在原序列里面两个数是相同的，那么排完序位置没有发生变化那么 这个排序就是稳定的，如果发生变化那么这个排序就是不稳定的。 冒泡排序（稳定） 考虑冒泡排序的复杂度，对于拥有N个字母的字符串，最多需要交换 N*(N - 1) / 2 次（完全逆序） 快速排序（不稳定）随机快速排序过程 确定分界点（也叫选择基准数）：$q[L], q[(L + R) / 2], q[R]$ 调整区间： 递归：处理左右两端排序，如果左右两侧都排序好了在合并一起那么就是一个有序的序列了 （暴力）版 可以先开辟两个空的数组 a[] 和 b[] 在 L 到 R 区间内扫描一遍 把 &gt;= x 和 &lt;= x 的数拆分出来放到 a, b 数组 $q[L - R] $ $q[i] &lt;= x, q[i] - &gt; a[]$ // q[i] &lt;= x 就它放到 a 数组里面 $q[i] &gt;= x, q[i] -&gt; b[]$ // q[i] &gt;= x 就它放到 b 数组里面 $a[] -&gt; q[], b[]-&gt;q[]$ //在把 a，b 数组数据在合并到 q 数组里面 （基础）版我们可以定义两个指针从线段两侧往中间走只要（i &lt; j) 红色i 蓝色j，如果红色指针要小于基准数那么i++, 如果红色指针要大于基准数了，那么判断j指针数是否大于基准值如果大于那么j++, 如果小于那么 交换i, j 指针。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/************************************************************************* &gt; File Name: Demo15.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2021年03月16日 星期二 20时37分05秒 ************************************************************************/#include&lt;stdio.h&gt;#define MAX_N 100000#define swap(a, b) &#123;\\ a ^= b, b ^= a, a ^= b;\\&#125;int q[MAX_N + 10];void quick_sort(int l, int r) &#123; if (l &gt;= r) return ; // 如果下面递归左右 选的是j的话 基准指数一定不能选 q[r] 要不然回发生边界问题 int x = q[l], i = l - 1, j = r + 1; while (i &lt; j) &#123; do i++; while (q[i] &lt; x); do j--; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); &#125; // 遍历左侧 quick_sort(l, j); // 遍历右侧 quick_sort(j + 1, r); return ;&#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, q + i); &#125; quick_sort(0, n - 1); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, q[i]); &#125; return 0;&#125; 归并排序（稳定） 确定分界点 mid(L + R) / 2 (这里的分界点是数组下标的位置)而快排是随机确定数组里面数。 递归排序左右两面。 归并（把排序好的左右两侧合并到一起）。","categories":[{"name":"算法基础","slug":"算法基础","permalink":"https://tutouwang.vercel.app/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"ACwin104_货仓选址","slug":"ACwin104_货仓选址","date":"2021-03-13T09:39:11.000Z","updated":"2021-03-13T13:12:12.671Z","comments":true,"path":"2021/03/13/ACwin104_货仓选址/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/13/ACwin104_%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80/","excerpt":"","text":"原题链接 题目：在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN。 现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。 为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。 输入格式第一行输入整数 N。 第二行 N 个整数 A1∼ AN 输出格式输出一个整数，表示距离之和的最小值。 数据范围$1≤N≤1000001≤N≤100000$$0 ≤ Ai ≤ 400000 ≤ Ai ≤ 40000$ 输入样例：1246 2 9 1 输出样例：112 解题思路:那面如何选择中位数仓库x如果当n等于奇数那么中间的数就是中位数，如果n是偶数那么现在中间两个其实一都可以。 首先考虑在坐标轴上建立仓库$x$如图 假设货仓在中间可得$|a - x| + |b - x| &gt;= |a - b|$，$|a - x|$就是a 到 x的距离 同理 $|b - x|、 |a - b|$ 如果货仓在最左侧或者最右侧情况，那么可以看出$|x - a|$的距离就走了两遍所有放在中间才是最优解。 第一种做法：12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#define MAX_N 100000int f[MAX_N + 10];int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, f + i); &#125; std::sort(f, f + n); int res = 0; for (int i = 0; i &lt; n; i++) &#123; res += abs(f[i] - f[n &gt;&gt; 1]); &#125; printf(&quot;%d\\n&quot;, res); return 0;&#125;","categories":[{"name":"ACwin题解","slug":"ACwin题解","permalink":"https://tutouwang.vercel.app/categories/ACwin%E9%A2%98%E8%A7%A3/"},{"name":"中位数","slug":"ACwin题解/中位数","permalink":"https://tutouwang.vercel.app/categories/ACwin%E9%A2%98%E8%A7%A3/%E4%B8%AD%E4%BD%8D%E6%95%B0/"}],"tags":[{"name":"中位数","slug":"中位数","permalink":"https://tutouwang.vercel.app/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"}]},{"title":"背包九讲","slug":"背包九讲","date":"2021-03-07T04:21:06.000Z","updated":"2021-10-11T12:17:31.415Z","comments":true,"path":"2021/03/07/背包九讲/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/07/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","excerpt":"","text":"动态规划 动态规划（Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息 学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题）， 再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归 的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少 计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查 表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 在大家看完什么是动态规划后就是说我们在之前也做题中可能也遇到过动态规划的题比如斐波那契数列 如 1，1， 2， 3… 就是这个 2 怎么来的就是 1 + 1 = 2 之后 3 的下一项是什么？就是 2 + 3 = 5 也就是说 3 的下一项就是 5 之后下几项就是 8，13，21…就会得到这组序列 我们如果相求第n斐波那契数列可以得到转移公式 $Fib(n) = Fib(n - 1) + Fib(n - 2);$ (Fib(1) = 1 和 Fib(2) = 1是由题目给出的，n &gt; 2 ) 完整的斐波那契数列 加上出口就是 n = 1 or n = 2 返回 1 , 就是说我们这里为什么提出这个斐波那契数列呢就是我们在递归时候，我们呢会发现他的递归式中会出现重叠的子问题，为什么会这么说我来计算一下斐波那契数列 第 5 项 Fib(5) 可得出如下 假如说我们用数组去求解Fib(6) 是不就可以直接用之前求Fib(5) + Fib(4) 的 直接得到 Fib(6) 这样我是不是就可以省去求重叠子问题的时间，这样我们的时间复杂度就从o(2^n^) 变成 o(n)(当然这个时间复杂度也是能弄记忆化搜索优化的)。 例题 01 背包 只又 2 种选择一种选一种不选。 洛谷 P1048 采药 完全背包 每件物品可以无限选（只要不超过背包的总体积）。 洛谷 P1616 疯狂的采药 多重背包 每个物品有相应的个数。 洛谷 P1776 宝物筛选 混合背包 基于以上上面三种背包。 洛谷 P1833 樱花 二维费用背包 类比以一维费用01背包，推广二维费用01背包。 洛谷 P1507 NASA的食物计划 分组背包 有 n 组物品 每组物品有若干个，同一组内互相冲突，同一组最多只能选一个或者不选 洛谷 P1757 通天之分组背包 有依赖的背包 类似捆绑销售 买附必须买主，买主可以不买附 洛谷 P1064 金明的预算方案 背包九讲0-1背包题目：有一天小鲁同学在家里学习算法，小鲁的妈妈就叫这个铲屎官小鲁去收拾一下，但是小鲁很不想去就说我在学习算法，小鲁的妈妈就说你要是在不去我就把你一起也铲出去，小鲁就想被你铲除去还不如我自己走，这样小鲁就回到了自己的房间，打破了储存已久的小猪储存罐🐖。 小鲁的背包可容纳下总重量为 20（ s ） 他需要带尽可能多的钱走。（没种钱可以重复的选取没有上限）。 简单的说： 有N件物品和一个容量为T的背包。第i件物品的费用是t[i]，价值是v[i]。求解将哪些物品装入背包可使价值总和最大。 下标 重量（w） 价值 （v） 1 2 3 2 3 4 3 4 5 4 5 8 5 9 10 这里为什么不用贪心而用动态规划？ 首先贪心他是局部最优解，而我所讲的动态规划可以达到全局最优解。 基本思路： 首先我们考虑什么，取不取第 n 件物品？ 取 $-&gt; n - 1$ 个物品，背包大小 $s - w[n]$ 不取$ -&gt; n - 1$ 个物品，背包大小 s 定义状态：$dp[i][j]$ 表示考虑前 i 个物品，背包大小 $0 -&gt; j $, 获得最大价值。 转移方程：$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])$ 代码实现：无优化-代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;#define MAX_N 1000int dp[MAX_N + 10][MAX_N + 10];int t[MAX_N + 10], v[MAX_N + 10];void backpack(int k, int T) &#123; for (int i = 1; i &lt;= k; i++) &#123; for (int j = 1; j &lt;= T; j++) &#123; if (t[i] &gt; j) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; int Y = dp[i - 1][j - t[i]] + v[i]; int T = dp[i - 1][j]; dp[i][j] = Y &gt; T ? Y : T; // dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); &#125; &#125; &#125;&#125;int main() &#123; int T, n; cin &gt;&gt; T &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; t[i] &gt;&gt; v[i]; &#125; backpack(n, T); cout &lt;&lt; dp[n][T];&#125; 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;const int MAX_N = 1e3;int n, m;int f[MAX_N + 10][MAX_N + 10], w[MAX_N + 10], v[MAX_N + 10];int main() &#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; w[i] &gt;&gt; v[i]; &#125; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; f[i][j] = f[i - 1][j]; if(j &gt;= w[i]) f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]); &#125; &#125; cout &lt;&lt; f[m][n] &lt;&lt; endl; return 0;&#125; 优化-代码12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;#define MAX_N 1000int dp[MAX_N];int T[MAX_N], V[MAX_N];void backpack(int k, int s) &#123; for (int i = 1; i &lt;= k; i++) &#123; for (int j = s; j &gt;= T[i]; j--) &#123; dp[j] = max(dp[j], dp[j - T[i]] + V[i]); &#125; &#125; return ;&#125;int main() &#123; int t, n; cin &gt;&gt; t &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; T[i] &gt;&gt; V[i]; &#125; backpack(n, t); cout &lt;&lt; dp[t]; return 0;&#125; 上面朴素算法时间复杂度与空间复杂度皆为 O(t*n) 其中时间复杂度不能再优化, 而空间复杂度可以 优化为O(t), 下面我们来讲解如何优化到一维数组 细节问题 1 我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。如果是第一种问法，要求恰好装满背包，那么在初始化时除了f[0]为0其它f[1..V]均设为-∞，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。 2 如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f[0..V]全部设为0。为什么呢？ 3 可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的（相当于没装东西），其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。这个小技巧完全可以推广到其它类型的背包问题，后面也就不再对进行状态转移之前的初始化进行讲解。 完全背包题目：有N种物品和一个容量为T的背包，每种物品都有无限件可用。第i种物品的费用是t[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路：和 01背包很相似 转移方程相同 转移方程：$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])$ 与 01背包的区别–第二个循环 01背包 在更新时候倒序因为是需要用之前元素 代码实现：无优化-代码123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;long long dp[MAX_N + 10][MAX_N +10];long long t[MAX_N + 10], v[MAX_N + 10];void backpack(int k, int s) &#123; for (int i = 1; i &lt;= k; i++) &#123; for (int j = 1; j &lt;= s; j++) &#123; if (j &lt; t[i]) dp[i][j] = dp[i - 1][j]; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - t[i]] + v[i]); &#125; &#125; &#125; return ;&#125;int main() &#123; int T, n; cin &gt;&gt; T &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; t[i] &gt;&gt; v[i]; &#125; backpack(n, T); cout &lt;&lt; dp[n][T] &lt;&lt; endl; return 0;&#125; 优化-代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e7;long long B[MAX_N + 10];int t[MAX_N + 10], v[MAX_N + 10];void backpack(int k, int s) &#123; for (int i = 1; i &lt;= k; i++) &#123; for (int j = t[i]; j &lt;= s; j++) &#123; B[j] = max(B[j], B[j - t[i]] + v[i]); &#125; &#125; return ;&#125;int main() &#123; int T, n; cin &gt;&gt; T &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; t[i] &gt;&gt; v[i]; &#125; backpack(n, T); cout &lt;&lt; B[T] &lt;&lt; endl; return 0;&#125; 多重背包题目：有N种物品和一个容量为s的背包。第i种物品最多有m[i]件可用，每件费用是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路：这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有m[i]+1种策略：取0件，取1件……取n[i]件。令f[i][j]表示前i种物品恰放入一个容量为v的背包的最大权值。 则转移方程： $dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * w] + k * v);$ 代码实现：无优化-代码1234567891011121314151617181920212223242526// 多重背包 朴素 算法#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e3;int dp[MAX_N + 10][MAX_N + 10];int main() &#123; int n, s; cin &gt;&gt; n &gt;&gt; s; for (int i = 1; i &lt;= n; i++) &#123; // 价值 重量 组数 int v, w, m; cin &gt;&gt; v &gt;&gt; w &gt;&gt; m; for (int j = s; j &gt;= w; j--) &#123; // 背包容量 for (int k = 0; k &lt;= m &amp;&amp; j &gt;= k * w; k++) &#123; // 决策 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * w] + k * v); &#125; &#125; &#125; cout &lt;&lt; dp[n][s] &lt;&lt; endl; return 0;&#125; 转化为01背包问题 另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成log(m)件01背包中的物品. 但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想. 二进制优化 假设有50个苹果，现在要取n个苹果(n≤50），如何取?朴素的做法应该是将苹果一个一个拿出来，直到n个苹果被取出来。再假设有50个苹果和6只箱子，利用箱子进行某些预备工作，可以在每个箱子中放2(k≥0)个苹果，也就是1、2、4、8、16、19（剩余的数），取任意n个苹果时，只要推出忆只箱子就可以了。 lg45÷lg2=1.6532125÷0.301029996=5.49185 优化-代码123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e5;int dp[MAX_N + 10];int ww[MAX_N + 10], vv[MAX_N + 10], mm[MAX_N + 10];int main () &#123; int n, s, count = 1, v, w, m; cin &gt;&gt; n &gt;&gt; s; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v &gt;&gt; w &gt;&gt; m; for (int j = 1; j &lt;= m; j &lt;&lt;= 1) &#123; ww[count] = j * w; vv[count++] = j * v; m -= j; &#125; // 处理 二进制拆分不了的 if (m) &#123; ww[count] = m * w; vv[count++] = m * v; &#125; &#125; // 01 背包 模板 for (int i = 1; i &lt; count; i++) &#123; for (int j = s; j &gt;= ww[i]; j--) &#123; dp[j] = max(dp[j], dp[j - ww[i]] + vv[i]); &#125; &#125; cout &lt;&lt; dp[s] &lt;&lt; endl; return 0;&#125; 混合背包题目：如果将 01背包、完全背包、多重背包、混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背1包）。应该怎么求解呢？ 基本思路： 01背包与完全背包的混合 我只需要考虑到在01背包和完全背包中给出的代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可. 12345678if // 如果是 01 背包 for (int j = s; j &gt;= w[i] j--) &#123; dp[j] = max(dp[j], dp[j - w[i]] + v[i]); &#125;else // 如果是 完全背包 for (int j = w[i]; j &lt;= s; j++) &#123; dp[j] = max(dp[j], dp[j - w[i]] + v[i]); &#125; 再加上多重背包 如果再加上有的物品最多可以取有限次，我们就可以用二进制拆分来把多重背包转换成01背包 1234567891011// m = 物品最多能取的个数for (int j = 1; j &lt;= m; j &lt;&lt;= 1) &#123; ww[count] = j * w; vv[count++] = j * v; m -= j;&#125;// 处理 二进制拆分不了的if (m) &#123; ww[count] = m * w; vv[count++] = m * v;&#125; 题解-代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e5;int dp[MAX_N + 10], ww[MAX_N + 10], vv[MAX_N + 10], mark[MAX_N + 10];int main() &#123; int T, t1, t11, t2, t22, n, count = 1; scanf(&quot;%d:%d %d:%d %d&quot;, &amp;t1, &amp;t11, &amp;t2, &amp;t22, &amp;n); T = (t2 * 60 + t22) - (t1 * 60 + t11); for (int i = 1; i &lt;= n; i++) &#123; int w, v, m; cin &gt;&gt; w &gt;&gt; v &gt;&gt; m; if (!m) &#123; ww[count] = w; vv[count] = v; // 标记为 0 代表可以重复观看 完全背包 mark[count++] = 0; &#125; else &#123; // 二进制拆分转换 01背包 for (int j = 1; j &lt;= m; j &lt;&lt;= 1) &#123; ww[count] = j * w; vv[count] = j * v; // 标记为 1 代表每棵树只能看或者不看 01背包 mark[count++] = 1; m -= j; &#125; // 因为二进制拆分 只能是 1 2 4 8 16 32 比如 m = 10 二进制拆分之后还会余下 1 下面 if 就是解决那个多余出来的 if (m) &#123; ww[count] = m * w; vv[count] = m * v; mark[count++] = 1; &#125; &#125; &#125; // 实现 01背包 和 完全背包 模板就行了 for (int i = 1; i &lt; count; i++) &#123; if (mark[i]) &#123; // 如果 mark[i] == 1 就执行 01背包 for (int j = T; j &gt;= ww[i]; j--) &#123; dp[j] = max(dp[j], dp[j - ww[i]] + vv[i]); &#125; &#125; else &#123; for (int j = ww[i]; j &lt;= T; j++) &#123; dp[j] = max(dp[j], dp[j - ww[i]] + vv[i]); &#125; &#125; &#125; cout &lt;&lt; dp[T] &lt;&lt; endl; return 0;&#125; 二维费用背包题目：二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和Q。物品的价值为v[i]。 基本思路：费用加了一维，只需状态也加一维即可。设dp[i][j][k]表示前i件物品付出两种代价分别为m和w时可获得的最大价值。 状态转移方程就是：$f [i][j][k]=max{f[i-1][j][k],f[i-1][f-a[i]][k-b[i]]+v[i]}$。 如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量m和w采用顺序的循环。 大概就是 由一维01背包费用推广二维01背包费用还可以推广三维，四维，…..N维。 当物品有如完全背包问题时采用逆序的循环。 当物品有如多重背包问题时拆分物品。 题解-代码：1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e3;int dp[MAX_N + 10][MAX_N + 10];int main() &#123; int V, Q, n; cin &gt;&gt; V &gt;&gt; Q &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; int m, w, v; cin &gt;&gt; m &gt;&gt; w &gt;&gt; v; for (int j = V; j &gt;= m; j--) &#123; for (int k = Q; k &gt;= w; k--) &#123; dp[j][k] = max(dp[j][k], dp[j - m][k - w] + v); &#125; &#125; &#125; cout &lt;&lt; dp[V][Q] &lt;&lt; endl; return 0;&#125; 分组的背包问题题目：有N件物品和一个容量为S的背包。第i件物品的费用是w[i]，价值是v[i]，组别g[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件或者不选,如果同属于v[i]组一共有m个那最多就有m + 1种选法。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路：$dp[i][j]$ 表前 i 组物品，能放下容量为j的背包的最大价值。 朴素算法 对第 i 组物品，容量为 j 的背包，有 m + 1种选法。 $max(dp[i-1][j], dp[i - 1][j - w[1]], dp[i - 1][j - w[2]]…dp[i - 1][j - w[m]])$ 这里基本就是01背包模板直接用01背包优化版的板子就可以了。 题解-代码：123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e3;int dp[MAX_N + 10];int w[MAX_N + 10], v[MAX_N + 10], g[MAX_N + 10], gg[MAX_N + 10][MAX_N + 10];int main() &#123; int n, s, nn = 0; cin &gt;&gt; s &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; int t; scanf(&quot;%d%d%d&quot;, &amp;w[i], &amp;v[i], &amp;t); nn = max(t, nn); g[t]++; gg[t][g[t]] = i; &#125; // 枚举 nn 个组 for (int i = 1; i &lt;= nn; i++) &#123; for (int j = s; j &gt;= 0; j--) &#123; // 背包容量 for (int k = 0; k &lt;= g[i]; k++) &#123; // 决策 if (j &gt;= w[gg[i][k]]) // 不选从 k - 1 个物品中选择一个价值最大的 dp[j] = max(dp[j], dp[j - w[gg[i][k]]] + v[gg[i][k]]); &#125; &#125; &#125; cout &lt;&lt; dp[s] &lt;&lt; endl; return 0;&#125; 问背包容量与决策循环是否可以调换？ 不能 因为更新$dp[j]$时用到$dp[i][j - w[k]]$的值，$dp[j- w[k]]$与$dp[i-1][j-w[k]]$ 有依赖的背包基本思路：这种背包问题的物品间存在某种“依赖”的关系。也就是说，物品 i 依赖于物品 j， 表示若选物品 i，则必须选物品 j。为了简化起见，我们先设没有某个物品既依赖于别 的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。 这个问题由 NOIP2006 中“金明的预算方案”一题扩展而来。遵从该题的提法，将 不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题 的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。 就好比如 你大一学的c\\c++语言完了大二才能学数据结构，就是你不能直接学数据结构要先学完c\\c++这就是依赖关系 可看上面例题 看题, 我们在选择时候会有5种情况： 选或者不选 选 、只选这个主件 不选、直接考虑下一个 选这个主件 选这个主件、并且选附件1 选这个主件、并且选附件2 选这个主件、 并且选附件1和附件2 例题-代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e6;int dp[MAX_N + 10];int w[MAX_N + 10], v[MAX_N + 10], g[MAX_N + 10][3], mark[MAX_N + 10];int main() &#123; int n, s; scanf(&quot;%d%d&quot;, &amp;s, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int p, q; scanf(&quot;%d%d%d&quot;, &amp;w[i], &amp;p, &amp;q); mark[i] = q; v[i] = w[i] * p; if (q) &#123; g[q][0]++; g[q][g[q][0]] = i; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if(mark[i] != 0) continue; for (int j = s; j &gt;= w[i]; j--) &#123; // 1、不选 或者 只选择主件 dp[j] = max(dp[j], dp[j - w[i]] + v[i]); // 2、选择第一个附件 if (j &gt;= w[g[i][1]] + w[i] &amp;&amp; g[i][1] != 0) &#123; dp[j] = max(dp[j], dp[j - w[i] - w[g[i][1]]] + v[i] + v[g[i][1]]); &#125; // 3、选择第二个附件 if (j &gt;= w[g[i][2]] + w[i] &amp;&amp; g[i][2] != 0) &#123; dp[j] = max(dp[j], dp[j - w[i] - w[g[i][2]]] + v[i] + v[g[i][2]]); &#125; // 4、两个附件都选 if (j &gt;= w[g[i][1]] + w[g[i][2]] + w[i] &amp;&amp; g[i][1] != 0 &amp;&amp; g[i][2] != 0) &#123; dp[j] = max(dp[j], dp[j - w[i] - w[g[i][1]] - w[g[i][2]]] + v[i] + v[g[i][1]]+ v[g[i][2]]); &#125; &#125; &#125; cout &lt;&lt; dp[s] &lt;&lt; endl; return 0;&#125; 泛化物品 (了解)定义考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的 费用而变化。这就是泛化物品的概念。 更严格的定义之。在背包容量为 V 的背包问题中，泛化物品是一个定义域为 0 . . . V 中的整数的函数 h，当分配给它的费用为 v 时，能得到的价值就是 h(v)。 这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组 h[0 . . . V ]，给它 费用 v，可得到价值 h[v]。 一个费用为 c 价值为 w 的物品，如果它是 01 背包中的物品，那么把它看成泛化物 品，它就是除了 h(c) = w 外，其它函数值都为 0 的一个函数。如果它是完全背包中的 物品，那么它可以看成这样一个函数，仅当 v 被 c 整除时有 h(v) = w · v c，其它函数值 均为 0。如果它是多重背包中重复次数最多为 m 的物品，那么它对应的泛化物品的函 数有 h(v) = w · v c 仅当 v 被 c 整除且 v c ≤ n，其它情况函数值均为 0。 一个物品组可以看作一个泛化物品 h。对于一个 0 . . . V 中的 v，若物品组中不存在 费用为 v 的物品，则 h(v) = 0，否则 h(v) 取值为所有费用为 v 的物品的最大价值。6中 每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。 视频","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://tutouwang.vercel.app/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"背包九讲","slug":"背包九讲","permalink":"https://tutouwang.vercel.app/tags/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tutouwang.vercel.app/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"蓝桥杯省赛 B组 十一届 第二场","slug":"蓝桥杯省赛_B组_十一届_第二场","date":"2021-03-06T04:21:06.000Z","updated":"2021-03-10T03:22:59.156Z","comments":true,"path":"2021/03/06/蓝桥杯省赛_B组_十一届_第二场/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B_B%E7%BB%84_%E5%8D%81%E4%B8%80%E5%B1%8A_%E7%AC%AC%E4%BA%8C%E5%9C%BA/","excerpt":"","text":"蓝桥杯省赛 B组 十一届 第二场试题A:门牌制作 答案：624 1234567891011121314151617181920212223242526/************************************************************************* &gt; File Name: 十一届—试题A门牌制作.cppz &gt; Author: &gt; Mail: &gt; Created Time: 2021年02月28日 星期日 16时31分53秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;const int MAX_N = 2020;int f[MAX_N + 10];int main() &#123; int n = 0; for (int i = 1; i &lt;= 2020; i++) &#123; int t = i; while (t) &#123; if (t % 10 == 2) n++; t /= 10; &#125; &#125; cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; 试题B:既约分数 答案：2481215 12345678910111213141516171819202122 /************************************************************************* &gt; File Name: 十一届—试题B既约分数.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年02月28日 星期日 19时46分32秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n = 0; for (int i = 1; i &lt;= 2020; i++) &#123; for (int j = 1; j &lt;= 2020; j++) &#123; if(__gcd(i, j) == 1) n++; &#125; &#125; cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; 试题C:蛇形填数 题解思路：有题目可以得出， 红色偶数是斜着向下，蓝色奇数是斜着向上由此可以写出代码。 答案：761 123456789101112131415161718192021222324252627282930313233343536/************************************************************************* &gt; File Name: 蛇形填数.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年02月28日 星期日 20时08分21秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;const int MAX_N = 40;int f[MAX_N][MAX_N];int main() &#123; int n = 1; for (int i = 1; i &lt;= MAX_N; i++) &#123; if (i &amp; 1) &#123; // 奇数的情况 for (int x = i, y = 1; x &gt;= 1 &amp;&amp; y &lt;= i; x--, y++) &#123; f[x][y] = n++; &#125; &#125; else &#123; for (int x = 1, y = i; x &lt;= i &amp;&amp; y &gt;= 1; x++, y--) &#123; f[x][y] = n++; &#125; &#125; &#125; for (int i = 1; i &lt;= 20; i++) &#123; for (int j = 1; j &lt;= 20; j++) &#123; cout &lt;&lt; f[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 试题D:跑步锻炼 答案：8879 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/************************************************************************* &gt; File Name: 跑步锻炼.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年03月01日 星期一 13时00分05秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;// 列出所有月份之后 在特殊处理 2 月int m[13] = &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;int leap_year(int x) &#123; if ((x % 4 == 0 &amp;&amp; x % 100 != 0) || x % 400 == 0) return 1; return 0;&#125;int main() &#123; int s = 0; int mark = 6; // 这里题目给出 2000 年 至 2020 年 因为题目给出 2020年不是整月所以就单处理一下 for (int i = 2000; i &lt; 2020; i++) &#123; if (leap_year(i)) m[2] = 29; else m[2] = 28; for (int j = 1; j &lt;= 12; j++) &#123; for (int k = 1; k &lt;= m[j]; k++) &#123; if (mark % 7 == 1 || k == 1) s += 2; else s++; mark++; &#125; &#125; &#125; // 闰年 29 平年 28 if (leap_year(2020)) m[2] = 29; else m[2] = 28; for (int i = 1; i &lt;= 9; i++) &#123; for (int j = 1; j &lt;= m[i]; j++) &#123; if (mark % 7 == 1 || j == 1) s += 2; else s++; mark++; &#125; &#125; // 题目要求 只道 10 月 1 日 由于还是 月初 所以加上 + 2 cout &lt;&lt; s + 2; return 0;&#125; 试题E:七段码 答案：80 来源于网上一个大佬 枚举出所有情况的做法 $$上面是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一 个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分$$ 试题F:成绩统计 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main() &#123; int n; int E = 0, G = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; int t; cin &gt;&gt; t; if (t &gt; 60) G++; if (t &gt; 85) E++; &#125; int t = E * 100.0 / n + 0.5; int t1 = G * 100.0 / n + 0.5; printf(&quot;%d%%\\n%d%%&quot;, t1, t); return 0;&#125;","categories":[{"name":"蓝桥杯历届真题","slug":"蓝桥杯历届真题","permalink":"https://tutouwang.vercel.app/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"教程","slug":"教程","permalink":"https://tutouwang.vercel.app/categories/%E6%95%99%E7%A8%8B/"},{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯历届真题","slug":"蓝桥杯历届真题","permalink":"https://tutouwang.vercel.app/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98/"},{"name":"算法基础","slug":"算法基础","permalink":"https://tutouwang.vercel.app/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"ACwin题解","slug":"ACwin题解","permalink":"https://tutouwang.vercel.app/categories/ACwin%E9%A2%98%E8%A7%A3/"},{"name":"中位数","slug":"ACwin题解/中位数","permalink":"https://tutouwang.vercel.app/categories/ACwin%E9%A2%98%E8%A7%A3/%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tutouwang.vercel.app/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://tutouwang.vercel.app/tags/%E9%93%BE%E8%A1%A8/"},{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"教程","slug":"教程","permalink":"https://tutouwang.vercel.app/tags/%E6%95%99%E7%A8%8B/"},{"name":"并查集","slug":"并查集","permalink":"https://tutouwang.vercel.app/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"中位数","slug":"中位数","permalink":"https://tutouwang.vercel.app/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"name":"背包九讲","slug":"背包九讲","permalink":"https://tutouwang.vercel.app/tags/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tutouwang.vercel.app/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]}