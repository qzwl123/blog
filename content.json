{"meta":{"title":"秃头王","subtitle":"","description":"","author":"John Doe","url":"https://tutouwang.vercel.app","root":"/"},"pages":[{"title":"","date":"2022-05-24T01:43:13.878Z","updated":"2021-03-10T02:47:10.545Z","comments":true,"path":"404.html","permalink":"https://tutouwang.vercel.app/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2022-05-24T01:43:13.901Z","updated":"2021-03-10T02:43:26.017Z","comments":true,"path":"categories/index.html","permalink":"https://tutouwang.vercel.app/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-24T01:43:13.900Z","updated":"2021-03-10T02:39:15.459Z","comments":true,"path":"about/index.html","permalink":"https://tutouwang.vercel.app/about/index.html","excerpt":"","text":"啊吧啊吧啊吧！！！"},{"title":"","date":"2022-05-24T01:43:13.902Z","updated":"2021-03-10T02:46:22.827Z","comments":true,"path":"mylist/index.html","permalink":"https://tutouwang.vercel.app/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-05-24T01:43:13.903Z","updated":"2021-03-10T02:44:59.392Z","comments":true,"path":"tags/index.html","permalink":"https://tutouwang.vercel.app/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"socket通信基础","slug":"Linux网络编程/socket通信基础","date":"2022-06-17T02:42:10.000Z","updated":"2022-07-01T01:47:26.917Z","comments":true,"path":"2022/06/17/Linux网络编程/socket通信基础/","link":"","permalink":"https://tutouwang.vercel.app/2022/06/17/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1.socket介绍 所谓 socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。 一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处 的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口， 是应用程序与网络协议根进行交互的接口。 socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概 念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接 字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在 主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台 主机的 socket 中，使对方能够接收到这段信息。socket 是由 IP 地址和端口结合的，提供向应用 层进程传送数据包的机制。 socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为 内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接 字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文 件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传 递。 1234// 套接字通信分两部分：- 服务器端：被动接受连接，一般不会主动发起连接- 客户端：主动向服务器发起连接socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别 2. 字节序简介 现代 CPU 的累加器一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。那么这 4 字节在内存中排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题。在各种计算机 体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问 题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如 果不达成一致的规则，通信双方将无法进行正确的编码&#x2F;译码从而导致通信失败。 字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数 据当然就无需谈顺序的问题了)。 字节序分为大端字节序（Big-Endian） 和小端字节序（Little-Endian）。大端字节序是指一个整 数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地 址处；小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地 址处。 字节序举例 小端字节序 ​ 0x 01 02 03 04 - ff &#x3D; 255 ​ 内存的方向 —–&gt; ​ 内存的低位 —–&gt; 内存的高位 ​ 04 03 02 01 ​ 0x 11 22 33 44 12 34 56 78 大端字节序 ​ 0x 01 02 03 04 ​ 内存的方向—– &gt; ​ 内存的低位 —–&gt; 内存的高位 ​ 01 02 03 04 ​ 0x 12 34 56 78 11 22 33 44 查看本机是 大端字节序 or 小端字节序1234567891011121314151617181920212223242526272829303132333435363738394041424344/************************************************************************* &gt; File Name: byteorder.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年06月18日 星期六 14时51分19秒 ************************************************************************//* * 字节序: 字节在内存中存储的顺序 * 小端字节序: 数据的高位字节存储在内存的高位地址,低位字节存储在内存的底位地址。 * 大端字节序: 数据的底位字节存储在内存的高位地址,高位字节存储在内存的底位地址。 * *///通过代码检测当前主机的字节序#include &lt;stdio.h&gt;int main() &#123; union&#123; // 2 字节 short value; // 2 字节 char bytes[sizeof(short)]; &#125; test; test.value = 0x0102; printf(&quot;%d\\n&quot;, test.bytes[0]); if((test.bytes[0] == 1) &amp;&amp; (test.bytes[1] == 2)) &#123; printf(&quot;大端字节序\\n&quot;); &#125; else if((test.bytes[0] == 2) &amp;&amp; (test.bytes[1] == 1))&#123; printf(&quot;小端字节序\\n&quot;); &#125; else &#123; printf(&quot;%d --- %d \\n&quot;, test.bytes[0], test.bytes[1]); printf(&quot;未知\\n&quot;); &#125; return 0;&#125; 字节序转换函数当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的 方法是：发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数 据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小 端机转换，大端机不转换）。 网络字节顺序是 TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而 可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。 BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数： htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。 12345h - host 主机，主机字节序to - 转换成什么n - network 网络字节序s - short unsigned shortl - long unsigned int 1234567#include &lt;arpa/inet.h&gt;// 转换端口uint16_t htons(uint16_t hostshort); // 主机字节序 - 网络字节序uint16_t ntohs(uint16_t netshort); // 网络字节序 - 主机字节序 // 转IPuint32_t htonl(uint32_t hostlong); // 主机字节序 - 网络字节序uint32_t ntohl(uint32_t netlong); // 网络字节序 - 主机字节序 代码实现 网络字节序 与 主机字节序 转换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/************************************************************************* &gt; File Name: byterans.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年06月18日 星期六 22时47分04秒 ************************************************************************//* 网络通信时,需要将主机字节序转换成网络字节序(大端),另外一端获取到数据以后根据情况将网络字节序转换成主机字节序。 #include &lt;arpa/inet.h&gt; // 转换端口 uint16_t htons(uint16_t hostshort); // 主机字节序 - 网络字节序 uint16_t ntohs(uint16_t netshort); // 网络字节序 - 主机字节序 // 转IP uint32_t htonl(uint32_t hostlong); // 主机字节序 - 网络字节序 uint32_t ntohl(uint32_t netlong); // 网络字节序 - 主机字节序 */#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // htons 转换端口 unsigned short a = 0x0102; unsigned short b = htons(a); printf(&quot;0xa = %x \\n0xb = %x\\n&quot;, a, b); printf(&quot;\\n==================================\\n\\n&quot;); // htol 转换ID char buf[4] = &#123;192, 168, 1, 100&#125;; int num = *(int *)buf; // printf(&quot;%d&quot;, num); int sum = htonl(num); unsigned char *p = (char *)&amp;sum; printf(&quot;%d %d %d %d\\n&quot;, *p, *(p + 1), *(p + 2), *(p + 3)); printf(&quot;\\n==================================\\n\\n&quot;); // ntohl unsigned char buf1[4] = &#123;1, 1, 168, 192&#125;; int num1 = *(int *)buf1; int sum1 = ntohl(num1); unsigned char *p1 = (unsigned char *) &amp;sum1; printf(&quot;%d %d %d %d\\n&quot;, *p1, *(p1 + 1), *(p1 + 2), *(p1 + 3)); printf(&quot;\\n==================================\\n\\n&quot;); // ntohs unsigned short a1 = 0x0201; unsigned short b1 = ntohs(a1); printf(&quot;0xa1 = %x\\n0xb1 = %x\\n&quot;, a1, b1); return 0;&#125; 3. socket 地址123// socket地址其实是一个结构体，封装端口号和IP等信息。后面的socket相关的api中需要使用到这个socket地址。// 客户端 -&gt; 服务器（IP, Port） 通用 socket 地址socket 网络编程接口中表示 socket 地址的是结构体 sockaddr，其定义如下： 123456#include &lt;bits/socket.h&gt;struct sockaddr &#123; sa_family_t sa_family; char sa_data[14];&#125;;typedef unsigned short int sa_family_t; sa_family 成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议 族（protocol family，也称 domain）和对应的地址族入下所示： 协议族 地址族 描述 PF_UNIX AF_UNIX UNIX本地域协议族 PF_INET AF_INET TCP&#x2F;IPv4协议族 PF_INET6 AF_INET6 TCP&#x2F;IPv6协议族 宏 PF_* 和 AF_* 都定义在 bits&#x2F;socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混 用。 sa_data 成员用于存放 socket 地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下所 示： 协议族 地址值含义和长度 PF_UNIX 文件的路径名，长度可达到108字节 PF_INET 16bit端口号和32bitIPv4地址，共6字节 PF_INET6 16bit端口号，32bit流标识，128bitIPv6地址，32bit范围ID，共26字节 由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新的 通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的。 1234567#include &lt;bits/socket.h&gt;struct sockaddr_storage &#123; sa_family_t sa_family; unsigned long int __ss_align; char __ss_padding[ 128 - sizeof(__ss_align) ];&#125;;typedef unsigned short int sa_family_t; 专用 socket 地址很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现 在sockaddr 退化成了（void *）的作用，传递一个地址给函数，至于这个函数是 sockaddr_in 还是 sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。 UNIX 本地域协议族使用如下专用的 socket 地址结构体： 123456#include &lt;sys/un.h&gt;struct sockaddr_un&#123; sa_family_t sin_family; char sun_path[108];&#125;; TCP&#x2F;IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和 IPv6： 123456789101112131415161718192021222324252627#include &lt;netinet/in.h&gt;struct sockaddr_in&#123; sa_family_t sin_family; /* __SOCKADDR_COMMON(sin_) */ in_port_t sin_port; /* Port number. */ struct in_addr sin_addr; /* Internet address. */ /* Pad to size of `struct sockaddr&#x27;. */ unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof (in_port_t) - sizeof (struct in_addr)];&#125;;struct in_addr&#123; in_addr_t s_addr;&#125;;struct sockaddr_in6&#123; sa_family_t sin6_family; in_port_t sin6_port; /* Transport layer port # */ uint32_t sin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 address */ uint32_t sin6_scope_id; /* IPv6 scope-id */&#125;;typedef unsigned short uint16_t;typedef unsigned int uint32_t;typedef uint16_t in_port_t;typedef uint32_t in_addr_t;#define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int)) 所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地 址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。 4. IP地址转换（字符串ip-整数 ，主机、网络 字节序的转换）通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用 十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录 日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字 符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换： 1234#include &lt;arpa/inet.h&gt;in_addr_t inet_addr(const char *cp);int inet_aton(const char *cp, struct in_addr *inp);char *inet_ntoa(struct in_addr in); 下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址： 12345678910111213#include &lt;arpa/inet.h&gt;// p:点分十进制的IP字符串， n:表示network，网络字节序的整数int inet_pton(int af, const char *src, void *dst); af:地址族： AF_INET AF_INET6 src:需要转换的点分十进制的IP字符串 dst:转换后的结果保存在这个里面// 将网络字节序的整数，转换成点分十进制的IP地址字符串const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); af:地址族： AF_INET AF_INET6 src: 要转换的ip的整数的地址 dst: 转换成IP地址字符串保存的地方 size：第三个参数的大小（数组的大小） 返回值：返回转换后的数据的地址（字符串），和 dst 是一样的 C代码-实现 IP地址转换函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/************************************************************************* &gt; File Name: iptrans.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年06月20日 星期一 19时45分21秒 ************************************************************************//* #include &lt;arpa/inet.h&gt; // p:点分十进制的IP字符串， n:表示network，网络字节序 的整数 int inet_pton(int af, const char *src, void *dst); af:地址族： AF_INET AF_INET6 src:需要转换的点分十进制的IP字符串 dst:转换后的结果保存在这个里面 // 将网络字节序的整数，转换成点分十进制的IP地址字符串 const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); af:地址族： AF_INET AF_INET6 src: 要转换的ip的整数的地址 dst: 转换成IP地址字符串保存的地方 size：第三个参数的大小（数组的大小） 返回值：返回转换后的数据的地址（字符串），和 dst 是一样的 */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include&lt;arpa/inet.h&gt;int main() &#123; // 创建一个ip字符串,点分十进制的 char buf[] = &quot;192.168.1.1&quot;; unsigned int num = 0; // 将点分十进制的IP字符串 inet_pton(AF_INET, buf, &amp;num); unsigned char *p = (unsigned char *)&amp;num; printf(&quot;%d %d %d %d \\n&quot;, *p, *(p + 1), *(p + 2), *(p + 3)); // 将网络字节序的IP整数 char ip[16] = &quot;&quot;; const char *str = inet_ntop(AF_INET, &amp;num, ip, sizeof(ip)); printf(&quot;str : %s\\n&quot;, str); printf(&quot;ip : %s\\n&quot;, ip); printf(&quot;ip == str = %d\\n&quot;, str == ip); return 0;&#125; 5. TCP通信流程TCP - UDP 特点区别123// TCP 和 UDP -&gt; 传输层的协议UDP:用户数据报协议，面向无连接，可以单播，多播，广播， 面向数据报，不可靠TCP:传输控制协议，面向连接的，可靠的，基于字节流，仅支持单播传输 UDP TCP 是否创建连接 无连接 面向连接 是否可靠 不可靠 可靠的 连接的对象个数 一对一、一对多、多对多、多对一 支持一对一 传输方式 面向数据报 面向字节流 首部开销 8个字节 最少20个字节 适用场景 实时应用（视频会议，直播） 可靠性高的应用（文件传输） 12345678910111213// TCP 通信的流程// 服务器端 （被动接受连接的角色）1. 创建一个用于监听的套接字 - 监听: 监听有客户端的连接 - 套接字: 这个套接字其实就是一个文件描述符2. 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息） - 客户端连接服务器的时候使用的就是这个IP和端口3. 设置监听，监听的fd开始工作4. 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字（fd）5. 通信 - 接收数据 - 发送数据6. 通信结束，断开连接 123456789// 客户端1.创建一个用于通信的套接字(fd)不需要绑定IP和端口 客户端IP会有的但是端口是随机的、连接到服务器刚开始会进行3次握手、两端都记录了两端的IP和端口2.连接服务器，需要指定的连接的服务器的 IP 和 端口3. 连接成功，客户端可以和服务器直接铜线 - 接受数据 - 发送数据6.通信结束，断开连接 6. 套接字函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt; // 包含了这个头文件，上面两个就可以省略int socket(int domain, int type, int protocol); - 功能：创建一个套接字 - 参数： - domain: 协议族 AF_INET : ipv4 AF_INET6 : ipv6 AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信） ... ... - type: 通信过程中使用的协议类型 SOCK_STREAM : 流式协议 - TCP SOCK_DGRAM : 报式协议 - UDP ... ... - protocol: 具体的一个协议。一般写 0 情况下 - SOCK_STREAM : 流式协议默认使用 TCP - SOCK_DGRAM : 报式协议默认使用 UDP - 返回值: - 成功：返回文件描述符，操作的就是内核缓冲区。 - 失败：-1 // 绑定也叫 - socket命名int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); - 功能: 绑定，将fd 和本地的IP + 端口进行绑定 - 参数: - sockfd : 通过socket函数得到的文件描述符 - addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息 - addrlen : 第二个参数结构体占的内存大小 - 返回值: - 成功: 返回 0 - 失败: 返回 -1 并设置错误号 int listen(int sockfd, int backlog); - 功能：监听这个socket上的连接 - 参数： - sockfd : 通过socket()函数得到的文件描述符 - backlog : 未连接的和已经连接的和的最大值, 一般指定 5 就够了,不能超过下面查看的值 查看最大连接 // cat /proc/sys/net/core/somaxconn - 返回值: - 成功: 返回 0 - 失败: 返回 -1 并设置错误号 int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); - 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接 - 参数： - sockfd : 用于监听的文件描述符 - addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port） - addrlenvv : 指定第二个参数的对应的内存大小 - 返回值： - 成功: 用于通信的文件描述符 - 失败: -1 int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); - 功能: 客户端连接服务器 - 参数: - sockfd: 用于通信的文件描述符 - addr: 客户端要连接的服务器的地址信息 - addrlen: 第二个参数的内存大小 - 返回值: - 成功: 0 - 失败: -1 // 写数据ssize_t write(int fd, const void *buf, size_t count); // 读数据ssize_t read(int fd, void *buf, size_t count); TCP - 手动输入消息 - 回射服务器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/************************************************************************* &gt; File Name: server.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年06月22日 星期三 18时45分38秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;// TCP 通信的服务器端Eint main() &#123; // 1.创建socket(用于监听套接字) int lfd = socket(AF_INET, SOCK_STREAM, 0); if(lfd == 1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.绑定 IP 和 端口 struct sockaddr_in saddr; saddr.sin_family = AF_INET; // inet_net_pton(AF_INET, &quot;192.168.3.206&quot;, saddr.sin_addr.s_addr); saddr.sin_addr.s_addr = INADDR_ANY; // = 0; // 0.0.0.0 任意地址 客户端不能这面写 saddr.sin_port = htons(9999); int ret = bind(lfd, (struct sockaddr *)&amp;saddr, sizeof(saddr)); if(ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 3.监听 ret = listen(lfd, 8); if(ret == -1) &#123; perror(&quot;listen&quot;); exit(-1); &#125; // 4.接受客户端的连接 - 阻塞 struct sockaddr_in clientaddr; socklen_t len = sizeof(clientaddr); int cfd = accept(lfd, (struct sockaddr *)&amp;clientaddr, &amp;len); if(cfd == -1) &#123; perror(&quot;accept&quot;); exit(-1); &#125; // 输出客户端的信息 char clientIP[16]; inet_ntop(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, sizeof(clientIP)); unsigned short clientPort = ntohs(clientaddr.sin_port); printf(&quot;client ip is %s, prot is %d\\n&quot;, clientIP, clientPort); while(1) &#123; // 5.通信 // 获取客户的数据 char recvBuf[1024] = &#123;0&#125;; int readLen = read(cfd, recvBuf, sizeof(recvBuf)); if(readLen == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if(readLen &gt; 0) &#123; printf(&quot;recv client data : %s\\n&quot;, recvBuf); &#125; else if(readLen == 0) &#123; // 客户端断开连接 printf(&quot;client closed ... ...\\n&quot;); break; &#125; // 给客户端发送数据 char *data = &quot;hello, i am server&quot;; write(cfd, recvBuf, strlen(data)); &#125; // 关闭文件描述符 close(cfd); close(lfd); return 0;&#125; 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/************************************************************************* &gt; File Name: client.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年06月23日 星期四 14时41分42秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;// TCP 通信客户端int main() &#123; // 1.创建套接字 int fd = socket(AF_INET, SOCK_STREAM, 0); if(fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.连接服务 struct sockaddr_in serveraddr; serveraddr.sin_family = AF_INET; serveraddr.sin_port = htons(9999); inet_pton(AF_INET, &quot;192.168.222.139&quot;, &amp;serveraddr.sin_addr.s_addr); int ret = connect(fd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)); if(ret == -1) &#123; perror(&quot;connect&quot;); exit(-1); &#125; // 通信 char recvBuf[1024] = &#123;0&#125;; char data[1024]; while (1) &#123; memset(data, 0, sizeof(data)); // 获取标准输入(stdin)的数据 fgets(data, sizeof(data), stdin); write(fd, data, strlen(data)); int readLen = read(fd, recvBuf, sizeof(recvBuf)); if(readLen == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if(readLen &gt; 0) &#123; printf(&quot;recv server data : %s\\n&quot;, recvBuf); &#125; else if(readLen == 0) &#123; // 表示服务端断开连接 printf(&quot;server closed ... ...\\n&quot;); break; &#125; &#125; // 关闭 close(fd); return 0;&#125; 7. TCP 三次握手TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连 接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。 TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程 中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。 TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 四次挥手 来关闭一个连接。 三次握手的目的是保证双方互相之间建立了连接 三次握手发生在客户端连接的时候，当调用connect(),底层会通过TCP协议进行三次握手。 TCP三次握手四次挥手 - 图解 为社么不能2次握手 直接说你做我女朋友行吗？ 回复 好的 答:客户端要知道自己能发数据也能收数据 服务端也是一样的 客户端给服务器发能确保的是客户端可以发送数据，但是不能确定服务端的收和发是否是好使的 服务端收到信息了服务端可以确定自己收是好的还能确定客户端的发是好的 (客) C -&gt; S(服) 服务端回一个数据就能确定自己发也是没有问题的 客户端收到信息能确定自己的收是没有问题也能确定服务端的收发是没有问题的 (客) C &lt;- S(服) 服务端收到客户发来的数据就知道客户端的收是好的 (客) C -&gt; S(服) ACK: 用来做确认的 SYN: 用来做连接的 FIN: 用来做四次挥手的 断开连接的 16 位端口号（port number）：告知主机报文段是来自哪里（源端口）以及传给哪个上层协议或 应用程序（目的端口）的。进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号。 32 位序号（sequence number）：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输 方向上的字节流的每个字节的编号。假设主机 A 和主机 B 进行 TCP 通信，A 发送给 B 的第一个 TCP 报文段中，序号值被系统初始化为某个随机值 ISN（Initial Sequence Number，初始序号 值）。那么在该传输方向上（从 A 到 B），后续的 TCP 报文段中序号值将被系统设置成 ISN 加上 该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个 TCP 报文段传送的数据是字 节流中的第 1025 ~ 2048 字节，那么该报文段的序号值就是 ISN + 1025。另外一个传输方向（从 B 到 A）的 TCP 报文段的序号值也具有相同的含义。 32 位确认号（acknowledgement number）：用作对另一方发送来的 TCP 报文段的响应。其值是 收到的 TCP 报文段的序号值 + 标志位长度（SYN，FIN） + 数据长度 。假设主机 A 和主机 B 进行 TCP 通信，那么 A 发送出的 TCP 报文段不仅携带自己的序号，而且包含对 B 发送来的 TCP 报文段 的确认号。反之，B 发送出的 TCP 报文段也同样携带自己的序号和对 A 发送来的报文段的确认序 号。 4 位头部长度（head length）：标识该 TCP 头部有多少个 32 bit(4 字节)。因为 4 位最大能表示 15，所以 TCP 头部最长是60 字节。 - 功能： 客户端连接服务器 - 参数： - sockfd : 用于通信的文件描述符 - addr : 客户端要连接的服务器的地址信息 - addrlen : 第二个参数的内存大小 - 返回值：成功 0， 失败 -1 ssize_t write(int fd, const void *buf, size_t count); &#x2F;&#x2F; 写数据 ssize_t read(int fd, void *buf, size_t count); &#x2F;&#x2F; 读数据 6 位标志位包含如下几项： URG 标志，表示紧急指针（urgent pointer）是否有效。 ACK 标志，表示确认号是否有效。我们称携带 ACK 标志的 TCP 报文段为确认报文段。 PSH 标志，提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为接收后续数据腾 出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在 TCP 接收缓冲区中）。 RST 标志，表示要求对方重新建立连接。我们称携带 RST 标志的 TCP 报文段为复位报文段。 SYN 标志，表示请求建立一个连接。我们称携带 SYN 标志的 TCP 报文段为同步报文段。 FIN 标志，表示通知对方本端要关闭连接了。我们称携带 FIN 标志的 TCP 报文段为结束报文 段。 16 位窗口大小（window size）：是 TCP 流量控制的一个手段。这里说的窗口，指的是接收 通告窗口（Receiver Window，RWND）。它告诉对方本端的 TCP 接收缓冲区还能容纳多少 字节的数据，这样对方就可以控制发送数据的速度。 16 位校验和（TCP checksum）：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以校验 TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。 这也是 TCP 可靠传输的一个重要保障。 16 位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一 个紧急数据的下一个字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏 移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。 时序图 1234567891011第一次握手: 1.客户端将SYN标志为1 2.生成一个随机的32位的序号seq = J，这序号后边是可以携带数据 (数据的大小)第二个次握手: 1.服务器端接收客户端的连接: ACK = 1 2.服务器会回发一个确认序号: ack = 客户的序号 + 数据的长度 + SYN/FIN(按一个字节来算) 3.服务器端会向客户端发起连接请求: SYN = 1 4.服务器也会生成一个随机序号: seq = K第三次握手: 1.客户端应答服务器的连接请求: ACK = 1 2.客户端回复收到了服务端的数据: ack = 服务端的序号 + 数据长度 + SYN/FIN(按一个字节算) 序号 和 确认序号 通信的过程 8. TCP 滑动窗口 滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的 拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包， 谁也发不了数据，所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种 技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包 （称窗口尺寸）。 TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于 接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报。 滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构。 窗口理为缓冲区的大小 滑动窗口的大小会随着发送数据和接受数据而变化 通信的双方都有发送的缓冲区和接收数据的缓冲区 ​ 服务器: ​ 发送缓冲区 (发送缓冲区的窗口) ​ 接受缓冲区 (接收缓冲区的窗口) ​ 客户端 ​ 发送缓冲区 (发送缓冲区的窗口) ​ 接受缓冲区 12345678发送方的缓冲区: 白色格子: 空闲的空间 灰色格子: 数据已经被发送出去，但是还没有被接收,服务-回复ack确认收到那了 紫色格子: 还没有发送出去的数据 接受收方的缓冲区: 白色格子: 空闲空间 紫色格子: 已经接收到的数据 123456789101112131415161718192021# mss: Maximum Segment Size(一条数据的最大的数据量)# win: 滑动窗口 1. 客户端向服务器发起连接，客户端的滑动窗口是4096,一次发送的最大的数据是14602. 服务器接收连接情况,告诉客户端服务的窗口大小是6144，一次发送的最大的数据是10243. 第三次握手4. 第4 - 9客户端连续给服务器发送了6k的数据, 每次发送1k5. 第10次, 服务器告诉客户端: 发送的6k数据以及接收到, 存储在缓冲区中, 缓冲区数据已经处理了2k, 窗口大小是2k6. 第11次, 服务器告诉客户端: 发送的6k数据以及接收到, 存储在缓冲区中, 缓冲区数据已经处理了4k, 窗口大小是4k7. 第12次, 给服务器发送了1k数据# 客户端发送请求断开连接 - 第一次挥手8. 第13次, 客户端主动发起请求和服务器断开连接, 并且给服务器发送了1k数据9. 第14次, 服务器回复ACK 8194 a:同意断开请求 b:告诉客户端已经接受到对方的才发的2k数据 c: 滑动窗口2k# 客户端一方断开后是不能发送数据了,但是可以接受数据10. 第15、16, 通知客户端11. 第17次, 第三次挥手服务器给客户端发送FIN请求断开连接12. 第18次, 第四次回收, 客户端同意了服务器的断开# 第一次握手 不能携带数据 因为: 三次握手还没建立连接就不能携带数据# 第二次握手之后 左边就可以给右面发送数据了, 但是右面不能给给左面发送数据, 只能等三次握手结束后右面才能给左面发送数据 9. TCP 四次挥手123四次挥手发生在断开连接的时候，在程序中调用了close()会使用TCP协议进行四次挥手。客户端和服务器都可以主动发起断开连接,谁先调用close()谁就是发起。因为在TCP连接的时候, 采用三次握手建立的连接是双向的, 在断开的时候也需要双向断开。 TCP 通信并发 - 进程 TCP多用户和服务器传输 123456要实现TCP通信服务器处理并发的任务, 使用多线程或者多进程来解决。思路: 1. 一个父进程, 多个子进程 2. 父进程负责等待并接受客户端的连接 3. 子进程: 完成通信, 接受一个客户端连接, 就创建一个子进程用于通信 server_process.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/************************************************************************* &gt; File Name: server_process.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年06月26日 星期日 21时33分58秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;#include &lt;wait.h&gt;#include &lt;errno.h&gt;void recyleChild(int arg) &#123; while(1) &#123; int ret = waitpid(-1, NULL, WNOHANG); if(ret == -1) &#123; // 所有的子进程都回收了 break; &#125; else if(ret == 0) &#123; // 还有子进程活着 break; &#125; else if(ret &gt; 0)&#123; // 被回收的子进程的 PID printf(&quot;子进程: %d 被回收了\\n&quot;, ret); &#125; &#125;&#125;int main() &#123; // 注册信号捕捉 struct sigaction act; act.sa_flags = 0; sigemptyset(&amp;act.sa_mask); act.sa_handler = recyleChild; sigaction(SIGCHLD, &amp;act, NULL); int ret = -1; // 创建一个socket PF 和 AF 是一样的可以混用 int lfd = socket(PF_INET, SOCK_STREAM, 0); if(lfd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 绑定 struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_port = htons(5210); saddr.sin_addr.s_addr = INADDR_ANY; ret = bind(lfd, (struct sockaddr *)&amp;saddr, sizeof(saddr)); if(ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 监听 ret = listen(lfd, 128); if(ret == -1) &#123; perror(&quot;listen&quot;); exit(-1); &#125; // 不断循环 等待接受客户端 while(1) &#123; // 保存连接进来的客户端的信息 struct sockaddr_in cliaddr; // int len = sizeof(cliaddr); socklen_t len = sizeof(cliaddr); // 接受连接 int cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len); if(cfd == -1) &#123; if(errno == EINTR) &#123; continue; &#125; perror(&quot;accept&quot;); exit(-1); &#125; // 每一个连接进来, 都创建一个子进程跟客户端通信 pid_t pid = fork(); if(pid == 0) &#123; // 子进程 // 获取客户端的信息 char cliIP[16]; inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIP, sizeof(cliIP)); unsigned short cliProt = ntohs(cliaddr.sin_port); printf(&quot;client ip is : %s, prot is : %d\\n&quot;, cliIP, cliProt); // 接受客户端发来的数据 char recvBuf[1024]; while(1) &#123; memset(recvBuf, 0, sizeof(recvBuf)); int len = read(cfd, &amp;recvBuf, sizeof(recvBuf)); if(len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if(len &gt; 0) &#123; printf(&quot;IP : %s\\n recv client Data : %s\\n\\n&quot;, cliIP, recvBuf); &#125; else &#123; printf(&quot;client closed ... ...\\n&quot;); break; &#125; // 回射 write(cfd, recvBuf, strlen(recvBuf)); &#125; close(cfd); // 退出当前子进程 exit(0); &#125; &#125; close(lfd); return 0;&#125; client.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/************************************************************************* &gt; File Name: client.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年06月23日 星期四 14时41分42秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;// TCP 通信客户端int main() &#123; // 1.创建套接字 int fd = socket(AF_INET, SOCK_STREAM, 0); if(fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.连接服务 struct sockaddr_in serveraddr; serveraddr.sin_family = AF_INET; serveraddr.sin_port = htons(5210); inet_pton(AF_INET, &quot;192.168.222.1&quot;, &amp;serveraddr.sin_addr.s_addr); int ret = connect(fd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)); if(ret == -1) &#123; perror(&quot;connect&quot;); exit(-1); &#125; // 通信 char recvBuf[1024] = &#123;0&#125;; char data[1024]; while (1) &#123; memset(data, 0, sizeof(data)); memset(recvBuf, 0, sizeof(recvBuf)); // 获取标准输入(stdin)的数据 fgets(data, sizeof(data), stdin); write(fd, data, strlen(data)); int readLen = read(fd, recvBuf, sizeof(recvBuf)); if(readLen == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if(readLen &gt; 0) &#123; printf(&quot;recv server data : %s\\n&quot;, recvBuf); &#125; else if(readLen == 0) &#123; // 表示服务端断开连接 printf(&quot;server closed ... ...\\n&quot;); break; &#125; &#125; // 关闭 close(fd); return 0;&#125; TCP 通信并发 - 线程server_thread.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/************************************************************************* &gt; File Name: server_thread.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年06月27日 星期一 18时00分07秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;pthread.h&gt;struct sockInfo &#123; // 通信的文件描述符 int fd; // 线程号 pthread_t tid; // 客户端的信息 struct sockaddr_in addr;&#125;;struct sockInfo sockinfos[128];void *working(void *arg) &#123; // 子线程和客户端通信 cfd、客户端的信息、线程号 // 获取客户端信息 struct sockInfo *pinfo = (struct sockInfo *) arg; char cliIP[16]; inet_ntop(AF_INET, &amp;pinfo-&gt;addr.sin_addr.s_addr, cliIP, sizeof(cliIP)); unsigned short cliPort = pinfo-&gt;addr.sin_port; printf(&quot;clien ip is : %s, prot is %d\\n&quot;, cliIP, cliPort); char recvBuf[1024]; while(1) &#123; memset(recvBuf, 0, sizeof(recvBuf)); int len = read(pinfo-&gt;fd, &amp;recvBuf, sizeof(recvBuf)); if(len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if(len &gt; 0) &#123; printf(&quot;IP : %s\\n recv client Data : %s\\n\\n&quot;, cliIP, recvBuf); &#125; else &#123; printf(&quot;client closed ... ...\\n&quot;); break; &#125; // 回射 write(pinfo-&gt;fd, recvBuf, strlen(recvBuf)); &#125; pinfo-&gt;fd = -1; pinfo-&gt;tid = -1; close(pinfo-&gt;fd); return NULL;&#125;int main() &#123; // 创建一个socket() int lfd = socket(AF_INET, SOCK_STREAM, 0); if(lfd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 绑定 struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_port = htons(5200); saddr.sin_addr.s_addr = INADDR_ANY; int ret = bind(lfd, (struct sockaddr *)&amp;saddr, sizeof(saddr)); // 监听 ret = listen(lfd, 128); if(ret == -1) &#123; perror(&quot;listen&quot;); exit(-1); &#125; // 初始化数据 int max = sizeof(sockinfos) / sizeof(sockinfos[0]); for(int i = 0; i &lt; max; i++) &#123; bzero(&amp;sockinfos[i], sizeof(sockinfos[i])); sockinfos[i].fd = -1; sockinfos[i].tid = -1; &#125; // 循环等待客户端连接, 一旦一个客户端连接进来, 就创建一个线程进行通信 while(1) &#123; struct sockaddr_in cliaddr; socklen_t len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr *) &amp;cliaddr, &amp;len); // 文件描述符fd、客户端的信息addr、线程号tid struct sockInfo *pinfo; for(int i = 0; i &lt; max; i++) &#123; // 从这个数组中找到一个可以用的sockInfo变量/元素 if(sockinfos[i].fd == -1) &#123; pinfo = &amp;sockinfos[i]; break; &#125; if(i == max - 1) &#123; sleep(1); i--; &#125; &#125; pinfo-&gt;fd = cfd; memcpy(&amp;pinfo-&gt;addr, &amp;cliaddr, len); // 创建子线程 // pthread_t tid; pthread_create(&amp;pinfo-&gt;tid, NULL, working, pinfo); // 线程分离 - 使线程在结束时候自动回收 pthread_detach(pinfo-&gt;tid); &#125; close(lfd); return 0;&#125; gcc server_thread.c -o server_thread -pthread client.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/************************************************************************* &gt; File Name: client.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年06月23日 星期四 14时41分42秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;// TCP 通信客户端int main() &#123; // 1.创建套接字 int fd = socket(AF_INET, SOCK_STREAM, 0); if(fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.连接服务 struct sockaddr_in serveraddr; serveraddr.sin_family = AF_INET; serveraddr.sin_port = htons(5200); inet_pton(AF_INET, &quot;192.168.222.1&quot;, &amp;serveraddr.sin_addr.s_addr); int ret = connect(fd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)); if(ret == -1) &#123; perror(&quot;connect&quot;); exit(-1); &#125; // 通信 char recvBuf[1024] = &#123;0&#125;; char data[1024]; while (1) &#123; memset(data, 0, sizeof(data)); memset(recvBuf, 0, sizeof(recvBuf)); // 获取标准输入(stdin)的数据 fgets(data, sizeof(data), stdin); write(fd, data, strlen(data)); int readLen = read(fd, recvBuf, sizeof(recvBuf)); if(readLen == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if(readLen &gt; 0) &#123; printf(&quot;recv server data : %s\\n&quot;, recvBuf); &#125; else if(readLen == 0) &#123; // 表示服务端断开连接 printf(&quot;server closed ... ...\\n&quot;); break; &#125; &#125; // 关闭 close(fd); return 0;&#125; 11. TCP 状态转换 红色线: 客户端 绿色线: 服务器 2MSL（Maximum Segment Lifetime） 主动断开连接的一方, 最后进出入一个 TIME_WAIT状态, 这个状态会持续: 2ms msl: 官方建议: 2分钟, 实际是30s 当 TCP 连接主动关闭方接收到被动关闭方发送的 FIN 和最终的 ACK 后，连接的主动关闭方 必须处于TIME_WAIT 状态并持续 2MSL 时间。 这样就能够让 TCP 连接的主动关闭方在它发送的 ACK 丢失的情况下重新发送最终的 ACK。 主动关闭方重新发送的最终 ACK 并不是因为被动关闭方重传了 ACK（它们并不消耗序列号， 被动关闭方也不会重传），而是因为被动关闭方重传了它的 FIN。事实上，被动关闭方总是 重传 FIN 直到它收到一个最终的 ACK。 半关闭 当 TCP 链接中 A 向 B 发送 FIN 请求关闭，另一端 B 回应 ACK 之后（A 端进入 FIN_WAIT_2 状态），并没有立即发送 FIN 给 A，A 方处于半连接状态（半开关），此时 A 可以接收 B 发 送的数据，但是 A 已经不能再向 B 发送数据。 从程序的角度，可以使用 API 来控制实现半连接状态 123456789#include &lt;sys/socket.h&gt;int shutdown(int sockfd, int how); sockfd: 需要关闭的socket的描述符 how: 允许为shutdown操作选择以下几种方式: SHUT_RD(0)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。 该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。 SHUT_WR(1): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。 SHUT_RDWR(2):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。 使用 close 中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用 计数为 0 时才关闭连接。shutdown 不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方 向的连接，只中止读或只中止写。 注意: 如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用 进程都调用了 close，套接字将被释放。 在多进程中如果一个进程调用了 shutdown(sfd, SHUT_RDWR) 后，其它的进程将无法进行通信。 但如果一个进程 close(sfd) 将不会影响到其它进程。 12. 端口复用 端口复用最常用的用途是: 防止服务器重启时之前绑定的端口还未释放 程序突然退出而系统没有释放端口 1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;// 设置套接字的属性 (不仅仅能设置端口的复用)int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); 参数: - socket: 要操作的文件描述符 - level: 级别 - SOL_SOCKET (端口复用的级别) - optname: 选项的命称 - SO_REUSEADDR - SO_REUSEPORT - optval: 端口复用的值(整形) - 1: 可以复用 - 0: 不可以复用 - oprlen: optval参数的大小端口复用: 设置的时机是在服务器绑定端口之前。 setsockopt(); bind(); 查看网络相关信息相关的命令netstat 参数: -a 显示所有连接的socke -p 显示正在使用socket的程序的名称 -n 直接使用IP -t 显示TCP -u 显示UDP netstat -anp | grep 端口 TCP - 服务端 和 客户端 - 网络连接状态及其相关信息正常通信下状态是不回改变 123为什么有两个 server 第一个是监听的 第二个是建立连接的 ESTABLISHED 断开服务器端 可看上面图解 - 状态","categories":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"https://tutouwang.vercel.app/categories/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"网络基础","slug":"Linux网络编程/网络基础","date":"2022-06-15T01:31:01.000Z","updated":"2022-07-01T01:47:50.435Z","comments":true,"path":"2022/06/15/Linux网络编程/网络基础/","link":"","permalink":"https://tutouwang.vercel.app/2022/06/15/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1.网络结构模式C&#x2F;S结构简介 服务器 - 客户机，即 Client - Server（C&#x2F;S）结构。C&#x2F;S 结构通常采取两层结构。服务器负责数据的 管理，客户机负责完成与用户的交互任务。客户机是因特网上访问别人信息的机器，服务器则是提 供信息供人访问的计算机。 客户机通过局域网与服务器相连，接受用户的请求，并通过网络向服务器提出请求，对数据库进行 操作。服务器接受客户机的请求，将数据提交给客户机，客户机将数据进行计算并将结果呈现给用 户。服务器还要提供完善安全保护及对数据完整性的处理等操作，并允许多个客户机同时访问服务 器，这就对服务器的硬件处理数据能力提出了很高的要求。 在C&#x2F;S结构中，应用程序分为两部分：服务器部分和客户机部分。服务器部分是多个用户共享的信 息与功能，执行后台服务，如控制共享数据库的操作等；客户机部分为用户所专有，负责执行前台 功能，在出错提示、在线帮助等方面都有强大的功能，并且可以在子程序间自由切换。 优点 能充分发挥客户端 PC 的处理能力，很多工作可以在客户端处理后再提交给服务器，所以 C&#x2F;S 结构 客户端响应速度快； 操作界面漂亮、形式多样，可以充分满足客户自身的个性化要求； C&#x2F;S 结构的管理信息系统具有较强的事务处理能力，能实现复杂的业务流程； 安全性较高，C&#x2F;S 一般面向相对固定的用户群，程序更加注重流程，它可以对权限进行多层次校 验，提供了更安全的存取模式，对信息安全的控制能力很强，一般高度机密的信息系统采用 C&#x2F;S 结 构适宜。 缺点 客户端需要安装专用的客户端软件。首先涉及到安装的工作量，其次任何一台电脑出问题，如病 毒、硬件损坏，都需要进行安装或维护。系统软件升级时，每一台客户机需要重新安装，其维护和 升级成本非常高； 对客户端的操作系统一般也会有限制，不能够跨平台。 B&#x2F;S结构简介 B&#x2F;S 结构（Browser&#x2F;Server，浏览器&#x2F;服务器模式），是 WEB 兴起后的一种网络结构模式，WEB 浏览器是客户端最主要的应用软件。这种模式统一了客户端，将系统功能实现的核心部分集中到服 务器上，简化了系统的开发、维护和使用。客户机上只要安装一个浏览器，如 Firefox 或 Internet Explorer，服务器安装 SQL Server、Oracle、MySQL 等数据库。浏览器通过 Web Server 同数据 库进行数据交互 优点B&#x2F;S 架构最大的优点是总体拥有成本低、维护方便、 分布性强、开发简单，可以不用安装任何专门的软 件就能实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能 使用。 缺点 通信开销大、系统和数据的安全性较难保障; 个性特点明显降低，无法实现具有个性化的功能要求； 协议一般是固定的：http&#x2F;https 客户端服务器端的交互是请求-响应模式，通常动态刷新页面，响应速度明显降低。 2. MAC 地址 网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件，又称为网络适配器或网 络接口卡NIC。其拥有 MAC 地址，属于 OSI 模型的第 2 层，它使得用户可以通过电缆或无线相互 连接。每一个网卡都有一个被称为 MAC 地址的独一无二的 48 位串行号。网卡的主要功能：1.数 据的封装与解封装、2.链路管理、3.数据编码与译码。 MAC 地址（Media Access Control Address），直译为媒体存取控制位址，也称为局域网地址、 以太网地址、物理地址或硬件地址，它是一个用来确认网络设备位置的位址，由网络设备制造商生 产时烧录在网卡中。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 位址 。MAC 地址用于在网络中唯一标识一个网卡，一台设备若有一或多个网卡，则每个网卡都需 要并会有一个唯一的 MAC 地址。 MAC 地址的长度为 48 位（6个字节），通常表示为 12 个 16 进制数，如：00-16-EA-AE-3C-40 就 是一个MAC 地址，其中前 3 个字节，16 进制数 00-16-EA 代表网络硬件制造商的编号，它由 IEEE（电气与电子工程师协会）分配，而后 3 个字节，16进制数 AE-3C-40 代表该制造商所制造的 某个网络产品（如网卡）的系列号。只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。 形象地说，MAC 地址就如同身份证上的身份证号码，具有唯一性。 3. IP 地址简介 IP 协议是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所 有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任 何厂家生产的计算机系统，只要遵守 IP 协议就可以与因特网互连互通。各个厂家生产的网络系统 和设备，如以太网、分组交换网等，它们相互之间不能互通，不能互通的主要原因是因为它们所传 送数据的基本单元（技术上称之为“帧”）的格式不同。IP 协议实际上是一套由软件程序组成的协议 软件，它把各种不同“帧”统一转换成“IP 数据报”格式，这种转换是因特网的一个最重要的特点，使 所有各种计算机都能在因特网上实现互通，即具有“开放性”的特点。正是因为有了 IP 协议，因特 网才得以迅速发展成为世界上最大的、开放的计算机通信网络。因此，IP 协议也可以叫做“因特网 协议”。 IP 地址（Internet Protocol Address）是指互联网协议地址，又译为网际协议地址。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以 此来屏蔽物理地址的差异。 IP 地址是一个 32 位的二进制数，通常被分割为 4 个“ 8 位二进制数”（也就是 4 个字节）。IP 地址 通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是 0~255 之间的十进制整数。 例：点分十进IP地址（100.4.5.6），实际上是 32 位二进制数 （01100100.00000100.00000101.00000110）。 IP 地址编址方式最初设计互联网络时，为了便于寻址以及层次化构造网络，每个 IP 地址包括两个标识码（ID），即网络 ID 和主机 ID。同一个物理网络上的所有主机都使用同一个网络 ID，网络上的一个主机（包括网络上工 作站，服务器和路由器等）有一个主机 ID 与其对应。Internet 委员会定义了 5 种 IP 地址类型以适合不 同容量的网络，即 A 类~ E 类。 其中 A、B、C 3类（如下表格）由 InternetNIC 在全球范围内统一分配，D、E 类为特殊地址。 类别 最大网络数 IP地址范围 单个网段最大主机数 私有IP地址范围 A 126(2^7-2) 1.0.0.1-126.255.255.254 16777214 10.0.0.0- 10.255.255.255 B 16384(2^14) 128.0.0.1- 191.255.255.254 65534 172.16.0.0- 172.31.255.255 C 2097152(2^21) 192.0.0.1-223.255.255.254 254 192.168.0.0- 192.168.255.255 A类IP地址一个 A 类 IP 地址是指， 在 IP 地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算 机的号码。如果用二进制表示 IP 地址的话，A 类 IP 地址就由 1 字节的网络地址和 3 字节主机地址组 成，网络地址的最高位必须是“0”。A 类 IP 地址中网络的标识长度为 8 位，主机标识的长度为 24 位，A 类网络地址数量较少，有 126 个网络，每个网络可以容纳主机数达 1600 多万台。 A 类 IP 地址 地址范围 1.0.0.1 - 126.255.255.254（二进制表示为：00000001 00000000 00000000 00000001 - 01111111 11111111 11111111 11111110）。最后一个是广播地址。 A 类 IP 地址的子网掩码为 255.0.0.0，每个网络支持的最大主机数为 256 的 3 次方 - 2 &#x3D; 16777214 台。 B类IP地址一个 B 类 IP 地址是指，在 IP 地址的四段号码中，前两段号码为网络号码。如果用二进制表示 IP 地址的 话，B 类 IP 地址就由 2 字节的网络地址和 2 字节主机地址组成，网络地址的最高位必须是“10”。B 类 IP 地址中网络的标识长度为 16 位，主机标识的长度为 16 位，B 类网络地址适用于中等规模的网络，有 16384 个网络，每个网络所能容纳的计算机数为 6 万多台。 B 类 IP 地址地址范围 128.0.0.1 - 191.255.255.254 （二进制表示为：10000000 00000000 00000000 00000001 - 10111111 11111111 11111111 11111110）。 最后一个是广播地址。 B 类 IP 地址的子网掩码为 255.255.0.0，每个网络支持的最大主机数为 256 的 2 次方 - 2 &#x3D; 65534 台。 C类IP地址一个 C 类 IP 地址是指，在 IP 地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算 机的号码。如果用二进制表示 IP 地址的话，C 类 IP 地址就由 3 字节的网络地址和 1 字节主机地址组 成，网络地址的最高位必须是“110”。C 类 IP 地址中网络的标识长度为 24 位，主机标识的长度为 8 位， C 类网络地址数量较多，有 209 万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台 计算机。 C 类 IP 地址范围 192.0.0.1-223.255.255.254 （二进制表示为: 11000000 00000000 00000000 00000001 - 11011111 11111111 11111111 11111110）。 C类IP地址的子网掩码为 255.255.255.0，每个网络支持的最大主机数为 256 - 2 &#x3D; 254 台。 D类IP地址D 类 IP 地址在历史上被叫做多播地址（multicast address），即组播地址。在以太网中，多播地址命 名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是 “1110”，范围从 224.0.0.0 - 239.255.255.255。 特殊的网址每一个字节都为 0 的地址（ “0.0.0.0” ）对应于当前主机； IP 地址中的每一个字节都为 1 的 IP 地址（ “255.255.255.255” ）是当前子网的广播地址； IP 地址中凡是以 “11110” 开头的 E 类 IP 地址都保留用于将来和实验使用。 IP地址中不能以十进制 “127” 作为开头，该类地址中数字 127.0.0.1 到 127.255.255.255 用于回路测 试，如：127.0.0.1可以代表本机IP地址。 子网掩码 子网掩码（subnet mask）又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个 IP 地 址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存 在，它必须结合 IP 地址一起使用。子网掩码只有一个作用，就是将某个 IP 地址划分成网络地址和 主机地址两部分。 子网掩码是一个 32 位地址，用于屏蔽 IP 地址的一部分以区别网络标识和主机标识，并说明该 IP 地址是在局域网上，还是在广域网上。 子网掩码是在 IPv4 地址资源紧缺的背景下为了解决 lP 地址分配而产生的虚拟 lP 技术，通过子网掩码将 A、B、C 三类地址划分为若干子网，从而显著提高了 IP 地址的分配效率，有效解决了 IP 地址资源紧张 的局面。另一方面，在企业内网中为了更好地管理网络，网管人员也利用子网掩码的作用，人为地将一 个较大的企业内部网络划分为更多个小规模的子网，再利用三层交换机的路由功能实现子网互联，从而 有效解决了网络广播风暴和网络病毒等诸多网络管理方面的问题。 在大多数的网络教科书中，一般都将子网掩码的作用描述为通过逻辑运算，将 IP 地址划分为网络标识 (Net.ID) 和主机标识(Host.ID)，只有网络标识相同的两台主机在无路由的情况下才能相互通信。 根据 RFC950 定义，子网掩码是一个 32 位的 2 进制数， 其对应网络地址的所有位都置为 1，对应于主 机地址的所有位置都为 0。子网掩码告知路由器，地址的哪一部分是网络地址，哪一部分是主机地址， 使路由器正确判断任意 IP 地址是否是本网段的，从而正确地进行路由。网络上，数据从一个地方传到另 外一个地方，是依靠 IP 寻址。从逻辑上来讲，是两步的。第一步，从 IP 中找到所属的网络，好比是去 找这个人是哪个小区的；第二步，再从 IP 中找到主机在这个网络中的位置，好比是在小区里面找到这个 人。 子网掩码的设定必须遵循一定的规则。与二进制 IP 地址相同，子网掩码由 1 和 0 组成，且 1 和 0 分别 连续。子网掩码的长度也是 32 位，左边是网络位，用二进制数字 “1” 表示，1 的数目等于网络位的长 度；右边是主机位，用二进制数字 “0” 表示，0 的数目等于主机位的长度。这样做的目的是为了让掩码 与 IP 地址做按位与运算时用 0 遮住原主机数，而不改变原网络段数字，而且很容易通过 0 的位数确定子 网的主机数（ 2 的主机位数次方 - 2，因为主机号全为 1 时表示该网络广播地址，全为 0 时表示该网络 的网络号，这是两个特殊地址）。通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使 网络正常工作。 4. 端口简介“端口” 是英文 port 的意译，可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理 端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见，是特指TCP&#x2F;IP协议中的端 口，是逻辑意义上的端口。例如计算机中的 80 端口、21 端口、23 端口等。物理端口又称为接 口，是可见端口，计算机背板的 RJ45 网口，交换机路由器集线器等 RJ45 端口。电话使用 RJ11 插 口也属于物理端口的范畴。 如果把 IP 地址比作一间房子，端口就是出入这间房子的门。真正的房子只有几个门，但是一个 IP 地址的端口可以有 65536（即：2^16）个之多！端口是通过端口号来标记的，端口号只有整数， 范围是从 0 到65535（2^16-1）。 端口类型 周知端口（Well Known Ports） 周知端口是众所周知的端口号，也叫知名端口、公认端口或者常用端口，范围从 0 到 1023，它们紧密 绑定于一些特定的服务。例如 80 端口分配给 WWW 服务，21 端口分配给 FTP 服务，23 端口分配给 Telnet服务等等。我们在 IE 的地址栏里输入一个网址的时候是不必指定端口号的，因为在默认情况下 WWW 服务的端口是 “80”。网络服务是可以使用其他端口号的，如果不是默认的端口号则应该在地址栏 上指定端口号，方法是在地址后面加上冒号“:”（半角），再加上端口号。比如使用 “8080” 作为 WWW 服务的端口，则需要在地址栏里输入“网址:8080”。但是有些系统协议使用固定的端口号，它是不能被改 变的，比如 139 端口专门用于 NetBIOS 与 TCP&#x2F;IP 之间的通信，不能手动改变。 注册端口（Registered Ports） 端口号从 1024 到 49151，它们松散地绑定于一些服务，分配给用户进程或应用程序，这些进程主要是 用户选择安装的一些应用程序，而不是已经分配好了公认端口的常用程序。这些端口在没有被服务器资 源占用的时候，可以用用户端动态选用为源端口。 动态端口 &#x2F; 私有端口（Dynamic Ports &#x2F; Private Ports） 动态端口的范围是从 49152 到 65535。之所以称为动态端口，是因为它一般不固定分配某种服务，而是 动态分配 5. 网络模型OSI 七层参考模型 七层模型，亦称 OSI（Open System Interconnection）参考模型，即开放式系统互联。参考模型 是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为 OSI 参 考模型或七层模型。 它是一个七层的、抽象的模型体，不仅包括一系列抽象的术语或概念，也包括具体的协议。 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率 等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为 1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。定义了如何让格式化数据以帧 为单位进行传输，以及如何让控制对物理介质的访问。将比特组合成字节进而组合成帧，用MAC地 址访问介质。 网络层：进行逻辑地址寻址，在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选 择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的 层。 传输层：定义了一些传输数据的协议和端口号（ WWW 端口 80 等），如：TCP（传输控制协议， 传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方 式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这 一层数据叫做段。 会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间 发起会话或者接受会话请求。 表示层：数据的表示、安全、压缩。主要是进行对接收的数据进行解释、加密与解密、压缩与解压 缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）。 应用层：网络服务与最终用户的一个接口。这一层为用户的应用程序（例如电子邮件、文件传输和 终端仿真）提供网络服务。 TCP&#x2F;IP 四层模型简介 现在 Internet（因特网）使用的主流协议族是 TCP&#x2F;IP 协议族，它是一个分层、多协议的通信体 系。TCP&#x2F;IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用 层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务。 TCP&#x2F;IP 协议在一定程度上参考了 OSI 的体系结构。OSI 模型共有七层，从下到上分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。但是这显然是有些复杂的，所以在 TCP&#x2F;IP 协议中， 它们被简化为了四个层次。 （1）应用层、表示层、会话层三个层次提供的服务相差不是很大，所以在 TCP&#x2F;IP 协议中，它们被合并 为应用层一个层次。 （2）由于传输层和网络层在网络协议中的地位十分重要，所以在 TCP&#x2F;IP 协议中它们被作为独立的两个 层次。 （3）因为数据链路层和物理层的内容相差不多，所以在 TCP&#x2F;IP 协议中它们被归并在网络接口层一个层 次里。只有四层体系结构的 TCP&#x2F;IP 协议，与有七层体系结构的 OSI 相比要简单了不少，也正是这样， TCP&#x2F;IP 协议在实际的应用中效率更高，成本更低。 四层介绍 应用层：应用层是 TCP&#x2F;IP 协议的第一层，是直接为应用进程提供服务的。 （1） 对不同种类的应用程序它们会根据自己的需要来使用应用层的不同协议，邮件传输应用使用 了 SMTP 协议、万维网应用使用了 HTTP 协议、远程登录服务应用使用了有 TELNET 协议。 （2） 应用层还能加密、解密、格式化数据。 （3） 应用层可以建立或解除与其他节点的联系，这样可以充分节省网络资源。 传输层：作为 TCP&#x2F;IP 协议的第二层，运输层在整个 TCP&#x2F;IP 协议中起到了中流砥柱的作用。且在运输层中， TCP 和 UDP 也同样起到了中流砥柱的作用。 网络层：网络层在 TCP&#x2F;IP 协议中的位于第三层。在 TCP&#x2F;IP 协议中网络层可以进行网络连接的建立和终止以及 IP 地址的寻找等功能。 网络接口层：在 TCP&#x2F;IP 协议中，网络接口层位于第四层。由于网络接口层兼并了物理层和数据链路层所以，网络接口层既是传输数据的物理媒介，也可以为网络层提供一条准确无误的线路。 6. 协议简介 协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连 接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。它的三要素是：语 法、语义、时序。 为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议 （protocol），它最终体现为在网络上传输的数据包的格式。 协议往往分成几个层次进行定义，分层定义是为了使某一层协议的改变不影响其他层次的协议。 常见协议 应用层常见的协议有：FTP协议（File Transfer Protocol 文件传输协议）、HTTP协议（Hyper Text Transfer Protocol 超文本传输协议）、NFS（Network File System 网络文件系统）。 传输层常见协议有：TCP协议（Transmission Control Protocol 传输控制协议）、UDP协议（User Datagram Protocol 用户数据报协议）。 网络层常见协议有：IP 协议（Internet Protocol 因特网互联协议）、ICMP 协议（Internet Control Message Protocol 因特网控制报文协议）、IGMP 协议（Internet Group Management Protocol 因特 网组管理协议）。 网络接口层常见协议有：ARP协议（Address Resolution Protocol 地址解析协议）、RARP协议 （Reverse Address Resolution Protocol 反向地址解析协议）。 UDP协议 源端口号：发送方端口号 目的端口号：接收方端口号 长度：UDP用户数据报的长度，最小值是8（仅有首部） 校验和：检测UDP用户数据报在传输中是否有错，有错就丢弃 TCP协议 源端口号：发送方端口号 目的端口号：接收方端口号 序列号：本报文段的数据的第一个字节的序号 确认序号：期望收到对方下一个报文段的第一个数据字节的序号 首部长度（数据偏移）：TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，即首部长度。单位：32位，即以 4 字节为计算单位 保留：占 6 位，保留为今后使用，目前应置为 0 紧急 URG ：此位置 1 ，表明紧急指针字段有效，它告诉系统此报文段中有紧急数据，应尽快传送 确认 ACK：仅当 ACK&#x3D;1 时确认号字段才有效，TCP 规定，在连接建立后所有传达的报文段都必须把 ACK 置1 推送 PSH：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作，这时，发送方TCP 把 PSH 置 1，并立即创建一个报文段发送出去，接收方收到 PSH &#x3D; 1 的报文段，就尽快地 （即“推送”向前）交付给接收应用进程，而不再等到整个缓存都填满后再向上交付 复位 RST：用于复位相应的 TCP 连接 同步 SYN：仅在三次握手建立 TCP 连接时有效。当 SYN &#x3D; 1 而 ACK &#x3D; 0 时，表明这是一个连接请求报文段，对方若同意建立连接，则应在相应的报文段中使用 SYN &#x3D; 1 和 ACK &#x3D; 1。因此，SYN 置1 就表示这是一个连接请求或连接接受报文 终止 FIN：用来释放一个连接。当 FIN &#x3D; 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放运输连接 窗口：指发送本报文段的一方的接收窗口（而不是自己的发送窗口） 校验和：校验和字段检验的范围包括首部和数据两部分，在计算校验和时需要加上 12 字节的伪头部 紧急指针：仅在 URG &#x3D; 1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据），即指出了紧急数据的末尾在报文中的位置，注意：即使窗口为零时也可发送紧急数 据 选项：长度可变，最长可达 40 字节，当没有使用选项时，TCP 首部长度是 20 字节 IP协议 版本：IP 协议的版本。通信双方使用过的 IP 协议的版本必须一致，目前最广泛使用的 IP 协议版本号为 4（即IPv4) 首部长度：单位是 32 位（4 字节） 服务类型：一般不适用，取值为 0 总长度：指首部加上数据的总长度，单位为字节 标识（identification）：IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1， 并将此值赋给标识字段 标志（flag）：目前只有两位有意义。 标志字段中的最低位记为 MF。MF &#x3D; 1 即表示后面“还有分片”的数据报。MF &#x3D; 0 表示这已是若干数据报片中的最后一个。 标志字段中间的一位记为 DF，意思是“不能分片”，只有当 DF &#x3D; 0 时才允许分片 片偏移：指出较长的分组在分片后，某片在源分组中的相对位置，也就是说，相对于用户数据段的 起点，该片从何处开始。片偏移以 8 字节为偏移单位。 生存时间：TTL，表明是数据报在网络中的寿命，即为“跳数限制”，由发出数据报的源点设置这个字段。路由器在转发数据之前就把 TTL 值减一，当 TTL 值减为零时，就丢弃这个数据报。 协议：指出此数据报携带的数据时使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程，常用的 ICMP(1)，IGMP(2)，TCP(6)，UDP(17)，IPv6（41） 10.首部校验和：只校验数据报的首部，不包括数据部分。 源地址：发送方 IP 地址 目的地址：接收方 IP 地址 以太网帧协议 类型：0x800表示 IP、0x806表示 ARP、0x835表示 RARP ARP协议 硬件类型：1 表示 MAC 地址 协议类型：0x800 表示 IP 地址 硬件地址长度：6 协议地址长度：4 操作：1 表示 ARP 请求，2 表示 ARP 应答，3 表示 RARP 请求，4 表示 RARP 应答 封装上层协议是如何使用下层协议提供的服务的呢？其实这是通过封装（encapsulation）实现的。应用程序 数据在发送到物理网络上之前，将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加 上自己的头部信息（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装。 分用当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据， 以获取所需的信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用（demultiplexing）。分用是依靠头部信息中的类型字段实现的。 网络通信流程 ARP请求","categories":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"https://tutouwang.vercel.app/categories/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"多表操作","slug":"多表操作","date":"2022-06-04T11:23:35.000Z","updated":"2022-06-04T11:51:50.817Z","comments":true,"path":"2022/06/04/多表操作/","link":"","permalink":"https://tutouwang.vercel.app/2022/06/04/%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"多表操作实际开发中，一个项目通常需要很多张表才能完成。 例如：一个商城项目就需要分类表(category)、商品表(products)、订单表(orders)等多张表。且这些表 的数据之间存在一定的关系，接下来我们将在单表的基础上，一起学习多表方面的知识。 MySQL关系型数据库非关系型数据库：ES、Redis… 多表之间的关系 一读一：一夫一妻制度 一对多：一夫多妻制度 多对多：群居制度 表跟表之间的关系，大家可以理解为是实体跟实体的关系的一种映射。比如，导师与学员，订单与客 户，部门与员工等等。 主要关系有三种： 123一对一：比如，一个男的只能取一个女的当老婆。一对多：比如，客户与订单，一个客户可以在商城中下多个订单。多对多：比如，学生与课程，一个学校有很多学生，学生都可以学很多课程。 1）一对一关系在实际工作中，一对一在开发中应用不多，因为一对一完全可以创建成一张表 建立两表的唯一一对一的关系： 第一步：将被关联的表主键唯一 第二步：建立外键约束，管理该表的唯一主键 案例：一个丈夫只能有一个妻子 1234567CREATE TABLE wife(id INT PRIMARY KEY , wname VARCHAR(20), sex CHAR(1));CREATE TABLE husband(id INT PRIMARY KEY , hname VARCHAR(20), sex CHAR(1)); 外键唯一一对一关系创建方式 1 之外键唯一： 添加外键列 wid，指定该列的约束为唯一（不加唯一约束就是一对多关系） 1ALTER TABLE husband ADD wid INT UNIQUE; 添加外键约束 1alter table husband add foreign key (wid) references wife(id); 主键做外键一对一关系创建方式 2 之主键做外键：（大家下去自己练习） 思路：使用主表的主键作为外键去关联从表的主键 2）一对多关系 常见实例：一个分类对应多个商品，客户和订单，分类和商品，部门和员工.总结：有外键的就是多的一方。 注意事项：一对多关系和一对一关系的创建很类似，唯一区别就是外键不唯一一对多关系创建： 添加外键列 添加外键约束 3）多对多关系常见实例：学生和课程、用户和角色 注意事项：需要中间表去完成多对多关系的创建，多对多关系其实就是两个一对多关系的组合 多对多关系创建： 创建中间表，并在其中创建多对多关系中两张表的外键列 在中间表中添加外键约束 在中间表中添加联合主键约束","categories":[],"tags":[]},{"title":"数据库备份与恢复","slug":"MySql/数据库备份与恢复","date":"2022-06-04T02:04:13.000Z","updated":"2022-06-04T02:18:56.269Z","comments":true,"path":"2022/06/04/MySql/数据库备份与恢复/","link":"","permalink":"https://tutouwang.vercel.app/2022/06/04/MySql/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/","excerpt":"","text":"备份数据库的备份是数据库转换成对应的的sql文件 1）MySQL命令备份数据库导出sql脚本的格式： 1mysqldump -u用户名 -p密码 数据库名&gt;生成的脚本文件路径 例如: 1mysqldump -uroot -proot day02&gt;d:\\backup.sql 以上备份数据库的命令中需要用户名和密码，即表明该命令要在用户没有登录的情况下使用 2）可视化工具备份选中数据库，右键 ”备份&#x2F;导出” ， 指定导出路径，保存成.sql文件即可。 恢复数据库的恢复指的是使用备份产生的sql文件恢复数据库，即将sql文件中的sql语句执行就可以恢复数据 库内容。 1）命令恢复使用数据库命令备份的时候只是备份了数据库内容，产生的sql文件中没有创建数据库的sql语句，在恢 复数据库之前需要自己动手创建数据库。 在数据库外恢复 格式: mysql -uroot -p密码 数据库名 &lt; 文件路径 例如: mysql -uroot -proot day02 在数据库内恢复 格式: source SQL脚本路径 例如: source d:\\backup.sql 注意:使用这种方式恢复数据，首先要登录数据库. 2)可视化工具恢复执行的SQL文件，执行即可。","categories":[],"tags":[]},{"title":"MySql常见问题解答","slug":"MySql/MySql常见问题解答","date":"2022-06-03T05:53:44.000Z","updated":"2022-06-03T07:54:46.417Z","comments":true,"path":"2022/06/03/MySql/MySql常见问题解答/","link":"","permalink":"https://tutouwang.vercel.app/2022/06/03/MySql/MySql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/","excerpt":"","text":"MySQL数据库密码重置 停止mysql服务器运行输入services.msc 停止mysql服务 在cmd下,输入mysqld –console –skip-grant-tables 启动服务器,出现一下页面,不要关闭该窗口 新打开cmd,输入mysql -uroot 不需要密码 12use mysql;update user set password=password(&#x27;root&#x27;) WHERE user=&#x27;root&#x27;; 关闭两个cmd窗口 DOS操作数据乱码解决我们在dos命令行操作中文时，会报错 123insert into category(cid,cname) values(‘c010’,’中文’);ERROR 1366 (HY000): Incorrect string value: &#x27;\\xB7\\xFE\\xD7\\xB0&#x27; for column&#x27;cname&#x27; at row 1 错误原因：因为mysql的客户端设置编码是utf8，而系统的cmd窗口编码是gbk 查看MySQL内部设置的编码 1show variables like &#x27;character%&#x27;; 查看所有mysql的编码 需要修改client、connection、results的编码一致（GBK编码） 12解决方案1：在cmd命令窗口中输入命令，此操作当前窗口有效，为临时方案。set names gbk; 解决方案2：安装目录下修改my.ini文件，重启服务所有地方生效 如果启动不了就用管理员或者去服务里面看看名字对不对 12开启mysql服务:net start mysql关闭mysql服务:net stop mysql 1services.msc","categories":[],"tags":[]},{"title":"Sql语句","slug":"MySql/Sql语句","date":"2022-06-02T10:26:31.000Z","updated":"2022-06-04T02:06:18.685Z","comments":true,"path":"2022/06/02/MySql/Sql语句/","link":"","permalink":"https://tutouwang.vercel.app/2022/06/02/MySql/Sql%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"SQL概述SQL语句介绍结构化查询语言(Structured Query Language)简称SQL，是关系型数据库管理系统都需要遵循的规范。 不同的数据库生产厂商都支持SQL语句，但都有特有内容。 扩展：SQL作为一种访问【关系型数据库的标准语言】，SQL 自问世以来得到了广泛的应用，不仅 是著名的大型商用数据库产品 Oracle、DB2、Sybase、SQL Server 支持它，很多开源的数据库产 品如 PostgreSQL、MySQL也支持它，甚至一些小型的产品如 Access 也支持 SQL。近些年蓬勃发 展的 NoSQL 系统最初是宣称不再需要 SQL 的，后来也不得不修正为 Not Only SQL，来拥抱 SQL。 蓝色巨人 IBM 对关系数据库以及 SQL 语言的形成和规范化产生了重大的影响，第一个版本的 SQL 标准 SQL86 就是基于 System R 的手册而来的。 Oracle 在 1979 年率先推出了支持 SQL 的商用产品。随着数据库技术和应用的发展，为不同 RDBMS提供一致的语言成了一种现实需要。 对 SQL 标准影响最大的机构自然是那些著名的数据库产商，而具体的制订者则是一些非营利机 构，例如【国际标准化组织 ISO、美国国家标准委员会 ANSI】等。 各国通常会按照 ISO 标准和 ANSI 标准（这两个机构的很多标准是差不多等同的）制定自己的国 家标准。 SQL作用 在数据库中检索信息。 对数据库的信息进行更新。 改变数据库的结构。 更改系统的安全设置。 增加或回收用户对数据库、表的许可权限。 SQL语句分类 数据定义语言：简称DDL(Data Definition Language) 作用：用来定义数据库对象：数据库，表，列等。 关键字：create，alter，drop等 数据操作语言：简称DML(Data Manipulation Language)， 作用：用来对数据库中表的记录进行更新。 关键字：insert，delete，update等 数据查询语言：简称DQL(Data Query Language)， 作用：用来查询数据库中表的记录。 关键字：select，from，where等 数据控制语言：简称DCL(Data Control Language)， 作用：用来定义数据库的访问权限和安全级别，及创建用户。 SQL通用语法 SQL语句可以单行或多行书写，以分号结尾 可使用空格和缩进来增强语句的可读性 MySQL数据库的SQL语句不区分大小写，关键字建议使用大写 例如：SELECT * FROM user。 常用注释形式 123-- 单行注释内容/* 多行注释 */# 单行注释内容 MySQL中的我们常使用的数据类型如下 类型名称 说明 int（integer） 整数类型 double 小数类型 decimal （m,d） 指定整数位与小数位长度的小数类型 decimal(10,2) date 日期类型，格式为yyyy-MM-dd，包含年月日，不包含时分秒 2019-05-06 datetime 日期类型，格式为 YYYY-MM-DD HH:MM:SS，包含年月日时分秒 2019-05-06 09:49:30 timestamp 日期类型，时间戳 varchar（M） 文本类型， M为0~65535之间的整数 DDL之数据库操作：database创建、查看、删除、修改… 1） 创建数据库123456789create database 数据库名;create database 数据库名 character set 字符集; -- 字符集 如 UTF-8-- 【案例】-- 1. 创建一个叫 hello 的数据库create database hello;-- 2. 判读如果不存在则创建create database if not exists hello;-- 3. 创建数据库并指定字符集create database hello default character set gbk; 2）查看数据库1234567查看数据库服务器中的所有的数据库：show databases;查看某个数据库的定义的信息：show create database 数据库名;-- 【案例】-- 查看数据库服务器中的所有的数据库show databases;-- 查看某个数据库的定义信息show create database hello; 3）删除数据库（慎用）123drop database 数据库名称;-- 【案例】drop database hello; 4）修改数据库1234修改数据库默认的字符集：alter database 数据库名 default character set 字符集-- 【案例】alter database hello3 character set utf8; 5）其他数据库操作命令12切换数据库： use 数据库名;查看正在使用的数据库：select database(); DDL之表操作：table 创建数据库表 查看表 快速创建：克隆 删除表 修改表结构：如果表内有数据，修改需要谨慎 字段更改字 段删除 修改表名称 1） 创建表建立数据表，就是建立表结构，指定数据表中的一共有多少列，每一列的数据类型 12345678910111213-- create 指的是【创建】，table 指的是【数据表】。-- 一张表中可以指定多个字段，用逗号隔开，最后的字段不需要逗号create table 表名(-- 可以定义多个列字段名 类型(长度) 约束,字段名 类型(长度) 约束);-- 【案例】-- 创建用户表create table t_user (uid int primary key auto_increment, -- 用户 iduname varchar(20) -- 用户名); 字段类型常用的类型有： 数字型：int、integer、bigint、mediumint、smallint、tinyint 浮点型：double、float、decimal（精确小数类型） 字符型：char（定长字符串）、varchar（可变长字符串） 日期类型：date（只有年月日）、time（只有时分秒）、datetime（年月日，时分秒）、year （年） 二进制字符串类型：binary（定长，以二进制形式保存字符串）、varbinary（可边长） 单表约束123主键约束：primary key唯一约束：unique非空约束：not null 注意1主键约束 &#x3D; 唯一约束 + 非空约束 2） 查看表12345678查看数据库中的所有表：show tables;查看表结构：desc 表名;查看创建表的 SQL 语句：show create table 表名;-- 【案例】use hello; -- 使用 hello 数据库show tables; -- 查看所有表desc user; -- 查看 user 表的结构show create table user; -- 查看 user 表的创建语句 3）快速创建一个表结构相同的表1234create table 新的表名 like 旧的表名;-- 【案例】create table tb_user like user;desc tb_user; 4）删除表12345drop table 表名;drop table if exists 表名;-- 【案例】-- 删除用户表drop table user; 5）修改表123456789101112131415161718192021-- 1.修改表添加列alter table 表名 add 列名 类型(长度) 约束;-- 2.修改表修改列的类型长度及约束alter table 表名 modify 列名 类型(长度) 约束;-- 3.修改表修改列名alter table 表名 change 旧列名 新列名 类型(长度) 约束;-- 4.修改表删除列alter table 表名 drop 列名;-- 5.修改表名rename table 表名 to 新表名;--【案例】-- 修改表添加列alter table user add address varchar(50);-- 修改表修改列的类型长度及约束alter table user modify address int(30);-- 修改表修改列名alter table user change address addr varchar(50);-- 修改表删除列alter table user drop addr;-- 修改表名rename table user to tb_user; DML数据操作语言1）插入记录：insert1234567891011121314-- 1.向表中插入某些列insert into 表 (列名1,列名2,列名3..) values (值1,值2,值3..);-- 2.向表中插入所有列insert into 表 values (值1,值2,值3..);-- 3.从另外一张表查某些列的结果插入当前表insert into 表 (列名1, 列名2, 列名3..) values select (列名1,列名2,列名3..) from表-- 4.从另外一张表查所有列的结果插入当前表insert into 表 values select * from 表--【案例】-- 向表中插入某些列，必须写列名insert into user (uid, uname) values (001, &#x27;cuihua&#x27;);-- 向表中插入所有列insert into user values (002, &#x27;aqiang&#x27;); 5个注意事项： ① 列名数与 values 后面的值的个数相等 ② 列的顺序与插入的值得顺序一致 ③ 列名的类型与插入的值要一致. ④ 插入值得时候不能超过最大长度. ⑤ 值如果是字符串或者日期需要加引号’’ （一般是单引号） 2）更新记录：update语法格式：update 更新、set 修改的列值、where 指定条件。 123456789- 1.不指定条件，会修改表中当前列所有数据update 表名 set 字段名=值, 字段名=值;-- 2.指定条件，符合条件的才会修改update 表名 set 字段名=值, 字段名=值 where 条件;-- 【案例】-- 更新所有字段的值update user set uname=&#x27;xiaodong&#x27;;-- 根据指定的条件来更新update user set uname=&#x27;hashiqi&#x27; where uid = 2; 注意： ① 列名的类型与修改的值要一致 ② 修改值得时候不能超过最大长度 ③ 值如果是字符串或者日期需要加 ’ ’ 引号 3）删除记录：delete &amp; truncate语法格式： 123456delete from 表名 [where 条件];-- 【案例】-- 删除表中所有数据delete from user;-- 删除 uid 为 1 的用户delete from user where uid = 1; 1truncate table 表名; 注意 删除表中所有记录使用【delete from 表名】，还是用【truncate table 表名】？ 删除方式的区别： 12delete ：一条一条删除，不清空 auto_increment 记录数。truncate ：直接将表删除，重新建表，auto_increment 将置为零，从新开始 SQL约束约束类型： 主键约束 primary key 唯一性约束 unique 非空约束 not null 外键约束 foreign key 主键约束PRIMARY KEY 约束唯一标识数据库表中的每条记录。 特点： 主键必须包含唯一的值。 主键列不能包含 NULL 值。 每个表都应该有一个主键，并且每个表只能有一个主键。 添加主键约束 方式一：创建表时，在字段描述处，声明指定字段为主键： 1234567CREATE TABLE persons(id_p int PRIMARY KEY,lastname varchar(255),firstname varchar(255),address varchar(255),city varchar(255)); 方式二：创建表时，在constraint约束区域，声明指定字段为主键： 格式： [constraint 名称] primary key (字段列表) 关键字constraint可以省略，如果需要为主键命名，constraint不能省略，主键名称一般没 用。 字段列表需要使用小括号括住，如果有多字段需要使用逗号分隔。声明两个以上字段为主键， 我们称为联合主键。 1234567CREATE TABLE persons_cons(firstname varchar(255),lastname varchar(255),address varchar(255),city varchar(255),CONSTRAINT pk_personID PRIMARY KEY (firstname,lastname)); 方式三：创建表之后，通过修改表结构，声明指定字段为主键： 格式： ALTER TABLE persons ADD [CONSTRAINT 名称] PRIMARY KEY (字段列表) 1234567CREATE TABLE persons_after(firstname varchar(255),lastname varchar(255),address varchar(255),city varchar(255));ALTER TABLE persons_after ADD PRIMARY KEY (firstname,lastname); 删除主键约束如需撤销 PRIMARY KEY 约束，请使用下面的 SQL： 1ALTER TABLE persons DROP PRIMARY KEY 自动增长列我们通常希望在每次插入新记录时，数据库自动生成字段的值。 我们可以在表中使用 auto_increment（自动增长列）关键字，自动增长列类型必须是整形，自动增长列 必须为键(一般是主键)。 下列 SQL 语句把 “persons” 表中的 “p_id” 列定义为 auto_increment 主键 1234567CREATE TABLE persons_id(p_id int PRIMARY KEY AUTO_INCREMENT,lastname varchar(255),firstname varchar(255),address varchar(255),city varchar(255)); 向persons添加数据时，可以不为p_id字段设置值，也可以设置成null，数据库将自动维护主键 值： 123INSERT INTO persons_id (firstname,lastname) VALUES (&#x27;Bill&#x27;,&#x27;Gates&#x27;);INSERT INTO persons_id (p_id,firstname,lastname) VALUES(NULL,&#x27;Bill&#x27;,&#x27;Gates&#x27;); 默认AUTO_INCREMENT 的开始值是 1，如果希望修改起始值，请使用下列 SQL 语法： 1ALTER TABLE persons AUTO_INCREMENT=100 非空约束NOT NULL 约束强制列不接受 NULL 值。 NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记 录。 下面的 SQL 语句强制 “id_p” 列和 “lastname” 列不接受 NULL 值： 12345678CREATE TABLE persons_null(id_p int NOT NULL,lastname varchar(255) NOT NULL,firstname varchar(255),address varchar(255),city varchar(255)); 唯一约束 UNIQUE 约束唯一标识数据库表中的每条记录。 UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。 PRIMARY KEY 拥有自动定义的 UNIQUE 约束。 注意：每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。 添加唯一约束与主键添加方式相同，共有3种 方式一：创建表时，在字段描述处，声明唯一： 1234567CREATE TABLE persons_unique(id_p int UNIQUE,lastname varchar(255) NOT NULL,firstname varchar(255),address varchar(255),city varchar(255)) 方式二：创建表时，在约束区域，声明唯一： 12345678CREATE TABLE persons(id_p int,lastname varchar(255) NOT NULL,firstname varchar(255),address varchar(255),city varchar(255),CONSTRAINT unique_id_p UNIQUE (Id_P)) 方式三：创建表后，修改表结构，声明字段唯一： 1ALTER TABLE persons ADD [CONSTRAINT 名称] UNIQUE (Id_P) 删除唯一约束 如需撤销 UNIQUE 约束，请使用下面的 SQL： 1ALTER TABLE persons DROP INDEX 名称 如果添加唯一约束时，没有设置约束名称，默认是当前字段的字段名。 SQL语句之DQL【重要、重要、重要】语法：查询不会对数据库中的数据进行修改，根据指定的方式来呈现数据。 语法格式： 1select * | 列名,列名 from 表名 [where 条件表达式] select 是查询指令，可以读 1 ~ n 行数据； 列名换成 * 号，可以查询所有字段数据； 使用 where 来指定对应的条件 准备工作创建商品表 12345678910111213CREATE TABLE products (-- 自增加 AUTO_INCREMENTpid INT PRIMARY KEY AUTO_INCREMENT,pname VARCHAR(20), -- 商品名称price DOUBLE, -- 商品价格pdate DATE, -- 日期sid VARCHAR(20) -- 分类ID);INSERT INTO products VALUES(NULL,&#x27;泰国大榴莲&#x27;, 98, NULL, &#x27;s001&#x27;);INSERT INTO products VALUES(NULL,&#x27;新疆大枣&#x27;, 38, NULL, &#x27;s002&#x27;);INSERT INTO products VALUES(NULL,&#x27;新疆切糕&#x27;, 68, NULL, &#x27;s001&#x27;);INSERT INTO products VALUES(NULL,&#x27;十三香&#x27;, 10, NULL, &#x27;s002&#x27;);INSERT INTO products VALUES(NULL,&#x27;老干妈&#x27;, 20, NULL, &#x27;s002&#x27;); 简单查询123456789101112131415161718192021-- 查询所有的商品select * from product;-- 查询指定列：商品名和商品价格select pname,price from product;-- 别名查询，使用的 as 关键字，as 也可以省略的-- 使用别名的好处：显示的时候使用识别性更强的名字，本身也不会去影响到表结构-- 表别名-- select 字段名 as 字段别名 from 表名select * from product as p;-- 列别名-- select 列名 as 列别名 from 表名select pname as pn from product;-- 列和表，同时指定别名-- select 列名 as 列别名 from 表名 as 表别名-- 去掉重复值-- select distinct 字段名 from 表名select distinct pname from product;--查询结果是表达式（运算查询）：将所有商品的价格 +10 元进行显示-- select 列名+固定值 from 表名-- select 列名1 + 列名2 from 表名select pname, price + 10 from product; 条件查询使用条件查询，可以根据当下具体情况直查想要的那部分数据，对记录进行过滤。 SQL 语法关键字： WHERE 语法格式： 1select 字段名 from 表名 where 条件; 运算符 12345678-- 查询商品名称为十三香的商品所有信息select * from product where pname = &#x27;十三香&#x27;;-- 查询商品价格 &gt;60 元的所有的商品信息select * from product where price &gt; 60;select * from product where price &lt;= 60;-- 不等于select * from product where price != 60;select * from product where price &lt;&gt; 60; 逻辑运算符 NOT 逻辑非【**!】 AND 逻辑与【&amp;&amp;】 OR 逻辑或【||】 123select * from product where price &gt; 40 and pid &gt; 3;select * from product where price &gt; 40 or pid &gt; 3; in 关键字1234-- in 匹配某些值中select * from product where pid in (2,5,8);-- 不在这些值中select * from product where pid not in (2,5,8); 指定范围中 between…and1select * from product where pid between 2 and 10; 模糊查询 like 关键字 模糊查询: 作用是帮助匹配模糊的字段内容 语法:where之后加上like 语法，%百分号，_下划线 % 代表任意长短内容模糊匹配: [%xxx]以xxx结尾的任意内容。 [xxx%]以xxx开头的任意内容 [%xxx%]包含xxx的任意内容 _代表任意一个字符的内容模糊匹配 [_xxx]以任意单个字符开头的xxx内容。 [xxx__x] 12345-- 使用 like 实现模糊查询-- “新”开头select * from product where pname like &#x27;新%&#x27;;-- 包含“新”select * from product where pname like &#x27;%新%&#x27;; 排序语法： 1234select 字段名 from 表名 where 字段 = 值 order by 字段名 [asc | desc]asc 升序desc 降序 12345-- 查询所有的商品，按价格进行排序select * from product order by price;-- 查询名称有新的商品的信息并且按价格降序排序select * from product where pname like &#x27;%新%&#x27; order by price desc; 聚合函数（组函数）12345678910111213特点：只对单列进行操作常用的聚合函数：sum()：求某一列的和avg()：求某一列的平均值max()：求某一列的最大值min()：求某一列的最小值count()：求某一列的元素个数-- 获得所有商品的价格的总和：select sum(price) from product;-- 获得所有商品的平均价格：select avg(price) from product;-- 获得所有商品的个数：select count(*) from product; 分组查询分组查询:作用是将查询结果按照某列数据来进行分组呈现 语法格式： 123SQL 语法关键字：GROUP BY、HAVINGselect 字段1, 字段2... from 表名 group by 分组字段 [having 条件]; 12345-- 根据 cno 字段分组，分组后统计商品的个数select sid, count(*) from product group by sid;-- 根据 cno 分组，分组统计每组商品的平均价格，并且平均价格 &gt; 60;select sid, avg(price) from product group by sid having avg(price) &gt; 60; 注意事项： ① select 语句中的列（非聚合函数列），必须出现在 group by 子句中 ② group by 子句中的列，不一定要出现在 select 语句中 ③ 聚合函数只能出现 select 语句中或者 having 语句中，一定不能出现在 where 语句中。 having 和 where 的区别： 1首先，执行的顺序是有先有后。 1） where 12对查询结果进行分组前，将不符合 where 条件的记录过滤掉，然后再分组。where 后面，不能再使用聚合函数。 2）having 12筛选满足条件的组，分组之后过滤数据。having 后面，可以使用聚合函数。 分页查询 功能: 将查询的结果按照一页一页的形式输出 语法 12345-- 语法select 列 from 表 limit offset, length-- 案例 0 偏移量select * from products limit 0, 3; 关键字：limit [offset,] rows 语法格式： 123456789select * | 字段列表 [as 别名] from 表名[where] 条件语句[group by] 分组语句[having] 过滤语句[order by] 排序语句[limit] 分页语句;limit offset, length;offset：开始行数，从 0 开始length：每页显示的行数 limit 关键字不是 SQL92 标准提出的关键字，它是 MySQL 独有的语法。 通过 limit 关键字，MySQL 实现了物理分页。 分页分为逻辑分页和物理分页： 逻辑分页：将数据库中的数据查询到内存之后再进行分页。 物理分页：通过 LIMIT 关键字，直接在数据库中进行分页，最终返回的数据，只是分页后的数据。 123-- 如果省略第一个参数，默认从 0 开始select * from product limit 5;select * from product limit 3, 5; 查询分类 条件查询 where 分组查询group by having针对分组结果过滤 排序order by 分页 limit 查询语句顺序: select 列 from 表 where 条件 group by 分组 having 过滤 order by 排序 limit 分页","categories":[],"tags":[]},{"title":"线程同步-锁-信号量","slug":"Linux多进程开发/线程同步-锁-信号量","date":"2022-05-31T06:23:35.000Z","updated":"2022-06-04T07:09:39.875Z","comments":true,"path":"2022/05/31/Linux多进程开发/线程同步-锁-信号量/","link":"","permalink":"https://tutouwang.vercel.app/2022/05/31/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E9%94%81-%E4%BF%A1%E5%8F%B7%E9%87%8F/","excerpt":"","text":"低配卖票很多问题 - 进程资源的抢占1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/************************************************************************* &gt; File Name: selltickets.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月31日 星期二 14时28分01秒 ************************************************************************//* * 使用多线程实现卖票案例 * 有3个窗口,一共是100张票 * */#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;// 全局变量,所有的线程都共享这一份资源 - 结果：不通的进程会卖同一张票int tickets = 100;void *sellticket(void *arg) &#123; // 卖票 // int tickets = 100; - 每个线程都会卖100张! while(tickets &gt; 0) &#123; usleep(6000); printf(&quot;%ld 正在卖第 %d 张门票\\n&quot;, pthread_self(), tickets--); &#125; return NULL;&#125;int main() &#123; // 创建3个子线程 pthread_t tid1, tid2, tid3; pthread_create(&amp;tid1, NULL, sellticket, NULL); pthread_create(&amp;tid2, NULL, sellticket, NULL); pthread_create(&amp;tid3, NULL, sellticket, NULL); // 回收子线程资源,阻塞 --- 可以设置线程分离 pthread_join(tid1, NULL); pthread_join(tid2, NULL); pthread_join(tid3, NULL); // 设置线程分离 /* pthread_detach(tid1); pthread_detach(tid2); pthread_detach(tid3); */ // 退出主线程 pthread_exit(NULL); return 0;&#125; 线程同步 线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程 修改的变量。 临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是 同时访问同一共享资源的其他线程不应终端该片段的执行。 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进 行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处 于等待状态。 互斥锁(互斥量) 为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion 的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共 享资源的原子访问。 互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报 错失败，具体取决于加锁时使用的方法。 一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情 况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问 同一资源时将采用如下协议： 针对共享资源锁定互斥量 访问共享资源 对互斥量解锁 如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域，如下图所示： 互斥量(互斥锁)相关操作函数及介绍1234567891011121314151617互斥量的类型 pthread_mutex_tint pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); - 功能: 初始化互斥量 - 参数: - mutex: 需要初始话的互斥量变量 - attr: 互斥量相关的属性NULL - restrict: c语言的修饰符,被修饰的指针,不能由另外的一个指针进行 操作 pthread_mutex_t *restrict = mutex = xxx; pthread_mutex_t *mutex1 = mutex; // 不允许int pthread_mutex_destroy(pthread_mutex_t *mutex); - 功能: 释放互斥量资源int pthread_mutex_lock(pthread_mutex_t *mutex); - 功能: 加锁 - 阻塞,如有有一个线程加锁了那么其他线程只能阻塞等待int pthread_mutex_trylock(pthread_mutex_t *mutex); - 功能: 尝试加锁,如果加锁失败,不会阻塞,会直接返回int pthread_mutex_unlock(pthread_mutex_t *mutex); - 释放锁(解锁) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/************************************************************************* &gt; File Name: mutex.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月31日 星期二 16时36分54秒 ************************************************************************/ /* 互斥量的类型 pthread_mutex_t int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); - 功能: 初始化互斥量 - 参数: - mutex: 需要初始话的互斥量变量 - attr: 互斥量相关的属性NULL - restrict: c语言的修饰符,被修饰的指针,不能由另外的一个指针进行 操作 pthread_mutex_t *restrict = mutex = xxx; pthread_mutex_t *mutex1 = mutex; // 不允许 int pthread_mutex_destroy(pthread_mutex_t *mutex); - 功能: 释放互斥量资源 int pthread_mutex_lock(pthread_mutex_t *mutex); - 功能: 加锁 - 阻塞,如有有一个线程加锁了那么其他线程只能阻塞等待 int pthread_mutex_trylock(pthread_mutex_t *mutex); - 功能: 尝试加锁,如果加锁失败,不会阻塞,会直接返回 int pthread_mutex_unlock(pthread_mutex_t *mutex); - 释放锁(解锁)*//************************************************************************* &gt; File Name: selltickets.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月31日 星期二 14时28分01秒 ************************************************************************//* * 使用多线程实现卖票案例 * 有3个窗口,一共是100张票 * */#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;// 创建一个互斥量pthread_mutex_t mutex;// 全局变量,所有的线程都共享这一份资源 - (没加互斥锁的情况)结果：不通的 进程会卖同一张票int tickets = 1000;void *sellticket(void *arg) &#123; // 卖票 // int tickets = 100; - 每个线程都会卖100张! while(1) &#123; // 加锁 pthread_mutex_lock(&amp;mutex); if(tickets &gt; 0) &#123; usleep(6000); printf(&quot;%ld 正在卖第 %d 张门票\\n&quot;, pthread_self(), tickets--); &#125; else &#123; // 解锁 pthread_mutex_unlock(&amp;mutex); break; &#125; // 解锁 pthread_mutex_unlock(&amp;mutex); &#125; return NULL;&#125;int main() &#123; // 初始化互斥量 pthread_mutex_init(&amp;mutex, NULL); // 创建3个子线程 pthread_t tid1, tid2, tid3; pthread_create(&amp;tid1, NULL, sellticket, NULL); pthread_create(&amp;tid2, NULL, sellticket, NULL); pthread_create(&amp;tid3, NULL, sellticket, NULL); // 回收子线程资源,阻塞 --- 可以设置线程分离 pthread_join(tid1, NULL); pthread_join(tid2, NULL); pthread_join(tid3, NULL); // 退出主线程 pthread_exit(NULL); // 释放互斥量资源 pthread_mutex_destroy(&amp;mutex); return 0;&#125; 死锁 有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。 两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。 死锁的几种场景： 忘记释放锁 &#x2F;&#x2F; pthread_mutex_trylock() 尝试加锁判断 重复加锁 多线程多锁，抢占锁资源 忘记加锁 - 可替换上述函数代码 尝试运行123456789101112131415161718192021void *sellticket(void *arg) &#123; // 卖票 // int tickets = 100; - 每个线程都会卖100张! while(1) &#123; // 加锁 pthread_mutex_lock(&amp;mutex); if(tickets &gt; 0) &#123; usleep(6000); printf(&quot;%ld 正在卖第 %d 张门票\\n&quot;, pthread_self(), tickets--); &#125; else &#123; // 解锁 pthread_mutex_unlock(&amp;mutex); break; &#125; // 解锁 // pthread_mutex_unlock(&amp;mutex); &#125; return NULL;&#125; 重复加锁123456789101112131415161718192021222324void *sellticket(void *arg) &#123; // 卖票 // int tickets = 100; - 每个线程都会卖100张! while(1) &#123; // 加锁 pthread_mutex_lock(&amp;mutex); pthread_mutex_lock(&amp;mutex); if(tickets &gt; 0) &#123; usleep(6000); printf(&quot;%ld 正在卖第 %d 张门票\\n&quot;, pthread_self(), tickets--); &#125; else &#123; // 解锁 pthread_mutex_unlock(&amp;mutex); break; &#125; // 解锁 pthread_mutex_unlock(&amp;mutex); pthread_mutex_unlock(&amp;mutex); &#125; return NULL;&#125; 多线程多锁，抢占锁资源 - C1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/************************************************************************* &gt; File Name: deadlock1.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月31日 星期二 19时09分34秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;// 创建2个互斥量pthread_mutex_t mutex1, mutex2;void *workA(void *arg) &#123; pthread_mutex_lock(&amp;mutex1); sleep(1); pthread_mutex_lock(&amp;mutex1); printf(&quot;workA\\n&quot;); pthread_mutex_unlock(&amp;mutex2); pthread_mutex_unlock(&amp;mutex1); return NULL;&#125;void *workB(void *arg) &#123; pthread_mutex_lock(&amp;mutex2); sleep(1); pthread_mutex_lock(&amp;mutex1); printf(&quot;workB\\n&quot;); pthread_mutex_unlock(&amp;mutex1); pthread_mutex_unlock(&amp;mutex2); return NULL;&#125;int main() &#123; // 初始化互斥量 pthread_mutex_init(&amp;mutex1, NULL); pthread_mutex_init(&amp;mutex2, NULL); // 创建2个子线程 pthread_t tid1, tid2; pthread_create(&amp;tid1, NULL, workA, NULL); pthread_create(&amp;tid2, NULL, workB, NULL); // 回收子线程资源 pthread_join(tid1, NULL); pthread_join(tid2, NULL); // 释放互斥量资源 pthread_mutex_destroy(&amp;mutex1); pthread_mutex_destroy(&amp;mutex2); return 0;&#125; 读写锁 当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想 读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读 访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。 在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。 读写锁的特点： 如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。 如果有其它线程写数据，则其它线程都不允许读、写操作。 写是独占的，写的优先级高。 123456789101112131415读写锁的类型 pthread_rwlock_t int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); - 功能: 初始化读写锁 int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); - 功能: 销毁 int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); - 功能: 加读锁 int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); - 功能: 尝试加读锁 int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); - 功能: 写锁 int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); - 功能: 尝试加写锁 int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); - 功能: 关闭写 读写锁(案例) - C123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/************************************************************************* &gt; File Name: rwlock.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年06月01日 星期三 10时27分52秒 ************************************************************************//* 读写锁的类型 pthread_rwlock_t int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); - 功能: 初始化读写锁 int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); - 功能: 销毁 int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); - 功能: 加读锁 int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); - 功能: 尝试加读锁 int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); - 功能: 写锁 int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); - 功能: 尝试加写锁 int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); - 功能: 关闭写*//* 案例: 创建8个线程操作同一个变量 3个线程不定时的写这个全局变量,5个线程不定时的读这个全局变量*/#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;// 创建一个共享数据int num = 1;// 创建一一个互斥量pthread_mutex_t mutex;// 创建一个读写锁pthread_rwlock_t rwlock;void *readNum(void *arg) &#123; while(1) &#123; // pthread_mutex_lock(&amp;mutex); pthread_rwlock_rdlock(&amp;rwlock); printf(&quot;==read, tid : %ld, num : %d\\n&quot;, pthread_self(), num); pthread_rwlock_unlock(&amp;rwlock); //pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; return NULL;&#125;void *writeNum(void *arg) &#123; while(1) &#123; // pthread_mutex_lock(&amp;mutex); pthread_rwlock_wrlock(&amp;rwlock); num++; printf(&quot;++write, tid : %ld, num : %d\\n&quot;, pthread_self(), num); pthread_rwlock_unlock(&amp;rwlock); //pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; return NULL;&#125;int main() &#123; // 初始化互斥量 // pthread_mutex_init(&amp;mutex, NULL); // 初始化读写锁 pthread_rwlock_init(&amp;rwlock, NULL); // 创建3个写线程,5个度 pthread_t wtids[3], rtids[5]; for(int i = 0; i &lt; 3; i++) &#123; pthread_create(&amp;wtids[i], NULL, writeNum, NULL); // 设置线程分离 pthread_detach(wtids[i]); &#125; for(int i = 0; i &lt; 5; i++) &#123; pthread_create(&amp;rtids[i], NULL, readNum, NULL); // 设置线程分离 // pthread_detach(rtids[i]); &#125; /* for(int i = 0; i &lt; 3; i++) &#123; // 设置线程分离 pthread_detach(wtids[i]); &#125; for(int i = 0; i &lt; 5; i++) &#123; // 设置线程分离 pthread_detach(rtids[i]); &#125; */ // 退出父进程 pthread_exit(NULL); // pthread_mutex_destroy(&amp;mutex); pthread_rwlock_destroy(&amp;rwlock); return 0;&#125; 生产者消费者模型 条件变量条件变量函数12345678910111213条件变量的类型 pthread_cond_tint pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); - 功能: 初始化int pthread_cond_destroy(pthread_cond_t *cond); - 功能: 释放int pthread_cond_wait(pthread_cond_t *restrict cond,thread_mutex_t *restrict mutex); - 功能: 等待,阻塞函数调用了该函数线程会阻塞int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); - 功能: 等待多长时间,调用了这个函数,线程会阻塞,直到指定的时间结束int pthread_cond_signal(pthread_cond_t *cond); - 功能: 唤醒一个或者多个等待的线程int pthread_cond_broadcast(pthread_cond_t *cond); - 功能: 唤醒所以的等待的线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/************************************************************************* &gt; File Name: cond.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年06月01日 星期三 19时49分46秒 ************************************************************************//* 条件变量的类型 pthread_cond_t int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); - 功能: 初始化 int pthread_cond_destroy(pthread_cond_t *cond); - 功能: 释放 int pthread_cond_wait(pthread_cond_t *restrict cond,thread_mutex_t *restrict mutex); - 功能: 等待,阻塞函数调用了该函数线程会阻塞 int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); - 功能: 等待多长时间,调用了这个函数,线程会阻塞,直到指定的时间结 束 int pthread_cond_signal(pthread_cond_t *cond); - 功能: 唤醒一个或者多个等待的线程 int pthread_cond_broadcast(pthread_cond_t *cond); - 功能: 唤醒所以的等待的线程*//* * 生产者消费者模型(粗略版本) */#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;typedef struct Node &#123; int num; struct Node *next;&#125; Node;// 头节点struct Node *head = NULL;// 互斥量pthread_mutex_t mutex;// 创建一个条件变量pthread_cond_t cond;void *producer(void *arg) &#123; // 不断的创建新的节点,添加到链表中 while(1) &#123; pthread_mutex_lock(&amp;mutex); Node *newNode = (Node *)malloc(sizeof(Node)); newNode-&gt;num = rand() % 1000; newNode-&gt;next = head; head = newNode; printf(&quot;add node, num : %d, tid : %ld\\n&quot;, newNode-&gt;num, pthread_self()); // 只要生成了一个,就通知消费者消费 pthread_cond_signal(&amp;cond); pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; return NULL;&#125;void *customer(void *arg) &#123; while(1) &#123; pthread_mutex_lock(&amp;mutex); if(head != NULL) &#123; // 保存头节点的指针 Node *temp = head; head = head-&gt;next; printf(&quot;del node, num : %d, tid : %ld\\n&quot;, temp-&gt;num, pthread_self()); free(temp); &#125; else &#123; // 没有数据需要等待 // 当这个函数调用阻塞时候会对互斥锁进行解锁,当不阻塞的，继续向下执行,会重新加锁 pthread_cond_wait(&amp;cond, &amp;mutex); &#125; pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; return NULL;&#125;int main() &#123; // 初始化信号量 pthread_mutex_init(&amp;mutex, NULL); // 初始化条件变量 pthread_cond_init(&amp;cond, NULL); // 创建5个生成者线程和5个消费者线程 pthread_t ptids[5], ctids[5]; for(int i = 0; i &lt; 5; i++) &#123; pthread_create(&amp;ptids[i], NULL, producer, NULL); pthread_create(&amp;ctids[i], NULL, customer, NULL); &#125; for(int i = 0; i &lt; 5; i++) &#123; pthread_detach(ptids[i]); pthread_detach(ctids[i]); &#125; while(1) &#123; sleep(10); &#125; pthread_mutex_destroy(&amp;mutex); pthread_cond_destroy(&amp;cond); pthread_exit(NULL); return 0;&#125; 信号量信号量函数12345678910111213141516171819信号量的类型 sem_tint sem_init(sem_t *sem, int pshared, unsigned int value); - 功能: 初始化信号量 - 参数: - sem: 信号量的的地址 - pshared: 0用在线程间、非0用在进程间 - value: 信号量中的值int sem_destroy(sem_t *sem); - 功能: 释放资源int sem_wait(sem_t *sem); - 功能: 对信号量加锁,对这个信号量的值减1,如果值为0,就阻塞int sem_trywait(sem_t *sem); - 功能: 尝试int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); - 功能: 等待多长的时间int sem_post(sem_t *sem); - 功能: 对信号量解锁,调用一次对信号的值加1int sem_getvalue(sem_t *sem, int *sval); - 功能: 获取 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142/************************************************************************* &gt; File Name: semaphore.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年06月02日 星期四 13时35分42秒 ************************************************************************//* 信号量的类型 sem_t int sem_init(sem_t *sem, int pshared, unsigned int value); - 功能: 初始化信号量 - 参数: - sem: 信号量的的地址 - pshared: 0用在线程间、非0用在进程间 - value: 信号量中的值 int sem_destroy(sem_t *sem); - 功能: 释放资源 int sem_wait(sem_t *sem); - 功能: 对信号量加锁,对这个信号量的值减1,如果值为0,就阻塞 int sem_trywait(sem_t *sem); - 功能: 尝试 int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); - 功能: 等待多长的时间 int sem_post(sem_t *sem); - 功能: 对信号量解锁,调用一次对信号的值加1 int sem_getvalue(sem_t *sem, int *sval); - 功能: 获取 // 生 sem_t pesm; // 消 sem_t csem; init(pesm, 0, 8); init(csem, 0, 0); // 生产 prodicer() &#123; sem_wait(&amp;osem); sem_post(&amp;csem); &#125; // 消费 customer() &#123; sem_wait(&amp;csem); sem_post(&amp;pesm); &#125;*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;typedef struct Node &#123; int num; struct Node *next;&#125; Node;// 头节点struct Node *head = NULL;// 互斥量pthread_mutex_t mutex;// 信号量sem_t psem;sem_t csem;void *producer(void *arg) &#123; // 不断的创建新的节点,添加到链表中 while(1) &#123; sem_wait(&amp;psem); pthread_mutex_lock(&amp;mutex); Node *newNode = (Node *)malloc(sizeof(Node)); newNode-&gt;num = rand() % 1000; newNode-&gt;next = head; head = newNode; printf(&quot;add node, num : %d, tid : %ld\\n&quot;, newNode-&gt;num, pthread_self()); pthread_mutex_unlock(&amp;mutex); sem_post(&amp;csem); usleep(100); &#125; return NULL;&#125;void *customer(void *arg) &#123; while(1) &#123; sem_wait(&amp;csem); pthread_mutex_lock(&amp;mutex); if(head != NULL) &#123; // 保存头节点的指针 Node *temp = head; head = head-&gt;next; printf(&quot;del node, num : %d, tid : %ld\\n&quot;, temp-&gt;num, pthread_self()); free(temp); &#125; pthread_mutex_unlock(&amp;mutex); sem_post(&amp;psem); usleep(100); &#125; return NULL;&#125;int main() &#123; // 初始化信号量 pthread_mutex_init(&amp;mutex, NULL); // 信号量初始化 sem_init(&amp;psem, 0, 8); sem_init(&amp;csem, 0, 0); // 创建5个生成者线程和5个消费者线程 pthread_t ptids[5], ctids[5]; for(int i = 0; i &lt; 5; i++) &#123; pthread_create(&amp;ptids[i], NULL, producer, NULL); pthread_create(&amp;ctids[i], NULL, customer, NULL); &#125; for(int i = 0; i &lt; 5; i++) &#123; pthread_detach(ptids[i]); pthread_detach(ctids[i]); &#125; while(1) &#123; sleep(10); &#125; pthread_mutex_destroy(&amp;mutex); pthread_exit(NULL); return 0;&#125;","categories":[{"name":"Linux多线程开发","slug":"Linux多线程开发","permalink":"https://tutouwang.vercel.app/categories/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"线程的操作","slug":"Linux多线程开发/线程的操作","date":"2022-05-30T05:38:53.000Z","updated":"2022-05-31T06:06:28.285Z","comments":true,"path":"2022/05/30/Linux多线程开发/线程的操作/","link":"","permalink":"https://tutouwang.vercel.app/2022/05/30/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%93%8D%E4%BD%9C/","excerpt":"","text":"pthread_create 创建线程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/************************************************************************* &gt; File Name: pthread_create.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月30日 星期一 10时33分57秒 ************************************************************************//* 一般情况下, main 函数所在的线程我们称之为主线程(main线程),其余创建的线程称之为子线程。 程序中默认只有一个进程,fork()函数调用,2进行 程序中默认只有一个线程,pthread_create(函数调用),2个线程 #include &lt;pthread.h&gt; int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg); - 功能: 创建一个子线程 - 参数: - thread: 传出参数,线程创建成功,子线程的线程ID被写到该变变量当中 - attr: 设置线程的属性, 一般使用默认值,NULL - start_routine: 函数指针,这个函数是子线程需要处理的逻辑代码 - atg: 给第三个参数使用的,传参 - 返回值: 成功返回 0 失败返回 错误号,和之前的errno不太一样 获取错误号的信息: char strerror(int errnum) */#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void *callback(void *arg) &#123; printf(&quot;child thread...\\n&quot;); printf(&quot;arg value:%d \\n&quot;, *(int *)arg); return NULL;&#125;int main() &#123; pthread_t tid; int num = 10; // 创建一个子线程 int ret = pthread_create(&amp;tid, NULL, callback, (void *)&amp;num); if(ret != 0) &#123; char * errstr = strerror(ret); printf(&quot;error : %s \\n&quot;, errstr); &#125; for(int i = 0; i &lt; 5; i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; sleep(1); return 0;&#125; 主线程和子线程其实是交替执行的 pthread_exit() 终止线程 - pthread_self() 获取当前的线程的线程ID123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/************************************************************************* &gt; File Name: pthread_exit.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月30日 星期一 14时30分18秒 ************************************************************************//* #include &lt;pthread.h&gt; void pthread_exit(void *retval); 功能: 终止一个线程,在那个线程中调用,就表示终止那个那个线程 参数: retval:需要传递一个指针,作为一个返回值,返回值可以在pthread_join()中获取到 pthread_t thread_self(void); 功能: 获取当前的线程的线程ID */#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;void *callback(void *arg) &#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); return NULL; // pthread_exit(null);&#125;int main() &#123; // 创建一个线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if(ret != 0) &#123; char *errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; for(int i = 0; i &lt; 5; i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); // 让主线程退出,当主线程退出时,不影响其他正常运行的线程 pthread_exit(NULL); // 运行之后可以看出 printf 和 return 0都没执行 所以说？？？？ printf(&quot;main thread exit \\n&quot;); return 0;&#125; pthread_join() 链接已终止的进程(回收子线程)回收子线程测试阻塞 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/************************************************************************* &gt; File Name: pthread_join.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月30日 星期一 17时54分48秒 ************************************************************************//* * #include &lt;pthread.h&gt; * int pthread_join(pthread_t thread, void **retval); * - 功能:和一个已经终止的线程进行链接 * 回收子线程的资源 * 这个函数是阻塞函数,调用一次只能回收一个子线程 * 一般在主线线程中使用 * - 参数: * - thread: 需要回收的子线程的ID * - retval: 接收子进程退出时的返回值 * - 返回值: * 成功返回 0 * 失败返回 错误号 */#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void *callback(void* arg) &#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); sleep(3); return NULL;&#125;int main() &#123; // 创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if(ret != 0) &#123; char *errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; for(int i = 0; i &lt; 5; i++) &#123; printf(&quot;%d \\n&quot;, i); &#125; printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); // 主线程调用pthread_join回收子进程资源 - 阻塞进程 ret = pthread_join(tid, NULL); if(ret != 0) &#123; char *errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; printf(&quot;回收子线程的资源成功\\n&quot;); // 让主线程退出 pthread_exit(NULL); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/************************************************************************* &gt; File Name: pthread_join.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月30日 星期一 17时54分48秒 ************************************************************************//* * #include &lt;pthread.h&gt; * int pthread_join(pthread_t thread, void **retval); * - 功能:和一个已经终止的线程进行链接 * 回收子线程的资源 * 这个函数是阻塞函数,调用一次只能回收一个子线程 * 一般在主线线程中使用 * - 参数: * - thread: 需要回收的子线程的ID * - retval: 接收子进程退出时的返回值 * - 返回值: * 成功返回 0 * 失败返回 错误号 */#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int value = 10;void *callback(void* arg) &#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); // sleep(3); // return NULL; // int value = 10; // 局部变量 - 因为在之前的图中可知栈空间是分层的所以你释放完时候下面输出的就是一个随机的值 pthread_exit((void *)&amp;value); // 跟retrn (void *)&amp;value&#125;int main() &#123; // 创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if(ret != 0) &#123; char *errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; for(int i = 0; i &lt; 5; i++) &#123; printf(&quot;%d \\n&quot;, i); &#125; printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); // 主线程调用pthread_join回收子进程资源 - 阻塞进程 int *thread_retval; ret = pthread_join(tid, (void **)&amp;thread_retval); /* 解释join为什么传2级指针 int data = 10; 假如你想调用函数修改 data的值一定是 test(&amp;data) 不是test(data) void test(int a) &#123;&#125; 同理 int **data = 10; void test(int a) &#123;&#125; test(** data) */ if(ret != 0) &#123; char *errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; printf(&quot;exit data : %d\\n&quot;, *thread_retval); printf(&quot;回收子线程的资源成功\\n&quot;); // 让主线程退出 pthread_exit(NULL); return 0;&#125; pthread_detach()线程的分离1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/************************************************************************* &gt; File Name: pthread_detach.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月30日 星期一 19时46分59秒 ************************************************************************//* * #include &lt;pthread.h&gt; * int pthread_detach(pthread_t thread); * - 功能: 分离一个线程,被分离的线程在终止的时候会自动释放资源返回 给系统。 * 1.不能多次的分离,会产生不可预料的行为. * 2.不能去连接一个已经分离的线程,会报错 * - 参数:需要分离的线程的ID * - 返回值: * 成功返回 0 * 失败返回 错误号 */#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void *callback(void *arg) &#123; printf(&quot;chid thread id %ld\\n&quot;, pthread_self()); return NULL;&#125;int main() &#123; // 创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if(ret != 0) &#123; char * errstr = strerror(ret); printf(&quot;error_create : %s\\n&quot;, errstr); &#125; // 输出子线程和子线程ID printf(&quot;tid : %ld, main thread id % ld\\n&quot;, tid, pthread_self()); // 设置子线程分离,子线程结束时对应的资源就不需要主线程释放 ret = pthread_detach(tid); if(ret != 0) &#123; char * errstr = strerror(ret); printf(&quot;error_datach : %s\\n&quot;, errstr); &#125; // 设置线程分离, 对分离的子线程进行链接 pthread_join() - 错误 /* ret = pthread_join(tid, NULL); if(ret != 0) &#123; char * errstr = strerror(ret); printf(&quot;error_join : %s\\n&quot;, errstr); &#125; */ // 退出主进程 pthread_exit(NULL); return 0;&#125; 线程分离之后不能再链接(join) pthread_cancel() 线程取消123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/************************************************************************* &gt; File Name: pthread_cancel.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月31日 星期二 09时32分12秒 ************************************************************************//* * #include &lt;pthread.h&gt; * int pthread_cancel(pthread_t thread); * - 功能: 取消线程(让线程终止) * 取消某个线程,可以终止某个线程的运行 * 但是并不是立马终止,而是当子线程执行到一个取消点，线程才会终 止 * 取消点:系统规定好的一些系统调用(每个系统都可能不一样),我们可以粗略的理解为 从用户区到内核去的切换这个位置称之为取消点 * */#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void *callback(void *arg) &#123; printf(&quot;chid thread id %ld\\n&quot;, pthread_self()); for(int i = 0; i &lt; 5; i++) &#123; printf(&quot;child : %d\\n&quot;, i); &#125; return NULL;&#125;int main() &#123; // 创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if(ret != 0) &#123; char * errstr = strerror(ret); printf(&quot;error_create : %s\\n&quot;, errstr); &#125; // 取消线程 pthread_cancel(tid); for(int i = 0; i &lt; 5; i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; // 输出子线程和子线程ID printf(&quot;tid : %ld, main thread id % ld\\n&quot;, tid, pthread_self()); // 退出主进程 pthread_exit(NULL); return 0;&#125; 线程属性线程分离 - 获取线程栈的大小12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/************************************************************************* &gt; File Name: pthread_attr.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月31日 星期二 13时27分44秒 ************************************************************************//* int pthread_attr_init(pthread_attr_t *attr); - 功能: 初始化线程属性变量 int pthread_attr_destroy(pthread_attr_t *attr); - 功能: 释放线程属性的资源 int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate); - 功能: 获取线程分离的状态属性 int pthread_attr_setdetachstate(ptread_attr_t *attr, int detachstate); - 功能: 设置线程分离的状态属性*/#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void *callback(void *arg) &#123; printf(&quot;chid thread id %ld\\n&quot;, pthread_self()); for(int i = 0; i &lt; 5; i++) &#123; printf(&quot;child : %d\\n&quot;, i); &#125; return NULL;&#125;int main() &#123; // 创建一个线程属性变量 pthread_attr_t attr; // 初始化属性变量 pthread_attr_init(&amp;attr); // 设置属性 - PTHREAD_CREATE_DETACHED(线程分离) pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); // 获取线程栈的大小 size_t size; pthread_attr_getstacksize(&amp;attr, &amp;size); // printf(&quot;thread stack size : %ld\\n&quot;, size); // 创建一个子线程 - 设置属性 pthread_t tid; int ret = pthread_create(&amp;tid, &amp;attr, callback, NULL); if(ret != 0) &#123; char * errstr = strerror(ret); printf(&quot;error_create : %s\\n&quot;, errstr); &#125; // 获取线程栈的大小 printf(&quot;thread stack size : %ld\\n&quot;, size); // 输出子线程和子线程ID printf(&quot;tid : %ld, main thread id % ld\\n&quot;, tid, pthread_self()); // 释放线程资源 pthread_attr_destroy(&amp;attr); // 退出主进程 pthread_exit(NULL); return 0;&#125;","categories":[{"name":"Linux多线程开发","slug":"Linux多线程开发","permalink":"https://tutouwang.vercel.app/categories/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"线程概述","slug":"Linux多线程开发/线程概述","date":"2022-05-29T08:02:24.000Z","updated":"2022-05-29T11:18:42.423Z","comments":true,"path":"2022/05/29/Linux多线程开发/线程概述/","link":"","permalink":"https://tutouwang.vercel.app/2022/05/29/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0/","excerpt":"","text":"线程概述 与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共 享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传 统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程） 进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。 线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本 质仍是进程。 查看指定进程的 LWP 号：ps –Lf pid 线程和进程区别 进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换。 调用 fork() 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如 内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销 依然不菲。 线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。 创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采 用写时复制来复制内存，也无需复制页表。 线程和进程虚拟地址空间 线程之间共享和非共享资源 共享资源 进程 ID 和父进程 ID p进程组 ID 和会话 ID p用户 ID 和 用户组 ID 文件描述符表 信号处置 文件系统的相关信息：文件权限掩码（umask）、当前工作目录 虚拟地址空间（除栈、.text） 非共享资源 非共享资源 信号掩码 线程特有数据 perror 变 量 实时调度策略和优先级 栈，本地变量和函数的调用链接信息 NPTL 当 Linux 最初开发时，在内核中并不能真正支持线程。但是它的确可以通过 clone() 系统调用将进程作为可调度的实体。这个调用创建了调用进程（calling process）的 一个拷贝，这个拷贝与调用进程共享相同的地址空间。LinuxThreads 项目使用这个调用 来完成在用户空间模拟对线程的支持。不幸的是，这种方法有一些缺点，尤其是在信号处 理、调度和进程间同步等方面都存在问题。另外，这个线程模型也不符合 POSIX 的要求。 要改进 LinuxThreads，需要内核的支持，并且重写线程库。有两个相互竞争的项目开始 来满足这些要求。一个包括 IBM 的开发人员的团队开展了 NGPT（Next-Generation POSIX Threads）项目。同时，Red Hat 的一些开发人员开展了 NPTL 项目。NGPT 在 2003 年中期被放弃了，把这个领域完全留给了 NPTL。 NPTL，或称为 Native POSIX Thread Library，是 Linux 线程的一个新实现，它 克服了 LinuxThreads 的缺点，同时也符合 POSIX 的需求。与 LinuxThreads 相 比，它在性能和稳定性方面都提供了重大的改进。 查看当前 pthread 库版本：getconf GNU_LIBPTHREAD_VERSION","categories":[{"name":"Linux多线程开发","slug":"Linux多线程开发","permalink":"https://tutouwang.vercel.app/categories/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"进程守护","slug":"Linux多进程开发/进程守护","date":"2022-05-27T09:55:21.000Z","updated":"2022-05-29T08:00:23.914Z","comments":true,"path":"2022/05/27/Linux多进程开发/进程守护/","link":"","permalink":"https://tutouwang.vercel.app/2022/05/27/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E8%BF%9B%E7%A8%8B%E5%AE%88%E6%8A%A4/","excerpt":"","text":"终端在 UNIX 系统中，用户通过终端登录系统后得到一个 shell 进程，这个终端成 为 shell 进程的控制终端（Controlling Terminal），进程中，控制终端是 保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进 程启动的其它进程的控制终端也是这个终端。 n默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指 向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准 错误输出写也就是输出到显示器上。 n在控制终端输入一些特殊的控制键可以给前台进程发信号，例如 Ctrl + C 会产 生 SIGINT 信号，Ctrl + \\ 会产生 SIGQUIT 信号。 echo $$ &#x2F;&#x2F; 查看当前用户ID tty &#x2F;&#x2F; 终端 进程组进程组和会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合， 会话是一组相关进程组的集合。进程组和会话是为支持 shell 作业控制而定义的抽 象概念，用户通过 shell 能够交互式地在前台或后台运行命令。 n进行组由一个或多个共享同一进程组标识符（PGID）的进程组成。一个进程组拥有一 个进程组首进程，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，新进程 会继承其父进程所属的进程组 ID。 n进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个 成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入 了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员。 会 话会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程 ID 会成为会 话 ID。新进程会继承其父进程的会话 ID。 一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终 端设备时被建立。一个终端最多可能会成为一个会话的控制终端。 在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为 后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终 端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。 n当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。 进程组、会话、控制终端之间的关系 进程组、会话操作函数12345678910// 获取当前的进程组npid_t getpgrp(void);// 获取指定的进程的进程组id 获得当前的npid_t getpgid(pid_t pid);// 设置进程组的ID把那个进程设置成那个组nint setpgid(pid_t pid, pid_t pgid);// 获取指定进程的会话的IDnpid_t getsid(pid_t pid);// 设置会话的IDnpid_t setsid(void); 守护进程守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周 期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。 守护进程具备下列特征： ​ 生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。 ​ 它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进 程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。 nLinux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd， Web 服务器 httpd 等。 守护进程的创建步骤执行一个 fork()，之后父进程退出，子进程继续执行。 子进程调用 setsid() 开启一个新会话。 清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。 修改进程的当前工作目录，通常会改为根目录（&#x2F;）。 关闭守护进程从其父进程继承而来的所有打开着的文件描述符。 在关闭了文件描述符0、1、2之后，守护进程通常会打开&#x2F;dev&#x2F;null 并使用dup2() 使所有这些描述符指向这个设备。 核心业务逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/************************************************************************* &gt; File Name: daemon.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月28日 星期六 17时01分15秒 ************************************************************************//* * 写一个守护进程,每隔2s获取一下系统时间,将这个时间写入到磁盘文件中 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/time.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;void work(int num) &#123; // 捕捉到信号后,获取系统时间,写入磁盘 time_t tm = time(NULL); struct tm *loc = localtime(&amp;tm); /* char buf[1024]; sprintf(buf, &quot;%d-%d-%d %d:%d:%d\\n&quot;, loc-&gt;tm_year, loc-&gt;tm_mon, loc-&gt;tm_mday, loc-&gt;tm_hour, loc-&gt;tm_min,loc-&gt;tm_sec); printf(&quot;%s\\n&quot;, buf); */ char *str = asctime(loc); int fd = open(&quot;time.txt&quot;, O_RDWR | O_CREAT | O_APPEND, 0664); write(fd, str, strlen(str)); close(fd); return ;&#125;int main() &#123; // 创建子进程 pid_t pid = fork(); // 退出父进程 // 为什么不用父进程创建会话 // 因为 如 父PID = 100那么进程的会话和进程组都是100那么再创建一个新的也是用的父进的PID会冲突所有利用子进程 if(pid &gt; 0) exit(0); // 将子进程重新创建会话 // 为什么创建新的会话: 因为新的会话会脱离控制终端就不会被一些信号杀死 setsid(); // 设置掩码 umask(022); // 更改工作目录 chdir(&quot;/home/qz&quot;); // 关闭、重定向文件描述符 int fd = open(&quot;/dev/null&quot;, O_RDWR); /* dup2(fd, STDIN_FILENO); // 写0 1 2 也是ok的 dup2(fd, STDOUT_FILENO); dup2(fd, STDERR_FILENO); */ // 业务逻辑 // 捕捉信号 struct sigaction act; act.sa_flags = 0; act.sa_handler = work; sigemptyset(&amp;act.sa_mask); sigaction(SIGALRM, &amp;act, NULL); struct itimerval val; // 过2秒 val.it_value.tv_sec = 2; val.it_value.tv_usec = 0; // 间隔 val.it_interval.tv_sec = 2; val.it_interval.tv_usec = 0; // 定时器 setitimer(ITIMER_REAL, &amp;val, NULL); while(1) &#123; &#125; return 0;&#125;","categories":[{"name":"Linux多进程开发","slug":"Linux多进程开发","permalink":"https://tutouwang.vercel.app/categories/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"共享内存","slug":"Linux多进程开发/共享内存","date":"2022-05-26T08:15:54.000Z","updated":"2022-05-29T08:00:16.488Z","comments":true,"path":"2022/05/26/Linux多进程开发/共享内存/","link":"","permalink":"https://tutouwang.vercel.app/2022/05/26/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/","excerpt":"","text":"共享内存共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于 一个共享内存段会成为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介 入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其 他所有共享同一个段的进程可用。 与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据 从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快 共享内存使用步骤调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其 他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。 使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存， 程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间 中该共享内存段的起点的指针。 调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存 了。这一步是可选的，并且在进程终止时会自动完成这一步。 调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之 后内存段才会销毁。只有一个进程需要执行这一步 共享内存操作函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;sys/ipc.h&gt;#inlcude &lt;sys/shm.h&gt;int shmget(key_t key, size_t size, int shmflg); - 功能创建一个新的共享内存段、或者获取一个既有的共享内存段的标识 新创建的内存段中的数据都会被初始化为0 - 参数: - key: key_t 类型是一个整形,通过这个找到或者创建一个共享内存 一般使用16进制表示,非0值 - size: 共享内存大小 分页大小 - shmflg: 属性 - 访问权限 - 附加属性: 创建/判断共享内存是不是存在 - 创建: IPC_CREAT - 判断共享内存是否存在: IPC_EXCL, 需要和IPC_CREAT一起使用 IPC_CREAT | IPC_EXCL | 0664 - 返回值: 失败: -1 并设置错误号 成功: &gt;0 返回共享内存的引用的ID,后面操作共享内存都是通过这个值 void *shmat(int shmid, const void *shmaddr, int shmflg); - 功能: 和当前的进程进行关联 - 参数: - shmid: 共享内存的标识(ID)由shmget返回值获取 - shmaddr: 申请的共享内存的起始地址,指定NULL, 内核指定 - shmflg: 对共享内存的操作 - 读 : SHM_RDONLY, 必须由读权限 - 读写 : 0 - 返回值: 成功: 返回共享内存的首地址(起始)地址。 失败: (void *) -1int shmdt(const void *shmaddr); - 功能: 解除当前进程和共享内存的关联 - 参数: shmaddr: 共享内存的首地址 - 返回值: 成功: 0 失败: -1int shmctl(int shmid, int cmd, struct shmid_ds *buf); - 功能: 对共享内存进行操作。删除共享内存, 共享内存要删除才会消失, 创建共享内存的进行被销毁了对共享内存是没有任何影响 - 参数: - shmid: 共享内存的ID - cmd: 要做的操作 - IPC_STAT:获得共享内存的当前状态 - IPC_SET: 设置共享内存的状态 - IPC_RMID: 标记共享内存被销毁 - buf: 需要设置或者获取的共享内存属性信息 - IPC_STAT:buf存储数据 - IPC_SET: buf中需要初始化数据,设置到内核中 - IPC_RMID: 没有用,NULL struct shmid_ds &#123; struct ipc_perm shm_perm; /* Ownership and permissions */ size_t shm_segsz; /* Size of segment (bytes) */ time_t shm_atime; /* Last attach time */ time_t shm_dtime; /* Last detach time */ time_t shm_ctime; /* Last change time */ pid_t shm_cpid; /* PID of creator */ pid_t shm_lpid; /* PID of last shmat(2)/shmdt(2) */ shmatt_t shm_nattch; /* No. of current attaches */ ... &#125;;key_t ftok(const char *pathname, int proj_id); - 功能: 根据指定的路, 和int值,生成一个共享内存的key - 参数: - pathname: 指定一个存在的路径 /home/qz/test/ / - proj_id: int类型的值,但是这关系调用只会使用其中的1个字符 范围: 0 - 255 一般指定一个字符 &#x27;a&#x27; write_shm.c123456789101112131415161718192021222324252627282930313233343536/************************************************************************* &gt; File Name: read_shm.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月27日 星期五 10时35分18秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;string.h&gt;int main() &#123; // 获取一个共享内存 int shmid = shmget(100, 4096, IPC_CREAT | 0664); printf(&quot;hmid : %d\\n&quot;,shmid); // 和当前进程进行关联 void *ptr = shmat(shmid, NULL, 0); char *str = &quot;hello world&quot;; memcpy(ptr, str, strlen(str) + 1); printf(&quot;按任意键继续\\n&quot;); getchar(); // 解除关联 shmdt(ptr); //删除关联 shmctl(shmid, IPC_RMID, NULL); return 0;&#125; read_shm.c12345678910111213141516171819202122232425262728293031323334/************************************************************************* &gt; File Name: read_shm.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月27日 星期五 10时35分18秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/ipc.h&gt;int main() &#123; // 获取一个共享内存 int shmid = shmget(100, 0, IPC_CREAT); printf(&quot;hmid : %d\\n&quot;,shmid); // 和当前进程进行关联 void *ptr = shmat(shmid, NULL, 0); printf(&quot;%s \\n&quot;, (char *) ptr); printf(&quot;按任意键继续\\n&quot;); getchar(); // 解除关联 shmdt(ptr); //删除关联 shmctl(shmid, IPC_RMID, NULL); return 0;&#125; yellow::问题1：操作系统如何知道一块共享内存被多少个进程关联？ 共享内存维护了一个结构体struct shmid_ds 这个结构体中由一个成员 shm_nattchshm_nattach 记录了关联的进程的个数 yellow::问题2：可不可以对共享内存进行多次删除shmctl 可以的因为shmctl 标记删除共享内存, 不是直接删除什么时候是真正删除呢？当共享内存和关联的进程数为0的时候，就真正被删除当共享内存的key为0的时候表示共享内存被标记删除了如果一个进程和共享内存取消关联,那么这个进程就不能继续操作这个共享内存。也不能进行再次关联 共享内存和内存映射的区别 共享内存可以直接创建，内存映射需要磁盘文件(匿名映射除外) 共享内存效果更高 内存 所有的进程操作的是同一块共享内存。 内存映射,每个进程在自己的虚拟地址空间中有一个独立的内存。 数据安全 进程突然退出 共享内存还存在 内存映射区消失 运行进程的电脑死机，宕机了 数据存储在共享内存中,没有了 内存映射区的数据,由于磁盘文件中的数据还在，所以内存映射区的数据还存在 生命周期 共享内存：进程退出,共享内存还在，标记删除(所有的关联的进程数为0)，或者关机、如果一个进程退出，会自动和共享内存进行取消关联。 内存映射区： 进程退出，内存映射区销毁 共享内存操作命令 ipcs 用 法 pipcs -a &#x2F;&#x2F; 打印当前系统中所有的进程间通信方式的信息 pipcs -m &#x2F;&#x2F; 打印出使用共享内存进行进程间通信的信息 pipcs -q &#x2F;&#x2F; 打印出使用消息队列进行进程间通信的信息 pipcs -s &#x2F;&#x2F; 打印出使用信号进行进程间通信的信息 ipcrm 用 法 pipcrm -M shmkey &#x2F;&#x2F; 移除用shmkey创建的共享内存段 pipcrm -m shmid &#x2F;&#x2F; 移除用shmid标识的共享内存段 pipcrm -Q msgkey &#x2F;&#x2F; 移除用msqkey创建的消息队列 pipcrm -q msqid &#x2F;&#x2F; 移除用msqid标识的消息队列 pipcrm -S semkey &#x2F;&#x2F; 移除用semkey创建的信号 pipcrm -s semid &#x2F;&#x2F; 移除用semid标识的信号","categories":[{"name":"Linux多进程开发","slug":"Linux多进程开发","permalink":"https://tutouwang.vercel.app/categories/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"信号","slug":"Linux多进程开发/信号","date":"2022-05-18T06:50:27.000Z","updated":"2022-05-29T08:00:20.677Z","comments":true,"path":"2022/05/18/Linux多进程开发/信号/","link":"","permalink":"https://tutouwang.vercel.app/2022/05/18/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E4%BF%A1%E5%8F%B7/","excerpt":"","text":"信号概述信号是 Linux进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个丘在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。 发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下: 对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C(9号信号)通常会给进程发送一个中断信号。 硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被О除，或者引用了无法访问的内存区域 系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的CPU时间超限，或者该进程的某个子进程退出。 运行 kill 命令或调用 kill 函数。 使用信号的两个主要目的是: 让进程知道已经发生了一个特定的事情。 强迫进程执行它自己代码中的信号处理程序。 信号的特点： 简单 不能携带大量的信息 满足某个特定条件才能发送 优先级比高 查看系统定义的信号列表：kill -l 前31个信号为常规信号,其余为实时信号。 信号一览表 编号 信号名称 对应事件 默认动作 1 SIGHUP 用户退出shell时，由该shell启动的所有进程将 收到这个信号 终止进程 2 SIGINT 当用户按下了组合键时，用户终端向正 在运行中的由该终端启动的程序发出此信号(CTRL + C) 终止进程 3 SIGQUIT 户按下组合键时产生该信号，用户终 端向正在运行中的由该终端启动的程序发出些信号 (CTRL + \\) 终止进程 4 SIGILL CPU检测到某进程执行了非法指令 终止进程并产生core文件 5 SIGTRAP 该信号由断点指令或其他 trap指令产生 终止进程并产生core文件 6 SIGABRT 调用abort函数时产生该信号 终止进程并产生core文件 7 SIGBUS 非法访问内存地址，包括内存对齐出错 终止进程并产生core文件 8 SIGFPE 在发生致命的运算错误时发出。不仅包括浮点运算 错误，还包括溢出及除数为0等所有的算法错误 终止进程并产生core文件 9 SIGKILL 无条件终止进程。该信号不能被忽略，处理和阻塞 终止进程，可以杀死任何进程 10 SIGUSE1 用户定义的信号。即程序员可以在程序中定义并使用该信号 终止进程 11 SIGSEGV 指示进程进行了无效内存访问(段错误) 终止进程并产生core文件 12 SIGUSR2 另外一个用户自定义信号，程序员可以在程序中定义并使用该信号 终止进程 13 SIGPIPE Broken pipe向一个没有读端的管道写数据 终止进程 14 SIGALRM 定时器超时，超时的时间 由系统调用alarm设置 终止进程 15 SIGTERM 程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号 终止进程 16 SIGSTKFLT Linux早期版本出现的信号，现仍保留向后兼容 终止进程 17 SIGCHLD 子进程结束时，父进程会收到这个信号 忽略这个信号 18 SIGCONT 如果进程已停止，则使其继续运行 继续&#x2F;忽略 19 SIGSTOP 停止进程的执行。信号不能被忽略，处理和阻塞 为终止进程 20 SIGTSTP 停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号 暂停进程 21 SIGTTIN 后台进程读终端控制台 暂停进程 22 SIGTTOU 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生 暂停进程 23 SIGURG 套接字上有紧急数据时，向当前正在运行的进程发出些信号，报 告有紧急数据到达。如网络带外数据到达 忽略该信号 24 SIGXCPU 进程执行时间超过了分配给该进程的CPU时间，系统产生该信号并发送给该进程 终止进程 25 SIGXFSZ 超过文件的最大长度设置 终止进程 26 SIGVTALRM 虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间 终止进程 27 SGIPROF 类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间 终止进程 28 SIGWINCH 窗口变化大小时发出 忽略该信号 29 SIGIO 此信号向进程指示发出了一个异步IO事件 忽略该信号 30 SIGPWR 关机 终止进程 31 SIGSYS 无效的系统调用 终止进程并产生core文件 34 ~64 SIGRTMIN ～ SIGRTMAX LINUX的实时信号，它们没有固定的含义（可以由用户自定义） 终止进程 信号的 5 种默认处理动作查看信号的详细信息：man 7 signal 信号的 5 中默认处理动作 Term 终止进程 Ign 当前进程忽略掉这个信号 Core 终止进程，并生成一个Core文件 Stop 暂停当前进程 Cont 继续执行当前被暂停的进程 信号的几种状态：产生、未决、递达 SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。 core0代表不会生成core文件 图2为设置core文件 123456789101112131415/************************************************************************* &gt; File Name: kill.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月18日 星期三 18时39分29秒 ************************************************************************/// 这个程序的作用是测试生成文件#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; char *buf; strcpy(buf, &quot;hello&quot;); return 0;&#125; kill、raise、abort函数因为会抢占cpu的资源不确定执行几次 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/************************************************************************* &gt; File Name: kill.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月18日 星期三 18时39分29秒 ************************************************************************//* * #include &lt;sys/types.h&gt; * #include &lt;signal.h&gt; * int kill(pid_t pid, int sig); * - 功能: 给任何的进程或者进程组pid, 发送某个信号 sig * - 参数: * - pid : 需要发送给的进程的id * &gt; 0 : 将信号发送给指定的进程 * = 0 : 将信号发送给当前的进程组 * = -1 : 表示将信号发送给每一个有权限的接受这个信号的进程 * &lt; -1 : 这个pid等于某个进程组的ID取反(1234) -&gt; (-1234) * - sig : 需要发送的信号的编号或者宏值,如果是0的话不发送任何信号 * kill(getppid(), 9); * kill(getpid(), 9); * * int raise(int sig); * - 功能: 给当前进程发送信号 * - 参数: * - sug : 要发送的信号 * - 返回值; * - 成功 0 * - 失败 非 0 * kill(getpid(), sig); * * void abort(void); * - 功能: 发送SIGABRT信号给当前进程,杀死当前进程 * kill(getpid(), SIGABRT); */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;int main() &#123; pid_t pid = fork(); if(pid == 0) &#123; // 子 for(int i = 0; i &lt; 5; i++) &#123; printf(&quot;child process\\n&quot;); sleep(1); &#125; &#125; else if(pid &gt; 0) &#123; // 父 printf(&quot;parent process\\n&quot;); sleep(2); printf(&quot;kill child process now\\n&quot;); // 父进程返回是子进程的信号 kill(pid, SIGINT); &#125; return 0;&#125; alarm 函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344/************************************************************************* &gt; File Name: alarm.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月19日 星期四 12时59分47秒 ************************************************************************//* * #include &lt;unistd.h&gt; * unisgned int alarm(unsigned int seconds); * - 功能: 设置定时器 (闹钟),函数调用,开始倒计时,倒计时为0的时候函数会给当前的 进程发送一个信号:SIGALARM * - 参数: * seconds: 倒计时的时长, 单位: 秒。 如果参数为0, 定时器无效(不进行倒计时不发信号) * 取消一个定时器,通过alarm(0); * - 返回值: 倒计时剩余的时间 * - 之前没有定时器, 返回0 * - 之前有定时器, 返回之前的定时器剩余时间 * -SIGALARM:默认终止当前的进程, 每一个进程都有且只有唯一的一个定时器 * alarm(10); -&gt; 返回 0 * 过了1秒 - 再定义一个 * alarm(5); -&gt; 返回9 * alarm(100) -&gt; 该函数是不阻塞的 * */#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; int seconds = alarm(5); printf(&quot;seconds = %d \\n&quot;, seconds); // 0 sleep(2); seconds = alarm(2); printf(&quot;seconds = %d \\n&quot;, seconds); // 3 while(1) &#123; &#125; return 0;&#125; 计算机一秒中电脑能数多少个数123456789101112131415161718192021222324252627/************************************************************************* &gt; File Name: alarm_One.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月19日 星期四 18时37分11秒 ************************************************************************//* * 实际时间 = 内核时间 + 用户时间 + 操作IO消耗的时间 * 进行文件IO操作的时间比较浪费时间 * * 定时器,与进程的状态无关 (自然定时法)。无论进程处于什么状态,alarm都会计时 * */#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; alarm(1); // 系统调用 -&gt; 内核 int i = 0; // 内核 -&gt; 用户区 while(1) &#123; printf(&quot;%d\\n&quot;, i++); &#125; return 0;&#125; 建议 g++ xxx.c .&#x2F;a.out &gt;&gt; a.txt setitimer 定时器函数 - 周期1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/************************************************************************* &gt; File Name: setitimer.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月19日 星期四 19时32分31秒 ************************************************************************//* * #include &lt;sys/time.h&gt; * int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value); * - 功能: 设置定时器(闹钟)。可以代替alarm函数。精度微秒us, 可以实现周期性定时 * - 参数: * - which: 定时器可以什么时间计时 * ITIMER_REAL: 真实时间,时间到达, 发送 SIGALRM 常用 * ITIMER_VIRTUAL: 用户时间,时间到达,发送SIGVTALRM * ITIMER_PROF: 以该进程在用户态下所消耗的时间来计算,时间到达, 发送SIGPROF * - new_value: * // 定时器结构体 * struct itimerval &#123; * // 每个阶段的时间,间隔时间 * struct timeval it_intercal; * // 延迟多长时间执行定时器 * struct timeval it_value; * &#125;; * * // 时间结构体 * struct timeval &#123; * // 秒数 * time_t tv_sec; * // 微妙 * suseconds_t tv_usec; * &#125;; * 过10(it_value)秒后,每隔2(it_intercal)秒定时一次 * - old_value: 记录上一次的定时的时间参数一般不使用,指定NULL * * - 返回值 * 成功 0 * 失败 -1 并设置错误号 */#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;stdlib.h&gt;// 过3秒以后,每2秒钟定时一次int main() &#123; struct itimerval new_value; new_value.it_interval.tv_sec = 2; // 微秒不设置就是随机的 new_value.it_interval.tv_usec = 0; // 设置延迟的时间, 3秒之后开始第一次定时 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret = setitimer(ITIMER_REAL, &amp;new_value, NULL); // 非阻塞 printf(&quot;定时器开始了！\\n&quot;); if(ret == -1) &#123; perror(&quot;setitimer&quot;); exit(-1); &#125; getchar(); return 0;&#125; signal 信号捕捉函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/************************************************************************* &gt; File Name: signal.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月24日 星期二 09时34分06秒 ************************************************************************//* * #include &lt;signal.h&gt; * typedef void (*sighandler_t)(int); * sighandler_t signal(int signum, sighandler_t handler); * - 功能: 设置某个信号的捕捉行为 * - 参数: * - signum: 要捕捉的信号 * - handler 捕捉的信号要如何处理 * - SIG_IGN: 忽略信号 * - SIG_DFL: 使用信号默认的行为 * - 回调函数: 这个函数是内核调用的(系统), 程序负责写,捕获到信号后如何去处理信号。 * 回调函数: * - 需要程序员实现,提前准好的,函数的类型根据实际需求,看函数指针的定义 * - 不是程序员调用,而是信号产生由内核调用 * - 函数指针是是现实函数回调的手段,函数实现之后,将函数名 放到函数指针的位置就可以了 * - 返回值: * 成功 返回上一次注册的信号处理函数的地址。第一次调用返回NULL * 失败 返回SIG_ERR,设置错误号 * SIGKILL(9号信号) SIGSTOP不能被捕捉,不能被忽略 */#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;void myalarm(int num) &#123; printf(&quot;捕捉到了信号的编号是: %d \\n&quot;, num); printf(&quot;xxxxxx\\n&quot;); return ;&#125;// 过3秒以后,每2秒钟定时一次int main() &#123; // 注册信号捕捉 // signal(SIGALRM, SIG_IGN); // signal(SIGALRM, SIG_DFL); // void (*sighandler_t)(int); 函数指针,int类型的参数表示捕捉的到的信号 值。 signal(SIGALRM, myalarm); struct itimerval new_value; new_value.it_interval.tv_sec = 2; // 微秒不设置就是随机的 new_value.it_interval.tv_usec = 0; // 设置延迟的时间, 3秒之后开始第一次定时 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret = setitimer(ITIMER_REAL, &amp;new_value, NULL); // 非阻塞 printf(&quot;定时器开始了！\\n&quot;); if(ret == -1) &#123; perror(&quot;setitimer&quot;); exit(-1); &#125; getchar(); return 0;&#125; 信号集许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为 信号集的数据结构来表示，其系统数据类型为 sigset_t。 在 PCB 中有两个非常重要的信号集。一个称之为 “阻塞信号集” ，另一个称之为 “未决信号集” 。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我 们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数 来对 PCB 中的这两个信号集进行修改。 信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。 信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。 信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号， 所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。 阻塞信号集和未决信号未决信号集：信号没被处理之前都会在未决信号集 阻塞信号集：我们需要对某几个信号进行阻塞 阻塞信号集和未决信号集1.用户通过键盘 Ctrl + C, 产生2号信号SIGINT (信号被创建) 2.信号产生但是没有被处理 （未决） - 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集） - SIGINT信号状态被存储在第二个标志位上 - 这个标志位的值为0， 说明信号不是未决状态 - 这个标志位的值为1， 说明信号处于未决状态 3.这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较 - 阻塞信号集默认不阻塞任何的信号 - 如果想要阻塞某些信号需要用户调用系统的API 4.在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了 如果没有阻塞，这个信号就被处理 如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理 号集相关的函数 - 只对自定义的有效123456789101112131415161718192021222324252627282930313233343536373839404142以下信号集相关的函数都是对自定义的信号集进行操作int sigemptyset(sigset_t *set); - 功能: 清空信号集中的数据, 将信号集中的所有的标志位置 清空 - 0 - 参数: set,传出参数,需要操作的信号集 - 返回值: - 成功返回 0 - 失败返回 -1int sigfillset(sigset_t *set); - 功能: 将信号集中的所有的标志位置为 1 - 参数: set,传出参数,需要操作的信号集 - 返回值: - 成功返回 0 - 失败返回 -1int sigaddset(sigset_t *set, int signum); - 功能: 向信号集中的某一个信号对应标志位为1，表示阻塞这个信号 - 参数: - set: 传出参数,需要操作的信号集 - signum: 需要设置阻塞的那个信号 - 返回值: - 成功返回 0 - 失败返回 -1int sigdelset(sigset_t *set, int signum); - 功能: 向信号集中的某一个信号对应标志位为0，表示不阻塞这个信号 - 参数: - set: 传出参数,需要操作的信号集 - signum: 需要设置不阻塞的那个信号 - 返回值: - 成功返回 0 - 失败返回 -1int sigismember(const sigset_t *set, int signum); - 功能: 判断某个信号是否阻塞 - 参数: - set: 需要操作的信号集 - signum: 需要判断的那个信号 - 返回值: - 1 signum 被阻塞 - 0 signum 不阻塞 - -1 signum 调用失败 /***************下面就是系统的API可以操作内核***************/int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);int sigpending(sigset_t *set); sigset - 设置未决信号集、阻塞信号集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/************************************************************************* &gt; File Name: sigset.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月24日 星期二 17时25分15秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;signal.h&gt;int main() &#123; // 创建一个信号集 sigset_t set; // 清空 sigemptyset(&amp;set); // 判断 SIGINT 是否在信号集 set 里 int ret = sigismember(&amp;set, SIGINT); if(ret == 0) &#123; printf(&quot;SIGINT 不阻塞\\n&quot;); &#125; else if(ret == 1) &#123; printf(&quot;SIGINT 阻塞\\n&quot;); &#125; else if(ret == -1) &#123; printf(&quot;调用失败\\n&quot;); &#125; // 添加几个信号到信号集中 sigaddset(&amp;set, SIGINT); sigaddset(&amp;set, SIGQUIT); ret = sigismember(&amp;set, SIGINT); if(ret == 0) &#123; printf(&quot;SIGINT 不阻塞\\n&quot;); &#125; else if(ret == 1) &#123; printf(&quot;SIGINT 阻塞\\n&quot;); &#125; else if(ret == -1) &#123; printf(&quot;调用失败\\n&quot;); &#125; ret = sigismember(&amp;set, SIGQUIT); if(ret == 0) &#123; printf(&quot;SIGQUIT 不阻塞\\n&quot;); &#125; else if(ret == 1) &#123; printf(&quot;SIGQUIT 阻塞\\n&quot;); &#125; else if(ret == -1) &#123; printf(&quot;调用失败\\n&quot;); &#125; // 从信号集中删除一个 sigdelset(&amp;set, SIGQUIT); ret = sigismember(&amp;set, SIGQUIT); if(ret == 0) &#123; printf(&quot;SIGQUIT 不阻塞\\n&quot;); &#125; else if(ret == 1) &#123; printf(&quot;SIGQUIT 阻塞\\n&quot;); &#125; else if(ret == -1) &#123; printf(&quot;调用失败\\n&quot;); &#125; return 0;&#125; sigprocmask - 阻塞信号集 - 内核 所有的常规信号 - 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/************************************************************************* &gt; File Name: sigprocmask.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月24日 星期二 18时42分13秒 ************************************************************************//* sigset_t == long int int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); - 功能: 将自定义信号集中的数据设置到内核中 (设置阻塞、解除阻塞、替换) - 参数: - how: 如何对内核阻塞信号进程处理 SIG_BLOCK: 将用户设置的阻塞信号集添加 到内核中,内核中原来的数据不变 列: 信号集 - mask 1 0 1 0 0 0 0 sigset_t - set | 0 1 0 0 0 0 0 ------------------ 1 1 1 0 0 0 0 假设内核中默认的阻塞信号集是 mask, mask | set SIG_UNBLOCK: 根据用户设置的数据,对内核中的数据进行解除阻塞 mask &amp;= ~set; SIG_SETMASK: 覆盖内核中原来的值 - set: 已经初始化好的用户自定义的信号集 - oldset: 保存设置之前的内核中的阻塞的信号集的状态, 可以是 NULL - 返回值: 成功返回: 0 失败返回: -1 并设置错误号: EFAULF、EINVAL int sigpending(sigset_t *set); - 功能: 获取内核中的未决信号集 - 参数: set, 传出参数, 保存的是内核中的未决信号集中的 信息 */#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt; // 所有的常规信号 kill -l (1 - 31) 未决状态打印到屏幕 // 设置某些信号是阻塞的,通过键盘产生这些信号int main() &#123; // 设置2、3信号阻塞 SIGINT(CTRL + C)、SIGQUIT(CTRL + \\) sigset_t set; sigemptyset(&amp;set); // 将2号和3号信号添加到信号集中 sigaddset(&amp;set, SIGINT); sigaddset(&amp;set, SIGQUIT); // 修改内核中的阻塞信号集 sigprocmask(SIG_BLOCK, &amp;set, NULL); int cnt = 0; while(1) &#123; cnt++; // 获取当前的未决信号集的数据 sigset_t pendingset; sigemptyset(&amp;pendingset); sigpending(&amp;pendingset); // 遍历前31位 for(int i = 1; i &lt;= 31; i++) &#123; if(sigismember(&amp;pendingset, i) == 1) &#123; printf(&quot;1&quot;); &#125;else if(sigismember(&amp;pendingset, i) == 0) &#123; printf(&quot;0&quot;); &#125; else &#123; printf(&quot;sigismember&quot;); exit(0); &#125; &#125; printf(&quot;\\n&quot;); sleep(1); if(cnt == 10) &#123; // 接触阻塞 sigprocmask(SIG_UNBLOCK, &amp;set, NULL); &#125; &#125; return 0;&#125; 前台进程和后台进程 run sigprocmask.c 直接运行程序 CTRL + z 也只是让程序后台运行 run sigprocmask.c &amp; &#x2F;&#x2F; 让程序在后台运行 fg &#x2F;&#x2F; 切换到前台 sigaction信号捕捉 尽量使用 sigaction 因为标准不一样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/************************************************************************* &gt; File Name: sigaction.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月25日 星期三 11时32分35秒 ************************************************************************//* * #include &lt;signal.h&gt; * int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); * - 功能: 检查或者改变信号的处理,信号捕捉 * - 参数: * - signum: 需要捕捉信号的编号或者宏值,不能捕捉的信号(SIGKILL and SIGSTOP) * - act: 捕捉信号之后的处理动作 * - oldact: 上一次对信号的捕捉相关的设置,一般补使用,传递NULL * - 返回值: * 成功 0 * 失败 -1 * * struct sigaction &#123; * 函数指针, 指向的函数就是信号捕捉到之后的处理函数 * void (*sa_handler)(int); * * 不常用 - 信号的编号, 信号的相关的信息, 信号的相关的信息 * void (*sa_sigaction)(int, siginfo_t *, void *); * * 临时阻塞信号集,信号捕捉函数执行过程中, 临时阻塞某些信号 * sigset_t sa_mask; * * 使用那一个信号处理对捕捉到的信号进行处理 * 这个值 0 表示使用sa_handler * 也可以是 SA_SIGINFO 表示使用 sa_sigaction * int sa_flags; * * 呗废弃掉了 * void (*sa_restorer)(void); * &#125;; */#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;void myalarm(int num) &#123; printf(&quot;捕获的信号的编号是: %d \\n&quot;, num); printf(&quot;xxxxxxx\\n&quot;); return ;&#125;int main() &#123; struct sigaction act; act.sa_flags = 0; act.sa_handler = myalarm; // 清空临时信号集 sigemptyset(&amp;act.sa_mask); // 注册信号捕捉 sigaction(SIGALRM, &amp;act, NULL); struct itimerval new_value; // 设置间隔时间 new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; // 设置延迟的时间, 3妙之后开始第一次定时 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; // 非阻塞 int ret = setitimer(ITIMER_REAL, &amp;new_value, NULL); printf(&quot;定时器开始了\\n&quot;); if(ret == -1) &#123; perror(&quot;setitimer&quot;); exit(-1); &#125; // getchar(); while(1); return 0;&#125; 内核实现信号捕捉的过程 SIGCHLD - 解决僵尸进程SIGCHLD信号产生的条件 子进程终止时 子进程接收到 SIGSTOP 信号停止时 子进程处在停止态,接受到SIGCONT后唤醒时 以上三种条件都会给父进程发送 SIGCHLD 信号, 父进程默认会忽略该信号 创建20个子进程12345678910111213141516171819202122232425262728293031323334353637383940414243444546/************************************************************************* &gt; File Name: sigchld.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月25日 星期三 17时19分37秒 ************************************************************************//* * SIGCHLD信号产生的3个条件: * 1.子进程结束 * 2.子进程暂停了 * 3.子进程继续运行 * 都会给父进程发送该信号,父进程默认忽略该信号 * 使用SIGCHLD信号解决僵尸进程的问题 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 创建一些子进程 pid_t pid; for(int i = 0; i &lt; 20; i++) &#123; pid = fork(); if(pid == 0) &#123; // 子 break; &#125; &#125; if(pid &gt; 0) &#123; // 父 while(1) &#123; printf(&quot;parent process pid : %d \\n&quot;, getpid()); sleep(2); &#125; &#125; else if(pid == 0) &#123; // 子 printf(&quot;child process pid : %d \\n&quot;, getpid()); &#125; return 0;&#125; 父进程结束子进程就死了 wait、waitpid 一次只能回收一个子进程 点我带你去看wait - waitpid 段错误(核心内存以转换) - 代码清除僵尸进程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/************************************************************************* &gt; File Name: sigchld.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月25日 星期三 17时19分37秒 ************************************************************************//* * SIGCHLD信号产生的3个条件: * 1.子进程结束 * 2.子进程暂停了 * 3.子进程继续运行 * 都会给父进程发送该信号,父进程默认忽略该信号 * 使用SIGCHLD信号解决僵尸进程的问题 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;void myFun(int num) &#123; printf(&quot;捕捉到的信号 : %d\\n&quot;, num); // 回收子进程PCB的资源 /* while(1) &#123; wait(NULL); &#125; */ while(1) &#123; int ret = waitpid(-1, NULL, WNOHANG); if(ret &gt; 0) &#123; printf(&quot;child die , pid = %d\\n&quot;, ret); &#125; else if(ret == 0) &#123; // printf(&quot;还有子进程活着\\n&quot;); break; &#125; else if(ret == -1) &#123; // 没有子进程了 break; &#125; &#125; return ;&#125;int main() &#123; // 创建一些子进程 pid_t pid; for(int i = 0; i &lt; 20; i++) &#123; pid = fork(); if(pid == 0) &#123; // 子 break; &#125; &#125; if(pid &gt; 0) &#123; // 父 // 捕捉子进程死亡时发送的SIGCHLD信号 struct sigaction act; act.sa_flags = 0; act.sa_handler = myFun; sigemptyset(&amp;act.sa_mask); sigaction(SIGCHLD, &amp;act, NULL); while(1) &#123; printf(&quot;parent process pid : %d \\n&quot;, getpid()); sleep(2); &#125; &#125; else if(pid == 0) &#123; // 子 printf(&quot;child process pid : %d \\n&quot;, getpid()); &#125; return 0;&#125; sigaction(SIGCHLD, &amp;act, NULL); 信号捕捉 信号捕捉还没有去注册成功 子进程就结束了 完了再去信号捕捉 就不能回收子进程了 回收改进12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/************************************************************************* &gt; File Name: sigchld.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月25日 星期三 17时19分37秒 ************************************************************************//* * SIGCHLD信号产生的3个条件: * 1.子进程结束 * 2.子进程暂停了 * 3.子进程继续运行 * 都会给父进程发送该信号,父进程默认忽略该信号 * 使用SIGCHLD信号解决僵尸进程的问题 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;void myFun(int num) &#123; printf(&quot;捕捉到的信号 : %d\\n&quot;, num); // 回收子进程PCB的资源 /* while(1) &#123; wait(NULL); &#125; */ while(1) &#123; int ret = waitpid(-1, NULL, WNOHANG); if(ret &gt; 0) &#123; printf(&quot;child die , pid = %d\\n&quot;, ret); &#125; else if(ret == 0) &#123; // printf(&quot;还有子进程活着\\n&quot;); break; &#125; else if(ret == -1) &#123; // 没有子进程了 break; &#125; &#125; return ;&#125;int main() &#123; // 提前设置好阻塞信号集, 阻塞SIGCHLD,因为有可能子进程很快结束,父进程还没注册好信号捕捉 sigset_t set; sigemptyset(&amp;set); sigaddset(&amp;set, SIGCHLD); sigprocmask(SIG_BLOCK, &amp;set, NULL); // 创建一些子进程 pid_t pid; for(int i = 0; i &lt; 20; i++) &#123; pid = fork(); if(pid == 0) &#123; // 子 break; &#125; &#125; if(pid &gt; 0) &#123; // 父 // 捕捉子进程死亡时发送的SIGCHLD信号 struct sigaction act; act.sa_flags = 0; act.sa_handler = myFun; sigemptyset(&amp;act.sa_mask); sigaction(SIGCHLD, &amp;act, NULL); // 注册完信号捕捉以后,解除阻塞 sigprocmask(SIG_UNBLOCK, &amp;set, NULL); while(1) &#123; printf(&quot;parent process pid : %d \\n&quot;, getpid()); sleep(2); &#125; &#125; else if(pid == 0) &#123; // 子 printf(&quot;child process pid : %d \\n&quot;, getpid()); &#125; return 0;&#125;","categories":[{"name":"Linux多进程开发","slug":"Linux多进程开发","permalink":"https://tutouwang.vercel.app/categories/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"[object Object]","slug":"object-Object","permalink":"https://tutouwang.vercel.app/tags/object-Object/"}]},{"title":"内存映射","slug":"Linux多进程开发/内存映射","date":"2022-05-17T03:09:38.000Z","updated":"2022-05-29T08:00:00.311Z","comments":true,"path":"2022/05/17/Linux多进程开发/内存映射/","link":"","permalink":"https://tutouwang.vercel.app/2022/05/17/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/","excerpt":"","text":"内存映射内存映射(Memory-mapped I&#x2F;O)是将磁盘文件的数据映射到内存,用户通过修改内存就能修改磁盘文件 父子进程间通信123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/************************************************************************* &gt; File Name: mmap-parent-child-ipc.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月15日 星期日 21时25分03秒 ************************************************************************//* * #include &lt;sys/mman.h&gt; * void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); * - 功能: 将一个文件或者设备的数据映射到内存中 * - 参数: * - void *addr : NULL // 由内核指定 * - length : 要映射的数据长度, 这个值不能为0,建议使用文件的长度。 * 获取文件长度 : stat、lseek * - prot : 对申请的内存映 * - PROT_EXEC : 可执行的权限 * - PROT_READ : 读权限 * - PROT_WRITE : 写权限 * - PROT_NONE : 没有权限 * 要操作映射内存,必须要有读的权限 * PROT_READ、PROT_READ|PROT_WRITE * - flags : * - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步,进程间通信,必 需要设置这个选项 * - MAP_PRIVATE : 不同步,内存映射器的数据改变了,对原的文件不会修改, 重新创建一个新的文件。(copy on write) * - fd: 需要映射的文件描述符 * - 通过open得到，open的是一个磁盘文件 * - 注意: 文件的大小不能为0, open指定的权限不能和prot参数有冲突。 * open 只读/读写 prot : PROT_READ(必须有) * prot : PROT_READ open:只读/读写 (小于open的权限) * prot : PROT_READ | PROT_WRITE open: 只能是读写 * - offset: 便宜量, 一般不用。必须指定的是4k的正数倍。0表示不偏移 * - 返回值: 返回创建的内存的首地址 * 失败返回MAP_FAILED, (void *) -1 * int munmap(void *addr, size_t length); * - 功能: 释放内存映射 * - 参数: * - addr : 要释放的内存的首地址 * - length : 要释放的内存大小, 要和 mmap 函数中的length参数的值一样 * *//* * 使用内存映射实现进程通信: * 1.有关系的进程(父子进程) * - 还有没有子进程的时候 * - 通过唯一的父进程, 先创建内存映射区 * - 有了内存映射区以后, 创建子进程 * - 父子进程共享创建的内存映射区 * * 2.没有关系的进程通信 * - 准备一个大小不是0的磁盘文件 * - 进程 1 通过磁盘文件创建内存映射区 * - 得到一个操作这块内存的指针 * - 进程 2 通过磁盘文件创建内存映射区 * - 得到一个操作这块内存的指针 * - 使用内存映射区实现进程通信 * 注意: 内存映射区通信,是非阻塞的 */#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;int main() &#123; // 1. 打开一个文件 int fd = open(&quot;test.txt&quot;, O_RDWR); int size = lseek(fd, 0, SEEK_END); // 获取文件的大小 // 2.创建文件 mmap(地址、大小、权限和open对应起来、同步、文件描述符、偏移量) void *ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(ptr == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if(pid &gt; 0) &#123; wait(NULL); // 父进程 char buf[64]; strcpy(buf, (char*)ptr); printf(&quot;read data : %s\\n&quot;, buf); &#125; else if(pid == 0)&#123; // 子进程 strcpy((char *)ptr, &quot;nihao a, son !!!&quot;); &#125; // 关闭内存映射区 munmap(ptr, size); return 0;&#125; 内存映射的注意事项 如果对mmap的返回值(ptr)做++操作(ptr++),munmap是否能够成功? ​ void *ptr &#x3D; mmap(…) ​ ptr++； 可以对其进行++ 操作 ​ 但是 munmap(ptr, len) &#x2F;&#x2F; 错误，要保存地址 如果open时O_RDONLY，mmap时prot参数指定PROT_READ | PROT_WRITE会怎样? ​ 错误,返回一个宏 MAP_FAILED ​ open() 函数中的权限建议和prot参数的权限保持一致 如果文件偏移量为1000会怎样? 偏移量是4k的整数倍，返回 MAP_FAILED mmap什么情况下会调用失败? ​ - 第二个参数: length &#x3D; 0 （映射数据长度） 不能再内存中映射为 0 ​ - 第三个参数： prot ​ 只指定了写权限 ​ prot PROT_READ | PROT_WRITE ​ 第5个参数(文件描述符) fd 通过open函数时指定的 O_RDONLY 或者 O_WRONLY 可以open的时候O_CREAT一个新文件来创建映射区吗? ​ 可以的，但文件的大小如果为0的话，肯定不行 ​ 可以对新的文件进行扩展 ​ lseek() ​ truncate() mmap后关闭文件描述符，对mmap映射有没有影响? int fd &#x3D; open(“xxx”); mmap(…, fd, 0); close(fd); &#x2F;&#x2F; 关闭不会产生问题 映射区还存在，创建映射区的fd被关闭,没有任何影响 对ptr越界操作会怎样? ​ void * ptr &#x3D; mmap(null, 100, …) ​ 4k ​ 越界操作的是非法的内存 -&gt; 段错误 使用内存映射实现文件拷贝需要先创建一个test.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/************************************************************************* &gt; File Name: copy.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月18日 星期三 10时47分03秒 ************************************************************************//* * 思路: * 1.对原始的文件进行内存映射 * 2.创建一个新文件 (拓展该文件) * 3.把新文件的数据映射要内存中 * 4.通过内存拷贝将第一个文件的内存数据拷贝到新的文件内存中 * 5.释放资源 * */#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 使用内存映射实现文件拷贝int main() &#123; // 对原始的文件进行内存映射 int fd = open(&quot;test.txt&quot;, O_RDWR); if(fd == -1) &#123; perror(&quot;open&quot;); exit(-1); &#125; // 获取原始文件大小 int len = lseek(fd, 0, SEEK_END); // 创建一个新文件 int fd1 = open(&quot;cpy.txt&quot;, O_RDWR | O_CREAT, 0664); // 对新创建文件进程拓展 truncate(&quot;cpy.txt&quot;, len); write(fd1, &quot; &quot;, 1); // 内存映射 void *ptr = mmap(NULL, len, PROT_READ| PROT_WRITE, MAP_SHARED, fd, 0); void *ptr1 = mmap(NULL, len, PROT_READ| PROT_WRITE, MAP_SHARED, fd1, 0); if(ptr == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(-1); &#125; if(ptr1 == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(-1); &#125; // 内存拷贝 memcpy(ptr1, ptr, len); // 释放资源 munmap(ptr, len); munmap(ptr1, len); close(fd1); close(fd); return 0;&#125; 匿名映射只能做父子进程中的通信 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/************************************************************************* &gt; File Name: mmap-anon.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月18日 星期三 13时10分14秒 ************************************************************************//* * 匿名映射: 不需要文件实体进程一个内存映射 */#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;int main() &#123; // 创建匿名映射区 int len = 4069; void *ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); if(ptr == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(-1); &#125; // 父子进程间通信 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父 strcpy((char *)ptr, &quot;hello&quot;); wait(NULL); &#125; else if(pid == 0) &#123; // 子 sleep(1); printf(&quot;%s\\n&quot;, (char *)ptr); &#125; int ret = munmap(ptr, len); if(ret == -1) &#123; perror(&quot;munmap&quot;); exit(-1); &#125; return 0;&#125;","categories":[{"name":"Linux多进程开发","slug":"Linux多进程开发","permalink":"https://tutouwang.vercel.app/categories/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"三角形求面积","slug":"有趣的知识/三角形求面积","date":"2022-05-15T12:08:27.000Z","updated":"2022-05-15T12:27:52.792Z","comments":true,"path":"2022/05/15/有趣的知识/三角形求面积/","link":"","permalink":"https://tutouwang.vercel.app/2022/05/15/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%B1%82%E9%9D%A2%E7%A7%AF/","excerpt":"","text":"行列式 - 直角坐标器给定 A(x1, y1) B(x2, y2) C(x3, y3) 以知三角行 底(a) - 高(h)$S &#x3D; (a * h ) &#x2F; 2$ 海伦公式$p &#x3D; (a + b + c) &#x2F; 2$ $S&#x3D;sqrt[p(p-a)(p-b)(p-c)]$ $&#x3D;sqrt[(1&#x2F;16)(a+b+c)(a+b-c)(a+c-b)(b+c-a)]$ $&#x3D; 1 &#x2F; 4 sqrt [(a+b+c)(a+b-c)(a+c-b)(b+c-a)] $ 利用正玄已知三角形两边a,b,这两边夹角C，则 ，即两夹边之积乘夹角正弦值的一半。","categories":[],"tags":[{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/tags/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"STL_二分","slug":"STL剖析/STL-二分","date":"2022-05-06T07:15:03.000Z","updated":"2022-05-06T08:12:33.962Z","comments":true,"path":"2022/05/06/STL剖析/STL-二分/","link":"","permalink":"https://tutouwang.vercel.app/2022/05/06/STL%E5%89%96%E6%9E%90/STL-%E4%BA%8C%E5%88%86/","excerpt":"","text":"数组是升序的情况例：1 3 5 7 7 10 11 lower_bound(begin, ned, key) — 得到第一个 &gt;&#x3D; key 的下标 upper_bound(begin, ned, key) — 得到第一个 &gt; key 的下标 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/************************************************************************* &gt; File Name: 二分.cpp &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月06日 星期五 15时18分04秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int f[] = &#123;1, 3, 5, 7, 7, 10, 11&#125;;void printNumber(int *f, int n) &#123; for(int i = 0; i &lt; n; i++) cout &lt;&lt; f[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return ;&#125;int main() &#123; int n = sizeof(f) / sizeof(int); printNumber(f, n); int idx = -1; idx = lower_bound(f, f + sizeof(f) / sizeof(int), 7) - f; cout &lt;&lt; &quot;升序数组 - lower_bound - key = 7, idx = &quot; &lt;&lt; idx &lt;&lt; endl; idx = upper_bound(f, f + sizeof(f) / sizeof(int), 7) - f; cout &lt;&lt; &quot;升序数组 - upper_bound - key = 7, idx = &quot; &lt;&lt; idx &lt;&lt; endl; idx = upper_bound(f, f + sizeof(f) / sizeof(int), 12) - f; cout &lt;&lt; &quot;不存在的情况 - 升序数组 - upper_bound - key = 100, idx = &quot; &lt;&lt; idx &lt;&lt; endl; /***********************************************************************************************/ sort(f, f + n, greater&lt;int&gt;()); printNumber(f, n); idx = lower_bound(f, f + sizeof(f) / sizeof(int), 7) - f; cout &lt;&lt; &quot;降序数组 - lower_bound - key = 7, idx = &quot; &lt;&lt; idx &lt;&lt; endl; idx = upper_bound(f, f + sizeof(f) / sizeof(int), 7) - f; cout &lt;&lt; &quot;降序数组 - upper_bound - key = 7, idx = &quot; &lt;&lt; idx &lt;&lt; endl; idx = upper_bound(f, f + sizeof(f) / sizeof(int), 12) - f; cout &lt;&lt; &quot;不存在的情况 - 升序数组 - upper_bound - key = 100, idx = &quot; &lt;&lt; idx &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]},{"title":"基础博弈","slug":"基础算法/基础博弈","date":"2022-05-04T09:22:50.000Z","updated":"2022-05-04T09:23:43.826Z","comments":true,"path":"2022/05/04/基础算法/基础博弈/","link":"","permalink":"https://tutouwang.vercel.app/2022/05/04/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E5%8D%9A%E5%BC%88/","excerpt":"","text":"博弈论1.简介 博弈博弈&#x2F;博弈论，又称为对策论（Game Theory）、赛局理论等，既是现代数学的一个新分支，也是运筹学的一个重要学科。博弈论主要研究公式化了的激励结构间的相互作用，是研究具有斗争或竞争性质现象的数学理论和方法，博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。 总而言之，博弈，就是两方（或者多方）在为了某一种目标进行的竞争。 在生活中，博弈无处不在，国与国之间的交锋就是一种博弈，在游戏中你与对手的有来有回也是一种博弈，面对老板提出加工资的需求又也是一种博弈，在博弈中，选择去做什么非常重要，这也是十分有研究价值的，一个有趣的题外话：从1994年诺贝尔经济学奖授予3位博弈论专家开始，共有7届的诺贝尔经济学奖与博弈论的研究有关。 2. 基础概念 必胜态：通过某一步可以转移到必败态的局面。 也就是说，对于一个处于必胜态的玩家，他总能找到一种合法操作，将当前局面变成一个必败态然后交给对方，如果中途不出现意外的话，最终自己就会得到胜利。但是处于必胜态并不意味着任意的操作都能将当前局面变成必败态。 必败态：通过某一步只能转移到必胜态的局面。 也就是说，处于必败态的玩家无论做什么操作，都只会将当前的局面变成必胜态，然后交给对方，只要对方足够聪明，那么该玩家将输掉比赛。 对于足够聪明的两个博弈者来说，游戏的胜负在比赛前就已经知道(当然，我这里只是说在题目里，在现实中如果是稍微复杂一点的博弈游戏，单凭人脑是很难达到那种水平)，也就是说胜利的一方总能找到胜利的路径，而输掉的那一方无论怎样走，胜利的一方都能找到对应的方法。也就是说先后手以及起始局面可以决定整场博弈的胜负。 3.思想博弈问题的特点 a) 博弈模型为两人轮流决策的非合作博弈。即两人轮流进行决策，并且两人都使用最优策略来获取胜利 b) 博弈是有限的。即无论两人怎样决策，都会在有限步后决出胜负 c) 公平博弈。即两人进行决策所遵循的规则相同 4.学习方法关于博弈论，最理想的学习方式还当属熟悉模型，几种常用的博弈论模型有：巴什博弈，威佐夫博弈，斐波那契博弈，尼姆博弈，通过理解模型以及他们模型可能产生的变种，面对各种题目也只是“换汤不换药”的思维。 在基本了解各类模型之后，我们可以开始学习“博弈树”和“决策树”这类算法，以及其他一些启发式算法，这与人工智能的思维很接近，此时算法难度已经直线上升，在经过这个瓶颈之后，等待你的是一片星辰大海。 巴什博弈 巴什博弈的主要内容：只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。其中它强调的是只有一堆物品：取光者胜 如果 n % (m + 1) &#x3D;&#x3D; 0 先手必败 ​ n % (m + 1) !&#x3D; 0 先后必败 相信大家看见这个一定有很多疑惑就是为什么这个公式就能看到结局！ 1.如果它能被（m+1）整除，那么假设你先手 取p个，那么对手总能取m+1-p 个（因为1&lt;&#x3D;p&lt;&#x3D;m，那么 1&lt;&#x3D;(m+1-p)&lt;&#x3D;m 也满足对手所取数量的条件限制），这样不断循环下去，最后拿到石头的一定是对手。 2.如果它不能被（m+1）整除，那么你一定可以拿走那个余数k（k&#x3D;n%(m+1)） 这样对手就相当于面对了 n%（m+1）的局面，也就是1的情况。 巴什博弈(例题)巴什博弈-普通http://acm.hdu.edu.cn/showproblem.php?pid=1846 123456789101112131415161718#include &lt;iostream&gt;using namespace std;// 最先取光石子的一方为胜bool Bash(int n, int m) &#123; return n % (m + 1) != 0 ? 1 : 0; // 核心代码&#125;int main() &#123; int t, n, m; // n = 组数 n = 石子个数 m = 每回取最多个数 cin &gt;&gt; t; for (int i = 0; i &lt; t; i++) &#123; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; (Bash(n, m) ? &quot;first&quot; : &quot;second&quot;) &lt;&lt; endl; &#125; return 0;&#125; 巴什博弈-变行http://acm.hdu.edu.cn/showproblem.php?pid=4764 12345678910111213#include &lt;iostream&gt;using namespace std;// 题目的意思就是谁取到最后一个谁输int main() &#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; if (!(n + m)) break; cout &lt;&lt; (((n - 1) % (m + 1)) == 0 ? &quot;Jiang&quot; : &quot;Tang&quot;) &lt;&lt; endl; &#125; return 0;&#125; 尼姆博弈在说尼姆博弈之前我们需要去了解一个什么呢！ 就是异或 异或 英文名字 exclusive OR 缩写 xor 数学符号 ⊕ 计算机符号是 xor 但是到底异或怎么使用 比如说 4 ^ 3 4 的二进制 1 0 0 3 的二进制 0 1 1 xor 异或 1 1 1 就是说他们相同为0不同为1,当然在其中你应该还能看出一个问题是什么呢！ 就是大家可以算一下7的二进制数是什么 1 1 1 对吧！ 从此问题看出他们异或的结果就等于他们两个数相加 对吧 ！！! 就是异或也叫半加运算 这里能大家可以比如再去实验一个数比如说 1 ^ 2 &#x3D; 什么对吧！！！ 现在说了这么多都是什么对吧！！！ 就是为了我们之后要讲的尼姆博弈做的 铺垫！ 什么是尼姆博弈 有n堆石子，两人从某一堆取任意多个，规定至少取走1个之多可以取走这堆的全部最后取光者胜。 在这里大家就可能发现了这和刚刚的巴什博弈不差什么对吧！ 情况 ① 当有 1 堆石子的时候先手可以全部取走，对吧 ， 之后先手胜利 情况 ② 当有 2 堆石子时候 我们令一堆石子为 n 另一堆 m 假设 n &gt; m —– n &#x3D; 4 —- m &#x3D; 3 之后先手先取 因为两个人都是顶尖聪明的人都会去去吧自己利益最大化 就是我们先取 n - m 个剩下的无论后手怎么去取我们都和后手去取相同 个数的石子这样我们一定是必胜局， n &#x3D; 4 - &gt; 二进制 1 0 0 m &#x3D; 3 - &gt; 二进制 0 1 1 xor 1 1 1 3 (4 - 1) 0 1 1 3 0 1 1 xor 0 0 0 我们让异或为0也就是说我们让两个石子数量相对 之后不就像我们之前说的不管后手取多少我们先手都是必胜 情况 ③ 当有 2 堆石子时候 我们令一堆石子为 n 另一堆 m 假设 n &#x3D; m —– n &#x3D; 4 —- m &#x3D; 4 从刚才上图看出一但出现 n &#x3D;&#x3D; m 时候无论先手怎么取 后手就可以取和先手相同的个数 这样先手必败 （就是说因为两个都足够聪明所有说先手一定是什么比败局） 之后咱们不可能说是只有2堆是吧 可能还有 3 堆 ， 4 堆 ， 5 堆，6 堆…..等等 比如说（1， 2 ，3）这种我们能看出 先手必败 1 二进制 0 0 1 2 二进制 0 1 0 3 二进制 0 1 1 +（xor） ​ 0 0 0 随机举例 堆数 n &#x3D; 5 石子个数 182 63 59 22 10 取光者胜 甲 先 乙 后 石子数 128 64 32 16 8 4 2 1 182 1 0 1 1 0 1 1 0 63 0 0 1 1 1 1 1 1 59 0 0 1 1 1 0 1 1 22 0 0 0 1 0 1 1 0 10 0 0 0 0 1 0 1 0 xor 1 0 1 0 1 1 1 0 甲 石子数 128 64 32 16 8 4 2 1 24 (182 - 128 - 32 - 4 - 2 + 8) 158 0 0 0 1 1 0 0 0 63 0 0 1 1 1 1 1 1 59 0 0 1 1 1 0 1 1 22 0 0 0 1 0 1 1 0 10 0 0 0 0 1 0 1 0 xor 0 0 0 0 0 0 0 0 乙 石子数 128 64 32 16 8 4 2 1 24 0 0 0 1 1 0 0 0 31 (63 - 32) 0 0 0 1 1 1 1 1 59 0 0 1 1 1 0 1 1 22 0 0 0 1 0 1 1 0 10 0 0 0 0 1 0 1 0 xor 0 0 1 0 0 0 0 0 甲 石子数 128 64 32 16 8 4 2 1 24 0 0 0 1 1 0 0 0 31 0 0 0 1 1 1 1 1 27 (59 - 32) 0 0 0 1 1 0 1 1 22 0 0 0 1 0 1 1 0 10 0 0 0 0 1 0 1 0 xor 0 0 0 0 0 0 0 0 经过几次后一定会得到情况② 尼姆博弈-代码模板12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int n, t = 0; // n = 堆数 cin &gt;&gt; n; while (n--) &#123; int d; cin &gt;&gt; d; t ^= d; &#125; if (t == 0) cout &lt;&lt; &quot;先手必输&quot;; else cout &lt;&lt; &quot;先手必胜&quot;; return 0;&#125;","categories":[{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"进程间通信-IPC","slug":"Linux多进程开发/进程间通信","date":"2022-04-17T11:15:03.000Z","updated":"2022-05-29T08:00:30.022Z","comments":true,"path":"2022/04/17/Linux多进程开发/进程间通信/","link":"","permalink":"https://tutouwang.vercel.app/2022/04/17/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","excerpt":"","text":"进程间通讯的概念进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程)之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信(IPC: Inter Processes Communication )。 GUI：用户图像接口 IDE：集成开发环境 API：应用程序接口 进程间通信的目的： 数据传输:一个进程需要将它的数据发送给另一个进程。 通知事件:一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程)。 资源共享:多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。 (同步(就是排队看病 - 安全)、异步(一个医生一起看多个病人 - 不安全)) 进程控制:有些进程希望完全控制另一个进程的执行（如Debug 进程)，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 Linux进程间通信的方式 匿名管道管道也叫无名（匿名）管道，它是是UNIX系统IPC(进程间通信)的最古老形式,所有的UNIX系统都支持这种通信机制。 统计一个目录中文件的数目命令: ls | wc -l，为了执行该命令, shell创建了两个进程来分别执行 ls 和 wc。 管道特点 匿名管道 - 有名管道 共同特点管道其实是一个在内核&#39;内存中&#39;通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。 管道拥有文件的特质:读操作、写操作，匿名管道没有文件实体(有关系的进程 父进程 - 子进程 - 孙子进程)，有名管道有文件实体(没有关系的进程),但不存储数据。可以按照操作文件的方式对管道进行操作。 一个管道是一个字节流(一个字节 一个字节 在管道里面)，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。 在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。 单工(遥控器发射信号给电视机 但是电视机不能给遥控器发射信号 这就是单工) 双工(打电话 1给2打电话 1 说 二可以听到、2说 1可以听到 同时) 半双工(同一时间只能一个方向就好比那放学 都往出走你就进不去(当然啊 除非你不要命的硬挤进去！！！) 当出来的都走完了进的在往里进) 从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据．在管道中无法使用lseek ()来随机的访问数据。 匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用 为什么可以使用管道进行进程通信 管道(红色长方体) 左侧读 右侧写 父 - 子 进程 管道的数据结构 匿名管道的使用 创建匿名管道 12#include &lt;unistd.h&gt;int pipe(int pipefd[2]); 查看管道缓冲大小命令 1ulimit -a 查看管道缓冲大小函数 123#include &lt;unistd.h&gt;long fpathconf(int fd, int name); 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/************************************************************************* &gt; File Name: pipe.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月18日 星期一 19时08分03秒 ************************************************************************//* * #include &lt;unistd.h&gt; * int pipe(int pipefd[2]); * 功能: 创建一个匿名管道, 用来进程间通信 * 参数: int pipefd[2] 这个数组是一个传出参数。 * - pipefd[0] : 对应管道的读端 * - pipefd[1] : 对应管道的写端 * 返回值: * 成功返回 0 * 失败返回 -1 * 注意: 匿名管道只能用于具有关系的进程之间通信 (父子进程, 兄弟进程, 孙子进程) * */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;// 子进程发送数据给父进程, 父进程读取到数据输出int main() &#123; // 再 fork 之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 // 从管道的读取端读取数据 char buf[1024] = &#123;0&#125;; int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;parent revc : %s, pid : %d\\n&quot;, buf, getpid()); &#125; else if(pid == 0)&#123; // 子进程 char *str = &quot;hello,i am child&quot;; write(pipefd[1], str, strlen(str)); &#125; return 0;&#125; 先猜想: 如果子进程写入前 sleep(10) 后 中端输出什么：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/************************************************************************* &gt; File Name: pipe.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月18日 星期一 19时08分03秒 ************************************************************************//* * #include &lt;unistd.h&gt; * int pipe(int pipefd[2]); * 功能: 创建一个匿名管道, 用来进程间通信 * 参数: int pipefd[2] 这个数组是一个传出参数。 * - pipefd[0] : 对应管道的读端 * - pipefd[1] : 对应管道的写端 * 返回值: * 成功返回 0 * 失败返回 -1 * 注意: 匿名管道只能用于具有关系的进程之间通信 (父子进程, 兄弟进程, 孙子进程) * 管道默认是阻塞的, 如果管道中没有数据, read阻塞, 如果管道满了, write阻塞 * */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;// 子进程发送数据给父进程, 父进程读取到数据输出int main() &#123; // 再 fork 之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 // 从管道的读取端读取数据 char buf[1024] = &#123;0&#125;; int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;parent revc : %s, pid : %d\\n&quot;, buf, getpid()); &#125; else if(pid == 0)&#123; // 子进程 sleep(10); char *str = &quot;hello,i am child&quot;; write(pipefd[1], str, strlen(str)); &#125; return 0;&#125; 多次写入 读取1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/************************************************************************* &gt; File Name: pipe.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月18日 星期一 19时08分03秒 ************************************************************************//* * #include &lt;unistd.h&gt; * int pipe(int pipefd[2]); * 功能: 创建一个匿名管道, 用来进程间通信 * 参数: int pipefd[2] 这个数组是一个传出参数。 * - pipefd[0] : 对应管道的读端 * - pipefd[1] : 对应管道的写端 * 返回值: * 成功返回 0 * 失败返回 -1 * 注意: 匿名管道只能用于具有关系的进程之间通信 (父子进程, 兄弟进程, 孙子进程) * 管道默认是阻塞的, 如果管道中没有数据, read阻塞, 如果管道满了, write阻塞 * */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;// 子进程发送数据给父进程, 父进程读取到数据输出int main() &#123; // 再 fork 之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 // 从管道的读取端读取数据 printf(&quot;i am parent process, pid : %d\\n&quot;, getpid()); char buf[1024] = &#123;0&#125;; // 关闭写端 close(pipefd[1]); while(1) &#123; int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;parent revc : %s, pid : %d\\n&quot;, buf, getpid()); // char *str = &quot;i am parent&quot;; // write(pipefd[1], str, strlen(str)); // sleep(1); &#125; &#125; else if(pid == 0)&#123; // 子进程 printf(&quot;i am child process, pid : %d\\n&quot;, getpid()); char buf[1024]; // 关闭读端 close(pipefd[0]); while(1) &#123; char *str = &quot;hello,i am child&quot;; write(pipefd[1], str, strlen(str)); // sleep(1); int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;pa child recv : %s, pid : %d\\n&quot;, buf, getpid()); bsize(buf, 1024); &#125; &#125; return 0;&#125; &#x2F;&#x2F; 发完数据还没有数字没清空 ps: 如果注释掉 sleep() 就会发现问题！就是自己写的会自己读回去 当然在项目中不会出现这种情况 项目中只会一端读一端写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/************************************************************************* &gt; File Name: pipe.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月18日 星期一 19时08分03秒 ************************************************************************//* * #include &lt;unistd.h&gt; * int pipe(int pipefd[2]); * 功能: 创建一个匿名管道, 用来进程间通信 * 参数: int pipefd[2] 这个数组是一个传出参数。 * - pipefd[0] : 对应管道的读端 * - pipefd[1] : 对应管道的写端 * 返回值: * 成功返回 0 * 失败返回 -1 * 注意: 匿名管道只能用于具有关系的进程之间通信 (父子进程, 兄弟进程, 孙子进程) * 管道默认是阻塞的, 如果管道中没有数据, read阻塞, 如果管道满了, write阻塞 * */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;// 子进程发送数据给父进程, 父进程读取到数据输出int main() &#123; // 再 fork 之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 // 从管道的读取端读取数据 printf(&quot;i am parent process, pid : %d\\n&quot;, getpid()); char buf[1024] = &#123;0&#125;; while(1) &#123; int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;parent revc : %s, pid : %d\\n&quot;, buf, getpid()); char *str = &quot;i am parent&quot;; write(pipefd[1], str, strlen(str)); sleep(1); &#125; &#125; else if(pid == 0)&#123; // 子进程 printf(&quot;i am child process, pid : %d\\n&quot;, getpid()); char buf[1024]; // 关闭读端 close(pipefd[0]); while(1) &#123; char *str = &quot;hello,i am child&quot;; write(pipefd[1], str, strlen(str)); sleep(1); // int len = read(pipefd[0], buf, sizeof(buf)); // printf(&quot;pa child recv : %s, pid : %d\\n&quot;, buf, getpid()); // bsize(buf, 1024); &#125; &#125; return 0;&#125; 查看管道大小 ulimit -a 1234567891011121314151617181920212223/************************************************************************* &gt; File Name: fpathconfig.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月19日 星期二 19时05分50秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main() &#123; int pipefd[2]; int ret = pipe(pipefd); // 获取管道的大小 可以查看man手册来查看宏值 long size = fpathconf(pipefd[0], _PC_PIPE_BUF); printf(&quot;pipe size : %ld&quot;, size); return 0;&#125; 匿名管道 - 案例ls | wc -l - ps aux | grep 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/************************************************************************* &gt; File Name: parent-child-ipc.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月20日 星期三 09时21分59秒 ************************************************************************//* * 实现 ps aux | grep xxx 父子进程通信 * 子进程: ps aux, 子进程结束后, 将数据发送给父进程 * 父进程: 获取到数据, 过滤 * * pipe() * execlp() -&gt; ps aux 会输出到终端 * 子进程将标准输出 stdout_fileno 重定向管道的写端 dup2 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main() &#123; // 创建一个管道 int fd[2]; int ret = pipe(fd); if(ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 // 关闭写端 close(fd[1]); // 从管道中读取数据 char buf[1024]; int len = -1; while((len = read(fd[0], buf, sizeof(buf) - 1)) &gt; 0) &#123; // 因为每次最多只能读取 1024 所以需要循环 // 过滤数据 printf(&quot;%s&quot;, buf); memset(buf, 0, sizeof(buf)); &#125; wait(NULL); &#125; else if(pid == 0) &#123; // 子进程 // 关闭读端 close(fd[0]); // 文件描述符的重定向 stdout_fileno -&gt; fd[1]; // 执行 ps aux dup2(fd[1], STDOUT_FILENO); execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL); perror(&quot;execlp&quot;); exit(0); &#125; else &#123; perror(&quot;fork&quot;); exit(0); &#125; return 0;&#125; 管道的读写特点使用管道时候，需要注意以下几种特殊的情况（假设都是I/O操作） 所有的指向管道写端文件描述符都关闭了 (管道写端引用计数为0)，进程从管道的读端读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样 如果有指向管道的写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，再次read会阻塞，值到管道中有数据可以读了才读取数据并返回。 如果所有指向管道的读端的文件描述符都关闭了（管道的读端引用计数为0）这个时候有进程向管道中写数据，那么该进程会收到一个信号SIGPIPE(管道破裂),通常会导致进程异常终止 如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0）而持有管道读端的进程也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候在次调用write时候就会被阻塞直到管道中有空位置猜能再次写入数据并返回 总结： ​ 读管道： ​ 管道中有数据，red返回实际读到的字节数 ​ 管道中无数据： ​ 写端被全包关闭，read返回0（相当于读到文件末尾） ​ 写端没有完全关闭，read阻塞等待 ​ 写管道： ​ 管道读端全部都关闭，进程异常终止（进程SIGPIPE信号） ​ 管道读端没有完全关闭： ​ 管道已满：writ阻塞 ​ 管道没满：wirt将数据写入，并返回实际写入的字节数。 管道 读非阻塞状态123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/************************************************************************* &gt; File Name: pipe.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月18日 星期一 19时08分03秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;/* * 设置管道非阻塞 * int flags = fcntl(fd[0], F_GETFL); // 获取原来的flags * flags |= O_NONBLOCK; // 修改flags * fcntl(fd[0], F_SETFL, flags); // 设置新的flgas * */// man 2 fcntl // 快捷键 shift + kint main() &#123; // 再 fork 之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 // 关闭写 close(pipefd[1]); // 从管道的读取端读取数据 printf(&quot;i am parent process, pid : %d\\n&quot;, getpid()); char buf[1024] = &#123;0&#125;; int flags = fcntl(pipefd[0], F_GETFL); flags |= O_NONBLOCK; fcntl(pipefd[0], F_SETFL, flags); while(1) &#123; int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;parent revc : %s, pid : %d\\n&quot;, buf, getpid()); printf(&quot;len : %d\\n&quot;, len); memset(buf, 0 ,sizeof(buf)); sleep(2); &#125; &#125; else if(pid == 0)&#123; // 关闭管道读 close(pipefd[0]); // 子进程 printf(&quot;i am child process, pid : %d\\n&quot;, getpid()); char buf[1024]; while(1) &#123; char *str = &quot;hello,i am child&quot;; write(pipefd[1], str, strlen(str)); sleep(5); &#125; &#125; return 0;&#125; 有名管道匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)，也叫命名管道、FIFO文件。 有名管道(FIFO)不同于匿名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO相互通信，因此，通过FIFO不相关的进程也能交换数据。 一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I&#x2F;O系统调用了(如read ( ) 、 write ()和close())。与管道一样, FIFO也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO的名称也由此而来:先入先出。 有名管道(FIFO)和匿名管道 (pipe)有一些特点是相同的，不一样的地方在于: 有名管道（FIFO）和匿名管道（pipe）有一些特点是相同的，不一样的地方在于： FIFO在文件系统中作为一个特殊文件存在，但 FIFO中的内容却存放在内存中。 当使用FIFO的进程退出后，FIFo文件将继续保存在文件系统中以便以后使用。 FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。 有名管道的使用通过命令创建有名管道 mkfifo 名字 文件类型 p 就是一个管道文件 通过函数创建有名管道 123#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;int mkfifo(const char *pathname, mode_t mode); 一旦使用mkfifo创建了一个FIFO就可以使用open打开它，常见的文件I&#x2F;O函数都可以用于fifo。如：close、read、write、unlink等 FIFO严格遵循先进先出（First in First out）, 对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。他们不支持诸如lseek()等文件定位操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/************************************************************************* &gt; File Name: mkfifo.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月24日 星期日 19时24分40秒 ************************************************************************//* * 创建fifo文件 * 1.通过命令: mkfifo 名字 * 2.通过函数: int mkfifo(const char *pathname, mode_t mode); * * #include &lt;sys/types.h&gt; * #include &lt;sys/stat.h&gt; * int mkfifo(const char *pathname, mode_t mode); * 参数: * - pathname: 管道名称的路径 * - mode: 文件的权限 和 opne 的 mode 是一样的 * 是一个八进制的数 * 返回值: * 成功返回: 0 * 失败返回: -1 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 判断文件是否存在 int ret = access(&quot;fifo1&quot;, F_OK); if(ret == -1) &#123; printf(&quot;管道不存在, 创建管道\\n&quot;); ret = mkfifo(&quot;fifo1&quot;, 0664); if(ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; return 0;&#125; 一端读、一端写write 123456789101112131415161718192021222324252627282930313233343536373839404142434445/************************************************************************* &gt; File Name: write.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月24日 星期日 20时20分58秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;// 向管道中写数据int main() &#123; int ret = access(&quot;test&quot;, F_OK); if(ret == -1) &#123; perror(&quot;管道不存在, 创建管道\\n&quot;); // 创建管道文件 ret = mkfifo(&quot;test&quot;, 0664); if(ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; // 打开管道 int fd = open(&quot;test&quot;, O_WRONLY); if(fd == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; for(int i = 0; i &lt; 100; i++) &#123; char buf[1024]; sprintf(buf, &quot;hellow, %d\\n&quot;, i); printf(&quot;write data : %s\\n&quot;, buf); write(fd, buf, strlen(buf)); sleep(1); &#125; close(fd); return 0;&#125; read 12345678910111213141516171819202122232425262728293031323334353637383940/************************************************************************* &gt; File Name: read.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月24日 星期日 20时25分41秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;// 从管道中读数据int main() &#123; // 打开管道文件 int fd = open(&quot;test&quot;, O_RDONLY); if(fd == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; // 读数据 while(1) &#123; char buf[1024] = &#123;0&#125;; int len = read(fd, buf, sizeof(buf)); // if(len == 0) &#123; printf(&quot;写端断开链接了...\\n&quot;); break; &#125; printf(&quot;recv buf : %s\\n&quot;, buf); &#125; close(fd); return 0;&#125; 有名管道的注意事项 一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道 一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道 读管道： ​ 管道中有数据，read返回实际读到的字节数 ​ 管道中无数据: ​ 管道写端被全部关闭，read返回0，（相当于读到文件末尾) ​ 写端没有全部被关闭，read阻塞等待 写管道： ​ 管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号) ​ 管道读端没有全部关闭: ​ 管道已经满了，write会阻塞 ​ 管道没有满,write将数据写入，并返回实际写入的字节数。 有名管道实现简单版聊天功能 - 一问一答 chatA12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/************************************************************************* &gt; File Name: chatA.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月26日 星期二 11时54分44秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main() &#123; // 判断有名管道1是否存在 int ret = access(&quot;fifo1&quot;, F_OK); if(ret == -1) &#123; // 文件不存 printf(&quot;管道文件不存在, 创建对应的有名管道\\n&quot;); // 文件路径 ret = mkfifo(&quot;fifo1&quot;, 0664); if(ret == -1) &#123; perror(&quot;fifo1&quot;); exit(-1); &#125; &#125; // 判断有名管道2是否存在 ret = access(&quot;fifo2&quot;, F_OK); if(ret == -1) &#123; // 文件不存 printf(&quot;管道文件不存在, 创建对应的有名管道\\n&quot;); // 文件路径 ret = mkfifo(&quot;fifo2&quot;, 0664); if(ret == -1) &#123; perror(&quot;fifo2&quot;); exit(-1); &#125; &#125; // 以只写方式打开管道fifo1 --- 1 int fdw = open(&quot;fifo1&quot;, O_WRONLY); if(fdw == -1) &#123; perror(&quot;open - fifo1&quot;); exit(-1); &#125; printf(&quot;打开fifo1成功！等待写入... ...\\n&quot;); // 以只读方式打开管道fifo2 --- 2 int fdr = open(&quot;fifo2&quot;, O_RDONLY); if(fdr == -1) &#123; perror(&quot;open - fifo2&quot;); exit(-1); &#125; printf(&quot;打开fifo2成功！等待读取... ...\\n&quot;); char buf[128]; // 循环写读数据 while(1) &#123; memset(buf, 0, sizeof(buf)); // 获取标准输入(stdin)的数据 fgets(buf, sizeof(buf), stdin); // 写数据 ret = write(fdw, buf, sizeof(buf)); if(ret == -1) &#123; perror(&quot;writ&quot;); exit(-1); &#125; // 读管道数据 memset(buf, 0, sizeof(buf)); ret = read(fdr, buf, sizeof(buf)); if(ret &lt;= 0) &#123; perror(&quot;read&quot;); break; &#125; printf(&quot; buf : %s\\n&quot;, buf); &#125; // 关闭文件描述符 close(fdr); close(fdw); return 0;&#125; chatB1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/************************************************************************* &gt; File Name: chatA.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月26日 星期二 11时54分44秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main() &#123; // 判断有名管道1是否存在 int ret = access(&quot;fifo1&quot;, F_OK); if(ret == -1) &#123; // 文件不存 printf(&quot;管道文件不存在, 创建对应的有名管道\\n&quot;); // 文件路径 ret = mkfifo(&quot;fifo1&quot;, 0664); if(ret == -1) &#123; perror(&quot;fifo1&quot;); exit(-1); &#125; &#125; // 判断有名管道2是否存在 ret = access(&quot;fifo2&quot;, F_OK); if(ret == -1) &#123; // 文件不存 printf(&quot;管道文件不存在, 创建对应的有名管道\\n&quot;); // 文件路径 ret = mkfifo(&quot;fifo2&quot;, 0664); if(ret == -1) &#123; perror(&quot;fifo2&quot;); exit(-1); &#125; &#125; // 以只读方式打开管道fifo1 --- 1 int fdr = open(&quot;fifo1&quot;, O_RDONLY); if(fdr == -1) &#123; perror(&quot;open - fifo1&quot;); exit(-1); &#125; printf(&quot;打开fifo1成功！等待读取... ...\\n&quot;); // 以只写方式打开管道fifo2 --- 2 int fdw = open(&quot;fifo2&quot;, O_WRONLY); if(fdw == -1) &#123; perror(&quot;open - fifo2&quot;); exit(-1); &#125; printf(&quot;打开fifo2成功！等待写入... ...\\n&quot;); char buf[128]; // 循环读写数据 while(1) &#123; // 读管道数据 memset(buf, 0, sizeof(buf)); ret = read(fdr, buf, sizeof(buf)); if(ret &lt;= 0) &#123; perror(&quot;read&quot;); break; &#125; printf(&quot; buf : %s\\n&quot;, buf); memset(buf, 0, sizeof(buf)); // 获取标准输入(stdin)的数据 fgets(buf, sizeof(buf), stdin); // 写数据 ret = write(fdw, buf, strlen(buf)); if(ret == -1) &#123; perror(&quot;writ&quot;); exit(-1); &#125; &#125; // 关闭文件描述符 close(fdr); close(fdw); return 0;&#125; 问！如何实现一方多次发送消息！怎么实现？可以fork创建子进程一起跑 - 有时间我一定代码实现测试一下 代码如下 A - B 无限通信 嗷嗷叫！chatA 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/************************************************************************* &gt; File Name: chatA.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月30日 星期六 19时58分44秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main() &#123; // 判断管道是否存在 - FIFO int ret = access(&quot;fifo1&quot;, F_OK); if(ret == -1) &#123; printf(&quot;FIFO1 文件不存在, 正在创建 ... ... \\n&quot;); ret = mkfifo(&quot;fifo1&quot;, 0664); if(ret == -1) &#123; perror(&quot;mkfifo1&quot;); exit(-1); &#125; &#125; ret = access(&quot;fifo2&quot;, F_OK); if(ret == -1) &#123; printf(&quot;FIFO2 文件不存在, 正在创建 ... ... \\n&quot;); ret = mkfifo(&quot;fifo2&quot;, 0664); if(ret == -1) &#123; perror(&quot;mkfifo2&quot;); exit(-1); &#125; &#125; // 以只写方式打开 FIFO1 int fdw = open(&quot;fifo1&quot;, O_WRONLY); if(fdw == -1) &#123; perror(&quot;open-FIFO1&quot;); exit(-1); &#125; printf(&quot;打开 FIFO1 成功! 等待写入....\\n&quot;); int fdr = open(&quot;fifo2&quot;, O_RDONLY); if(fdr == -1) &#123; perror(&quot;open-FIFO2&quot;); exit(-1); &#125; printf(&quot;打开 FIFO2 成功! 等待读取....\\n&quot;); // 创建进程 pid_t pid = fork(); // char *buf = (char *)malloc(sizeof(char) * 5); char buf[1024]; if(pid &gt; 0) &#123; // 父进程 while(1) &#123; memset(buf, 0, sizeof(buf)); // 获取标准输入(stdin)的数据 fgets(buf, sizeof(buf), stdin); ret = write(fdw, buf, sizeof(buf)); if(ret == -1) &#123; perror(&quot;writ&quot;); exit(-1); &#125; &#125; &#125; else if(pid == 0) &#123; // 创建子进程 while(1) &#123; memset(buf, 0, sizeof(buf)); ret = read(fdr, buf, sizeof(buf)); if(ret &lt;= 0) &#123; perror(&quot;read&quot;); exit(-1); break; &#125; printf(&quot;buf : %s\\n&quot;, buf); &#125; &#125; // 关闭文件描述符 close(fdw); close(fdr); // free(buf); return 0;&#125; chatB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/************************************************************************* &gt; File Name: chatA.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月30日 星期六 19时58分44秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main() &#123; // 判断管道是否存在 - FIFO int ret = access(&quot;fifo1&quot;, F_OK); if(ret == -1) &#123; printf(&quot;FIFO1 文件不存在, 正在创建 ... ... \\n&quot;); ret = mkfifo(&quot;fifo1&quot;, 0664); if(ret == -1) &#123; perror(&quot;mkfifo1&quot;); exit(-1); &#125; &#125; ret = access(&quot;fifo2&quot;, F_OK); if(ret == -1) &#123; printf(&quot;FIFO2 文件不存在, 正在创建 ... ... \\n&quot;); ret = mkfifo(&quot;fifo2&quot;, 0664); if(ret == -1) &#123; perror(&quot;mkfifo2&quot;); exit(-1); &#125; &#125; // 以只读方式打开 FIFO1 int fdr = open(&quot;fifo1&quot;, O_RDONLY); if(fdr == -1) &#123; perror(&quot;open-FIFO1&quot;); exit(-1); &#125; printf(&quot;打开 FIFO1 成功! 等待读取....\\n&quot;); int fdw = open(&quot;fifo2&quot;, O_WRONLY); if(fdw == -1) &#123; perror(&quot;open-FIFO2&quot;); exit(-1); &#125; printf(&quot;打开 FIFO2 成功! 等待写入....\\n&quot;); // 创建进程 pid_t pid = fork(); // char *buf = (char *)malloc(sizeof(char) * 1024); char buf[1024]; if(pid &gt; 0) &#123; // 父进程 while(1) &#123; memset(buf, 0, sizeof(buf)); ret = read(fdr, buf, sizeof(buf)); if(ret &lt;= 0) &#123; perror(&quot;read&quot;); // exit(-1); break; &#125; printf(&quot;buf : %s\\n&quot;, buf); &#125; &#125; else if(pid == 0) &#123; // 创建子进程 while(1) &#123; memset(buf, 0, sizeof(buf)); // 获取标准输入(stdin)的数据 fgets(buf, sizeof(buf), stdin); ret = write(fdw, buf, sizeof(buf)); if(ret == -1) &#123; perror(&quot;writ&quot;); exit(-1); &#125; &#125; &#125; // 关闭文件描述符 close(fdr); close(fdw); return 0;&#125;","categories":[{"name":"Linux多进程开发","slug":"Linux多进程开发","permalink":"https://tutouwang.vercel.app/categories/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"wait-waitpid 函数","slug":"Linux多进程开发/wait函数","date":"2022-04-11T07:49:11.000Z","updated":"2022-05-29T08:00:13.487Z","comments":true,"path":"2022/04/11/Linux多进程开发/wait函数/","link":"","permalink":"https://tutouwang.vercel.app/2022/04/11/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/wait%E5%87%BD%E6%95%B0/","excerpt":"","text":"wait - 回收子进程资源123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/************************************************************************* &gt; File Name: wait.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月12日 星期二 19时01分25秒 ************************************************************************//* * #include &lt;sys/types.h&gt; * #include &lt;sys/wait.ch&gt; * pid_t wait(int *wstatus); * 功能: 等待任意一个子进程结束, 如果任意一个子进程结束了,此函数会回收子进程的资源 * 参数: int *wstatus * 进程退出时的状态信息,传入的是一个int类型的地址, 传出参数 * 返回值: * - 成功: 返回被回收的子进程的ID * - 失败: -1 (所有的子进程都结束了, 调用函数失败) * 调用wait函数的进程会被挂起(阻塞),直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒(相当于继续执行) * 如果没有子进程了,函数立刻返回,返回-1:如果子进程都已经结束了,也会立即返回-1 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 有一个父进程,创建5个子进程(兄弟) pid_t pid; for(int i = 0; i &lt; 5; i++) &#123; pid = fork(); if(pid == 0) &#123; // 干掉子进程 break; &#125; &#125; if(pid &gt; 0) &#123; // 父进程 while(1) &#123; printf(&quot;i am parent, pid = %d\\n&quot;, getpid()); sleep(1); &#125; &#125; else if(pid == 0) &#123; // 子进程 printf(&quot;child, pid = %d\\n&quot;, getpid()); &#125; return 0;&#125; 5次子进程结束后父进程一直再执行就会出现在5个孤儿进程 结束掉父进程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/************************************************************************* &gt; File Name: wait.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月12日 星期二 19时01分25秒 ************************************************************************//* * #include &lt;sys/types.h&gt; * #include &lt;sys/wait.ch&gt; * pid_t wait(int *wstatus); * 功能: 等待任意一个子进程结束, 如果任意一个子进程结束了,此函数会回收子进程的资 源 * 参数: int *wstatus * 进程退出时的状态信息,传入的是一个int类型的地址, 传出参数 * 返回值: * - 成功: 返回被回收的子进程的ID * - 失败: -1 (所有的子进程都结束了, 调用函数失败) * 调用wait函数的进程会被挂起(阻塞),直到它的一个子进程退出或者收到一个不能被忽略 的信号时才被唤醒(相当于继续执行) * 如果没有子进程了,函数立刻返回,返回-1:如果子进程都已经结束了,也会立即返回-1 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 有一个父进程,创建5个子进程(兄弟) pid_t pid; for(int i = 0; i &lt; 5; i++) &#123; pid = fork(); if(pid == 0) &#123; // 干掉子进程 break; &#125; &#125; if(pid &gt; 0) &#123; // 父进程 while(1) &#123; printf(&quot;i am parent, pid = %d\\n&quot;, getpid()); int ret = wait(NULL); if(ret == -1) &#123; break; &#125; printf(&quot;child die, pid = %d\\n&quot;, ret); sleep(1); &#125; &#125; else if(pid == 0) &#123; // 子进程 printf(&quot;child, pid = %d\\n&quot;, getpid()); sleep(1); &#125; return 0;&#125; 退出信息相关宏函数 正常运行结束代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/************************************************************************* &gt; File Name: wait.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月12日 星期二 19时01分25秒 ************************************************************************//* * #include &lt;sys/types.h&gt; * #include &lt;sys/wait.ch&gt; * pid_t wait(int *wstatus); * 功能: 等待任意一个子进程结束, 如果任意一个子进程结束了,此函数会回收子进程的资 源 * 参数: int *wstatus * 进程退出时的状态信息,传入的是一个int类型的地址, 传出参数 * 返回值: * - 成功: 返回被回收的子进程的ID * - 失败: -1 (所有的子进程都结束了, 调用函数失败) * 调用wait函数的进程会被挂起(阻塞),直到它的一个子进程退出或者收到一个不能被忽略 的信号时才被唤醒(相当于继续执行) * 如果没有子进程了,函数立刻返回,返回-1:如果子进程都已经结束了,也会立即返回-1 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 有一个父进程,创建5个子进程(兄弟) pid_t pid; for(int i = 0; i &lt; 5; i++) &#123; pid = fork(); if(pid == 0) &#123; // 干掉子进程 break; &#125; &#125; if(pid &gt; 0) &#123; // 父进程 while(1) &#123; printf(&quot;i am parent, pid = %d\\n&quot;, getpid()); //int ret = wait(NULL); int st; int ret = wait(&amp;st); if(ret == -1) &#123; break; &#125; if(WIFEXITED(st)) &#123; // 是不是正常退出 printf(&quot;退出的状态码 : %d\\n&quot;, WEXITSTATUS(st)); &#125; if(WIFSIGNALED(st)) &#123; // 是不是异常终止 printf(&quot;被那个信号干掉了: %d\\n&quot;, WTERMSIG(st)); &#125; printf(&quot;child die, pid = %d\\n&quot;, ret); sleep(1); &#125; &#125; else if(pid == 0) &#123; // 子进程 printf(&quot;child, pid = %d\\n&quot;, getpid()); sleep(1); exit(0); &#125; return 0; // exit(0)&#125; 信号干掉代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/************************************************************************* &gt; File Name: wait.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月12日 星期二 19时01分25秒 ************************************************************************//* * #include &lt;sys/types.h&gt; * #include &lt;sys/wait.ch&gt; * pid_t wait(int *wstatus); * 功能: 等待任意一个子进程结束, 如果任意一个子进程结束了,此函数会回收子进程的资 源 * 参数: int *wstatus * 进程退出时的状态信息,传入的是一个int类型的地址, 传出参数 * 返回值: * - 成功: 返回被回收的子进程的ID * - 失败: -1 (所有的子进程都结束了, 调用函数失败) * 调用wait函数的进程会被挂起(阻塞),直到它的一个子进程退出或者收到一个不能被忽略 的信号时才被唤醒(相当于继续执行) * 如果没有子进程了,函数立刻返回,返回-1:如果子进程都已经结束了,也会立即返回-1 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 有一个父进程,创建5个子进程(兄弟) pid_t pid; for(int i = 0; i &lt; 5; i++) &#123; pid = fork(); if(pid == 0) &#123; // 干掉子进程 break; &#125; &#125; if(pid &gt; 0) &#123; // 父进程 while(1) &#123; printf(&quot;i am parent, pid = %d\\n&quot;, getpid()); //int ret = wait(NULL); int st; int ret = wait(&amp;st); if(ret == -1) &#123; break; &#125; if(WIFEXITED(st)) &#123; // 是不是正常退出 printf(&quot;退出的状态码 : %d\\n&quot;, WEXITSTATUS(st)); &#125; if(WIFSIGNALED(st)) &#123; // 是不是异常终止 printf(&quot;被那个信号干掉了: %d\\n&quot;, WTERMSIG(st)); &#125; printf(&quot;child die, pid = %d\\n&quot;, ret); sleep(1); &#125; &#125; else if(pid == 0) &#123; // 子进程 while(1) &#123; printf(&quot;child, pid = %d\\n&quot;, getpid()); sleep(1); &#125; exit(0); &#125; return 0; // exit(0)&#125; waitpid - 回收子进程资源12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/************************************************************************* &gt; File Name: wait_pid.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月15日 星期五 16时38分41秒 ************************************************************************//* * * #include &lt;sys/types.h&gt; * #include &lt;sys/wait.h&gt; * pid_t waitpid(pid_t pid, int *wstatus, int options); * 功能: 回收指定进程号的子进程,可以设置是否阻塞。 * 参数: * - pid: * PID &gt; 0 : 回收某个指定子进程的 PID * PID = 0 : 回收当前进程组的所有子进程 * 进程 A -&gt; B A -&gt; C 放到一个集合 (A - B, A - C) &lt;- D 在把D给别人就不输入当前组 释放时候就与D没有关系了。// ajx 查看组查看进程组 * PID = -1 : 回收所有的子进程 相当于 wait() (最长用) * PID &lt; -1 : 某个进程组的组id的绝对值回收指定进程组中的子进程 * - options: 设置阻塞或者非阻塞 * 0 : 阻塞 * WNOHANG : 非阻塞 * - 返回值: * &gt; 0 : 返回子进程的id * = 0 : options = WNOHANG, 表示还有子进程活着 * = -1 : 错误, 或者没有子进程了 * * */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 有一个父进程, 创建5个子进程 pid_t pid; // 创建5个子进程 for(int i = 0; i &lt; 5; i++) &#123; pid = fork(); if(pid == 0) break; &#125; if(pid &gt; 0) &#123; while(1) &#123; printf(&quot;parent, pid = %d\\n&quot;, getpid()); sleep(1); int st; // int ret = waitpid(-1, &amp;st, 0); // 阻塞 int ret = waitpid(-1, &amp;st, WNOHANG); if(ret == - 1) break; // 还有子进程存在 else if(ret == 0) &#123; continue; &#125; else if(ret &gt; 0) &#123; if(WIFEXITED(st)) &#123; // 是不是正常退出 printf(&quot;退出的状态码 : %d\\n&quot;, WEXITSTATUS(st)); &#125; if(WIFSIGNALED(st)) &#123; // 是不是异常终止 printf(&quot;被那个信号干掉了 : %d\\n&quot;,WTERMSIG(st)); &#125; printf(&quot;child die, pid = %d\\n&quot;, ret); &#125; sleep(1); &#125; &#125; else if(pid == 0) &#123; while(1) &#123; printf(&quot;child , pid = %d\\n&quot;, getpid()); sleep(1); &#125; exit(0); &#125; return 0;&#125;","categories":[{"name":"Linux多进程开发","slug":"Linux多进程开发","permalink":"https://tutouwang.vercel.app/categories/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"进程控制","slug":"Linux多进程开发/进程控制","date":"2022-04-10T10:45:44.000Z","updated":"2022-05-29T08:00:26.487Z","comments":true,"path":"2022/04/10/Linux多进程开发/进程控制/","link":"","permalink":"https://tutouwang.vercel.app/2022/04/10/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"","text":"进程退出12345#include &lt;stdlib.h&gt;void exit(int status);#include &lt;unistd.h&gt;void _exit(int status); 12345678910111213141516171819202122232425262728293031323334/************************************************************************* &gt; File Name: exit.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月10日 星期日 19时08分41秒 ************************************************************************//* #include &lt;stdlib.h&gt; void exit(int status); #include &lt;unistd.h&gt; void _exit(int status); 父进程回收子进程时候会用到! status参数: 是进程退时的一个状态信息。父进程回收子进程资源时候可以h 获取到。*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main() &#123; printf(&quot;hello\\n&quot;); printf(&quot;world&quot;); //exit(0); // 输出 hello world --- \\n 会刷新缓冲区 吧缓冲区 world 输出到控制台 _exit(0); // 输出 hello return 0;&#125; 孤儿进程父进程运行结束，但子进程还在运行(未运行结束)，这样的子进程就称为孤儿进程(Orphan Process). 每当出现一个孤儿进程时候,内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()(进程资源释放)它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作 因此孤儿进程并不会有什么危害。 对比代码12345678910111213141516171819202122232425262728293031/************************************************************************* &gt; File Name: fork_exit.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月10日 星期日 21时12分28秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main() &#123; pid_t pid = fork(); // 判断是父进程 if(pid &gt; 0) &#123; printf(&quot;i am parent process, pid : %d, ppid : %d\\n&quot;, getpid(), getppid()); &#125; else if(pid == 0) &#123; printf(&quot;i am child process, pid : %d, ppid : %d\\n&quot;, getpid(), getppid()); sleep(1); &#125; for(int i = 0; i &lt; 3; i++) &#123; printf(&quot;i : %d, pid : %d\\n&quot;, i, getpid()); &#125; return 0;&#125; 注意 pid、ppid 变化 12345678910111213141516171819202122232425262728293031/************************************************************************* &gt; File Name: fork_exit.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月10日 星期日 21时12分28秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main() &#123; pid_t pid = fork(); // 判断是父进程 if(pid &gt; 0) &#123; printf(&quot;i am parent process, pid : %d, ppid : %d\\n&quot;, getpid(), getppid()); &#125; else if(pid == 0) &#123; sleep(1); printf(&quot;i am child process, pid : %d, ppid : %d\\n&quot;, getpid(), getppid()); &#125; for(int i = 0; i &lt; 3; i++) &#123; printf(&quot;i : %d, pid : %d\\n&quot;, i, getpid()); &#125; return 0; 僵尸进程每个进程结束之后，都会释放自己地址空间中的用户区数据，内核区的 PCB没有办法自己释放掉，需要父进程去释放。 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸( zombie)进程。 僵尸进程不能被kill -9杀死。 这样就会导致一个问题，如果父进程不调用wait()或waitpid()的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的， 如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。 123456789101112131415161718192021222324252627282930313233/************************************************************************* &gt; File Name: zombie.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月10日 星期日 21时12分28秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main() &#123; pid_t pid = fork(); // 判断是父进程 if(pid &gt; 0) &#123; while(1) &#123; printf(&quot;i am parent process, pid : %d, ppid : %d\\n&quot;, getpid(), getppid()); sleep(1); &#125; &#125; else if(pid == 0) &#123; printf(&quot;i am child process, pid : %d, ppid : %d\\n&quot;, getpid(), getppid()); &#125; for(int i = 0; i &lt; 3; i++) &#123; printf(&quot;i : %d, pid : %d\\n&quot;, i, getpid()); &#125; return 0;&#125; 新打开一个窗口 ps aux 查看进程 可以试着用 kill -9 进程id (测试杀死僵尸进程) 如果父进程结束了 子进程就会被进程为 1 的接替 进程回收在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息(包括进程号、退出状态、运行时间等)。 父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。 wait()和waitpid()函数的功能一样，区别在于, wait()函数会阻塞，waitpid ()可以设置不阻塞, waitpid()还可以指定等待哪个子进程结束。 注意:一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。","categories":[{"name":"Linux多进程开发","slug":"Linux多进程开发","permalink":"https://tutouwang.vercel.app/categories/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://tutouwang.vercel.app/tags/Linux/"}]},{"title":"exec函数族","slug":"Linux多进程开发/exec函数族","date":"2022-04-08T10:26:59.000Z","updated":"2022-05-29T08:00:03.580Z","comments":true,"path":"2022/04/08/Linux多进程开发/exec函数族/","link":"","permalink":"https://tutouwang.vercel.app/2022/04/08/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/exec%E5%87%BD%E6%95%B0%E6%97%8F/","excerpt":"","text":"函数族族 ： 一族就是一系列函数 相同或者相似的 如oop 函数重载 名字不同 但是实现的功能相似的 exec函数族介绍exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。 exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代．只留下进程ID 等一些表面上的信息仍保持原样，颇有些神似”三十六计”中的”金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。 exec函数族作用图解替换 最后一条才是Linux函数库的 其他都是标准c库的 execl1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/************************************************************************* &gt; File Name: execl.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月10日 星期日 11时37分27秒 ************************************************************************//* #include &lt;unistd.h&gt; * int execl(const char *path, const char *arg, ...); * - 参数: * - path: 需要指定的执行的文件的路径或者名称 * a.out /test/高并发/Linux多线程/exec函数族/execl.aout * 建议写绝对路径 * ./a.out hello world * - arg: 是执行可执行文件所需要的参数列表 * 第一个参数一般没有什么作用, 为了方便, 一般可写的是执行的程序名称 * 从二个参数开始往后, 就是程序执行的所需要的参数列表 * 参数最后要以NULL结束(哨兵) * - 返回值: * 只有调用失败, 才会返回值, 返回-1, 并设置errno * 如果调用成功没有返回值！ * */#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 创建一个子进程, 在子进程中执行exec函数族中的函数 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 printf(&quot;i am paren peocess, pid : %d\\n&quot;, getpid()); sleep(1); &#125; else if(pid == 0) &#123; // 子进程 // 自己的可执行程序 --- 参数 可执行文件 // execl(&quot;test&quot;, &quot;test&quot;, NULL); // which ps --- /usr/bin/ps // or // execl(&quot;/usr/bin/ps&quot;, &quot;ps&quot;, &quot;a&quot;,&quot;u&quot;,&quot;x&quot;, NULL); execl(&quot;/usr/bin/ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL); printf(&quot;i am child proess pid = %d\\n&quot;, getpid()); &#125; for(int i = 0; i &lt; 3; i++) &#123; printf(&quot; i = %d, pid = %d\\n&quot;, i, getpid()); &#125; return 0;&#125; execlpenv // 环境变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/************************************************************************* &gt; File Name: execl.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月10日 星期日 11时37分27秒 ************************************************************************//* #include &lt;unistd.h&gt; * int execl(const char *file, const char *arg, ...); * - 会到环境变量中查找指定的可执行文件, 如果找到了就执行, 找不到就执行不成功。 * - 参数: * - file: 需要执行的可执行文件的文件名 * - arg: 是执行可执行文件所需要的参数列表 * 第一个参数一般没有什么作用, 为了方便, 一般可写的是执行的程序名称 * 从二个参数开始往后, 就是程序执行的所需要的参数列表 * 参数最后要以NULL结束(哨兵) * - 返回值: * 只有调用失败, 才会返回值, 返回-1, 并设置errno * 如果调用成功没有返回值！ * */#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 创建一个子进程, 在子进程中执行exec函数族中的函数 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 printf(&quot;i am paren peocess, pid : %d\\n&quot;, getpid()); sleep(1); &#125; else if(pid == 0) &#123; // 子进程 // 自己的可执行程序 --- 参数 可执行文件 // execl(&quot;test&quot;, &quot;test&quot;, NULL); // which ps --- /usr/bin/ps // or // execl(&quot;/usr/bin/ps&quot;, &quot;ps&quot;, &quot;a&quot;,&quot;u&quot;,&quot;x&quot;, NULL); execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL); printf(&quot;i am child proess pid = %d\\n&quot;, getpid()); &#125; for(int i = 0; i &lt; 3; i++) &#123; printf(&quot; i = %d, pid = %d\\n&quot;, i, getpid()); &#125; return 0;&#125; execv1234567/* int execv(const char *path, char *const argv[]);* - argv: 是需要的参数的一个字符串数组** // 使用 execv* char *argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;* execv(&quot;/usr/bin/ps&quot;, argv);*/ execve123456/* * int execve(const char *filename, char *const argv[], char *const envp[]); * 先从指定环境变量中 查找 如果第一个查找不到就到第二个中查找 ... * char *envp[] = &#123;&quot;/usr/bin&quot;, &quot;/usr/bin/test&quot;, &quot;xxxxx&quot;&#125;; */","categories":[{"name":"Linux多进程开发","slug":"Linux多进程开发","permalink":"https://tutouwang.vercel.app/categories/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"[object Object]","slug":"object-Object","permalink":"https://tutouwang.vercel.app/tags/object-Object/"}]},{"title":"STL-Sort解析","slug":"OOP/手动实现Sort","date":"2022-04-08T09:13:49.000Z","updated":"2022-04-08T10:07:10.259Z","comments":true,"path":"2022/04/08/OOP/手动实现Sort/","link":"","permalink":"https://tutouwang.vercel.app/2022/04/08/OOP/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0Sort/","excerpt":"","text":"STL_sort 模板解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428/************************************************************************* &gt; File Name: Sort.cpp &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2021年11月10日 星期三 20时30分05秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;time.h&gt;#include &lt;functional&gt;using namespace std;// MAX_N == 存放数组大小，n == 循环右边边界const int MAX_N = 100, n = 20;#define BEGINS(x) namespace x &#123;#define ENDS(x) &#125; // end of namespace x// 初始化_BEGINESvoid init(int *f) &#123; for(int i = 0; i &lt; n; i++) *(f + i) = rand() % 10; return ;&#125;void output(int *first, int *last, const char *msg) &#123; cout &lt;&lt; msg; while(first != last) &#123; cout &lt;&lt; *first &lt;&lt; &quot; &quot;; ++first; &#125; cout &lt;&lt; endl; return ;&#125;// 初始化_ENDS// STL_自带sort_使用BEGINS(test1)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test1)// 手动实现sort firstEditionBEGINS(test2)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;void sort(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; if(first &gt;= last) return ; int *x = first, *y = last - 1, z = *first; while(x &lt; y) &#123; // while(x &lt; y &amp;&amp; *y &gt;= z) y--; while(x &lt; y &amp;&amp; cmp(z, *y)) y--; if(x &lt; y) *(x++) = *y; // while(x &lt; y &amp;&amp; *x &lt;= z) x++; while(x &lt; y &amp;&amp; cmp(*x, z)) x++; if(x &lt; y) *(y--) = *x; &#125; *x = z; sort(first, x, cmp); sort(x + 1, last, cmp); return ;&#125;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test2)// 手动实现sort secondEdition 单边递归法BEGINS(test3)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;void sort(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; if(first &gt;= last) return ; while(first &lt; last) &#123; int *x = first, *y = last - 1, z = *first; while(x &lt; y) &#123; while(x &lt; y &amp;&amp; cmp(z, *y)) y--; if(x &lt; y) *(x++) = *y; while(x &lt; y &amp;&amp; cmp(*x, z)) x++; if(x &lt; y) *(y--) = *x; &#125; *x = z; sort(first, x, cmp); first = x + 1; &#125; return ;&#125;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test3)// 手动实现sort secondEdition 单边递归法_无监督BEGINS(test4)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;void sort(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; while(first &lt; last) &#123; int *x = first, *y = last - 1, z = *first; do &#123; while(cmp(*x, z)) x++; while(cmp(z, *y)) y--; if(x &lt;= y) &#123; swap(*x, *y); x++, y--; &#125; &#125; while(x &lt;= y); sort(x, last, cmp); last = y + 1; &#125; return ;&#125;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test4)// 手动实现sort secondEdition 单边递归法_无监督_插入排序BEGINS(test5)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;const int threshold = 16;void intro_loop(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; while(last - first &gt; threshold) &#123; int *x = first, *y = last - 1, z = *first; do &#123; while(cmp(*x, z)) x++; while(cmp(z, *y)) y--; if(x &lt;= y) &#123; swap(*x, *y); x++, y--; &#125; &#125; while(x &lt;= y); sort(x, last, cmp); last = y + 1; &#125; return ;&#125;void insertion_sort(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; int *ind = first; // 找到最小值 for(int *i = first + 1; i &lt; last; ++i) &#123; if(cmp(*i, *ind)) ind = i; &#125; while(ind != first) &#123; swap(*ind, *(ind - 1)); --ind; &#125; for(int *i = first + 2; i &lt; last; ++i) &#123; int *j = i; while(cmp(*j, *(j - 1))) &#123; swap(*j, *(j - 1)); --j; &#125; &#125; return ;&#125;void sort(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; intro_loop(first, last, cmp); insertion_sort(first, last, cmp); return ;&#125;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test5)// 手动实现sort secondEdition 单边递归法_无监督_插入排序_随机迭代器(指针对象)BEGINS(test6)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;const int threshold = 16;class RandomIter&#123;public : RandomIter(int *ptr) : ptr(ptr)&#123;&#125; int &amp;operator*() &#123;return *ptr; &#125; RandomIter operator-(int x) &#123;return RandomIter(ptr - x); &#125; RandomIter operator+(int x) &#123;return RandomIter(ptr + x); &#125; int operator-(const RandomIter &amp;iter) &#123;return ptr - iter.ptr; &#125; // 前 ++ operator++() // 后 ++ operator++(int) RandomIter &amp;operator++() &#123; ++ptr; return *this; &#125;; RandomIter &amp;operator--() &#123; --ptr; return *this; &#125;; bool operator&lt;(const RandomIter &amp;iter) const &#123; return this-&gt;ptr &lt; iter.ptr; &#125; bool operator&gt;(const RandomIter &amp;iter) const &#123; return iter &lt; *this; &#125; bool operator&lt;=(const RandomIter &amp;iter) const &#123; return !(iter &lt; *this); &#125; bool operator&gt;=(const RandomIter &amp;iter) const &#123; return !(*this &lt; iter); &#125; bool operator==(const RandomIter &amp;iter) const &#123; return !(iter &lt; *this) &amp;&amp; !(*this &lt; iter); &#125; bool operator!=(const RandomIter &amp;iter) &#123; return !(iter == *this); &#125;private : int *ptr;&#125;;void intro_loop(RandomIter first, RandomIter last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; while(last - first &gt; threshold) &#123; RandomIter x = first, y = last - 1; int z = *first; do &#123; while(cmp(*x, z)) ++x; while(cmp(z, *y)) --y; if(x &lt;= y) &#123; swap(*x, *y); ++x, --y; &#125; &#125; while(x &lt;= y); intro_loop(x, last, cmp); last = y + 1; &#125; return ;&#125;void insertion_sort(RandomIter first, RandomIter last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; RandomIter ind = first; // 找到最小值 for(RandomIter i = first + 1; i &lt; last; ++i) &#123; if(cmp(*i, *ind)) ind = i; &#125; while(ind != first) &#123; swap(*ind, *(ind - 1)); --ind; &#125; for(RandomIter i = first + 2; i &lt; last; ++i) &#123; RandomIter j = i; while(cmp(*j, *(j - 1))) &#123; swap(*j, *(j - 1)); --j; &#125; &#125; return ;&#125;void sort(RandomIter first, RandomIter last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; intro_loop(first, last, cmp); insertion_sort(first, last, cmp); return ;&#125;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test6)int main() &#123; // test1::main(); // test2::main(); // test3::main(); // test4::main(); // test5::main(); test6::main(); return 0;&#125;","categories":[{"name":"c++OOP","slug":"c-OOP","permalink":"https://tutouwang.vercel.app/categories/c-OOP/"}],"tags":[]},{"title":"GDB多线程调试","slug":"Linux多进程开发/GDB多线程调试","date":"2022-04-06T09:09:41.000Z","updated":"2022-05-29T07:59:50.548Z","comments":true,"path":"2022/04/06/Linux多进程开发/GDB多线程调试/","link":"","permalink":"https://tutouwang.vercel.app/2022/04/06/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/GDB%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95/","excerpt":"","text":"GDB多进程调试使用GDB调试的时候，GDB默认只能跟踪一个进程，可以在fork函数调用之前,通过指令设置GDB调试工具跟踪父进程或者跟踪跟踪子进程，默认跟踪父进程。 设置调试父进程或者子进程： set follow-fork-mode [paren(默认) | child] 设置调试模式：set detach-on-fork [on | off] 默认 on,表示调试当前进程的时候,其他的进程继续运行, 如果为off, 调试当前进程的时候, 其他进程被GDB挂起。 查看调试的进程：info inferiors 切换当前调试的进程： inferior id 使进程脱离GDB调试：detach inferiors id 使进程移除GDB调试：remo inferiors id gdb多线程报错8.x 版本调试多进程会有一些BUG inferior 2 info inferiors &#x2F;&#x2F; 查看","categories":[{"name":"Linux多进程开发","slug":"Linux多进程开发","permalink":"https://tutouwang.vercel.app/categories/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://tutouwang.vercel.app/tags/Linux/"}]},{"title":"进程状态转换","slug":"Linux多进程开发/进程状态转换","date":"2022-04-02T11:12:47.000Z","updated":"2022-05-29T08:00:07.171Z","comments":true,"path":"2022/04/02/Linux多进程开发/进程状态转换/","link":"","permalink":"https://tutouwang.vercel.app/2022/04/02/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"进程状态转换三态模型：就绪态、运行态、阻塞态 五态模型：新建态、就绪态、运行态、阻塞态、终止态 进程的状态 查看进程 man ps ps aux &#x2F; ajx (PPID 父进程的IP、 PID 进程的ID、PGID 进程组的ID、SID 绘话) a：显示终端上的所有进程, 包括其他用户的进程 u: 显示进程的详细信息 x: 显示没有控制终端的进程 j: 列出与作业控制相关的信息 进程状态转换STAT 参数意义：​ D 不可中断 Uninterruptible（usually IO） ​ R 正在运行, 或在队列中的进程 ​ S (大写) 处于休眠状态 ​ T 停止或被追踪 ​ Z 僵尸进程 ​ W 进入内存交换 (从内核2.6开始无效) ​ X 杀掉的进程 ​ &lt; 高优先级 ​ N 底优先级 ​ s 包含子进程 ​ + 位于前台的进程组 实时显示进程状态​ top ​ 可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔，在top命令执行后，可以按下按键对显示的结果排序 按 键 M 根据内存使用量排序 P 根据 CPU 占有率排序 T 根据进程运行时间长短 U 根据用户名来筛选进程 K 输入指定的 PID 杀死进程 杀死进程 kill [-signal] pid kill -l 列出所有信号 kill -SIGKILL 进程ID kill -9 进程ID &#x2F;&#x2F; -l 信号 SIGKILL &#x2F; -9 强制杀死 Killall name 根据进程名杀死进程 进程杀死测试终端 测试 运行代码 12345678910111213141516/************************************************************************* &gt; File Name: whil_lastiung.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月03日 星期日 10时39分54秒 ************************************************************************/#include&lt;stdio.h&gt;int main() &#123; while(1) &#123; printf(&quot;秃头王\\n&quot;); sleep(1); &#125; return 1;&#125; 后台运行./a.out &amp; 进程号和相关函数 pid 进程ID ppid 父进程的ID pgpid 用组的ID 进程创建 - man 2 fork系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成讲程树结构模型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/************************************************************************* &gt; File Name: fork.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月03日 星期日 14时14分05秒 ************************************************************************//* * #include &lt;sys/types.h&gt; * #include &lt;unistd.h&gt; * * pid_t fork(void) ; * 函数的作用: 用于创建子进程 * 返回值: * fork()的返回值会返回2次 一次在父进程中、一次在子进程中。 * 在父进程中返回创建的子进程的 ID * 在子进程中返回 0 * 如何区分子进程和父进程: 通过fork的返回值 * 在父进程中返回-1, 表示创建子进程失败, 并设置errno * * 父子进程之间的关系: * 区别: * 1. fork() 函数的返回值不同 * 父进程中: &gt; 0 返回的子进程的ID * 子进程中: = 0 * 2. pcb 中的一些数据 * 当前的进程id pid * 当前的进程的父进程的id ppid * 信号集 * 共同点: * 某些状态下: 子进程中刚被创建出来, 还没有执行任何的写数据的操作 * - 用户区的数据 * - 文件描述表 * 父子进程对变量是不是共享的？ * - 刚开始时候, 是一样的共享。如果修改的数据就不共享了 * - 读时候共享(子进程被创建, 两个进程没有做任何的写的操作), 写时拷贝 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main() &#123; int num = 10; pid_t pid = fork(); if(pid &gt; 0) &#123; printf(&quot;pid : %d\\n&quot;, pid); // 如果大于0,返回的是创建的子进程的进程号, 当前父进程 printf(&quot;i am parent process, pid : %d, ppid % d\\n&quot;, getpid(), getppid()); printf(&quot;parent num : %d \\n&quot;, num); num += 10; printf(&quot;parent num += 10 : %d \\n&quot;, num); &#125; else if(pid == 0) &#123; // 当前是子进程 printf(&quot;i am child process, pid : %d, ppid : %d \\n&quot;, getpid(), getppid()); printf(&quot;child num : %d \\n&quot;, num); num += 100; printf(&quot;child num += 100 : %d \\n&quot;, num); &#125; for(int i = 0; i &lt; 3; i++) &#123; printf(&quot;i : %d, pid : %d\\n&quot;, i, getpid()); sleep(1); &#125; return 0;&#125; fork 执行流程 修改子进程后就会开辟一个新地址","categories":[{"name":"Linux多进程开发","slug":"Linux多进程开发","permalink":"https://tutouwang.vercel.app/categories/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"进程概述","slug":"Linux多进程开发/进程概述","date":"2022-04-01T14:18:54.000Z","updated":"2022-05-29T08:00:35.430Z","comments":true,"path":"2022/04/01/Linux多进程开发/进程概述/","link":"","permalink":"https://tutouwang.vercel.app/2022/04/01/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0/","excerpt":"","text":"程序和进程程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程： 二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式） 机器语言指令：对程序算法进行编码。 程序入口地址：标识程序开始执行时的起始指令位置。 数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。 符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。 共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。 其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。 进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。 可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。 单道、多道程序设计 单道程序，即在计算机内存中只允许一个的程序运行。 多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。 对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。 在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。 时间片 时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。 时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。 并行和并发 并发：有限的资源交替使用 进程控制块(PCB) 为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 task_struct 结构体。 在 &#x2F;usr&#x2F;src&#x2F;linux-headers-xxx&#x2F;include&#x2F;linux&#x2F;sched.h 文件中可以查看 struct task_struct 结构体定义。其内部成员有很多，我们只需要掌握以下部分即可： 进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数 进程的状态：有就绪、运行、挂起、停止等状态 进程切换时需要保存和恢复的一些CPU寄存器 描述虚拟地址空间的信息 描述控制终端的信息 ulimit - a 进程可用资源上限","categories":[{"name":"Linux多进程开发","slug":"Linux多进程开发","permalink":"https://tutouwang.vercel.app/categories/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://tutouwang.vercel.app/tags/Linux/"}]},{"title":"标准c库IO函数和Linux系统IO函数对比","slug":"LInux-系统编程入门/标准c库IO函数和Linux系统IO函数对比","date":"2022-03-10T11:48:40.000Z","updated":"2022-05-27T01:54:26.207Z","comments":true,"path":"2022/03/10/LInux-系统编程入门/标准c库IO函数和Linux系统IO函数对比/","link":"","permalink":"https://tutouwang.vercel.app/2022/03/10/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E6%A0%87%E5%87%86c%E5%BA%93IO%E5%87%BD%E6%95%B0%E5%92%8CLinux%E7%B3%BB%E7%BB%9FIO%E5%87%BD%E6%95%B0%E5%AF%B9%E6%AF%94/","excerpt":"","text":"标准C库IO函数 自带帮助文档 第三章 虚拟地址空间 Linux系统IO函数帮助文档 ~Linux : man 2 open停留在函数上Shif + k可进行快速跳转 123456789101112131415161718192021// 为社么定义三个头文件：不同的宏定义在两个文件里#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;// 宏 flags = 标记(只读、可读、可读可写 ...)// 打开一个已经存在的文件int open(const char *pathname, int flags); 参数: - pathname : 要打开的文件路径 - flags : 对文件的操作权限还有其的他设置 O_RDONLY (只读), O_WRONLY (只写), O_RDWR (可读可写) 这三个是互斥的 返回值：返回一个新的文件描述符，如果失败了返回 -1 ，否则返回一个整形文件描述符 errno：属于Linux系统函数库，库里的一个全局变量，记录的是最近的错误号。 #include &lt;stdio.h&gt; void perror(const char *s); 作用：打印errno对应的错误描述 参数:用户描述，比如hello,最终点输出的内容是 hello:xxx(实际的错误描述) // 创建一个新的文件int open(const char *pathname, int flags, mode_t mode); 没有创建 a.txt 代码 1234567891011121314151617181920212223242526/************************************************************************* &gt; File Name: open_test1.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月11日 星期五 22时30分53秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;int main() &#123; int fd = open(&quot;a.txt&quot;, O_RDONLY); if(fd == -1) &#123; perror(&quot;open&quot;); &#125; // 读写操作 // 关闭一个文件描述符 close(fd); return 0;&#125; 创建文件 touch a.txt 设置umask umask 022 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/************************************************************************* &gt; File Name: open_test1.c &gt; Author: &gt; Mail: &gt; Created Time: 2022年03月11日 星期五 22时30分53秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;/* * int open(const char *pathname, int flags, mode_t mode); * 参数 : * - pathname : 要创建的文件路径 * - flags : 对文件操作的权限和其他的设置 * - 必选项 : O_RDONLY, O_WDONLY, O_WEONLY 这三个互斥 * - 可选项 ：O_CREAT (文件不存在，创建新文件) * - mode : 八进制的数, 表示创建出的新的文件的操纵权限, 例如：0775 (0开头表示 八进制) * RWX(读、写、 可执行、三组 当前用户的权限、当前用户所在祖的权限、其他组) = 777 * 最终的权限是 : mode &amp; ~umask(0002) // 不同用户不一样 这个值也能 更改 * 八进制 -&gt; 二进制 * 0777 -&gt; 111 111 111 * &amp; 0775 -&gt; 111 111 101 * -------------------------- * 111 111 101 * 按位与：0和任何数都为0 * * umask : 作用就是抹去某些权限 * flags : 或的作用 * 参数是一个int类型的数据,占4个字节32位。 * 32个位，每一位就是一个标志位。 * 1 - R * 2 - W * 3 - RW * 4 - CR * */int main() &#123; // 创建一个新的文件 int fd = open(&quot;create.txt&quot;, O_RDWR | O_CREAT, 0777); if(fd == -1) &#123; perror(&quot;open&quot;); &#125; // 关闭 close(fd); return 0;&#125; 帮助文档 : man 2 copy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/************************************************************************* &gt; File Name: copyfile.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月17日 星期四 20时48分17秒 ************************************************************************/#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;/* * * #include &lt;unistd.h&gt; * ssize_t read(int fd, void *buf, size_t count); * 参数: * - fd: 文件描述符, open得到的,通过这个文件描述符操作某个文件 * - buf: 缓冲区读取数据存放的地方数组的地址 (传出参数) * - count: 指定的数组大小 * 返回值: * - 成功: * &gt; 0: 返回实际的读取到的字数 * = 0: 文件已经读取完 * - 失败: - 1, 并设置errno * #include &lt;unistd.h&gt; * ssize_t write(int fd, const void *buf, size_t count); * 参数： * - fd: 文件描述, open得到的,y通过这个 * - buf: 要往磁盘写入的数据 * - count: 要写的数据的实际大小 * 返回值: * 成功: 实际写入的大小 * 失败: 返回-1,并设置errno * */int main() &#123; // 1.通过open打开english.txt // 相对路径&quot;文件名.后缀&quot; // 绝对路径&quot;c:/xxx/xxx/文件名.后缀&quot; int srcfd = open(&quot;english.txt&quot;, O_RDONLY); if(srcfd == -1) &#123; perror(&quot;opne&quot;); return -1; &#125; // 2.创建一个新的文件(拷贝文件) int destfd = open(&quot;cpy.txt&quot;, O_WRONLY | O_CREAT, 0664); if(destfd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; // 3.频繁的读写操作 char buf[1024] = &#123;0&#125;; int len = 0; while((len = read(srcfd, buf, sizeof(buf))) &gt; 0) &#123; // destfd: 目标文件文件描述符 write(destfd, buf, len); &#125; // 4.关闭文件 close(destfd); close(srcfd) ; return 0;&#125; 帮助文档 : man 2 lseekLinux 的 lseek 在标准c库中 man 3 fseek 为什么要扩展比如说下载一个大小文件大小为5G(下载时候也正在用磁盘)假如磁盘大小么有5G(就不能正确下载下来)所以会提起占用一点点在替换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/************************************************************************* &gt; File Name: lseek.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月20日 星期日 16时40分30秒 ************************************************************************//* * 标准c库 * #inline &lt;stdio.h&gt; * int fseek(FLE *stream, long offset, int whence); * * Linux系统函数 * #include &lt;sys/types.h&gt; * #include &lt;unistd.h&gt; * oof_t lseek(int fd, oof_t offset, int whence); * 参数: * - fd: 文件描述, 通过open得到的, 通过这个fd操作某个文件 * - offset: 偏移量 * - whence: * SEEK_SET The file offset is set to offset bytes. * 设置文件指针的偏移量 * SEEK_CUR The file offset is set to its current location plus offset bytes. * 设置便宜量: 当前位置 + 第 二个参数 offset的值 * SEEK_END The file offset is set to the size of the file plus offset bytes. * 设置偏移量: 文件大小 + 第 二个参数offse的值 * 返回值: 返回文件指针的位置 * 作用: * 1.移动文件指针 * lseek(fd, 0, SEEL_SET); * * 2.获取当前文件指针位置 * lseek(fd, 0, SEEK_CUR); * * 3.可以获取文件长度 * lseek(fd, 0, SEEK_END); * * 4.拓展文件的长度,当文件10b, 110b, 增加了100个字节 * lseek(fd, 100, SEEK_END); * // 注意：需要些一次数据 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;int main() &#123; int fd = open(&quot;hello.txt&quot;, O_RDWR); if(fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; // 扩展文件的长度 int ret = lseek(fd, 100, SEEK_END); if(ret == -1) &#123; perror(&quot;open&quot;); return -1; &#125; // 写入一个空格数据 write(fd, &quot; &quot;, 1); // 关闭文件 close(fd); return 0;&#125; 帮助文档 : man 2 stat 1234567891011121314151617181920212223242526272829303132333435363738394041424344/************************************************************************* &gt; File Name: stat.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月23日 星期三 16时29分33秒 ************************************************************************//* #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;unistd.h&gt; int stat(const char *pathname, struct stat *statbuf); 作用: 获取一个文件相关的一些信息 参数; - pathname: 操作文件的路径 - statbuf: 结构体变量, 传出参数, 用于保存获取的文件信息 返回值: 成功: 返回0 失败: 返回-1, 并设置errno int fstat(int fd, struct stat *statbuf); int lstat(const char *pathname, struct stat *statbuf);*/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;int main() &#123; struct stat statbuf; int ret = stat(&quot;a.txt&quot;, &amp;statbuf); if(ret == -1) &#123; perror(&quot;stat&quot;); return -1; &#125; printf(&quot;size: %ld\\n&quot;, statbuf.st_size); return 0;&#125; 模拟实现 ls -l 命令 参考文档 man 3 getpwuid 参考文档 man 3 getgrgid 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/************************************************************************* &gt; File Name: ls-l.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月26日 星期六 15时29分49秒 -***********************************************************************/// 模拟实现 ls -l 指令// -rw-r--r-- 1 qz qz 11 3月 26 15:30 a.txt#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;pwd.h&gt;#include &lt;grp.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;int main(int argc, char* argv[]) &#123; // 判断输入的参数是否正确 if(argc &lt; 2) &#123; printf(&quot;%s filename\\n&quot;, argv[0]); return -1; &#125; // 通过stat函数获取用户传入的文件信息 struct stat st; int ret = stat(argv[1], &amp;st); if(ret == -1) &#123; perror(&quot;stat&quot;); return -1; &#125; // 获取文件类型和文件权限 char *perms = (char *)calloc(sizeof(char), 11); switch(st.st_mode &amp; S_IFMT) &#123; case S_IFLNK: perms[0] = &#x27;l&#x27;; break; case S_IFDIR: perms[0] =&#x27;d&#x27;; break; case S_IFREG: perms[0] =&#x27;-&#x27;; break; case S_IFBLK: perms[0] =&#x27;b&#x27;; break; case S_IFCHR: perms[0] =&#x27;c&#x27;; break; case S_IFSOCK: perms[0] =&#x27;s&#x27;; break; case S_IFIFO: perms[0] =&#x27;p&#x27;; break; default: perms[0] = &#x27;?&#x27;; &#125; // 判断文件的访问权限 // 文件所有者 perms[1] = (st.st_mode &amp; S_IRUSR) ? &#x27;r&#x27; : &#x27;-&#x27;; perms[2] = (st.st_mode &amp; S_IWUSR) ? &#x27;w&#x27; : &#x27;-&#x27;; perms[3] = (st.st_mode &amp; S_IXUSR) ? &#x27;x&#x27; : &#x27;-&#x27;; // 文件所有组 perms[4] = (st.st_mode &amp; S_IRGRP) ? &#x27;r&#x27; : &#x27;-&#x27;; perms[5] = (st.st_mode &amp; S_IWGRP) ? &#x27;w&#x27; : &#x27;-&#x27;; perms[6] = (st.st_mode &amp; S_IXGRP) ? &#x27;x&#x27; : &#x27;-&#x27;; // 其他人 perms[7] = (st.st_mode &amp; S_IROTH) ? &#x27;r&#x27; : &#x27;-&#x27;; perms[8] = (st.st_mode &amp; S_IWOTH) ? &#x27;w&#x27; : &#x27;-&#x27;; perms[9] = (st.st_mode &amp; S_IXOTH) ? &#x27;x&#x27; : &#x27;-&#x27;; // 硬链接数 int linkNum = st.st_nlink; // 文件所有者 char *fileUser = getpwuid(st.st_uid)-&gt;pw_name; // 文件所在组 char *fileGrp = getgrgid(st.st_gid)-&gt;gr_name; // 文件大小 long int fileSize = st.st_size; // 修改的时间 从 1970年 会自带一个换行 char *time = ctime(&amp;st.st_mtime); char mtime[512] =&#123;0&#125;; strncpy(mtime, time, strlen(time) - 1); char buf[1024]; sprintf(buf, &quot;%s %d %s %s %ld %s %s&quot;, perms, linkNum, fileUser, fileGrp, fileSize, mtime, argv[1]); printf(&quot;%s\\n&quot;, buf); return 0;&#125; 文件属性man 2 access 12345678910111213141516171819202122232425262728293031/************************************************************************* &gt; File Name: chmod.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月27日 星期日 11时21分04秒 ************************************************************************//* include &lt;sys/stat.h&gt; int chmod(const char *pathname, mode_t mode); 修改文件的权限 参数: - pathname: 需要修改的文件路径 - mode: 需要修改的权限值, 八进制的数 返回: h成功返回0, 失败返回-1*/#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;int main() &#123; int ret = chmod(&quot;a.txt&quot;, 0775); if(ret == -1) &#123; perror(&quot;chmod&quot;); return -1; &#125; return 0;&#125; man 2 truncate 1234567891011121314151617181920212223242526272829303132333435/************************************************************************* &gt; File Name: truncate.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月27日 星期日 17时35分17秒 ************************************************************************//* #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; int truncate(const char *path, off_t length); 作用: 缩减或者扩展文件的尺寸至指定的大小 参数: - path: 需要修改的文件的k路径 - length: 需要最终文件变成的大小 如果 一个文件(10K) 想变成一个(5k)就会把后面截取掉 返回: 成功0,失败-1*/#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main() &#123; int ret = truncate(&quot;b.txt&quot;, 20); // int ret = truncate(&quot;b.txt&quot;, 5); if(ret == -1) &#123; perror(&quot;truncat&quot;); return -1; &#125; return 0;&#125; 目录操作函数man 2 mkdir 1234567891011121314151617181920212223242526272829303132333435363738394041/************************************************************************* &gt; File Name: mkdir.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月28日 星期一 11时39分42秒 ************************************************************************//* include &lt;sys/stat.h&gt; #include &lt;sys/types.h&gt; int mkdir(const char *pathname, mode_t mode); 作用: 创建一个目录 参数: pathname: 创建的目录的路径 mode: 权限, 八进制 返回: 成功返回0, 失败返回-1 // 删除 int rmdir(const char *pathname); // 更名 第一个参数旧的名字 第二个参数新的名字 int rename(const char *oldpath, const char *newpath);*/#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;int main() &#123; // 0777 0是八进制 // 一定要有可执行权限 x 要不就永不了 你不信试试 int ret = mkdir(&quot;aaa&quot;, 0777); if(ret == -1) &#123; perror(&quot;mkdir&quot;); return -1; &#125; return 0;&#125; man 2 getcwd 工作路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/************************************************************************* &gt; File Name: getcwd.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月29日 星期二 09时27分16秒 ************************************************************************//* #include &lt;unistd.h&gt; int chdir(const char *path); 作用: 修改进程的工作目录 比如在/home/root 启动了一个可执程序 a.out, 进程的工作目录 参数: path: 需要修改的工作目录 #nclude &lt;unistd.h&gt; char *getcwd(char *buf, size_t size); 作用: 获取当前工作目录 参数: - buf: 存储的路径, 指向的是一个数组(传出参数) - size: 数组大小 返回值: 返回的指向的一块内存, 这个数据就是第一个参数*/#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;int main() &#123; // 获取当前工作目录 char buf[128]; getcwd(buf, sizeof(buf)); printf(&quot;当前的工作目录是 : %s\\n&quot;, buf); // 修改工作目录 下面是相对路径 不是绝对路径 int ret = chdir(&quot;../test&quot;); if(ret == -1) &#123; perror(&quot;chdir&quot;); return -1; &#125; // 创建一个新的文件 int fd = open(&quot;w.txt&quot;, O_CREAT| O_RDWR, 0664); if(fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; // 关闭文件描述符 close(fd); // 获取当前工作目录 char buf1[128]; getcwd(buf1, sizeof(buf1)); printf(&quot;当前的工作目录是 : %s\\n&quot;, buf1); return 0;&#125; man 3 opendir 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/************************************************************************* &gt; File Name: readFileNum.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月30日 星期三 10时01分49秒 ************************************************************************//* // 打开目录 #nclude &lt;sys/types.h&gt; #include &lt;dirent.h&gt; DIR *opendir(const char *name); 参数: - name: 需要打开的目录名称 返回值: DIR * 类型理解为目录流 失败返回 NULL // 读取目录中的数据 #include &lt;dirent.h&gt; struct diren *readdir(DIR *dirp); 参数: - dirp 是 opendir 返回的结果 返回值: struct dirent 代表读取到的文件的信息 读取到了末尾或者失败了, 返回NULL // 关闭目录 #include &lt;sys/types.h&gt; #include &lt;dirent.h&gt; int closedir(DIR *dirp);*/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int getFileNum(const char *path);// 读取某个目录下的普通文件的个数int main(int argc, char *argv[]) &#123; if(argc &lt; 2) &#123; printf(&quot;%s path\\n&quot;, argv[0]); return -1; &#125; int num = getFileNum(argv[1]); printf(&quot;普通文件的个数: %d \\n&quot;, num); return 0;&#125;// 用于获取目录下所有普通文件的个数int getFileNum(const char *path) &#123; // 打开目录 DIR *dir = opendir(path); if(dir == NULL) &#123; perror(&quot;opendir&quot;); exit(0); &#125; struct dirent *ptr; // 记录普通文件的个数 int total = 0; while((ptr = readdir(dir)) != NULL) &#123; // 获取名称 char *dname = ptr-&gt;d_name; // 忽略掉 .和 .. if(strcmp(dname, &quot;.&quot;) == 0 || strcmp(dname, &quot;..&quot;) == 0) continue; // 判断是否是普通文件 if(ptr-&gt;d_type == DT_DIR) &#123; // 目录, 需要继续读取这个目录 char newpath[256]; sprintf(newpath, &quot;%s%s&quot;, path, dname); total += getFileNum(newpath); &#125; if(ptr-&gt;d_type == DT_REG) &#123; // 普通文件 total++; &#125; &#125; // 关闭目录 closedir(dir); return total;&#125; dup，dup2函数man 2 dup 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/************************************************************************* &gt; File Name: dup.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月30日 星期三 16时03分03秒 ************************************************************************//* * #include &lt;unistd.h&gt; * int dup(int oldfd); * 作用: 复制一个新的文件描述符 * fd = 3, fd1 = dup(fd); * fd指向的是a.txt, fd1也是指向的a.txt * 从空闲的文件描述符表中找到一个最小的, 作为新的拷贝的文件描述 符 * * */#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;// 创建文件#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;int main() &#123; // 第一个读写 第二创建 int fd = open(&quot;a.txt&quot;, O_RDWR | O_CREAT, 0664); int fd1 = dup(fd); if(fd1 == -1) &#123; perror(&quot;dup&quot;); return -1; &#125; printf(&quot;fd : %d \\n fd1 : %d&quot;, fd, fd1); close(fd); char *str = &quot;hello, world&quot;; int ret = write(fd1, str, strlen(str)); if(ret == -1) &#123; perror(&quot;write&quot;); return -1; &#125; close(fd1); return 0;&#125; man 2 dup2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/************************************************************************* &gt; File Name: dup2.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月31日 星期四 14时25分22秒 ************************************************************************//* * #include &lt;unistd.h&gt; * int dup2(int oldfd, int newfd); * 作用: 重定向文件描述符 * oldfd 指向 a.txt, newfd 指向 b.txt * 调用函数成功后: newfd 和 b.txt 做 close(), newfd 指向了 a.txt * oldfd 必须是一个有效的文件描述符 * oldfd 和 newfd 值相同相当于什么也没做 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main() &#123; int fd = open(&quot;1.txt&quot;, O_RDWR | O_CREAT, 0664); if(fd == -1) &#123; perror(&quot;open&quot;); &#125; int fd1 = open(&quot;2.txt&quot;, O_RDWR | O_CREAT, 0664); if(fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; printf(&quot;fd : %d, fd1 : %d\\n&quot;, fd, fd1); int fd2 = dup2(fd, fd1); if(fd2 == -1) &#123; perror(&quot;dup2&quot;); return -1; &#125; // 通过fd1去写数据, 实际操作的是1.txt, 而不是2.txt char * str = &quot;hello, dup2&quot;; int len = write(fd1, str, strlen(str)); if(len == -1) &#123; perror(&quot;write&quot;); return -1; &#125; printf(&quot;fd : %d, fd1 : %d, fd2 : %d \\n&quot;, fd, fd1, fd2); close(fd); close(fd1); return 0;&#125; man 2 fucnt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/************************************************************************* &gt; File Name: fcntl.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月31日 星期四 18时55分53秒 ************************************************************************//* * #include &lt;unistd.h&gt; * #include &lt;fcntl.h&gt; * * int fcntl(int fd, int cmd, ...); * 参数: * - fd: 表示需要操作的文件描述符 * - cmd: 表示文件描述符进行如何操作 * 1. F_DUPFD: 复制文件描述符,复制的是一个参数fd,得到一个新的 * int ret = fcntl(fd, F_DUPFD); * 2. F_GETFL: 获取指定的文件描述符文件状态flag * 获取的flag和通过open函数传递的flag是一个东西 * 3. F_SETFL: 设置文件描述符文件状态falg * 必选项: O_RDONLY, O_WRODNLY, O_RDWR 不可以被修改 * 可选性: O_APPEND, O_NONBLOCK * O_APPEND: 表示追加数据 * O_NONBLOCK: 设置成非阻塞 * 阻塞和非阻塞: 指的是函数调用的行为。add() */#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main() &#123; // 1.复制文件描述符 // int fd = open(&quot;1.txt&quot;, O_RDONLY); // int ret = fcntl(fd, F_DUPFD); // 2.修改或者获取文件状态flag --- 当前文件只读 int fd = open(&quot;1.txt&quot;, O_RDWR); if(fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; // 获取文件描述符状态 int flag = fcntl(fd,F_GETFL); if(flag == -1) &#123; perror(&quot;fcntl_GET&quot;); return -1; &#125; flag |= O_APPEND; // 修改文件描述符状态的flag, 给flag加入O_APPEND这个标记 int ret = fcntl(fd, F_SETFL, flag); if(ret == -1) &#123; perror(&quot;fcntl_SET&quot;); return -1; &#125; char *str = &quot;nihao&quot;; write(fd, str, strlen(str)); close(fd); return 0;&#125;","categories":[{"name":"LInux-系统编程入门","slug":"LInux-系统编程入门","permalink":"https://tutouwang.vercel.app/categories/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"LInux","slug":"LInux","permalink":"https://tutouwang.vercel.app/tags/LInux/"}]},{"title":"Vim复制代码错位问题","slug":"复制代码错位问题","date":"2022-03-09T02:10:56.000Z","updated":"2022-03-09T06:37:32.830Z","comments":true,"path":"2022/03/09/复制代码错位问题/","link":"","permalink":"https://tutouwang.vercel.app/2022/03/09/%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E9%94%99%E4%BD%8D%E9%97%AE%E9%A2%98/","excerpt":"","text":"Vim中复制粘贴缩进错乱问题的解决方Vim中复制粘贴缩进错乱问题的解决方案 当你把这段缩进优美的代码直接ctrl+c(ctrl+shift + c)，ctrl+v到Vim的时候，就会出现如下恶心的情况 可以看到，这种直接粘贴的方式会导致代码丢失和缩进错乱等情况。 解决方案vim进入paste模式，命令如下： :set paste 进入paste模式之后，再按i进入插入模式，进行复制、粘贴就很正常了。命令模式下，输入 :set nopaste 解除paste模式。 paste模式主要帮我们做了如下事情： textwidth设置为0wrapmargin设置为0set noaiset nosisofttabstop设置为0revins重置ruler重置showmatch重置formatoptions使用空值","categories":[{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"GDB调试","slug":"LInux-系统编程入门/GDB调试","date":"2022-03-08T09:34:18.000Z","updated":"2022-05-27T01:27:02.221Z","comments":true,"path":"2022/03/08/LInux-系统编程入门/GDB调试/","link":"","permalink":"https://tutouwang.vercel.app/2022/03/08/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/GDB%E8%B0%83%E8%AF%95/","excerpt":"","text":"什么是 GDB GDB是由 GNU软件系统社区提供的调试工具，同GCC 配套组成了一套完整的开发环境，GDB是 Linux和许多类Unix系统中的标准开发环境。 一般来说，GDB主要帮助你完成下面四个方向的功能： 启动程序，可以按照自定义的要求随心所欲的运行程序 可让被调试的程序在指定的调置的断点处停住(断点可以是条件表达式) 当程序被停住时,可以检查此时程序中发生的事 可以改变程序，将一个BUG产生的影响修正从而测试其他 BUG 准备工作 通常，在为调试而编译时，我们会关掉编译器的优化选项（’-o’) ，并打开调试选项(‘-g’)。另外， ‘-Wall’在尽量不影响程序行为的情况下选项打开所有warning(警告)，也可以发现许多问题，避免一些不必要的 BUG。 gcc -g -Wall program.c -o program ‘g’ 选项的作用是在执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，可以在调试时必须保证 gdb 能找打源文件 -w 的意思是关闭编译时的警告，也就是编译后不显示任何warning，因为有时在编译之后编译器会显示一些例如数据转换之类的警告，这些警告是我们平时可以忽略的。 -Wall选项意思是编译后显示所有警告。 -W选项类似-Wall，会显示警告，但是只显示编译器认为会出现错误的警告。 在编译一些项目的时候可以-W和-Wall选项一起使用。 GDB命令-启动、退出、查看代码 启动和退出 gdb 可执行程序 quit 给程序设置参数&#x2F;获取设置参数 set args 10 20 show args GDB 使用帮助 help 查看当前文件代码 (回车继续执行上一行命令) list&#x2F;l (从默认位置显示) list&#x2F;l 行号 (从指定的行显示) list&#x2F;l 函数名 (从指定的函数显示) 查看非当前文件文件 list&#x2F;l 文件名：行号 list&#x2F;l 文件名：函数名 设置显示行数 show list&#x2F;listsize set list&#x2F;listsize 行数 gdb 调试代码12345678910111213141516171819202122232425262728293031323334353637383940/************************************************************************* &gt; File Name: gdb_test1.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月09日 星期三 10时19分28秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int test(int a) &#123; int sum = 0; for(int i = 0; i &lt; a; i++) &#123; sum += i; &#125; return sum;&#125;// ./test1 10 20 // 传递参数就会给main里面int main(int argc, char* argv[]) &#123; int a, b; printf(&quot;argc = %d\\n&quot;, argc); if(argc &lt; 3) &#123; a = 10; b = 30; &#125; else &#123; a = atoi(argv[1]); b = atoi(argv[2]); &#125; printf(&quot;a = %d, b = %d\\n&quot;, a, b); printf(&quot;a + b = %d \\n&quot;, a + b); for(int i = 0; i &lt; a; i++) &#123; printf(&quot;i = %d\\n&quot;, i); int res = test(i); printf(&quot;res value : %d \\n&quot;, res); &#125; printf(&quot;THE END !!! \\n&quot;); return 0;&#125; vim 下 set nu gcc test1.c -o test1 -g 加上调试信息 &#x2F;&#x2F; 源代码文件要要和可执行程序在一起否则 gdb 中命令不可使用 gcc test1.c -o test2 不加调试信息 可以 ll 对比一下两个文件大小 ssh命令 gdb 可执行程序(test1) 进入到gdb模式 GDB调试中设置参数 ：set args 10 20 GDB 获取设置参数 ： show args 可以看上面 点我跳转 调试多个文件1234567gcc main.c a.c b.c -o main -ggdb main&#x2F;&#x2F; 查看其中一个文件&#x2F;&#x2F; 注意不能是一个文件例如 list mian.cl a.c:1 &#x2F;&#x2F; 就会进入 a.c 的第一行 以行号为中心显示orl a.c:函数名 &#x2F;&#x2F; 就会进入 a.c 的第函数为中心显示 GDB命令-断电操作 设置断点 b&#x2F;break 行号 b&#x2F;break 函数名 b&#x2F;break 文件名：行号 b&#x2F;break 文件名: 函数 查看断点 i&#x2F;info b&#x2F;break 删除断点 d&#x2F;del&#x2F;delete 断点编号 设置断点无效 dis&#x2F;disable 断点编号 设置断点生效 ena&#x2F;enable 断电编号 设置条件断点(一般在循环的位置) b&#x2F;break 10 if i &#x3D;&#x3D; 5 断点设置 断点编号：Num 下面数字(断电编号) 设置断点无效 End &#x3D; n 正常是 y 想要断点再次生效 设置断点生效 (命令)end&#x2F;enable 断电编号 GDB命令-调试命令 运行GDB程序 start (程序停在第一行) run (遇到断点才停) 继续运行，到下一个断点停 c&#x2F;continue 向下执行一行代码 (不会进入函数体) n&#x2F;next 变量操作 p&#x2F;print 变量名 (打印变量值) ptype 变量名 (打印变量类型) 向下单步调试 (遇到函数进入函数体) s&#x2F;step finish (跳出函数体) 自动变量操作 display num (自动打印指定变量的值) i&#x2F;info display undisplay 编号 其他操作 set var 变量名 &#x3D; 变量值 until (跳出循环)","categories":[{"name":"LInux-系统编程入门","slug":"LInux-系统编程入门","permalink":"https://tutouwang.vercel.app/categories/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"LInux","slug":"LInux","permalink":"https://tutouwang.vercel.app/tags/LInux/"}]},{"title":"Makefile","slug":"LInux-系统编程入门/Makefile","date":"2022-03-04T10:24:52.000Z","updated":"2022-04-01T13:30:29.028Z","comments":true,"path":"2022/03/04/LInux-系统编程入门/Makefile/","link":"","permalink":"https://tutouwang.vercel.app/2022/03/04/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/Makefile/","excerpt":"","text":"什么是Makefile 一个工程中的源文件不计其数．其按类型、功能、模块分别放在若干个目录中，Makefile文件定义了一系列的规则来指定哪些文件要生编扁i译.哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 Makefile文件就像一个Shell 脚本一样,也可以执行操作系统的命 Makefile带来的好处就是“自动化编译”，一旦写好只需要一个make命令，整个工程完全自动编译．极大的提高了软件开发的效率。make 是一个命令工具，是一个解释Makefile文件中指令的命令工具，一般来说，大多数的IDE都有这个命令.比如Delphi 的 make，Visual C++的nmake,Linux 下GNU的make。 Makefile文件命名和规则 文件命名 makefile 或者 Makefile Makefile 规则 一个Makefile文件中可以有一个或者多个规则 目标 …:依赖 … (… 表示多个依赖) ​ (Tab)命令(Shell 命令) ​ … 目标 : 最终要生成的文件(伪目标除外) 依赖 ：生成目标所需要的文件或者是目标 命令 ：通过执行命令对依赖操作生成目标(命令前必须 Tab 缩进) make安装sudo apt install make make 使用 - 第一版 Makefile12app:sub.c add.c mult.c div.c main.c gcc sub.c mult.c div.c main.c -o app sub.c 1234567#include &lt;stdio.h&gt;#include &quot;head.h&quot;int subtract(int a, int b)&#123; return a-b;&#125; mult.c 1234567#include &lt;stdio.h&gt;#include &quot;head.h&quot;int multiply(int a, int b)&#123; return a*b;&#125; div.c 1234567#include &lt;stdio.h&gt;#include &quot;head.h&quot;double divide(int a, int b)&#123; return (double)a/b;&#125; main.c 1234567891011121314#include &lt;stdio.h&gt;#include &quot;head.h&quot;int main()&#123; int a = 20; int b = 12; printf(&quot;a = %d, b = %d\\n&quot;, a, b); printf(&quot;a + b = %d\\n&quot;, add(a, b)); printf(&quot;a - b = %d\\n&quot;, subtract(a, b)); printf(&quot;a * b = %d\\n&quot;, multiply(a, b)); printf(&quot;a / b = %f\\n&quot;, divide(a, b)); return 0;&#125; head.h 1234567891011#ifndef _HEAD_H#define _HEAD_H// 加法int add(int a, int b);// 减法int subtract(int a, int b);// 乘法int multiply(int a, int b);// 除法double divide(int a, int b);#endif 工作原理 命令在执行前，需要检查规则中的依赖是否u才能在 如果存在，执行命令 如果不存在，向下检查其它命令规则，检查有没有一个规则用来生成这个依赖的，如果找到则执行该规则中的命令 检测更新，在执行规则的命令时，会比较目标和依赖的文件的时间(直接输入 make) 如果依赖的时间比目标时间晚，需要重新生成目标 如果依赖的时间比目标时间早，目标不需要更新，对应规则中的命令不需要执行 第二版 Makefile123456789101112app:sub.o add.o mult.o div.o main.o gcc sub.o mult.o div.o main.o -o appusb.o:sub.c gcc -c sub.c -o sub.oadd.o:add.c gcc -c add.c -o add.omult.o:mult.c gcc -c mult.c -o mult.odiv.o:div.c gcc -c div.c -o div.omain.o:main.c gcc -c main.c -o main.o 变量 自定义变量 变量名 &#x3D; 变量值 var &#x3D; hello $(var) 预定义变量 AR : 归档维护程序的名称，默认值 ar CC ： C 编译器的名称，默认值为 cc CXX : C++ 编译器的名称。默认值为 g++ $@ : 目标的完整名称 $&lt; : 第一个依赖文件名称 $^ : 所有依赖文件 获取变量的值 $(变量名) 1234app:main.c a.c b.c gcc -c main.c a.c b.c#自动变量只能在规则的命令中使用 目标就是(app) $(cc) -c $^ -o $@ 第三版 Makefile1234567891011121314151617# 定义变量src = sub.o add.o mult.o div.o main.otarget = app$(target):$(src) $(CC) $(src) -o $(target)sub.o:sub.c gcc -c sub.c -o sub.oadd.o:add.c gcc -c add.c -o add.omult.o:mult.c gcc -c mult.c -o mult.odiv.o:div.c gcc -c div.c -o div.omain.o:main.c gcc -c main.c -o main.o 模式匹配12345678# %.o:%.c# - %:通配符，匹配一个字符# - 两个%匹配的是同一个字符串# %.o:%.c# gcc -c %&lt; -o $@sub.o:sub.c gcc -c sub.c -o sub.o %&lt;啥意思请点我 第四版 Makefile12345678# 定义变量src = sub.o add.o mult.o div.o main.otarget = app$(target):$(src) $(CC) $(src) -o $(target)%.o:%.c $(CC) -c $&lt; -o $@ 函数 $(wildcard PATTERN…) 功能:获取指定目录下指定类型的文件列表 参数：PATTERN指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔 返回：得到的若干个文件的文件列表，文件之间使用空格间隔 示例 $(wildcard *.c ./sub/*.c)(第一个*.获取当前目录下的所有.c文件 第二个是.&#x2F;sub 下的所有文件 多个目录可以用空格隔开) 返回值格式：a.c b.c c.c d.c f.c $(patsubst &lt;pattern&gt;, &lt;replacement&gt;, &lt;text&gt;) 功能：查找&lt;text&gt;中的单词（单词以”空格”、”Tab”或”回车””换行”分割）是否符合模式&lt;pattern&gt;,如果匹配的话，则可以&lt;replacemnt&gt;替换。 &lt;sattern&gt;可以包括通配符$,表示任意长度的字串。如果&lt;replacement&gt;中包含$,那么，&lt;replacemnt&gt;中的这个$将是&lt;pattern&gt;中的那个$所代表的字串。(可以用’\\‘来转义，以’\\%’来表示真实含义的’%’字符) 返回：函数返回被替换过的字符串 示例： $(patsubst %.c, %.o, x.c bar.c) 返回值格式：x.o bar.o 第五版 Makefile12345678910# 定义变量src = $(wildcard ./*.c)objs = $(patsubst %.c, %.o, $(src))target = app$(target):$(objs) $(CC) $(objs) -o $(target)%.o:%.c $(CC) -c $&lt; -o $@ 第五版 Makefile12345678910# 定义变量src = $(wildcard ./*.c)objs = $(patsubst %.c, %.o, $(src))target = app$(target):$(objs) $(CC) $(objs) -o $(target)%.o:%.c $(CC) -c $&lt; -o $@ 第六版 Makefile12345678910111213141516# 定义变量# 可以单独直行一段 make cleansrc = $(wildcard ./*.c)objs = $(patsubst %.c, %.o, $(src))target = app$(target):$(objs) $(CC) $(objs) -o $(target)%.o:%.c $(CC) -c $&lt; -o $@ # 因为clean没有依赖可以设置一个尾目标.PHONY:clean clean: rm $(objs) -f","categories":[{"name":"LInux-系统编程入门","slug":"LInux-系统编程入门","permalink":"https://tutouwang.vercel.app/categories/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"LInux","slug":"LInux","permalink":"https://tutouwang.vercel.app/tags/LInux/"}]},{"title":"sscanf/spintf妙用","slug":"有趣的知识/sscanf-spintf妙用","date":"2022-02-25T02:12:40.000Z","updated":"2022-04-03T10:26:52.077Z","comments":true,"path":"2022/02/25/有趣的知识/sscanf-spintf妙用/","link":"","permalink":"https://tutouwang.vercel.app/2022/02/25/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/sscanf-spintf%E5%A6%99%E7%94%A8/","excerpt":"","text":"leetcode-力扣(537)123456789int a1,b1,a2,b2;sscanf(num1,&quot;%d+%di&quot;,&amp;a1,&amp;b1); sscanf(num2,&quot;%d+%di&quot;,&amp;a2,&amp;b2);string s;sscanf(s.c_str(), &quot;%d:%d&quot;, ); //读取实部和虚部 char* ans=(char*)malloc(sizeof(char)*13); sprintf(ans,&quot;%d+%di&quot;,a1*a2-b1*b2,a1*b2+a2*b1);","categories":[{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"gcc/g++区别与流程","slug":"LInux-系统编程入门/gcc-g-区别与流程","date":"2022-02-20T12:50:35.000Z","updated":"2022-05-22T15:05:06.445Z","comments":true,"path":"2022/02/20/LInux-系统编程入门/gcc-g-区别与流程/","link":"","permalink":"https://tutouwang.vercel.app/2022/02/20/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/gcc-g-%E5%8C%BA%E5%88%AB%E4%B8%8E%E6%B5%81%E7%A8%8B/","excerpt":"","text":"gcc&#x2F;G++gcc工作流程源代码(.h, .c, .cpp) - &gt; 预处理器 - &gt; 预处理后源代码 (.i) - &gt; 编译器 - &gt; 汇编代码（.s) - &gt; 汇编器 - &gt; 目标代码（.o) 处理指令 gcc&#x2F;g++的区别 -D 宏的名字","categories":[{"name":"LInux-系统编程入门","slug":"LInux-系统编程入门","permalink":"https://tutouwang.vercel.app/categories/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"LInux","slug":"LInux","permalink":"https://tutouwang.vercel.app/tags/LInux/"}]},{"title":"二维矩阵映射成一维","slug":"有趣的知识/二维矩阵映射成一维","date":"2022-02-16T06:56:35.000Z","updated":"2022-05-23T14:24:24.358Z","comments":true,"path":"2022/02/16/有趣的知识/二维矩阵映射成一维/","link":"","permalink":"https://tutouwang.vercel.app/2022/02/16/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E6%98%A0%E5%B0%84%E6%88%90%E4%B8%80%E7%BB%B4/","excerpt":"","text":"二维数组映射成一维 - (0，0)开始 设一维数组下标为index,二维长度为$n*m$则 一维数组转为二维数组 12row = index / m // 行col = index % m // 列 二维数组转换为一维数组 1index = row * m + col","categories":[{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"并查集 — 2","slug":"基础数据结构/并查集_2","date":"2022-01-23T08:21:07.000Z","updated":"2022-05-22T15:05:06.441Z","comments":true,"path":"2022/01/23/基础数据结构/并查集_2/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/23/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86_2/","excerpt":"","text":"[TOC] 并查集(Union Find)并查集主要讲的就是连通性问题 比如说现在咱们这个教学楼，被大水淹了比如说一楼和其它楼层都被大水淹了，就唯独咱们教室没有，可以说明什么，咱们现在就是与世隔绝了，之后呢就被大水淹没的个个楼层水是不是都可以来回走，比如流到了咱们教室恰巧关上了们，之后水就没流进来，说明什么咱们现在是与这个教学楼的一间教室都不连图，如果说咱们与隔壁是连通的，而且咱们隔壁还被大水淹没了，你说咱们这屋是不是也被淹没了。 若某个家族人员过于庞大，要判断两个是否是亲戚，确实不容易，给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。 树形结构在春秋战国时期有各种思想学术流派的成就，有 孔子 墨子 老子 还有谁比如 韩非子等等 从我们当前图中我门可以看出我们有几个连同块 有3个对把 比如说有一天 2 号 跟 4号 打起来来了说你写的东西不如我，（这里有个规定就是说徒弟一定不如师傅）完了4号本身就是1号的徒弟肯定不如2号 当然 4号有师傅 之后4号找到自己的师傅 1 号 说今天我被人羞辱了对吧那当师傅的肯定不能做事不管对吧 之后一看 说这2号也老孔的徒弟一看这不是就是一个师傅么那就别报仇了 让 4 号 给 2 号认个错 就是下次的时候我们可以怎么看 就是先知道自己的师傅的师傅是谁对吧 在看你要找的人的师傅的师傅（这师傅可能还有师傅所有要找到最后一个师傅）是谁 如果他们最后的师傅都是同一个人那他们是不是就是一家人属于同一个师傅 （可以说明他们在通一课树中说明它们俩个连同） 其实我们在连同性中不在乎连接成什么样子谁是谁的徒弟我只在乎他们能不能连同最后的祖师，祖师爷是不是同一个人 这个两个点能不能连同 Ps 比如 （1， 2） 为一个集合 数组表示 （1，4） （4，7） 这里代表两个集合链接，这里链接的时候你说是 1 当作根节点还是 4 当作根节点 1 其实是无所谓的。这里假定 4为根节点我们可以得到 图 这两个点的连同不仅仅是两个点的连同而是两个集合的连通（其实他们都属一个个体） 比如你的爸和你妈是两个姓对吧 他们在没结婚之前是什么，两个家的人就可以比作什么两个集合，之后他们结婚了 是只有他俩是一家人么 不是吧 是两家人，这就好比我们两个点的链接。 我们可以用数组表示 初始化把每个点所在的集合初始化为其自身。 初始化加粗 为下标 我们可以用用它自身去初始化（也可以用 -1 但是后期在优化的时候会有点麻烦） 0 1 2 3 0 1 2 3 4 5 6 7 4 5 6 7 0 1 2 3 0 4 2 3 4 5 6 7 4 5 6 4 竞赛阶段我们会用到的算法 find union123456789101112131415161718// 朴素int find_root(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;// 查找--优化int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x]; // return x == parent[x] ? x : parent[x] = find_root(parent[x], parent); // return parent[x] = (x == parent[x] ? x : find_root(parent[x], parent));&#125; 123456789101112131415161718192021// 合并void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; // parent[x_root] = y_root; // 原先代码 // 安秩合并 if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; return ; &#125; mark = 1; return ;&#125; 路径压缩–按秩合并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int mark = 0;// 初始化void inital(int n, int parent[], int height[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; height[i] = 0; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x]; // &#125;// 路径压缩--非递归版int find_root1(int x, int parent[]) &#123; int k = x; while (parent[k] != k) &#123; k = parent[k]; &#125; while (x != k) &#123; int temp = parent[x]; parent[x] = k; x = temp; &#125; return k;&#125;void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; // parent[x_root] = y_root; // 原先代码 // 按秩合并 if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; return ; &#125; mark = 1; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10], height[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; inital(m, parent, height); for (int i = 0; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(x, y, parent, height); &#125; if (mark) cout &lt;&lt; &quot;有环！&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;无环！&quot; &lt;&lt; endl; return 0;&#125; 路径压缩是怎么实现的 检测是否存在环我们如何去检测一个图是否存在环环路 如下 我们有 0️⃣ 1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 把每个点看成单个集合比如我们相连（0 ，1） （1，2） （1，3）（2，4）（2，3） 我们在合并时候需要先查询一下他们是否属于同一集合，如果不属于同一集合我才能合并，反之要是它们在合并就会构成回路。 如果不考虑链接红色两点，合并集合之后是{0，1，2，3，4} 我们可以得到站在任意点到达另一任意点。不构成环 如果说我们在已连接中任意选择两个去链接他一定会成环对吧。🔶 比如红色两点链接，我们可以看到 1， 2， 3 点形成了环。 形成环路 我们怎么知道他是成环了呢我们把 1 当做根结点 ，0， 2，4，3 都属于 1 的孩子或者是孙子 当你去链接 （2， 3）时候你会发现他们都属于 1 下就如我们刚才所说 🔶因为我们知道两个集合在合并的时候一定会先去找根节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int mark = 0;int parent[MAX_N + 10];// 初始化void inital(int n, int parent[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; &#125; return ;&#125;int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;void merge(int x, int y, int parent[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; parent[x_root] = y_root; return ; &#125; mark = 1; return ;&#125;int main() &#123; int n, m; // 组数 最大值 cin &gt;&gt; n &gt;&gt; m; inital(m, parent); for (int i = 0; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(x, y, parent); &#125; if (mark) cout &lt;&lt; &quot;有环！&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;无环！&quot; &lt;&lt; endl; return 0;&#125; 并查集–数据结构实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;struct UnionSet &#123; int *parent;&#125;;// 初始化UnionSet *init(int n) &#123; UnionSet *U = (UnionSet *)malloc(sizeof(UnionSet)); U-&gt;parent = (int *)malloc(sizeof(int) * (n + 1)); for (int i = 1; i &lt;= n; i++) &#123; U-&gt;parent[i] = i; &#125; return U;&#125;int find_root(UnionSet *U, int x) &#123; if (U-&gt;parent[x] != x) &#123; return find_root(U, U-&gt;parent[x]); &#125; return x;&#125;void merge(UnionSet *U, int x, int y) &#123; int x_root = find_root(U, x); int y_root = find_root(U, y); if (x_root != y_root) &#123; U-&gt;parent[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); UnionSet *U = init(n); // 进行 M 次操作 for (int i = 1; i &lt;= m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); switch(a) &#123; case 1: merge(U, b, c); break; // 合并操作 case 2: printf(&quot;%s\\n&quot;, find_root(U, b) == find_root(U, c) ? &quot;Yes&quot; : &quot;No&quot;); &#125; &#125; return 0;&#125; 例题–题解海贼 #71 朋友圈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/************************************************************************* &gt; File Name: 海贼_#71并查集_路径压缩优化.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年01月18日 星期一 15时33分00秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e4;// 初始化void initialization(int n, int parent[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;// 朴素算法int find_root1(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;void merge(int x, int y, int parent[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; parent[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; initialization(n, parent); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if (a == 1) &#123; // 添加 merge(b, c, parent); &#125; else &#123; // 查看 if (find_root(b, parent) - find_root(c, parent)) &#123; printf(&quot;No\\n&quot;); &#125; else printf(&quot;Yes\\n&quot;); &#125; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/************************************************************************* &gt; File Name: 海贼_#71并查集_路径压缩_安秩合并_优化.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年01月18日 星期一 21时33分00秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e4;// 初始化 void initialization(int n, int parent[], int height[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; // 开始树高为 0 height[i] = 0; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;// 朴素算法int find_root1(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; &#125; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10], height[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; initialization(n, parent, height); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if (a == 1) &#123; // 添加 merge(b, c, parent, height); &#125; else &#123; // 查看 if (find_root(b, parent) - find_root(c, parent)) &#123; printf(&quot;No\\n&quot;); &#125; else printf(&quot;Yes\\n&quot;); &#125; &#125; return 0;&#125; 洛谷 P1551 亲戚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int arr[MAX_N];void initial(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; arr[i] = i; &#125;&#125;int find(int x) &#123; if (arr[x] != x) &#123; x = find(arr[x]); &#125; return arr[x];&#125;void merge(int x, int y) &#123; int x_root = find(x); int y_root = find(y); if (x_root != y_root) &#123; arr[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; initial(n); while (m--) &#123; int mi, mj; cin &gt;&gt; mi &gt;&gt; mj; merge(mi, mj); &#125; while (p--) &#123; int mi, mj; cin &gt;&gt; mi &gt;&gt; mj; if (find(mi) == find(mj)) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"并查集 — 1","slug":"基础数据结构/并查集_1","date":"2022-01-23T08:21:07.000Z","updated":"2022-05-22T15:05:06.443Z","comments":true,"path":"2022/01/23/基础数据结构/并查集_1/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/23/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86_1/","excerpt":"","text":"并查集连通性问题： 基于染色的思想，一开始所有点的颜色不同 连接两个点的操作，可以看成将一种颜色的点染成另一种颜色 如果两个点颜色一样，证明联通，否则不联通 这种方法叫做并查集的:【Quick-Find算法】 Quick-Find 近似$ O(1) $查询 Quick-Find 默认的做法吧前一个数字的颜色改成后一个颜色(大白话：就是让4接到3后面，让3作为根节点) 这里要说明一下 ： 无论以 4 还是以 3 作为根节点都是可以的这个不重要 - 节点的链接其实是两个集合的链接 4 和 8 链接是直接吧4接到8下面么？(其实不对) 相当于 4 和 3已经属于一个集合那么你要改4当然3也要改变所以3和4的下标都要改成8 Quick-Find 时间复杂度分析 联通判断：近似$O(1)$ 合并操作：$O(n)$ Quick-Union Quick-Unionu算法是选先找根节点判断是否处在同一根节点猜能在合并 Quick-Union 总结问题思考：(需要自己手动模拟一下) 如果不看上述 Quick-Union 正常合并情况在极端情况下会退化成一条链 - 这就是一个$O(n)$操作 将节点数量多的接到少的树上面，导致了退化 将树高深度的接到浅的上面，导致退化 问题思考：若要改进，是按照节点数量还是节点高度合并？ 可以得到： 树高合并到树矮的上面(树高不变) 如果一棵树很矮但是包含了很多节点和一颗高树有较少节点在这种情况下就需要节点数量为合并条件 谁的节点数量多就往那个树上合并 平均查找次数每个节点深度相加之和除总节点数量 按秩合并下图 但是要把0接到3下面就路径压缩 + 按秩合并了就开头所看到的样子 并查集四种算法 代码见 并查集2","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"由数据范围反推算法复杂度以及算法内容","slug":"有趣的知识/由数据范围反推算法复杂度以及算法内容","date":"2022-01-22T07:51:38.000Z","updated":"2022-01-22T07:53:23.211Z","comments":true,"path":"2022/01/22/有趣的知识/由数据范围反推算法复杂度以及算法内容/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/22/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E7%94%B1%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/","excerpt":"","text":"一般ACM或者笔试题的时间限制是1秒或2秒。在这种情况下，C++代码中的操作次数控制在 107∼108107∼108 为最佳。 下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择： n≤30n≤30, 指数级别, dfs+剪枝，状态压缩dp n≤100n≤100 &#x3D;&gt; O(n3)O(n3)，floyd，dp，高斯消元 n≤1000n≤1000 &#x3D;&gt; O(n2)O(n2)，O(n2logn)O(n2logn)，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford n≤10000n≤10000 &#x3D;&gt; O(n∗n√)O(n∗n)，块状链表、分块、莫队 n≤100000n≤100000 &#x3D;&gt; O(nlogn)O(nlogn) &#x3D;&gt; 各种sort，线段树、树状数组、set&#x2F;map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树 n≤1000000n≤1000000 &#x3D;&gt; O(n)O(n), 以及常数较小的 O(nlogn)O(nlogn) 算法 &#x3D;&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O(nlogn)O(nlogn) 的做法：sort、树状数组、heap、dijkstra、spfa n≤10000000n≤10000000 &#x3D;&gt; O(n)O(n)，双指针扫描、kmp、AC自动机、线性筛素数n≤109n≤109 &#x3D;&gt; O(n√)O(n)，判断质数 n≤1018n≤1018 &#x3D;&gt; O(logn)O(logn)，最大公约数，快速幂，数位DP n≤101000n≤101000 &#x3D;&gt; O((logn)2)O((logn)2)，高精度加减乘除 n≤10100000n≤10100000 &#x3D;&gt; O(logk×loglogk)，k表示位数O(logk×loglogk)，k表示位数，高精度加减、FFT&#x2F;NTT 来源：AcWing","categories":[{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"STL-简介","slug":"有趣的知识/STL-简介","date":"2022-01-22T07:49:05.000Z","updated":"2022-01-22T07:53:34.820Z","comments":true,"path":"2022/01/22/有趣的知识/STL-简介/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/22/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/STL-%E7%AE%80%E4%BB%8B/","excerpt":"","text":"C++ STL简介123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()&#x2F;back() push_back()&#x2F;pop_back() begin()&#x2F;end() [] 支持比较运算，按字典序pair&lt;int, int&gt; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序）string，字符串 size()&#x2F;length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素priority_queue, 优先队列，默认是大根堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素deque, 双端队列 size() empty() clear() front()&#x2F;back() push_back()&#x2F;pop_back() push_front()&#x2F;pop_front() begin()&#x2F;end() []set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()&#x2F;end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set&#x2F;multiset insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()&#x2F;upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map&#x2F;multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()&#x2F;upper_bound()unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()&#x2F;upper_bound()， 迭代器的++，--bitset, 圧位 bitset&lt;10000&gt; s; ~, &amp;, |, ^ &gt;&gt;, &lt;&lt; &#x3D;&#x3D;, !&#x3D; [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 来自Acwing","categories":[{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"堆与优先队列","slug":"基础数据结构/堆与优先队列","date":"2022-01-22T04:03:52.000Z","updated":"2022-05-22T15:05:06.444Z","comments":true,"path":"2022/01/22/基础数据结构/堆与优先队列/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/22/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","excerpt":"","text":"回顾 - 二叉树完全二叉树 编号为 i 的字节点 左孩子编号 ：2 * i 右孩子编号 ：2 * i + 1 可以使用连续空间存储 (数组) 堆 大顶堆 在任意一个三元组中 根 大于左孩子和右孩子 12 - 11 - 10 根节点 (极大) 全局最大 小顶堆 在任意一个三元组中 根 小于左孩子和右孩子 3 - 7 - 4 根节点 (极小) 全局最小 堆 - 尾部插入调整 (自下向上)依次和和根比较 13 &gt; 7 交换 13 &gt; 11 交换 13 &gt; 12 交换 堆 - 头部弹出调整 (自上向下)从堆的最后元素直接放到堆顶 之后在在根节点的三元组中比较是是否满足条件 如果不满足最大值和根交换一直操作 12 &gt; 7 交换 11 &gt; 7 交换 时间复杂度分析 插入调整时间复杂度 - 层序遍历 ： $O(log^N)$ 删除调整时间复杂度 $O(log^N)$ 建堆时间复杂度 ： $O(Nlog^N)$ 堆排序 - (大顶堆情况)口诀： 将堆顶元素与堆尾元素交换 将此操作看最做是堆顶元素弹出操作 按照头部弹出以后的策略调整推 如果想要一个从小到大的排序 那么就建立一个大顶堆 如果想要一个从大到小的排序 那么就建立一个小顶堆 堆 - 优先队列 堆代码实现 - (大顶堆举例)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/************************************************************************* &gt; File Name: 堆-优先队列.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月22日 星期六 15时45分42秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;typedef struct priority_queue &#123; int *data; int cnt, size;&#125; priority_queue;priority_queue *init(int n) &#123; priority_queue *q = (priority_queue *)malloc(sizeof(priority_queue)); q-&gt;data = (int *)malloc(sizeof(int) * n + 1); q-&gt;size =n; q-&gt;cnt = 0; return q;&#125;int empty(priority_queue *q) &#123; return q-&gt;cnt == 0;&#125;int top(priority_queue *q) &#123; return q-&gt;data[1];&#125;int push(priority_queue *q, int val) &#123; if(q == NULL) return 0; if(q-&gt;cnt == q-&gt;size) return 0; q-&gt;data[++(q-&gt;cnt)] = val; int ind = q-&gt;cnt; // 大顶堆 while(ind &gt;&gt; 1 &amp;&amp; q-&gt;data[ind] &gt; q-&gt;data[ind &gt;&gt; 1]) &#123; swap(q-&gt;data[ind], q-&gt;data[ind &gt;&gt; 1]); ind &gt;&gt;= 1; &#125; return 1;&#125;int pop(priority_queue *q) &#123; if(q == NULL) return 0; if(empty(q)) return 0; q-&gt;data[1] = q-&gt;data[q-&gt;cnt--]; int ind = 1; // ind &lt;&lt; 1 &lt;= q-&gt;cnt 证明左孩子存在 while((ind &lt;&lt; 1) &lt;= q-&gt;cnt) &#123; int temp = ind, l = ind &lt;&lt; 1, r = ind &lt;&lt; 1 | 1; if(q-&gt;data[l] &gt; q-&gt;data[temp]) temp = l; // r &lt;= q-&gt;cnt 证明右孩子存在 if(r &lt;= q-&gt;cnt &amp;&amp; q-&gt;data[r] &gt; q-&gt;data[temp]) temp = r; if(ind == temp) break; swap(q-&gt;data[ind], q-&gt;data[temp]); ind = temp; &#125; return 1;&#125;void clear(priority_queue * q) &#123; if(q == NULL) return ; free(q-&gt;data); free(q); return ;&#125;int main() &#123; srand(time(0)); #define MAX_OP 20 priority_queue *q = init(MAX_OP); for(int i = 0; i &lt; MAX_OP; i++) &#123; int val = rand() % 100; push(q, val); printf(&quot;insert %d to the priority_queue!\\n&quot;, val); &#125; for(int i = 0; i &lt; MAX_OP; i++) &#123; printf(&quot;%d &quot;, top(q)); pop(q); &#125; printf(&quot;\\n&quot;); return 0;&#125; 线性建堆法 - (自上向下) 向上调整次数分析 在第 1 层时候(0表示向上调整0次) $0 * 2^0$ ($2^0$代表第一层有多少个节点) 第三次层每个节点最多向上调整2次 $0 * 2^1 + 1 * 2^1 + 2 * 2^2 + 3 + 2^3 + … + (n - 1) * 2^{n-1}$ 0次 1个节点 1次 2个节点 … n - 1次 $2^{n-1}$节点 $0 * 2^{n - 1} + 1 * 2^{n - 2}$ 堆排序 - 代码实现(线性建堆法)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/************************************************************************* &gt; File Name: 堆-排序.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月22日 星期六 19时34分46秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;void downUpdate(int *arr, int n, int ind) &#123; while((ind &lt;&lt; 1) &lt;= n) &#123; int temp = ind, l = ind &lt;&lt; 1, r = (ind &lt;&lt; 1) + 1; // if(arr[l] &gt; arr[temp]) temp = l; if(arr[l] &lt; arr[temp]) temp = l; // if(r &lt;= n &amp;&amp; arr[r] &gt; arr[temp]) temp = r; if(r &lt;= n &amp;&amp; arr[r] &lt; arr[temp]) temp = r; if(ind == temp) break; swap(arr[ind], arr[temp]); ind = temp; &#125; return ;&#125;void heap_Sort(int *arr, int n) &#123; arr -= 1; for(int i = n &gt;&gt; 1; i &gt;= 1; i--) &#123; downUpdate(arr, n, i); &#125; for(int i = n; i &gt; 1; i--) &#123; swap(arr[i], arr[1]); downUpdate(arr, i - 1, 1); &#125; return ;&#125;void output(int *arr, int n) &#123; for(int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, arr[i]); &#125; printf(&quot;\\n&quot;);&#125;int main() &#123; srand(time(0)); #define MAX_N 20 int *arr = (int *)malloc(sizeof(int) * MAX_N); for(int i = 0; i &lt; MAX_N; i++) &#123; arr[i] = rand() % 100; &#125; output(arr, MAX_N); printf(&quot;\\n&quot;); heap_Sort(arr, MAX_N); output(arr, MAX_N); free(arr); #undef MAX_N return 0;&#125; 时间复杂度分析 $O(log^N)$","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"哈希表","slug":"基础数据结构/哈希表","date":"2022-01-20T13:51:03.000Z","updated":"2022-01-21T10:20:16.993Z","comments":true,"path":"2022/01/20/基础数据结构/哈希表/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/20/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/","excerpt":"","text":"哈希表 通过数组下标索引到值 任意类型映射成一个整型 (下标) 简单举例 val % size 假如 val &#x3D; 16、size &#x3D; 9 16 % 9 &#x3D; 7 (下标) 假如 val &#x3D; 7、size &#x3D; 9 7 % 9 &#x3D; 7 (下标) 产生冲突了 - 优秀的哈希都会冲突 下标 0 1 2 3 4 5 6 7 8 16 解决哈希冲突的 四 种 方法 开放定值法 拉链法 在哈希法 (在散列法) 建立公共溢出区 解决哈希冲突方法 - 开放定值法可以使用开放定值法 (二次探测法) - 不好用会堆聚 下标7后面8是空着的所以7可以存放到此处 下标 0 1 2 3 4 5 6 7 8 16 7 解决哈希冲突方法 - 拉链法顾名思义拉链法就是以下标为7的位置做成一个链表 下标 0 1 2 3 4 5 6 7 8 16 7 解决哈希冲突方法 - 在哈希法 (在散列法)如果第一个哈希函数冲突了，那么就可以利用第二个哈希函数在去做映射，如果在冲突了那么就利用第三个哈希函数在做。。。(禁止套娃)🤐 解决哈希冲突方法 - 建立公共溢出区将冲突的元素集中去管理 时间复杂度 平均复杂度 ： $O(1)$ 字符串-哈希123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/************************************************************************* &gt; File Name: 哈希.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月21日 星期五 16时28分39秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct Node &#123; char *str; struct Node *next;&#125; Node;typedef struct HashTable &#123; Node **data; int size;&#125; HashTable;Node *init_node(char *str, Node *head) &#123; Node *p =(Node *)malloc(sizeof(Node)); // 深拷贝 p-&gt;str = strdup(str); p-&gt;next = head; return p;&#125;HashTable *init_hash(int n) &#123; HashTable *h = (HashTable *)malloc(sizeof(HashTable)); // 利用率 h-&gt;size = (n &lt;&lt; 1); h-&gt;data = (Node **)calloc(h-&gt;size, sizeof(Node *)); return h;&#125;int BKDRHash(char *str) &#123; // seed 可以是任意一质数 int seed = 31, hash = 0; for(int i = 0; str[i]; i++) hash = hash * seed + str[i]; // 确保 head 是一个正数 return hash &amp; 0x7fffffff;&#125;int insert(HashTable *h, char *str) &#123; if(h == NULL) return 0; int hash = BKDRHash(str); int ind = hash % h-&gt;size; h-&gt;data[ind] = init_node(str, h-&gt;data[ind]); return 1;&#125;int search(HashTable *h, char *str) &#123; if(h == NULL) return 0; int hash = BKDRHash(str); int ind = hash % h-&gt;size; Node *p = h-&gt;data[ind]; while(p &amp;&amp; strcmp(p-&gt;str, str)) p = p-&gt;next; return p != NULL;&#125;void clear_node(Node *node) &#123; if(node == NULL) return ; Node *p = node, *t; while(p) &#123; t = p-&gt;next; free(p-&gt;str); free(p); p = t; &#125; return ;&#125;void clear(HashTable *h) &#123; if(h == NULL) return ; for(int i = 0; i &lt; h-&gt;size; i++) &#123; clear_node(h-&gt;data[i]); &#125; free(h); return ;&#125;int main() &#123; #define MAX_N 100 int op; char str[MAX_N + 5] = &#123;0&#125;; HashTable *h = init_hash(MAX_N); while(~scanf(&quot;%d%s&quot;, &amp;op, str)) &#123; switch(op) &#123; case 0 : &#123; printf(&quot;insert %s to HashTable\\n&quot;, str); insert(h, str); &#125; break; case 1 : &#123; printf(&quot;search %s from HashTable result = %d\\n&quot;, str, search(h, str)); &#125;break; &#125; &#125; #undef MAX_N clear(h); return 0;&#125;","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"二分查找与三分查找","slug":"基础数据结构/二分查找与三分查找","date":"2022-01-20T07:51:45.000Z","updated":"2022-05-22T15:05:06.444Z","comments":true,"path":"2022/01/20/基础数据结构/二分查找与三分查找/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/20/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%B8%89%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"二分查找 (折半查找)条件 单调性 - (一般单调递减) 特殊情况 - 1 查找第最后出现的 1 如果待查值不存在的情况可以设置一个虚拟头 特殊情况 - 2 查找第一个 1 如果待查值不存在的情况可以设置一个虚拟尾 时间复杂度 平均复杂度 ： $O(log^N)$ 三分查找","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"排序合集 5 种 - 插入、冒泡、归并、选择、快排","slug":"基础数据结构/排序合集","date":"2022-01-19T02:32:08.000Z","updated":"2022-05-22T15:05:06.438Z","comments":true,"path":"2022/01/19/基础数据结构/排序合集/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/19/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/","excerpt":"","text":"排序算法分类 稳定 ：( 插入、冒泡、归并) 非稳定 (不稳定) ：(选择、快排) 内部 ：(整体一次性的加入到内存当中,整体的去排序) 外部 ： (对一个数据文件排序的话可以不将整个文件都加载到内存里面进行排序 - 归并！ ) 插入排序 (insert_Sort)口诀 : 将数组分成【已排序区】 和 【待排序区】 将【待排序区】第一个元素，向前插入到【已排序区】 直到【待排序区】没有元素为止 时间复杂度分析 最好 ：0 次 最坏 ：n - 1 次 平均复杂度 ：( 最好 + 最坏 ) &#x2F; 2 : $\\frac{(n - 1)}{2} * N$ : $O(N^2)$ 代码实现 - 模块123456789// 插入排序void insert_Sort(int *num, int n) &#123; for(int i = 1; i &lt; n; i++) &#123; for(int j = i; j &gt; 0 &amp;&amp; num[j] &lt; num[j - 1]; j--) &#123; swap(num[j], num[j - 1]); &#125; &#125; return ;&#125; 冒泡排序 (bubble_Sort)口诀 : 将数组分成【已排序区】 和 【待排序区】 从头到尾扫描【待排序区】，若前面元素比后面元素大，则交换 每一轮都会将【待排序区】中最大的放到【已排序区】的开头 直到【待排序区】没有元素为止 小优化 ： 如果一轮中一次交换都没有就证明序列已经有序可以提前结束 时间复杂度 平均复杂度 ： $O(N^2)$ 代码实现 - 模块12345678910111213// 冒泡排序void bubble_Sort(int *num, int n) &#123; int falg = 1; for(int i = 1; i &lt; n &amp;&amp; falg; i++) &#123; falg = 0; for(int j = 0; j &lt; n - i; j++) &#123; if(num[j] &lt;= num[j + 1]) continue; swap(num[j], num[j + 1]); falg++; &#125; &#125; return ;&#125; 归并排序 - 二路归并 (merge_Sort)核心思想分治 将【待排序数组】分为两个部分 如 ： 9 7 8 5 4 1 2 3 6 5 分为 : 9 7 8 5 4 — 1 2 3 6 5 再分：9 7 — 8 5 4 — 1 2 — 365 达到足够小并且立马能拿到答案的规模 上一层 ： 【 — 我是空数组 — 】 可以得到 7 9 — 4 5 8 — 1 2 — 3 5 6 组内有序组间无序 一个指向👆 ____👆 合并成一个有序数组 - 在拷贝到原数组 他们两个比较谁小就插入到上面数组 时间复杂度 平均复杂度 ： $O(Nlog^N)$ 代码实现 - 模块12345678910111213141516171819202122232425// 归并排序void merge_Sort(int *num, int l, int r) &#123; if(r - l &lt;= 1) &#123; if(r - l == 1 &amp;&amp; num[r] &lt; num[l]) &#123; swap(num[r], num[l]); &#125; return ; &#125; int mid = (r + l) &gt;&gt; 1; merge_Sort(num, l, mid); merge_Sort(num, mid + 1, r); int *temp = (int *)malloc(sizeof(int) * (r - l + 1)); int p1 = l, p2 = mid + 1, cnt = 0; while(p1 &lt;= mid || p2 &lt;= r) &#123; if(p2 &gt; r || (p1 &lt;= mid &amp;&amp; num[p1] &lt;= num[p2])) &#123; temp[cnt++] = num[p1++]; &#125; else &#123; temp[cnt++] = num[p2++]; &#125; &#125; memcpy(num + l, temp, sizeof(int) * (r - l + 1)); free(temp); return ;&#125; 稳定排序代码合集 - 插入、冒泡、归并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/************************************************************************* &gt; File Name: 稳定排序合集-插入、冒泡、归并.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月19日 星期三 17时02分43秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;// typeof(a) 相当于获取 a 的类型 在定义一个变量 __temp#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b, b = __temp;\\&#125;#define TEST(arr, n, func, args...) &#123;\\ int *num = (int *)malloc(sizeof(int) * n);\\ memcpy(num, arr, sizeof(int) * n);\\ output(num, n);\\ printf(&quot;%s = &quot;, #func);\\ func(args);\\ output(num, n);\\ free(num);\\ printf(&quot;\\n&quot;);\\&#125;// 插入排序void insert_Sort(int *num, int n) &#123; for(int i = 1; i &lt; n; i++) &#123; for(int j = i; j &gt; 0 &amp;&amp; num[j] &lt; num[j - 1]; j--) &#123; swap(num[j], num[j - 1]); &#125; &#125; return ;&#125;// 冒泡排序void bubble_Sort(int *num, int n) &#123; int falg = 1; for(int i = 1; i &lt; n &amp;&amp; falg; i++) &#123; falg = 0; for(int j = 0; j &lt; n - i; j++) &#123; if(num[j] &lt;= num[j + 1]) continue; swap(num[j], num[j + 1]); falg++; &#125; &#125; return ;&#125;// 归并排序void merge_Sort(int *num, int l, int r) &#123; if(r - l &lt;= 1) &#123; if(r - l == 1 &amp;&amp; num[r] &lt; num[l]) &#123; swap(num[r], num[l]); &#125; return ; &#125; int mid = (r + l) &gt;&gt; 1; merge_Sort(num, l, mid); merge_Sort(num, mid + 1, r); int *temp = (int *)malloc(sizeof(int) * (r - l + 1)); int p1 = l, p2 = mid + 1, cnt = 0; while(p1 &lt;= mid || p2 &lt;= r) &#123; if(p2 &gt; r || (p1 &lt;= mid &amp;&amp; num[p1] &lt;= num[p2])) &#123; temp[cnt++] = num[p1++]; &#125; else &#123; temp[cnt++] = num[p2++]; &#125; &#125; memcpy(num + l, temp, sizeof(int) * (r - l + 1)); free(temp); return ;&#125;void randint(int *arr, int n) &#123; while(n--) arr[n] = rand() % 100; return ;&#125;void output(int *arr, int n) &#123; for(int i = 0; i &lt; n; i++) &#123; i &amp;&amp; printf(&quot;, &quot;); printf(&quot;%d&quot;, arr[i]); &#125; printf(&quot;\\n&quot;);&#125;int main() &#123; srand(time(0)); #define MAX_N 20 int arr[MAX_N]; randint(arr, MAX_N); TEST(arr, MAX_N, insert_Sort, num, MAX_N); TEST(arr, MAX_N, bubble_Sort, num, MAX_N); TEST(arr, MAX_N, merge_Sort, num, 0, MAX_N - 1); #undef MAX_N return 0;&#125; 分界线👇不稳定了 选择排序 (select_Sort)口诀 : 将数组分成【已排序区】 和 【待排序区】 每一轮从【待排序区】中选择一个最小的元素方到【已排序区】的尾部 直到【待排序区】没有元素为止 时间复杂度 平均复杂度 ： $O(N^2)$ 代码实现 - 模块1234567891011// 选择排序void select_Sort(int *num, int n) &#123; for(int i = 0; i &lt; n - 1; i++) &#123; int ind = i; for(int j = i + 1; j &lt; n; j++) &#123; if(num[ind] &gt; num[j]) ind = j; &#125; swap(num[i], num[ind]); &#125; return ;&#125; 快速排序 (quick_Sort)口诀 : 选择基准数 ： 一般选择序列的第一个数 (基准值) 进行（partition）操作：作用就是使得待排序的序列分为了两部分 前部分都小于基准值 — 后面一部分都大于基准值 (一轮partition 操作) head &#x3D; 第一个数(基准值) tail &#x3D; 最后一个元素 tail 操作 从后往前找第一个小于基准值的数 - 找到之后填到头指针的位置 head 操作 从前往后找到找到一个大于基准值的数 - 找到之后填到尾针的位置 时间复杂度 平均复杂度 ： $O(Nlog^N)$ 完全逆序 ： $ O(N^2)$ - (就变成了选择排序) 代码实现 - 模块 - 未优化 - 填坑法1234567891011121314151617// 快排 — 第一版void quick_Sort(int *num, int l, int r) &#123; if(l &gt; r) return ; int x = l, y = r, z = num[l]; while(x &lt; y) &#123; // 先从后往前扫因为第一个位置是空着可以覆盖掉 while(x &lt; y &amp;&amp; num[y] &gt; z) y--; if(x &lt; y) num[x++] = num[y]; while(x &lt; y &amp;&amp; num[x] &lt; z) x++; if(x &lt; y) num[y--] = num[x]; &#125; // 头尾指针重合 num[x] = z; quick_Sort(num, l, x - 1); quick_Sort(num, x + 1, r); return ;&#125; 代码实现 - 模块 - 优化 - 基准值两点取中法、无监督优化(去掉x &lt; y)、单边递归法123456789101112131415161718// 快排 — 第二版 基准值两点取中法、无监督优化(去掉x &lt; y)、单 边递归法void quick_Sort1(int *num, int l, int r) &#123; while(l &lt; r) &#123; int x = l, y = r, z = num[(l + r) &gt;&gt; 1]; do &#123; while(num[x] &lt; z) x++; while(num[y] &gt; z) y--; if(x &lt;= y) &#123; swap(num[x], num[y]); x++, y--; &#125; &#125; while(x &lt;= y); quick_Sort1(num, l, y); l = x; &#125; return ;&#125; 不稳定排序代码合集 - 选择、快速、快速优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/************************************************************************* [0] &gt; File Name: 稳定排序合集-插入、冒泡、归并.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月19日 星期三 17时02分43秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;// typeof(a) 相当于获取 a 的类型 在定义一个变量 __temp#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b, b = __temp;\\&#125;#define TEST(arr, n, func, args...) &#123;\\ int *num = (int *)malloc(sizeof(int) * n);\\ memcpy(num, arr, sizeof(int) * n);\\ output(num, n);\\ printf(&quot;%s = &quot;, #func);\\ func(args);\\ output(num, n);\\ free(num);\\ printf(&quot;\\n&quot;);\\&#125;// 选择排序void select_Sort(int *num, int n) &#123; for(int i = 0; i &lt; n - 1; i++) &#123; int ind = i; for(int j = i + 1; j &lt; n; j++) &#123; if(num[ind] &gt; num[j]) ind = j; &#125; swap(num[i], num[ind]); &#125; return ;&#125;// 快排 — 第一版void quick_Sort(int *num, int l, int r) &#123; if(l &gt; r) return ; int x = l, y = r, z = num[l]; while(x &lt; y) &#123; // 先从后往前扫因为第一个位置是空着可以覆盖掉 while(x &lt; y &amp;&amp; num[y] &gt; z) y--; if(x &lt; y) num[x++] = num[y]; while(x &lt; y &amp;&amp; num[x] &lt; z) x++; if(x &lt; y) num[y--] = num[x]; &#125; // 头尾指针重合 num[x] = z; quick_Sort(num, l, x - 1); quick_Sort(num, x + 1, r); return ;&#125;// 快排 — 第二版 基准值两点取中法、无监督优化(去掉x &lt; y)、单 边递归法void quick_Sort1(int *num, int l, int r) &#123; while(l &lt; r) &#123; int x = l, y = r, z = num[(l + r) &gt;&gt; 1]; do &#123; while(num[x] &lt; z) x++; while(num[y] &gt; z) y--; if(x &lt;= y) &#123; swap(num[x], num[y]); x++, y--; &#125; &#125; while(x &lt;= y); quick_Sort1(num, l, y); l = x; &#125; return ;&#125;void randint(int *arr, int n) &#123; while(n--) arr[n] = rand() % 100; return ;&#125;void output(int *arr, int n) &#123; for(int i = 0; i &lt; n; i++) &#123; i &amp;&amp; printf(&quot;, &quot;); printf(&quot;%d&quot;, arr[i]); &#125; printf(&quot;\\n&quot;);&#125;int main() &#123; srand(time(0)); #define MAX_N 20 int arr[MAX_N]; randint(arr, MAX_N); TEST(arr, MAX_N, select_Sort, num, MAX_N); TEST(arr, MAX_N, quick_Sort, num, 0, MAX_N - 1); TEST(arr, MAX_N, quick_Sort1, num, 0, MAX_N - 1); #undef MAX_N return 0;&#125; 有趣的知识12345g++ test.cpptime .&#x2F;a.out &gt; out_1&#x2F;&#x2F; 比较两个文件是否相等diff out_1 out_2","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://tutouwang.vercel.app/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"广义表转二叉树","slug":"基础数据结构/广义表转二叉树","date":"2022-01-18T04:02:39.000Z","updated":"2022-05-22T15:05:06.438Z","comments":true,"path":"2022/01/18/基础数据结构/广义表转二叉树/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/18/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%BF%E4%B9%89%E8%A1%A8%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"代码实现广义表还原二叉树 (栈原理)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190/************************************************************************* &gt; File Name: 广义表转二叉树.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月18日 星期二 14时33分25 秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;typedef struct Node &#123; char data; struct Node *lchild, *rchild;&#125; Node;typedef struct Tree &#123; Node *root; int length;&#125; Tree;typedef struct Stack &#123; Node **data; int top, size;&#125; Stack;Node *getNewNode(char val) &#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;data = val; p-&gt;lchild = p-&gt;rchild = NULL; return p;&#125;Tree *getNewTree() &#123; Tree *tree = (Tree *)malloc(sizeof(Tree)); tree-&gt;root = NULL; tree-&gt;length = 0; return tree;&#125;Stack *init_stack(int n) &#123; Stack *s = (Stack *)malloc(sizeof(Stack)); s-&gt;data = (Node **)malloc(sizeof(Node *) * n); s-&gt;top = -1; s-&gt;size = n; return s;&#125;Node *top(Stack *s) &#123; return s-&gt;data[s-&gt;top];&#125;int empty(Stack *s) &#123; return s-&gt;top == -1;&#125;int push(Stack *s, Node *val) &#123; if(s == NULL) return 0; if(s-&gt;size - 1 == s-&gt;top) return 0; s-&gt;data[++(s-&gt;top)] = val; return 1;&#125;int pop(Stack *s) &#123; if(s == NULL) return 0; if(empty(s)) return 0; s-&gt;top--; return 1;&#125;void clear_stack(Stack *s) &#123; if(s == NULL) return ; free(s-&gt;data); free(s); return ;&#125;void clear_node(Node *root) &#123; if(root == NULL) return ; clear_node(root-&gt;lchild); clear_node(root-&gt;rchild); free(root); return ;&#125;void clear_tree(Tree *tree) &#123; if(tree == NULL) return ; clear_node(tree-&gt;root); free(tree); return ;&#125;Node *build(const char *str, int *node_num) &#123; Stack *s = init_stack(strlen(str)); int falg = 0; Node *temp = NULL, *p =NULL; while(str[0]) &#123; switch(str[0]) &#123; case &#x27;(&#x27; : &#123; push(s, temp); falg = 0; &#125; break; case &#x27;)&#x27; : &#123; p = top(s); pop(s); &#125; break; case &#x27;,&#x27; : falg = 1; break; case &#x27; &#x27; : break; default : temp = getNewNode(str[0]); if(!empty(s) &amp;&amp; !falg) &#123; top(s)-&gt;lchild = temp; &#125; else if(!empty(s) &amp;&amp; falg)&#123; top(s)-&gt;rchild = temp; &#125; ++(*node_num); &#125; ++str; &#125; clear_stack(s); if(temp &amp;&amp; p == NULL) p = temp; return p;&#125;// 前 根 左 右void pre_order_node(Node *root) &#123; if(root == NULL) return ; printf(&quot;%c &quot;, root-&gt;data); pre_order_node(root-&gt;lchild); pre_order_node(root-&gt;rchild); return ;&#125;// 前void pre_order(Tree *tree) &#123; if(tree == NULL) return ; printf(&quot;pre_order (%d) : &quot;, tree-&gt;length); pre_order_node(tree-&gt;root); printf(&quot;\\n&quot;); return ;&#125;// 中 左 根 右void in_order_node(Node *root) &#123; if(root == NULL) return ; in_order_node(root-&gt;lchild); printf(&quot;%c &quot;, root-&gt;data); in_order_node(root-&gt;rchild); return ;&#125;// 中void in_order(Tree *tree) &#123; if(tree == NULL) return ; printf(&quot;in_order (%d) : &quot;, tree-&gt;length); in_order_node(tree-&gt;root); printf(&quot;\\n&quot;); return ;&#125;// 后 左 右 根void post_order_node(Node *root) &#123; if(root == NULL) return ; in_order_node(root-&gt;lchild); in_order_node(root-&gt;rchild); printf(&quot;%c &quot;, root-&gt;data); return ;&#125;// 后void post_order(Tree *tree) &#123; if(tree == NULL) return ; printf(&quot;post_order (%d) : &quot;, tree-&gt;length); post_order_node(tree-&gt;root); printf(&quot;\\n&quot;); return ;&#125;int main() &#123; char str[1000] = &#123;0&#125;; int node_num = 0; scanf(&quot;%[^\\n]s&quot;, str); getchar(); Tree *tree = getNewTree(); tree-&gt; root = build(str, &amp;node_num); tree-&gt;length = node_num; pre_order(tree); in_order(tree); post_order(tree); return 0;&#125;","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"广义表转二叉树","slug":"广义表转二叉树","permalink":"https://tutouwang.vercel.app/tags/%E5%B9%BF%E4%B9%89%E8%A1%A8%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"树与二叉树","slug":"基础数据结构/树与二叉树","date":"2022-01-17T06:34:23.000Z","updated":"2022-05-22T15:05:06.433Z","comments":true,"path":"2022/01/17/基础数据结构/树与二叉树/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/17/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"树根节点 可以看成一个集合 链接的线可以看成关系 跟节点下面的子集 怎么判断机叉树：其中某个节点最多的子孩子个数 下面就是一个三叉树 树的高度-深度 节点4深度 2 是从根节点向下看 节点4高度 4 是从节点8向上看是4 从节点6向上看是 2 取最大 4 节点4高度 分层看 也是4 什么是节点的度 数据结构的理解 度 &#x3D; 出度 + 入度 图 在数据结构树的描述中 度 &#x3D;&#x3D; 出度 从当前节点有多少条出边 节点数量等于边数+1 树 转 二叉树树 转换成 二叉树 左孩子 - 右兄弟 十字链表法 二叉树 最多有2个子孩子叫二叉树 - 度最大为2 节点1出度指向 节点 2 和 节点3 分别为 左孩子 和 右孩子 为什么要讲二叉树 因为所有的树都可以转换成2叉树 度为0的节点比度为2的节点多1个 二叉树中 有度为0 (n0)， 1(n1)， 2(n0) 节点个数等于边数加1 n0 + n1 + n2 &#x3D; 0 + n1 + 2 * n2 + 1 n0 &#x3D; n2 + 1 二叉树 - 遍历 前序遍历 ： 根、左、右 — 根、左子树、右子树 ： 1， 2， 4，5，3，6 中序遍历 ： 左、根、右 — 左子树、根、右子树 ： 4，2，5，1，3，6 后序遍历 ： 左、右、根 — 左子树、右子树 、根 ：4，5，2，6，3，1 1.先序遍历- root - 左 - 右 123456void dfs(root) &#123; if(root) return ; f.push_back(roo-&gt;val); dfs(root-&gt;left); dfs(root-&gt;right);&#125; 2.中序遍历 左 - root - 右 123456void dfs(root) &#123; if(root) return ; dfs(root-&gt;left); f.push_back(root-&gt;val); dfs(root-&gt;right);&#125; 3.后序遍历 左 - 右 - root 123456void dfs(root) &#123; if(root) return ; dfs(root-&gt;left); dfs(root-&gt;right); f.push_back(root-&gt;val);&#125; 二叉树 - 中国版 完全二叉 只会有一个度为 1 的节点 缺省的只会是右孩子 满二叉树 每一个层都会满满的 二叉树 - 国际版 二叉树 - 完全二叉树 编号为 i 的子节点 左孩子编号 ：2 * i 右孩子编号 ： 2 * i + 1 可以用连续空间存储（数组）可以用顺序表实现！(更节省空间) 二叉树 - 广义表 广义表如何还原成一科二叉树 推荐使用第一种和第二种 二叉树代码实现 引入二叉排序树的概念 存在一课二叉树中三元组 广义表中 A, B, C A &gt; B &amp;&amp; A &lt; C (维护性质) 中序遍历就可以得到一个有序序列 前、中、后 遍历序列 得到中序和任意两种就可以还原出一课树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/************************************************************************* &gt; File Name: 二叉树.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月17日 星期一 16时25分06秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Node &#123; int data; struct Node *lchild, *rchild;&#125; Node;typedef struct Tree &#123; Node *root; int length;&#125; Tree;Node *getNewNode(int val) &#123; // 为什么使用calloc(对象数目, 每个对象大小)可以自动初始化。 Node *p = (Node *)calloc(1, sizeof(Node)); p-&gt;data = val; // 可省去 // p-&gt;lchild = NULL; // p-&gt;rchild = NULL; return p;&#125;Tree *getNewTree() &#123; Tree *tree = (Tree *)malloc(sizeof(Tree)); tree-&gt;root = NULL; tree-&gt;length = 0; return tree;&#125;void clear_node(Node *root) &#123; if(root == NULL) return ; clear_node(root-&gt;lchild); clear_node(root-&gt;rchild); free(root); return ;&#125;void clear(Tree *tree) &#123; if(tree == NULL) return ; clear_node(tree-&gt;root); free(tree); return ;&#125;// A &gt; B &amp;&amp; A &lt; CNode *insert_node(Node *root, int val, int *falg) &#123; if(root == NULL) &#123; *falg = 1; return getNewNode(val); &#125; if(root-&gt;data == val) return root; if(root-&gt;data &lt; val) root-&gt;rchild = insert_node(root-&gt;rchild, val, falg); else root-&gt;lchild = insert_node(root-&gt;lchild, val,falg); return root;&#125;// 这插入是根据二叉排序树 不会插入重复元素 falg = 标记void insert(Tree *tree, int val) &#123; if(tree == NULL) return ; int falg = 0; tree-&gt;root = insert_node(tree-&gt;root, val, &amp;falg); tree-&gt;length += falg; return ;&#125;// 前序void pre_order_node(Node *root) &#123; if(root == NULL) return ; printf(&quot;%d &quot;, root-&gt;data); pre_order_node(root-&gt;lchild); pre_order_node(root-&gt;rchild); return ;&#125;// 前序 根 左 右void pre_order(Tree *tree) &#123; if(tree == NULL) return ; printf(&quot;pre_order : [&quot;); pre_order_node(tree-&gt;root); printf(&quot;]\\n&quot;); return ;&#125;// 中序void in_order_node(Node *root) &#123; if(root == NULL) return ; in_order_node(root-&gt;lchild); printf(&quot;%d &quot;, root-&gt;data); in_order_node(root-&gt;rchild); return ;&#125;// 中序 左 根 右void in_order(Tree *tree) &#123; if(tree == NULL) return ; printf(&quot;in_order : [&quot;); in_order_node(tree-&gt;root); printf(&quot;]\\n&quot;); return ;&#125;// 后序void post_order_node(Node *root) &#123; if(root == NULL) return ; post_order_node(root-&gt;lchild); post_order_node(root-&gt;rchild); printf(&quot;%d &quot;, root-&gt;data); return ;&#125;// 后序 左 右 根void post_order(Tree *tree) &#123; if(tree == NULL) return ; printf(&quot;post_order : [&quot;); post_order_node(tree-&gt;root); printf(&quot;]\\n&quot;); return ;&#125;void output_node(Node *root) &#123; if(root == NULL) return ; printf(&quot;%d &quot;, root-&gt;data); if(root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) return ; printf(&quot;(&quot;); output_node(root-&gt;lchild); printf(&quot;, &quot;); output_node(root-&gt;rchild); printf(&quot;)&quot;); return ;&#125;// 广义表打印void output(Tree *tree) &#123; if(tree == NULL) return ; printf(&quot;tree(%d) : &quot;, tree-&gt;length); output_node(tree-&gt;root); return ;&#125;int main() &#123; srand(time(0)); #define MAX_OP 5 Tree *tree = getNewTree(); for(int i = 0; i &lt; MAX_OP; i++) &#123; int val = rand() % 100; insert(tree, val); output(tree), printf(&quot;\\n&quot;); &#125; pre_order(tree); in_order(tree); post_order(tree); #undef MAX_OP clear(tree); return 0;&#125;","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树与二叉树","slug":"树与二叉树","permalink":"https://tutouwang.vercel.app/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"栈与队列","slug":"基础数据结构/栈与队列","date":"2022-01-16T01:45:23.000Z","updated":"2022-05-22T15:05:06.437Z","comments":true,"path":"2022/01/16/基础数据结构/栈与队列/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/16/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","excerpt":"","text":"队列 (FIFO)结构操作：尾部入队、头部出队（排队做核酸！捅一个走一个 哈哈哈！） FIFO first in firas out : 先进先出 结构定义： 队列长度 (length) 队头位置 (head) 队尾位置 (tail) 任意类型元素 (data_type) (int \\ char) 连续空间存储 循环队列在队列结构定义之上 count 计数 (count) 可判断满和空 tail % leng 出队操作 - 入队操作 出队 (head +&#x3D; 1) 入队 (tail +&#x3D; 1) 假溢出出队操作 - 入队操作 - 假溢出优化 入队 (q-&gt;count !&#x3D; q-&gt;length) 当前队列数据总长度 (count)、队列总长度 (q-&gt;length) 满足条件情况： q-&gt;data[q-&gt;tail++] &#x3D; val; if(q-&gt;tail &#x3D;&#x3D; q-&gt;leng ) q-&gt;tail &#x3D; 0; q-&gt;count++; 出队 empty(q) 是否存在元素 满足条件情况： q-&gt;head++; if(q-&gt;head &#x3D;&#x3D; q-&gt;leng) q-&gt;head &#x3D; 0; q-&gt;count–; 队列代码演示 - 无假溢出优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/************************************************************************* &gt; File Name: 队列 - 假溢出.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月16日 星期日 09时44分03秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Queue &#123; int *data; int head, tail; int length;&#125; Queue;Queue *init(int n) &#123; Queue *q = (Queue *)malloc(sizeof(Queue)); q-&gt;data = (int *)malloc(sizeof(int) * n); q-&gt;head = 0; q-&gt;tail = 0; q-&gt;length = n; return q;&#125;int push(Queue *q, int val) &#123; // 空 if(q == NULL) return 0; // 满 if(q-&gt;tail == q-&gt;length) return 0; q-&gt;data[q-&gt;tail++] = val; return 1;&#125;int empty(Queue *q) &#123; return q-&gt;tail == q-&gt;head;&#125;int pop(Queue *q) &#123; if(q == NULL) return 0; if(empty(q)) return 0; q-&gt;head++; return 1;&#125;int front(Queue *q) &#123; if(q == NULL) return -1; return q-&gt;data[q-&gt;head];&#125;void clear(Queue *q) &#123; if(q == NULL) return ; free(q-&gt;data); free(q); return ;&#125;void output(Queue *q) &#123; if(q == NULL) return ; printf(&quot;Queue(%d) [&quot;, q-&gt;length); for(int i = q-&gt;head; i &lt; q-&gt;tail; i++) &#123; i != q-&gt;head &amp;&amp; printf(&quot;,&quot;); printf(&quot;%d&quot;, q-&gt;data[i]); &#125; printf(&quot;]&quot;); printf(&quot;\\n&quot;); return ;&#125;int main() &#123; #define MAX_OP 20 srand(time(0)); Queue *q = init(MAX_OP); for(int i = 0; i &lt; MAX_OP; i++) &#123; // 0 1 2 int op = rand() % 3; int val = rand() % 100; switch(op) &#123; case 0: &#123; if(!empty(q)) &#123; printf(&quot;pop front from the Queue = %d \\n&quot;, pop(q)); &#125; &#125; break; case 1: &#123; printf(&quot;push %d to the Queue = %d\\n&quot;, val, push(q, val)); &#125; break; case 2: &#123; printf(&quot;front one from Queue = %d\\n&quot;, front(q)); &#125; break; &#125; output(q), printf(&quot;\\n&quot;); &#125; #undef MAX_OP clear(q); return 0;&#125; 队列代码演示 - 假溢出优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/************************************************************************* &gt; File Name: 队列 - 假溢出优化.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月16日 星期日 09时44分03秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Queue &#123; int *data; int head, tail; int length; int count;&#125; Queue;Queue *init(int n) &#123; Queue *q = (Queue *)malloc(sizeof(Queue)); q-&gt;data = (int *)malloc(sizeof(int) * n); q-&gt;head = 0; q-&gt;tail = 0; q-&gt;count = 0; q-&gt;length = n; return q;&#125;int push(Queue *q, int val) &#123; // 空 if(q == NULL) return 0; // 满 if(q-&gt;length == q-&gt;count) return 0; q-&gt;data[q-&gt;tail++] = val; if(q-&gt;tail == q-&gt;length) q-&gt;tail = 0; q-&gt;count++; return 1;&#125;int empty(Queue *q) &#123; return q-&gt;count == 0;&#125;int pop(Queue *q) &#123; if(q == NULL) return 0; if(empty(q)) return 0; q-&gt;head++; if(q-&gt;head == q-&gt;length) q-&gt;head = 0; q-&gt;count--; return 1;&#125;int front(Queue *q) &#123; if(q == NULL) return -1; return q-&gt;data[q-&gt;head];&#125;void clear(Queue *q) &#123; if(q == NULL) return ; free(q-&gt;data); free(q); return ;&#125;void output(Queue *q) &#123; if(q == NULL) return ; printf(&quot;Queue(%d) [&quot;, q-&gt;length); for(int i = q-&gt;head, j = 0; j &lt; q-&gt;count; j++) &#123; j &amp;&amp; printf(&quot;,&quot;); printf(&quot;%d&quot;, q-&gt;data[(i + j) % q-&gt;length]); &#125; printf(&quot;]&quot;); printf(&quot;\\n&quot;); return ;&#125;int main() &#123; #define MAX_OP 20 srand(time(0)); Queue *q = init(4); for(int i = 0; i &lt; MAX_OP; i++) &#123; // 0 1 2 int op = rand() % 3; int val = rand() % 100; switch(op) &#123; case 0: &#123; if(!empty(q)) &#123; printf(&quot;pop front from the Queue = %d \\n&quot;, pop(q)); &#125; &#125; break; case 1: &#123; printf(&quot;push %d to the Queue = %d\\n&quot;, val, push(q, val)); &#125; break; case 2: &#123; printf(&quot;front one from Queue = %d\\n&quot;, front(q)); &#125; break; &#125; output(q), printf(&quot;\\n&quot;); &#125; #undef MAX_OP clear(q); return 0;&#125; 队列代码演示 - 假溢出优化 - 自动扩容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/************************************************************************* &gt; File Name: 栈与队列.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月16日 星期日 09时44分03秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Queue &#123; int *data; int head, tail; int length; int count;&#125; Queue;Queue *init(int n) &#123; Queue *q = (Queue *)malloc(sizeof(Queue)); q-&gt;data = (int *)malloc(sizeof(int) * n); q-&gt;head = 0; q-&gt;tail = 0; q-&gt;count = 0; q-&gt;length = n; return q;&#125;int expand(Queue *q) &#123; int extr_size = q-&gt;length; int *p; while(extr_size) &#123; p = (int *)malloc(sizeof(int) * (extr_size + q-&gt;length)); // 不能用 realloc if(p != NULL) break; extr_size &gt;&gt;= 1; &#125; if(p == NULL) return 0; for(int i = q-&gt;head, j = 0; j &lt; q-&gt;count; j++) &#123; p[j] = q-&gt;data[(i + j) % q-&gt;length]; &#125; q-&gt;data = p; q-&gt;head = 0, q-&gt;tail = q-&gt;count; q-&gt;length += extr_size; return 1;&#125;int push(Queue *q, int val) &#123; // 空 if(q == NULL) return 0; // 满 if(q-&gt;length == q-&gt;count) &#123; if(!expand(q)) &#123; printf(&quot;自动扩容失败！\\n&quot;); return 0; &#125; printf(&quot;自动扩容成功！\\n&quot;); &#125; q-&gt;data[q-&gt;tail++] = val; if(q-&gt;tail == q-&gt;length) q-&gt;tail = 0; q-&gt;count++; return 1;&#125;int empty(Queue *q) &#123; return q-&gt;count == 0;&#125;int pop(Queue *q) &#123; if(q == NULL) return 0; if(empty(q)) return 0; q-&gt;head++; if(q-&gt;head == q-&gt;length) q-&gt;head = 0; q-&gt;count--; return 1;&#125;int front(Queue *q) &#123; if(q == NULL) return -1; return q-&gt;data[q-&gt;head];&#125;void clear(Queue *q) &#123; if(q == NULL) return ; free(q-&gt;data); free(q); return ;&#125;void output(Queue *q) &#123; if(q == NULL) return ; printf(&quot;Queue(%d) [&quot;, q-&gt;length); for(int i = q-&gt;head, j = 0; j &lt; q-&gt;count; j++) &#123; j &amp;&amp; printf(&quot;,&quot;); printf(&quot;%d&quot;, q-&gt;data[(i + j) % q-&gt;length]); &#125; printf(&quot;]&quot;); printf(&quot;\\n&quot;); return ;&#125;int main() &#123; #define MAX_OP 20 srand(time(0)); Queue *q = init(1); for(int i = 0; i &lt; MAX_OP; i++) &#123; // 0 1 2 int op = rand() % 3; int val = rand() % 100; switch(op) &#123; case 0: &#123; if(!empty(q)) &#123; printf(&quot;pop front from the Queue = %d \\n&quot;, pop(q)); &#125; &#125; break; case 1: &#123; printf(&quot;push %d to the Queue = %d\\n&quot;, val, push(q, val)); &#125; break; case 2: &#123; printf(&quot;front one from Queue = %d\\n&quot;, front(q)); &#125; break; &#125; output(q), printf(&quot;\\n&quot;); &#125; #undef MAX_OP clear(q); return 0;&#125; 栈 (FILO) - (手枪弹夹🔫)FILO first in last out : 先进后出 结构定义： 栈大小 (size) 栈顶指针 (top) 栈中元素 (data_type) 连续空间存储 栈代码演示 - 自动扩容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/************************************************************************* &gt; File Name: 栈.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月16日 星期日 17时20分08秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Stack &#123; int *data; int size; int top;&#125; Stack;Stack *init(int n) &#123; Stack *s = (Stack *) malloc(sizeof(Stack)); s-&gt;data = (int *)malloc(sizeof(int) * n); s-&gt;size = n; s-&gt;top = -1; return s;&#125;void clear(Stack *s) &#123; if(s == NULL) return ; free(s-&gt;data); free(s); return ;&#125;int expand(Stack *s) &#123; int extr_size = s-&gt;size; int *p; while(extr_size) &#123; p = (int *) realloc(s-&gt;data,sizeof(int) * ( extr_size * s-&gt;size)); if(p != NULL) break; extr_size &gt;&gt;= 1; &#125; if(p == NULL) return 0; s-&gt;data = p; s-&gt;size += extr_size; return 1;&#125;int push(Stack *s, int val) &#123; if(s == NULL) return 0; if(s-&gt;top == s-&gt;size - 1) &#123; if(!expand(s)) &#123; printf(&quot;自动扩容失败！\\n&quot;); return 0; &#125; printf(&quot;自带扩容成功！\\n&quot;); &#125; s-&gt;data[++(s-&gt;top)] = val; return 1;&#125;int empty(Stack *s) &#123; if(s == NULL) return 1; return s-&gt;top == -1;&#125;int pop(Stack *s) &#123; if(s == NULL) return 0; if(empty(s)) return 0; s-&gt;top--; return 1;&#125;int top(Stack *s) &#123; if(s == NULL) return 0; if(empty(s)) return 0; return s-&gt;data[s-&gt;top];&#125;void output(Stack *s) &#123; if(s == NULL) return ; printf(&quot;Stack(%d, %d) : [&quot;, s-&gt;size, s-&gt;top); for(int i = s-&gt;top; ~i; i--) &#123; i != s-&gt;top &amp;&amp; printf(&quot;, &quot;); printf(&quot;%d&quot;, s-&gt;data[i]); &#125; printf(&quot;]\\n&quot;); return ;&#125;int main() &#123; srand(time(0)); #define MAX_OP 20 Stack *s = init(1); for(int i = 0; i &lt; MAX_OP; i++) &#123; int val = rand() % 100; int op = rand() % 3; switch(op) &#123; case 0: &#123; if(s != NULL) printf(&quot;top %d from the Stack \\n&quot;, top(s)); &#125; break; case 1: &#123; printf(&quot;push %d to the Stack = %d\\n&quot;, val, push(s, val)); &#125; break; case 2: &#123; if(s != NULL) printf(&quot;pop %d from the Stack \\n&quot;, pop(s)); &#125; break; &#125; output(s), printf(&quot;\\n&quot;); &#125; #undef MAX_OP clear(s); return 0;&#125; 链栈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/************************************************************************* &gt; File Name: 链栈.cpp &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月18日 星期二 16时28分15 秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct StackNode &#123; int data; StackNode *next;&#125; StackNode;typedef struct LinkStack &#123; StackNode *top; int length;&#125; LinkStack;StackNode *init_node(int val) &#123; StackNode *p = (StackNode * )malloc(sizeof(StackNode)); p-&gt;data = val; p-&gt;next = NULL; return p;&#125;LinkStack *init_stack() &#123; LinkStack *l = (LinkStack *)malloc(sizeof(LinkStack)); l-&gt;top = NULL; l-&gt;length = 0; return l;&#125;int empty(LinkStack *l) &#123; return l-&gt;top == NULL;&#125;int Stack_top(LinkStack *l) &#123; if(empty(l)) return -1; return l-&gt;top-&gt;data;&#125;int push(LinkStack *l, int val) &#123; if(l == NULL) return 0; StackNode *node = init_node(val); node-&gt;next = l-&gt;top; l-&gt;top = node; l-&gt;length += 1; return 1;&#125;void clear_node(StackNode *node) &#123; if(node == NULL) return ; free(node); return ;&#125;void clear(LinkStack *l) &#123; if(l == NULL) return ; StackNode *p = l-&gt;top, *t; while(p) &#123; t = p-&gt;next; clear_node(p); p = t; &#125; free(l); return ;&#125;int pop(LinkStack *l) &#123; if(l == NULL) return 0; if(empty(l)) return 0; StackNode *p = l-&gt;top; l-&gt;top = l-&gt;top-&gt;next; clear_node(p); l-&gt;length -= 1; return 1;&#125;void output_node(StackNode *p) &#123; if(p == NULL) return ; while(p) &#123; printf(&quot;%d &quot;, p-&gt;data); p = p-&gt;next; &#125; return ;&#125;void output(LinkStack *l) &#123; if(l == NULL) return ; printf(&quot;LinkStack(%d) : &quot;, l-&gt;length); output_node(l-&gt;top); printf(&quot;\\n&quot;); return ;&#125;int main() &#123; srand(time(0)); #define MAX_OP 20 LinkStack *s = init_stack(); for(int i = 0; i &lt; MAX_OP; i++) &#123; int op = rand() % 2; int val = rand() % 100; switch(op) &#123; case 0 : &#123; printf(&quot;pop %d from the LinkStack = &quot;, Stack_top(s)); printf(&quot;%d\\n&quot;, pop(s)); &#125; break; case 1 : &#123; printf(&quot;push %d to the form LinkStack = %d\\n&quot;, val, push(s, val)); &#125; break; &#125; output(s), printf(&quot;\\n&quot;); &#125; return 0;&#125; &#x2F;&#x2F; 待做 链栈、链队列、循环队列扩容、还没实现","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈与队列","slug":"栈与队列","permalink":"https://tutouwang.vercel.app/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"}]},{"title":"链表","slug":"基础数据结构/链表","date":"2022-01-15T02:32:20.000Z","updated":"2022-05-22T15:05:06.433Z","comments":true,"path":"2022/01/15/基础数据结构/链表/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/15/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"单向链表结点组成部分 数据域 - data 指针域 - next &#x2F; 后继 插入 - 结点 把待插入数据创建成一个结点 把待插入结点指向新建结点的next 把待插入结点前一个结点的next指向新建结点 代码演示 - 单向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/************************************************************************* &gt; File Name: 链表.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月15日 星期六 11时09分25秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define COLOR_HL(a, b) &quot;\\033[1;&quot; #b &quot;m&quot; a &quot;\\033[0m&quot;#define GREEN_HL(a) COLOR_HL(a, 32)typedef struct ListNode &#123; int data; struct ListNode *next;&#125; ListNode;typedef struct List &#123; // 虚拟头 ListNode head; int length;&#125; List;ListNode *getNewNode(int);List *getLinkList();void clear_node(ListNode *);void clear(List *);int insert(List*, int, int);int erase(List *, int);void reverse(List *);ListNode* getNewNode(int val) &#123; // sizeof ListNode 可以不加括号 可能是在c语言中不行 ListNode *p = (ListNode *) malloc(sizeof (ListNode)); p-&gt;data = val; p-&gt;next = NULL; return p;&#125;List *getLinkList() &#123; List *l = (List *)malloc(sizeof(List)); l-&gt;head.next = NULL; l-&gt;length = 0; return l;&#125;void clear_node(ListNode *node) &#123; if(node == NULL) return ; free(node); return ;&#125;void clear(List * l) &#123; if(l == NULL) return ; ListNode *p = l-&gt;head.next; ListNode *t = NULL; if(p != NULL) &#123; t = p-&gt;next; clear_node(p); p = t; &#125; free(l); return ;&#125;int insert(List *l, int ind, int val) &#123; if(l == NULL) return 0; if(ind &lt; 0 || ind &gt; l-&gt;length) return 0; ListNode *p = getNewNode(val); ListNode *h = &amp;(l-&gt;head); while(ind--) h = h-&gt;next; p-&gt;next = h-&gt;next; h-&gt;next = p; l-&gt;length++; return 1;&#125;int erase(List *l, int ind) &#123; if(l == NULL) return 0; if(ind &lt; 0 || ind &gt;= l-&gt;length) return 0; ListNode *h = &amp;(l-&gt;head); // 这里说明一下为什么不 直接 h-&gt;next = h-&gt;next-&gt;next; // 1. 这个操作是合法的 但是要这样操作的就会发生内存泄漏 // 2. 所有我们这里需要一个临时变量 t 来存储待删除结点 之后好free掉 ListNode *t = NULL; while(ind--) h = h-&gt;next; t = h-&gt;next; h-&gt;next = t-&gt;next; l-&gt;length--; clear_node(t); return 1;&#125;void output(List *l) &#123; if(l == NULL) return ; printf(&quot;List(%d) : &quot;, l-&gt;length); ListNode *h = l-&gt;head.next; while(h != NULL) &#123; printf(&quot;%d-&gt;&quot;, h-&gt;data); h = h-&gt;next; &#125; printf(&quot;NULL\\n\\n&quot;);&#125;void reverse(List *l) &#123; if(l == NULL) return ; ListNode *h = l-&gt;head.next; l-&gt;head.next = NULL; ListNode *t = NULL; while(h != NULL) &#123; t = h-&gt;next; t = l-&gt;head.next; l-&gt;head.next = h; h = t; &#125; return ;&#125;int main() &#123; srand(time(0)); // 20 次测试 #define MAX_OP 20 List *l = getLinkList(); for(int i = 0; i &lt; MAX_OP; i++) &#123; int val = rand() % 100; int ind = rand() % (l-&gt;length + 3) - 1; // 想变大插入概率 可以把 2 变成 4 // case 0 1 2 3 int op = rand() % 3; switch(op) &#123; case 0: &#123; printf(&quot;erase a iterm at %d from List = %d \\n&quot;, ind, erase(l, ind)); break; &#125; case 1: &#123; printf(&quot;insert %d at %d to List = %d \\n&quot;, val, ind, insert(l, ind, val)); break; &#125; case 2: &#123; printf(GREEN_HL(&quot;reverse the list ! \\n&quot;)); reverse(l); break; &#125; &#125; output(l); &#125; #undef MAX_OP clear(l); return 0;&#125; 单线循环链表 头- -&gt; 尾 双向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/************************************************************************* &gt; File Name: 双向链表.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月18日 星期二 17时05分55 秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Node &#123; int data; struct Node *next, *pre;&#125; Node;typedef struct Dlist &#123; Node head; int length;&#125; Dlist;Node *getNewNode(int val) &#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;data = val; p-&gt;next = p-&gt;pre = NULL; return p;&#125;Dlist *init_list() &#123; Dlist *l = (Dlist *)malloc(sizeof(Dlist)); l-&gt;head.next = NULL; l-&gt;length = 0; return l;&#125;int insert(Dlist *l, int ind, int val) &#123; if(l == NULL) return 0; if(ind &lt; 0 || ind &gt; l-&gt;length) return 0; Node *p = &amp;(l-&gt;head), *node = getNewNode(val); while(ind--) p = p-&gt;next; node-&gt;next = p-&gt;next; p-&gt;next = node; node-&gt;pre = p; if(node-&gt;next != NULL) node-&gt;next-&gt;pre = node; l-&gt;length ++; return 1;&#125;void clear_node(Node *node) &#123; if(node == NULL) return ; free(node); return ;&#125;void clear(Dlist *l) &#123; if(l == NULL) return ; Node *p = l-&gt;head.next, *t; while(p) &#123; t = p-&gt;next; clear_node(p); p = t; &#125; free(l); return ;&#125;int erase(Dlist *l, int ind) &#123; if(l == NULL ) return 0; if(ind &lt; 0 || ind &gt;= l-&gt;length) return 0; Node *p= &amp;(l-&gt;head), *t; while(ind--) p = p-&gt;next; t = p-&gt;next; p-&gt;next = t-&gt;next; if(t-&gt;next != NULL) t-&gt;next-&gt;pre = p; clear_node(t); l-&gt;length--; return 1;&#125;void l_output(Dlist *l) &#123; if(l == NULL) return ; printf(&quot;L-Dlist(%d) : &quot;, l-&gt;length); for(Node *p = l-&gt;head.next; p; p = p-&gt;next) &#123; printf(&quot;%d-&gt;&quot;, p-&gt;data); &#125; printf(&quot;NULL\\n&quot;); return ;&#125;void r_output(Dlist *l) &#123; if(l == NULL) return ; printf(&quot;L-Dlist(%d) : &quot;, l-&gt;length); int ind = 0; Node *p = &amp;(l-&gt;head); while(ind++ != l-&gt;length) p = p-&gt;next; for(; p != &amp;(l-&gt;head); p = p-&gt;pre) &#123; printf(&quot;%d-&gt;&quot;, p-&gt;data); &#125; printf(&quot;head\\n&quot;); return ;&#125;int main() &#123; #define MAX_OP 20 Dlist *l = init_list(); for(int i = 0; i &lt; MAX_OP; i++) &#123; int val = rand() % 100; int ind = rand() % (l-&gt;length + 3) - 1; int op = rand() % 2; switch(op) &#123; case 0 : &#123; printf(&quot;erase a iterm at %d form lis = %d&quot;, ind, erase(l, ind)); &#125; break; case 1 : &#123; printf(&quot;insert %d at %d to Lis = %d\\n&quot;, val, ind, insert(l, ind, val)); &#125; break; &#125; l_output(l); r_output(l), printf(&quot;\\n&quot;); &#125; #undef MAX_OP clear(l); return 0;&#125; 链表翻转 力扣206","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://tutouwang.vercel.app/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"顺序表","slug":"基础数据结构/顺序表","date":"2022-01-14T03:11:14.000Z","updated":"2022-01-19T03:29:03.317Z","comments":true,"path":"2022/01/14/基础数据结构/顺序表/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/14/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/","excerpt":"","text":"数据结构 &#x3D; 结构定义 + 结构操作cppreference https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5 顺序表 - 线性结构：一对一1.什么是顺序表？ 是一个更高级的数组 结构定义： 一片连续存储空间 可以存储任意类型值 (类型需要一致，int、char、结构体…) (data_type) 顺序表大小 (size) 顺序表以存储个数 (length) 结构操作： 插入元素 (insert) 如果第一个满足只执行1不满足可以直接执行 2 可以通过整理 直接用2来实现 如果代插入数据i 等于i == length 那么直接在后面添加length++ 在待插入位置i 把i + 1 后数据全部向后移动一位,并且legth++ 删除元素 (clear) 待删位置 i 把i + 1之后位置的数据向前移动一位 覆盖掉 length-- 新知识1234567891011121314151617181920212223242526272829#include &lt;stdlib.h&gt; // malloc 需要头文件#include &lt;stdio.h&gt;#demine MAX_N 20/* 函数中 // int arr[n + 1]; // 栈区 在Linux系统中只有 8M 很小 * malloc 动态开辟空间 如果不用需要主动释放 返回值是一块连续的地址(逻辑上) void* * calloc 参数size为申请地址的单元元素长度，nmemb为元素个数，即在内存中申请nmemb *size字节大小的连续地址空间， 并赋值0-相当于自带初始化； * realloc 给一个已经分配了地址的指针重新分配空间，参数ptr为原有的空间地址，size为重新申请的地址长度； * free 释放 **/int main() &#123; // 函数 malloc int *v = (int *) malloc(sizeof(int) * MAX_N); free(v); v = NULL; // 函数 calloc int *v1 = (int *) calloc(20, MAX_N * sizeof(int)); free(v); v = NULL; // 函数 realloc 在 malloc 基础上 // 数字数量大于当前 malloc 大小 重新分配 int *v = (int *) malloc(sizeof(int) * MAX_N); v = (int *) realloc (v, 5 * sizeof(int) * MAX_N); free(v); v = NULL; return 0;&#125; 代码演示-顺序表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/************************************************************************* &gt; File Name: 顺序表.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月14日 星期五 12时03分03秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define COLOR(a, b) &quot;\\033[&quot; #b &quot;m&quot; a&quot;\\033[0m&quot;#define GREEN(a) COLOR(a, 32)#define RED(a) COLOR(a, 31)typedef int Type;typedef struct Vector &#123; Type *data; int size, length;&#125; Vec;Vec *init(int n) &#123; // int arr[n + 1]; // 栈区 在Linux系统中只有 8M 很小 Vec *v = (Vec *)malloc(sizeof(Vec)); v-&gt;data = (Type *)malloc(sizeof(Type) * n); v-&gt;size = n; v-&gt;length = 0; return v;&#125;void clear(Vec *v) &#123; if(v == NULL) return ; // 如果内存申请失败 free(v-&gt;data); // 申请了2个空间 free(v); return ;&#125;// 扩容int expand(Vec *v) &#123; int extr_size = v-&gt;size; Type *p; while(extr_size) &#123; p = (Type *)realloc(v-&gt;data, sizeof(Type) * (v-&gt;size + extr_size)); if(p != NULL) break; extr_size &gt;&gt;= 1; &#125; if(p == NULL) &#123; printf(RED(&quot;扩容失败\\n&quot;)); return 0; &#125; v-&gt;size += extr_size; v-&gt;data = p; printf(GREEN(&quot;当前容量 : %d -- 扩容到 : %d\\n&quot;), v-&gt;size - extr_size, v-&gt;size); return 1;&#125;int insert(Vec *v, int ind, Type val) &#123; // ind 需要插入的位置 if(v == NULL) return 0; if(ind &lt; 0 || ind &gt; v-&gt;length) return 0; if(v-&gt;length == v-&gt;size) &#123; if(!expand(v)) return 0; &#125; for(int i = v-&gt;length; i &gt; ind; i--) &#123; v-&gt;data[i] = v-&gt;data[i - 1]; &#125; v-&gt;data[ind] = val; v-&gt;length +=1; return 1;&#125;int erase(Vec *v, int ind) &#123; if(v == NULL) return 0; if(ind &lt; 0 || ind &gt;= v-&gt;length) return 0; for(int i = ind + 1; i &lt; v-&gt;length; i++) &#123; v-&gt;data[i - 1] = v-&gt;data[i]; &#125; v-&gt;length--; return 1;&#125;void output(Vec *v) &#123; if(v == NULL) return ; printf(&quot;Vector(%d) :[&quot;, v-&gt;length); for(int i = 0; i &lt; v-&gt;length; i++) &#123; i &amp;&amp; printf(&quot;,&quot;); printf(&quot;%d&quot;, v-&gt;data[i]); &#125; printf(&quot;]\\n&quot;); return ;&#125;int main() &#123; #define MAX_N 20 Vec *v = init(1); srand(time(0)); for(int i = 0; i &lt; MAX_N; i++) &#123; int op = rand() % 2; int ind = rand() % (v-&gt;length + 3) - 1; int val = rand() % 100; switch(op) &#123; case 0: printf(&quot;insert %d at %d to Vector = %d \\n&quot;, val, ind, insert(v, ind, val)); break; case 1: printf(&quot;erase a iterm at %d from Vector = %d\\n&quot;, ind, erase(v, ind)); break; &#125; output(v), printf(&quot;\\n&quot;); &#125; clear(v); #undef MAX_N return 0;&#125;","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"顺序表","slug":"顺序表","permalink":"https://tutouwang.vercel.app/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}]},{"title":"StackReverse","slug":"有趣的知识/StackReverse","date":"2022-01-06T02:14:14.000Z","updated":"2022-01-19T02:40:43.592Z","comments":true,"path":"2022/01/06/有趣的知识/StackReverse/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/06/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/StackReverse/","excerpt":"","text":"Stack - 翻转1234567891011121314151617181920212223242526272829303132333435363738394041424344/************************************************************************* &gt; File Name: stackRecerse.cpp &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月06日 星期四 10时15分16秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;void reverseStack(stack&lt;string&gt; &amp;f, string &amp;res) &#123; // 当然这里 string res 也可以写成另一个 栈 这里这个引用会加点速 if(!f.empty()) &#123; string t = f.top(); f.pop(); reverseStack(f, res); res += t + &quot; &quot;; &#125; return ;&#125;int main() &#123; stack&lt;string&gt; f, f1; f.push(&quot;a&quot;); f.push(&quot;b&quot;); f.push(&quot;c&quot;); f.push(&quot;d&quot;); f.push(&quot;e&quot;); f.push(&quot;f&quot;); f1 = f; while(!f1.empty()) &#123; cout &lt;&lt; f1.top() &lt;&lt; &quot; &quot;; f1.pop(); &#125; cout &lt;&lt; endl; string res; reverseStack(f, res); cout &lt;&lt; res; return 0;&#125;","categories":[{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"将b进制数转化成十进制","slug":"有趣的知识/将b进制数转化成十进制","date":"2022-01-05T12:38:52.000Z","updated":"2022-01-19T02:42:48.862Z","comments":true,"path":"2022/01/05/有趣的知识/将b进制数转化成十进制/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/05/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E5%B0%86b%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E5%8C%96%E6%88%90%E5%8D%81%E8%BF%9B%E5%88%B6/","excerpt":"","text":"秦九韶算法-将b进制数转化成十进制有二进制1010 取出 第一位 1 1 * 2 + 0 &#x3D; 2 10 * 2 + 1 &#x3D;&#x3D; 2 * 2 + 1 10 &#x3D; 5 5 * 2 + 0 &#x3D; 10 有二进制1010 二进制转换成十进制:基数乘以权,然后相加 $$ 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0$$ $$ &#x3D; ((1 * 2 + 0) * 2 + 1 ) * 2 + 0$$ 123456int get(string s, b) &#123; int res = 0; for(auto c : s) res = res * b + c- &#x27;0&#x27;; return res;&#125;","categories":[{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"继承","slug":"OOP/继承","date":"2021-11-19T11:50:51.000Z","updated":"2022-05-22T15:05:06.444Z","comments":true,"path":"2021/11/19/OOP/继承/","link":"","permalink":"https://tutouwang.vercel.app/2021/11/19/OOP/%E7%BB%A7%E6%89%BF/","excerpt":"","text":"继承123456789// 派生类 B 基类 Aclass B&#123;public : &#125;;// class A : public B &#123; &#125;; 继承权限影响的什么 类外对于访问子类对继承父类的方法和属性的访问权限 继承的好处： 代码的复用性 逻辑上的递进关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172/************************************************************************* &gt; File Name: 继承.cpp &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2021年11月19日 星期五 19时55分12秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;#define BEGINS(x) namespace x &#123; // namesoace of x#define ENDS(x) &#125; // namespace of xBEGINS(test1)class Base &#123;public : int x;protected : int y;private : int z;&#125;;class public_Bace : public Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected //z = 2; // no, z private &#125;&#125;;class protected_Bace : protected Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected //z = 2; // no, z private &#125;&#125;;class private_Bace : private Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected // z = 2; // no, z private &#125;&#125;;int main() &#123; public_Bace a; // 都是继承父类的方法 // 继承 + x 在父类中的权限 = 表现出来的 a.x = 3; // ok, putback + public = public // a.y = 4; // no, public + protected = protected // a.z = 5; // no, public + private = private protected_Bace b; // b.x = 3; // no, protected + public = protected // b.y = 4; // no, protected + protected = protected // b.z = 5; // no, protected + private = private private_Bace c; // c.x = 3; // no, private + public = private // c.y = 4; // no, private + protected = private // c.z = 5; // no, private + private = private return 0;&#125;ENDS(test1)BEGINS(test2)class Base &#123;public : Base(string name) : class_name(name)&#123;&#125; int x; string class_name;private : int y;&#125;;class A : public Base &#123;public: A() : Base(&quot;class_A&quot;)&#123;&#125;&#125;;class B : public Base &#123;public: B() : Base(&quot;class_B&quot;)&#123;&#125;&#125;;class C : public Base &#123;public: C() : Base(&quot;class_C&quot;)&#123;&#125;&#125;;void func(Base &amp;b) &#123; cout &lt;&lt; &quot;nput class : &quot; &lt;&lt; b.class_name &lt;&lt; endl; return ;&#125;int main() &#123; A a; B b; C c; // 隐式类型转换 子类 -&gt; 父类 func(a); func(b); func(c); cout &lt;&lt; &quot;sizeof(Base) = &quot; &lt;&lt; sizeof(Base) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(A) = &quot; &lt;&lt; sizeof(A) &lt;&lt; endl; return 0;&#125;ENDS(test2)BEGINS(test3)class Base &#123;public : Base(string name) : class_name(name)&#123;&#125; int x; string class_name;private : int y;&#125;;class A : public Base &#123;public: A() : Base(&quot;class_A&quot;)&#123;&#125;&#125;;class B : public Base &#123;public: B() : Base(&quot;class_B&quot;)&#123;&#125;&#125;;class C : public Base &#123;public: C() : Base(&quot;class_C&quot;)&#123;&#125;&#125;;void func(Base *b) &#123; cout &lt;&lt; &quot;nput class : &quot; &lt;&lt; b-&gt;class_name &lt;&lt; endl; return ;&#125;int main() &#123; A a; B b; C c; // 子类的地址也是可以转换成父类的地址 func(&amp;a); func(&amp;b); func(&amp;c); return 0;&#125;ENDS(test3)int main() &#123; // test1::main(); // test2::main(); test3::main(); return 0;&#125; 继承-构造函数构造顺序与析构顺序一定是相反的 先构造一定后析构 先析构子类的属性后析构父类的属性 菱形继承-多继承是不是所有的面向对象语言都允许多继承? 不是 C#、java 是不允许多继承的 A ( run () ) B ( run () ) C ( run () ) D ( run () ) 菱形继承有些场景是可以编译通过但是输出不确定 先是完成 基类构造 在完成 派生类构造 拷贝&amp;赋值–继承先完成父类的拷贝行为 在完成子类的拷贝行为 拷贝行为 拷贝构造函数：显示调用父类拷贝构造 赋值运算符：显示调用父类的赋值运算函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232/************************************************************************* &gt; File Name: 继承.cpp &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2021年11月19日 星期五 19时55分12秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;#define BEGINS(x) namespace x &#123; // namesoace of x#define ENDS(x) &#125; // namespace of xBEGINS(test1)class Base &#123;public : int x;protected : int y;private : int z;&#125;;class public_Bace : public Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected //z = 2; // no, z private &#125;&#125;;class protected_Bace : protected Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected //z = 2; // no, z private &#125;&#125;;class private_Bace : private Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected // z = 2; // no, z private &#125;&#125;;int main() &#123; public_Bace a; // 都是继承父类的方法 // 继承 + x 在父类中的权限 = 表现出来的 a.x = 3; // ok, putback + public = public // a.y = 4; // no, public + protected = protected // a.z = 5; // no, public + private = private protected_Bace b; // b.x = 3; // no, protected + public = protected // b.y = 4; // no, protected + protected = protected // b.z = 5; // no, protected + private = private private_Bace c; // c.x = 3; // no, private + public = private // c.y = 4; // no, private + protected = private // c.z = 5; // no, private + private = private return 0;&#125;ENDS(test1)BEGINS(test2)class Base &#123;public : Base(string name) : class_name(name)&#123;&#125; int x; string class_name;private : int y;&#125;;class A : public Base &#123;public: A() : Base(&quot;class_A&quot;)&#123;&#125;&#125;;class B : public Base &#123;public: B() : Base(&quot;class_B&quot;)&#123;&#125;&#125;;class C : public Base &#123;public: C() : Base(&quot;class_C&quot;)&#123;&#125;&#125;;void func(Base &amp;b) &#123; cout &lt;&lt; &quot;nput class : &quot; &lt;&lt; b.class_name &lt;&lt; endl; return ;&#125;int main() &#123; A a; B b; C c; // 隐式类型转换 子类 -&gt; 父类 func(a); func(b); func(c); cout &lt;&lt; &quot;sizeof(Base) = &quot; &lt;&lt; sizeof(Base) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(A) = &quot; &lt;&lt; sizeof(A) &lt;&lt; endl; return 0;&#125;ENDS(test2)BEGINS(test3)class Base &#123;public : Base(string name) : class_name(name)&#123;&#125; int x; string class_name;private : int y;&#125;;class A : public Base &#123;public: A() : Base(&quot;class_A&quot;)&#123;&#125;&#125;;class B : public Base &#123;public: B() : Base(&quot;class_B&quot;)&#123;&#125;&#125;;class C : public Base &#123;public: C() : Base(&quot;class_C&quot;)&#123;&#125;&#125;;void func(Base *b) &#123; cout &lt;&lt; &quot;nput class : &quot; &lt;&lt; b-&gt;class_name &lt;&lt; endl; return ;&#125;int main() &#123; A a; B b; C c; // 子类的地址也是可以转换成父类的地址 func(&amp;a); func(&amp;b); func(&amp;c); return 0;&#125;ENDS(test3)// 父类子类的构造顺序BEGINS(test4)class ATTR_BASE &#123;public: ATTR_BASE(string name) : name(name)&#123; cout &lt;&lt; &quot;construct &quot; &lt;&lt; name &lt;&lt; endl; &#125; ~ATTR_BASE() &#123; cout &lt;&lt; &quot;destructor&quot; &lt;&lt; name &lt;&lt; endl; &#125; string name;&#125;;class ATTR1 : public ATTR_BASE&#123;public : ATTR1(string name) : ATTR_BASE(name) &#123;&#125;&#125;;class ATTR2 : public ATTR_BASE&#123;public : ATTR2(string name) : ATTR_BASE(name) &#123;&#125;&#125;;class Base &#123;public: Base() : attr1(&quot;attr1 in Base&quot;), attr2(&quot;attr2 in Base&quot;) &#123; cout &lt;&lt; &quot;Base constructor done&quot; &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; &quot;Base destructor don&quot; &lt;&lt; endl; &#125;private : ATTR1 attr1; ATTR2 attr2;&#125;;// Base 派生类class A : public Base &#123;public : A() : attr1(&quot;attr1 in A&quot;), attr2(&quot;attr2 in A&quot;)&#123; cout &lt;&lt; &quot;A constructor don&quot; &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;A destructor don&quot; &lt;&lt; endl; &#125;private : ATTR1 attr1; ATTR2 attr2;&#125;;int main() &#123; A a; return 0;&#125;ENDS(test4)int main() &#123; // test1::main(); // test2::main(); // test3::main(); test4::main(); return 0;&#125; 构造析构顺序 拷贝构造拷贝构造行为方式 ： 默认的 ： 默认调用每一个属性的拷贝函数默认的调用父类的拷贝函数","categories":[{"name":"C++\\OOP","slug":"C-OOP","permalink":"https://tutouwang.vercel.app/categories/C-OOP/"}],"tags":[]},{"title":"静态链接库-静态链接库","slug":"LInux-系统编程入门/静态链接库","date":"2021-11-14T11:49:27.000Z","updated":"2022-05-02T02:21:29.084Z","comments":true,"path":"2021/11/14/LInux-系统编程入门/静态链接库/","link":"","permalink":"https://tutouwang.vercel.app/2021/11/14/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/","excerpt":"","text":"命名规则Linux Linux : libxxxx.so lib : 前缀（固定） xxxx : 库的名字，自己起 .so ： 后缀（固定） 在Linux下是一个可执行文件 Windwos Windows ： libxxxx.dll 静态链接库把所有.c文件 进行编译、汇编 不进行链接 1gcc -c test1.c test1.c test2.c test3.c r 插入 c 创建 s建立索引 lib库的名称.a 1ar rcs libcalc.a add.o sub.o mult.o gcc main.c -o app -I .&#x2F;头文件 动态库的制作gcc 得到 .o文件 ， 得到和位置无关的代码 1gcc -c -fpic&#x2F;-fpIC a.c b.c gcc 得到动态库 1gcc -shared a.o b.o -o libxxxx.so","categories":[{"name":"LInux-系统编程入门","slug":"LInux-系统编程入门","permalink":"https://tutouwang.vercel.app/categories/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"LInux","slug":"LInux","permalink":"https://tutouwang.vercel.app/tags/LInux/"}]},{"title":"Windows子系统搭建Vim","slug":"教程/Windows子系统搭建Vim","date":"2021-11-07T14:01:42.000Z","updated":"2022-05-22T15:15:04.323Z","comments":true,"path":"2021/11/07/教程/Windows子系统搭建Vim/","link":"","permalink":"https://tutouwang.vercel.app/2021/11/07/%E6%95%99%E7%A8%8B/Windows%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BAVim/","excerpt":"","text":"注意：本文档没有任何问题，请仔细阅读文档，按步骤完成，不要轻易质疑文档的正确性；遇到问题，请大家先仔细阅读屏幕输出，不要直接提问 Windows10下Linux子系统1、启用开发者模式设置-更新和安全-针对开发人员-开发人员模式-等待完成（可以不开） 2、设置-程序和功能-启用或关闭windows功能-适用于Linux的Windows子系统-确定-等待安装完成并重启PC 3、安装Linux打开windows10的应用商店，搜索ubuntu，选择需要的版本点击-获取 我这里选择的是ubuntu20.04，点击获取后等待安装完成 4、启动在开始菜单中找到安装的ubuntu点击启动，第一次启动需要设置用户和密码按照提示设置即可。 换源Ubuntu系统自带的源都是国外的网址，国内用户在使用的时候网速比较慢，这样我们在下载或更新软件时就会十分痛苦。所以对于一个新手来说，给Ubuntu换源，就显得十分必要了。 一：备份原来的源1sudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources_init.list 注意，我们操作Ubuntu一般都是要在管理员权限下进行操作的，尤其是要对系统文件进行更改。sudo就是告诉系统使用管理员权限运行后面的命令。敲入回车后输入我们之前设置的密码即可运行。 二：查看版本号1lsb_release -a 三：更换阿里源进入更换阿里数据源 打开网站 找到对应版本数据源 12&#x2F;&#x2F;阿里源地址https:&#x2F;&#x2F;developer.aliyun.com&#x2F;mirror&#x2F;ubuntu?spm&#x3D;a2c6h.13651102.0.0.3e221b11dHF7v5 12&#x2F;&#x2F;清华源地址https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;help&#x2F;ubuntu&#x2F; 1sudo vim /etc/apt/sources.list 将文件里的内容全部删除（可在vim的命令模式下，使用gg将光标移到文件首行，使用dG命令清空文件），敲入i进入编辑模式，将下面内容粘贴(ctrl + shift + v)进文件 保持原有格式粘贴（esc 后 输入： set paste 在按下i键 ctrl + shift + v） 123456789101112131415//阿里源20.04LTSdeb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse 按ESC（或Ctrl + [）退出编辑模式进入命令模式，然后先按“:”，再输入wq，敲入回车，文件即写入成功。 三：更新系统输入下列命令，等待更新完毕~ 12sudo apt-get updatesudo apt-get upgrade 安装系统后的环境准备配置sshd Vim的简单使用，请百度 使用命令sudo vim /etc/ssh/sshd_config打开sshd的配置文件，找到ClientAliveInterval和ClientAliveCountMax并将其修改为（如果没有直接添加即可）：60 3 重启sshd服务 1sudo service sshd restart 如果上述命令报错，大致内容为sshd这个服务不存在的话，就执行sudo service ssh restart 以下所有配置，都是为了优化终端，提升使用效率，如果你已经能独立对bash，zsh，vim等进行配置优化，可自行选择方案，无需完全按照这个方案 GitHub访问优化 请进入这个网址：点击这里 找到图中的IP1 在上面的网站上搜索github.com,找到IP2 使用命令sudo vim /etc/hosts打开hosts文件，并在最后加入以下信息 12199.232.69.194 github.global.ssl.fastly.net140.82.112.4 github.com 保存并退出 vim###配置Vim（使用新添加的用户操作） 在后续的学习过程中，会使用vim写程序 Vim配置推荐 - ma6174（不用打开这个官方网站） 更新apt源信息 1sudo apt update 配置vim，执行下面命令配置安装vim sudo apt-get install git 12wget 47.93.11.51:88/install_vim.shbash install_vim.sh vim的配置因为需要安装较多插件，所以需要等较多时间，大家耐心等待 如果出现括号不能自动匹配情况重新安装第二条命令即可 zsh的安装及配置 安装zsh &#x2F;&#x2F; 主题 1sudo apt install zsh 修改默认shell为zsh &#x2F;&#x2F; 应该是修改主题 1chsh -s /bin/zsh 安装oh-my-zsh &#x2F;&#x2F; 1234sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;##如果不成功，请执行下面两条命令，成功了就不需要做下面两条wget 47.93.11.51:88/install_zsh.shbash install_zsh.sh 安装zsh-syntax-highlighting &#x2F;&#x2F; 代码高亮插件 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 使用命令vim .zshrc打开.zshrc文件，找到plugins=()这一行，将zsh-syntax-highlighting添加进去 1plugins=(git zsh-syntax-highlighting) 安装其他插件 1234567##命令自动补全插件mkdir ~/.oh-my-zsh/plugins/incrwget http://mimosa-pudica.net/src/incr-0.2.zsh -O ~/.oh-my-zsh/plugins/incr/incr.plugin.zsh##命令自动推荐，根据历史记录git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions##目录自动跳转插件sudo apt install autojump 使用命令vim .zshrc，打开后在最后插入以下内容： 123456789#设置终端颜色，提示符，及上一条指令返回码提示autoload -U colors &amp;&amp; colorsPROMPT=&quot;%&#123;$fg[red]%&#125;%n%&#123;$reset_color%&#125;@%&#123;$fg[blue]%&#125;%m %&#123;$fg[yellow]%&#125;%1~ %&#123;$reset_color%&#125;%# &quot;RPROMPT=&quot;[%&#123;$fg[yellow]%&#125;%?%&#123;$reset_color%&#125;]&quot;# Useful support for interacting with Terminal.app or other terminal programs[ -r &quot;/etc/zshrc_$TERM_PROGRAM&quot; ] &amp;&amp; . &quot;/etc/zshrc_$TERM_PROGRAM&quot;source ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.plugin.zshsource /usr/share/autojump/autojump.shsource ~/.oh-my-zsh/plugins/incr/incr*.zsh 注意，复制后可能会因为Vim的配置导致以上内容被注释，也就是在前面加上了#,如果有的话，删掉就行。 ctags安装与配置 使用以下命令安装ctags 1sudo apt install ctags 执行以下命令 1ctags -I __THROW -I __attribute_pure__ -I __nonnull -I __attribute__ --file-scope=yes --langmap=c:+.h --languages=c,c++ --links=yes --c-kinds=+p --c++-kinds=+p --fields=+iaS --extra=+q -f ~/.vim/systags /usr/include/* /usr/include/x86_64-linux-gnu/sys/* /usr/include/x86_64-linux-gnu/bits/* /usr/include/arpa/* 使用命令vim .vimrc编辑.vimrc，在最后添加以下内容 1set tags+=~/.vim/systags 安装 gcc&#x2F;g++gcc 安装命令 1sudo apt install gcc g++ 安装命令 1sudo apt install g++ 运行各种程序的run脚本查看环境变量echo $PATH，在任意一个目录下创建一个run文件 或者在环境变量里面新建一个文件 run文件内容 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/bin/bash#0 c#1 c++#2 bash#3 pyCC=&quot;gcc -lm -Wall&quot;GPP=&quot;g++ -std=c++11 -Wall&quot;function CheckType() &#123; type=`echo $1 | tr &quot;.&quot; &quot;\\n&quot; | tail -1` if [[ $&#123;type&#125; == &quot;c&quot; ]]; then return 0 elif [[ $&#123;type&#125; == &quot;cpp&quot; ]]; then return 1 elif [[ $&#123;type&#125; == &quot;sh&quot; ]]; then return 2 elif [[ $&#123;type&#125; == &quot;py&quot; ]]; then return 3 else exit fi&#125;File=$1Args=($@)unset Args[0]OutFile=`echo $&#123;File&#125; | tr &quot;.&quot; &quot;\\n&quot; | head -1 | tr &quot;\\n&quot; &quot;.&quot;`CheckType $&#123;File&#125;re=$?if [[ $&#123;re&#125; -eq 0 ]]; then $&#123;CC&#125; $&#123;File&#125; -o $&#123;OutFile&#125;exe &amp;&amp; time ./$&#123;OutFile&#125;exe $&#123;Args[*]&#125; &amp;&amp; rm -f $&#123;OutFile&#125;exeelif [[ $&#123;re&#125; -eq 1 ]]; then $&#123;GPP&#125; $&#123;File&#125; -o $&#123;OutFile&#125;exe &amp;&amp; time ./$&#123;OutFile&#125;exe $&#123;Args[*]&#125;&amp;&amp; rm -f $&#123;OutFile&#125;exeelif [[ $&#123;re&#125; -eq 2 ]]; then time bash $&#123;File&#125; $&#123;Args[*]&#125;else time python3 $&#123;File&#125; $&#123;Args[*]&#125;fi 保存后给run文件加上x权限chmod +x run 以后执行.c .cpp .sh .py文件时就直接run + 源文件名就可以了 安装glibc-doc 使用以下命令安装 1sudo apt install glibc-doc Vim下字体修改windows + r打开运行输入regedit 找到这个 1计算机\\HKEY_CURRENT_USER\\Console\\C:_Program Files_WindowsApps_CanonicalGroupLimited.Ubuntu20.04onWindows_2004.2021.825.0_x64__79rhkp1fndgsc_ubuntu2004.exe 这里是我更新之后的个个版本(每次更新都需要重新设置一下字体) 在右侧添加新建一个Dword键 CodePage是用来设置终端代码页的选项，65001是UTF-8，这个可以支持各种字体。这是关键。 保存，退出，再次打开Ubuntu，就可以自由的设置喜欢的字体了，连VIM也一并搞定。 自己设置的是 Cascadia Code 字体还挺好用的~ 中文设置 - 在20.04中好像时效了因为是刚刚安装的需要更新下软件源和软件包：时间可能会久点 12sudo apt updatesudo apt upgrade 安装中文语言包1sudo apt install -y language-pack-zh-hans language-pack-zh-hans-base 设置中文环境变量vi ~&#x2F;.profile 1在末尾新增一行:LANG=zh_CN.UTF-8 设置完毕重新打开ubuntu即可，部分软件及命令不支持汉化以ls命令为例： 中文设置先查找一下是否有apt-cache search language-pack-zh-hans中文包，如果没有则需要更新一下软件源。 之后执行 sudo apt install -y language-pack-zh-hans 安装中文包，需要管理员密码。 之后会提示是否安装，输入y。 安装完成会看到语言的名字。 sudo update-locale LANG&#x3D;zh_CN.UTF-8 之后看一下帮助信息，已有中文显示了。 vim设置代码文件作者信息等vim .vimrc 创建文件 vim test.c","categories":[{"name":"教程","slug":"教程","permalink":"https://tutouwang.vercel.app/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://tutouwang.vercel.app/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"并查集","slug":"基础算法/并查集","date":"2021-03-27T10:08:15.000Z","updated":"2022-05-22T15:05:06.431Z","comments":true,"path":"2021/03/27/基础算法/并查集/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/27/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集(Union Find)并查集主要讲的就是连通性问题 比如说现在咱们这个教学楼，被大水淹了比如说一楼和其它楼层都被大水淹了，就唯独咱们教室没有，可以说明什么，咱们现在就是与世隔绝了，之后呢就被大水淹没的个个楼层水是不是都可以来回走，比如流到了咱们教室恰巧关上了们，之后水就没流进来，说明什么咱们现在是与这个教学楼的一间教室都不连图，如果说咱们与隔壁是连通的，而且咱们隔壁还被大水淹没了，你说咱们这屋是不是也被淹没了。 若某个家族人员过于庞大，要判断两个是否是亲戚，确实不容易，给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。 树形结构在春秋战国时期有各种思想学术流派的成就，有 孔子 墨子 老子 还有谁比如 韩非子等等 从我们当前图中我门可以看出我们有几个连同块 有3个对把 比如说有一天 2 号 跟 4号 打起来来了说你写的东西不如我，（这里有个规定就是说徒弟一定不如师傅）完了4号本身就是1号的徒弟肯定不如2号 当然 4号有师傅 之后4号找到自己的师傅 1 号 说今天我被人羞辱了对吧那当师傅的肯定不能做事不管对吧 之后一看 说这2号也老孔的徒弟一看这不是就是一个师傅么那就别报仇了 让 4 号 给 2 号认个错 就是下次的时候我们可以怎么看 就是先知道自己的师傅的师傅是谁对吧 在看你要找的人的师傅的师傅（这师傅可能还有师傅所有要找到最后一个师傅）是谁 如果他们最后的师傅都是同一个人那他们是不是就是一家人属于同一个师傅 （可以说明他们在通一课树中说明它们俩个连同） 其实我们在连同性中不在乎连接成什么样子谁是谁的徒弟我只在乎他们能不能连同最后的祖师，祖师爷是不是同一个人 这个两个点能不能连同 Ps 比如 （1， 2） 为一个集合 数组表示 （1，4） （4，7） 这里代表两个集合链接，这里链接的时候你说是 1 当作根节点还是 4 当作根节点 1 其实是无所谓的。这里假定 4为根节点我们可以得到 图 这两个点的连同不仅仅是两个点的连同而是两个集合的连通（其实他们都属一个个体） 比如你的爸和你妈是两个姓对吧 他们在没结婚之前是什么，两个家的人就可以比作什么两个集合，之后他们结婚了 是只有他俩是一家人么 不是吧 是两家人，这就好比我们两个点的链接。 我们可以用数组表示 初始化把每个点所在的集合初始化为其自身。 初始化加粗 为下标 我们可以用用它自身去初始化（也可以用 -1 但是后期在优化的时候会有点麻烦） 0 1 2 3 0 1 2 3 4 5 6 7 4 5 6 7 0 1 2 3 0 4 2 3 4 5 6 7 4 5 6 4 竞赛阶段我们会用到的算法 find union123456789101112131415161718// 朴素int find_root(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;// 查找--优化int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x]; // return x == parent[x] ? x : parent[x] = find_root(parent[x], parent); // return parent[x] = (x == parent[x] ? x : find_root(parent[x], parent));&#125; 123456789101112131415161718192021// 合并void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; // parent[x_root] = y_root; // 原先代码 // 安秩合并 if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; return ; &#125; mark = 1; return ;&#125; 路径压缩–按秩合并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int mark = 0;// 初始化void inital(int n, int parent[], int height[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; height[i] = 0; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x]; // &#125;// 路径压缩--非递归版int find_root1(int x, int parent[]) &#123; int k = x; while (parent[k] != k) &#123; k = parent[k]; &#125; while (x != k) &#123; int temp = parent[x]; parent[x] = k; x = temp; &#125; return k;&#125;void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; // parent[x_root] = y_root; // 原先代码 // 按秩合并 if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; return ; &#125; mark = 1; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10], height[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; inital(m, parent, height); for (int i = 0; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(x, y, parent, height); &#125; if (mark) cout &lt;&lt; &quot;有环！&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;无环！&quot; &lt;&lt; endl; return 0;&#125; 路径压缩是怎么实现的 检测是否存在环我们如何去检测一个图是否存在环环路 如下 我们有 0️⃣ 1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 把每个点看成单个集合比如我们相连（0 ，1） （1，2） （1，3）（2，4）（2，3） 我们在合并时候需要先查询一下他们是否属于同一集合，如果不属于同一集合我才能合并，反之要是它们在合并就会构成回路。 如果不考虑链接红色两点，合并集合之后是{0，1，2，3，4} 我们可以得到站在任意点到达另一任意点。不构成环 如果说我们在已连接中任意选择两个去链接他一定会成环对吧。🔶 比如红色两点链接，我们可以看到 1， 2， 3 点形成了环。 形成环路 我们怎么知道他是成环了呢我们把 1 当做根结点 ，0， 2，4，3 都属于 1 的孩子或者是孙子 当你去链接 （2， 3）时候你会发现他们都属于 1 下就如我们刚才所说 🔶因为我们知道两个集合在合并的时候一定会先去找根节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int mark = 0;int parent[MAX_N + 10];// 初始化void inital(int n, int parent[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; &#125; return ;&#125;int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;void merge(int x, int y, int parent[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; parent[x_root] = y_root; return ; &#125; mark = 1; return ;&#125;int main() &#123; int n, m; // 组数 最大值 cin &gt;&gt; n &gt;&gt; m; inital(m, parent); for (int i = 0; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(x, y, parent); &#125; if (mark) cout &lt;&lt; &quot;有环！&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;无环！&quot; &lt;&lt; endl; return 0;&#125; 并查集–数据结构实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;struct UnionSet &#123; int *parent;&#125;;// 初始化UnionSet *init(int n) &#123; UnionSet *U = (UnionSet *)malloc(sizeof(UnionSet)); U-&gt;parent = (int *)malloc(sizeof(int) * (n + 1)); for (int i = 1; i &lt;= n; i++) &#123; U-&gt;parent[i] = i; &#125; return U;&#125;int find_root(UnionSet *U, int x) &#123; if (U-&gt;parent[x] != x) &#123; return find_root(U, U-&gt;parent[x]); &#125; return x;&#125;void merge(UnionSet *U, int x, int y) &#123; int x_root = find_root(U, x); int y_root = find_root(U, y); if (x_root != y_root) &#123; U-&gt;parent[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); UnionSet *U = init(n); // 进行 M 次操作 for (int i = 1; i &lt;= m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); switch(a) &#123; case 1: merge(U, b, c); break; // 合并操作 case 2: printf(&quot;%s\\n&quot;, find_root(U, b) == find_root(U, c) ? &quot;Yes&quot; : &quot;No&quot;); &#125; &#125; return 0;&#125; 例题–题解海贼 #71 朋友圈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/************************************************************************* &gt; File Name: 海贼_#71并查集_路径压缩优化.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年01月18日 星期一 15时33分00秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e4;// 初始化void initialization(int n, int parent[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;// 朴素算法int find_root1(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;void merge(int x, int y, int parent[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; parent[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; initialization(n, parent); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if (a == 1) &#123; // 添加 merge(b, c, parent); &#125; else &#123; // 查看 if (find_root(b, parent) - find_root(c, parent)) &#123; printf(&quot;No\\n&quot;); &#125; else printf(&quot;Yes\\n&quot;); &#125; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/************************************************************************* &gt; File Name: 海贼_#71并查集_路径压缩_安秩合并_优化.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年01月18日 星期一 21时33分00秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e4;// 初始化 void initialization(int n, int parent[], int height[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; // 开始树高为 0 height[i] = 0; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;// 朴素算法int find_root1(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; &#125; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10], height[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; initialization(n, parent, height); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if (a == 1) &#123; // 添加 merge(b, c, parent, height); &#125; else &#123; // 查看 if (find_root(b, parent) - find_root(c, parent)) &#123; printf(&quot;No\\n&quot;); &#125; else printf(&quot;Yes\\n&quot;); &#125; &#125; return 0;&#125; 洛谷 P1551 亲戚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int arr[MAX_N];void initial(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; arr[i] = i; &#125;&#125;int find(int x) &#123; if (arr[x] != x) &#123; x = find(arr[x]); &#125; return arr[x];&#125;void merge(int x, int y) &#123; int x_root = find(x); int y_root = find(y); if (x_root != y_root) &#123; arr[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; initial(n); while (m--) &#123; int mi, mj; cin &gt;&gt; mi &gt;&gt; mj; merge(mi, mj); &#125; while (p--) &#123; int mi, mj; cin &gt;&gt; mi &gt;&gt; mj; if (find(mi) == find(mj)) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://tutouwang.vercel.app/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"蓝桥杯省赛_B组组_十届","slug":"蓝桥杯题解/十届B组-真题/蓝桥杯省赛_B组组_十届","date":"2021-03-21T09:07:43.000Z","updated":"2022-01-19T02:47:14.198Z","comments":true,"path":"2021/03/21/蓝桥杯题解/十届B组-真题/蓝桥杯省赛_B组组_十届/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/21/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E8%A7%A3/%E5%8D%81%E5%B1%8AB%E7%BB%84-%E7%9C%9F%E9%A2%98/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B_B%E7%BB%84%E7%BB%84_%E5%8D%81%E5%B1%8A/","excerpt":"","text":"试题A:平方序列","categories":[{"name":"蓝桥杯历届真题","slug":"蓝桥杯历届真题","permalink":"https://tutouwang.vercel.app/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://tutouwang.vercel.app/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"排序合集","slug":"基础算法/排序合集","date":"2021-03-14T01:48:14.000Z","updated":"2021-04-03T07:38:30.808Z","comments":true,"path":"2021/03/14/基础算法/排序合集/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/","excerpt":"","text":"怎么区分稳定还是不稳定如果在原序列里面两个数是相同的，那么排完序位置没有发生变化那么 这个排序就是稳定的，如果发生变化那么这个排序就是不稳定的。 冒泡排序（稳定） 考虑冒泡排序的复杂度，对于拥有N个字母的字符串，最多需要交换 N*(N - 1) &#x2F; 2 次（完全逆序） 快速排序（不稳定）随机快速排序过程 确定分界点（也叫选择基准数）：$q[L], q[(L + R) &#x2F; 2], q[R]$ 调整区间： 递归：处理左右两端排序，如果左右两侧都排序好了在合并一起那么就是一个有序的序列了 （暴力）版 可以先开辟两个空的数组 a[] 和 b[] 在 L 到 R 区间内扫描一遍 把 &gt;&#x3D; x 和 &lt;&#x3D; x 的数拆分出来放到 a, b 数组 $q[L - R] $ $q[i] &lt;&#x3D; x, q[i] - &gt; a[]$ &#x2F;&#x2F; q[i] &lt;&#x3D; x 就它放到 a 数组里面 $q[i] &gt;&#x3D; x, q[i] -&gt; b[]$ &#x2F;&#x2F; q[i] &gt;&#x3D; x 就它放到 b 数组里面 $a[] -&gt; q[], b[]-&gt;q[]$ &#x2F;&#x2F;在把 a，b 数组数据在合并到 q 数组里面 （基础）版我们可以定义两个指针从线段两侧往中间走只要（i &lt; j) 红色i 蓝色j，如果红色指针要小于基准数那么i++, 如果红色指针要大于基准数了，那么判断j指针数是否大于基准值如果大于那么j++, 如果小于那么 交换i, j 指针。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/************************************************************************* &gt; File Name: Demo15.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2021年03月16日 星期二 20时37分05秒 ************************************************************************/#include&lt;stdio.h&gt;#define MAX_N 100000#define swap(a, b) &#123;\\ a ^= b, b ^= a, a ^= b;\\&#125;int q[MAX_N + 10];void quick_sort(int l, int r) &#123; if (l &gt;= r) return ; // 如果下面递归左右 选的是j的话 基准指数一定不能选 q[r] 要不然回发生边界问题 int x = q[l], i = l - 1, j = r + 1; while (i &lt; j) &#123; do i++; while (q[i] &lt; x); do j--; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); &#125; // 遍历左侧 quick_sort(l, j); // 遍历右侧 quick_sort(j + 1, r); return ;&#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, q + i); &#125; quick_sort(0, n - 1); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, q[i]); &#125; return 0;&#125; 归并排序（稳定） 确定分界点 mid(L + R) &#x2F; 2 (这里的分界点是数组下标的位置)而快排是随机确定数组里面数。 递归排序左右两面。 归并（把排序好的左右两侧合并到一起）。","categories":[{"name":"算法基础","slug":"算法基础","permalink":"https://tutouwang.vercel.app/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"ACwin104_货仓选址","slug":"ACwin题解/ACwin104_货仓选址","date":"2021-03-13T09:39:11.000Z","updated":"2022-01-19T02:51:41.482Z","comments":true,"path":"2021/03/13/ACwin题解/ACwin104_货仓选址/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/13/ACwin%E9%A2%98%E8%A7%A3/ACwin104_%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80/","excerpt":"","text":"原题链接 题目：在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN。 现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。 为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。 输入格式第一行输入整数 N。 第二行 N 个整数 A1∼ AN 输出格式输出一个整数，表示距离之和的最小值。 数据范围$1≤N≤1000001≤N≤100000$$0 ≤ Ai ≤ 400000 ≤ Ai ≤ 40000$ 输入样例：1246 2 9 1 输出样例：112 解题思路:那面如何选择中位数仓库x如果当n等于奇数那么中间的数就是中位数，如果n是偶数那么现在中间两个其实一都可以。 首先考虑在坐标轴上建立仓库$x$如图 假设货仓在中间可得$|a - x| + |b - x| &gt;&#x3D; |a - b|$，$|a - x|$就是a 到 x的距离 同理 $|b - x|、 |a - b|$ 如果货仓在最左侧或者最右侧情况，那么可以看出$|x - a|$的距离就走了两遍所有放在中间才是最优解。 第一种做法：12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#define MAX_N 100000int f[MAX_N + 10];int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, f + i); &#125; std::sort(f, f + n); int res = 0; for (int i = 0; i &lt; n; i++) &#123; res += abs(f[i] - f[n &gt;&gt; 1]); &#125; printf(&quot;%d\\n&quot;, res); return 0;&#125;","categories":[{"name":"ACwin题解","slug":"ACwin题解","permalink":"https://tutouwang.vercel.app/categories/ACwin%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"中位数","slug":"中位数","permalink":"https://tutouwang.vercel.app/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"}]},{"title":"背包九讲","slug":"基础算法/背包九讲","date":"2021-03-07T04:21:06.000Z","updated":"2022-05-22T15:05:06.431Z","comments":true,"path":"2021/03/07/基础算法/背包九讲/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/07/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","excerpt":"","text":"动态规划 动态规划（Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息 学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题）， 再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归 的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少 计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查 表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 在大家看完什么是动态规划后就是说我们在之前也做题中可能也遇到过动态规划的题比如斐波那契数列 如 1，1， 2， 3… 就是这个 2 怎么来的就是 1 + 1 &#x3D; 2 之后 3 的下一项是什么？就是 2 + 3 &#x3D; 5 也就是说 3 的下一项就是 5 之后下几项就是 8，13，21…就会得到这组序列 我们如果相求第n斐波那契数列可以得到转移公式 $Fib(n) &#x3D; Fib(n - 1) + Fib(n - 2);$ (Fib(1) &#x3D; 1 和 Fib(2) &#x3D; 1是由题目给出的，n &gt; 2 ) 完整的斐波那契数列 加上出口就是 n &#x3D; 1 or n &#x3D; 2 返回 1 , 就是说我们这里为什么提出这个斐波那契数列呢就是我们在递归时候，我们呢会发现他的递归式中会出现重叠的子问题，为什么会这么说我来计算一下斐波那契数列 第 5 项 Fib(5) 可得出如下 假如说我们用数组去求解Fib(6) 是不就可以直接用之前求Fib(5) + Fib(4) 的 直接得到 Fib(6) 这样我是不是就可以省去求重叠子问题的时间，这样我们的时间复杂度就从o(2^n^) 变成 o(n)(当然这个时间复杂度也是能弄记忆化搜索优化的)。 例题 01 背包 只又 2 种选择一种选一种不选。 洛谷 P1048 采药 完全背包 每件物品可以无限选（只要不超过背包的总体积）。 洛谷 P1616 疯狂的采药 多重背包 每个物品有相应的个数。 洛谷 P1776 宝物筛选 混合背包 基于以上上面三种背包。 洛谷 P1833 樱花 二维费用背包 类比以一维费用01背包，推广二维费用01背包。 洛谷 P1507 NASA的食物计划 分组背包 有 n 组物品 每组物品有若干个，同一组内互相冲突，同一组最多只能选一个或者不选 洛谷 P1757 通天之分组背包 有依赖的背包 类似捆绑销售 买附必须买主，买主可以不买附 洛谷 P1064 金明的预算方案 背包九讲0-1背包题目：有一天小鲁同学在家里学习算法，小鲁的妈妈就叫这个铲屎官小鲁去收拾一下，但是小鲁很不想去就说我在学习算法，小鲁的妈妈就说你要是在不去我就把你一起也铲出去，小鲁就想被你铲除去还不如我自己走，这样小鲁就回到了自己的房间，打破了储存已久的小猪储存罐🐖。 小鲁的背包可容纳下总重量为 20（ s ） 他需要带尽可能多的钱走。（没种钱可以重复的选取没有上限）。 简单的说： 有N件物品和一个容量为T的背包。第i件物品的费用是t[i]，价值是v[i]。求解将哪些物品装入背包可使价值总和最大。 下标 重量（w） 价值 （v） 1 2 3 2 3 4 3 4 5 4 5 8 5 9 10 这里为什么不用贪心而用动态规划？ 首先贪心他是局部最优解，而我所讲的动态规划可以达到全局最优解。 基本思路： 首先我们考虑什么，取不取第 n 件物品？ 取 $-&gt; n - 1$ 个物品，背包大小 $s - w[n]$ 不取$ -&gt; n - 1$ 个物品，背包大小 s 定义状态：$dp[i][j]$ 表示考虑前 i 个物品，背包大小 $0 -&gt; j $, 获得最大价值。 转移方程：$dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])$ 代码实现：无优化-代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;#define MAX_N 1000int dp[MAX_N + 10][MAX_N + 10];int t[MAX_N + 10], v[MAX_N + 10];void backpack(int k, int T) &#123; for (int i = 1; i &lt;= k; i++) &#123; for (int j = 1; j &lt;= T; j++) &#123; if (t[i] &gt; j) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; int Y = dp[i - 1][j - t[i]] + v[i]; int T = dp[i - 1][j]; dp[i][j] = Y &gt; T ? Y : T; // dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); &#125; &#125; &#125;&#125;int main() &#123; int T, n; cin &gt;&gt; T &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; t[i] &gt;&gt; v[i]; &#125; backpack(n, T); cout &lt;&lt; dp[n][T];&#125; 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;const int MAX_N = 1e3;int n, m;int f[MAX_N + 10][MAX_N + 10], w[MAX_N + 10], v[MAX_N + 10];int main() &#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; w[i] &gt;&gt; v[i]; &#125; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; f[i][j] = f[i - 1][j]; if(j &gt;= w[i]) f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]); &#125; &#125; cout &lt;&lt; f[m][n] &lt;&lt; endl; return 0;&#125; 优化-代码12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;#define MAX_N 1000int dp[MAX_N];int T[MAX_N], V[MAX_N];void backpack(int k, int s) &#123; for (int i = 1; i &lt;= k; i++) &#123; for (int j = s; j &gt;= T[i]; j--) &#123; dp[j] = max(dp[j], dp[j - T[i]] + V[i]); &#125; &#125; return ;&#125;int main() &#123; int t, n; cin &gt;&gt; t &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; T[i] &gt;&gt; V[i]; &#125; backpack(n, t); cout &lt;&lt; dp[t]; return 0;&#125; 上面朴素算法时间复杂度与空间复杂度皆为 O(t*n) 其中时间复杂度不能再优化, 而空间复杂度可以 优化为O(t), 下面我们来讲解如何优化到一维数组 细节问题 1 我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。如果是第一种问法，要求恰好装满背包，那么在初始化时除了f[0]为0其它f[1..V]均设为-∞，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。 2 如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f[0..V]全部设为0。为什么呢？ 3 可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的（相当于没装东西），其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。这个小技巧完全可以推广到其它类型的背包问题，后面也就不再对进行状态转移之前的初始化进行讲解。 完全背包题目：有N种物品和一个容量为T的背包，每种物品都有无限件可用。第i种物品的费用是t[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路：和 01背包很相似 转移方程相同 转移方程：$dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])$ 与 01背包的区别–第二个循环 01背包 在更新时候倒序因为是需要用之前元素 代码实现：无优化-代码123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;long long dp[MAX_N + 10][MAX_N +10];long long t[MAX_N + 10], v[MAX_N + 10];void backpack(int k, int s) &#123; for (int i = 1; i &lt;= k; i++) &#123; for (int j = 1; j &lt;= s; j++) &#123; if (j &lt; t[i]) dp[i][j] = dp[i - 1][j]; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - t[i]] + v[i]); &#125; &#125; &#125; return ;&#125;int main() &#123; int T, n; cin &gt;&gt; T &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; t[i] &gt;&gt; v[i]; &#125; backpack(n, T); cout &lt;&lt; dp[n][T] &lt;&lt; endl; return 0;&#125; 优化-代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e7;long long B[MAX_N + 10];int t[MAX_N + 10], v[MAX_N + 10];void backpack(int k, int s) &#123; for (int i = 1; i &lt;= k; i++) &#123; for (int j = t[i]; j &lt;= s; j++) &#123; B[j] = max(B[j], B[j - t[i]] + v[i]); &#125; &#125; return ;&#125;int main() &#123; int T, n; cin &gt;&gt; T &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; t[i] &gt;&gt; v[i]; &#125; backpack(n, T); cout &lt;&lt; B[T] &lt;&lt; endl; return 0;&#125; 多重背包题目：有N种物品和一个容量为s的背包。第i种物品最多有m[i]件可用，每件费用是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路：这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有m[i]+1种策略：取0件，取1件……取n[i]件。令f[i][j]表示前i种物品恰放入一个容量为v的背包的最大权值。 则转移方程： $dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - k * w] + k * v);$ 代码实现：无优化-代码1234567891011121314151617181920212223242526// 多重背包 朴素 算法#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e3;int dp[MAX_N + 10][MAX_N + 10];int main() &#123; int n, s; cin &gt;&gt; n &gt;&gt; s; for (int i = 1; i &lt;= n; i++) &#123; // 价值 重量 组数 int v, w, m; cin &gt;&gt; v &gt;&gt; w &gt;&gt; m; for (int j = s; j &gt;= w; j--) &#123; // 背包容量 for (int k = 0; k &lt;= m &amp;&amp; j &gt;= k * w; k++) &#123; // 决策 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * w] + k * v); &#125; &#125; &#125; cout &lt;&lt; dp[n][s] &lt;&lt; endl; return 0;&#125; 转化为01背包问题 另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成log(m)件01背包中的物品. 但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想. 二进制优化 假设有50个苹果，现在要取n个苹果(n≤50），如何取?朴素的做法应该是将苹果一个一个拿出来，直到n个苹果被取出来。再假设有50个苹果和6只箱子，利用箱子进行某些预备工作，可以在每个箱子中放2(k≥0)个苹果，也就是1、2、4、8、16、19（剩余的数），取任意n个苹果时，只要推出忆只箱子就可以了。 lg45÷lg2&#x3D;1.6532125÷0.301029996&#x3D;5.49185 优化-代码123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e5;int dp[MAX_N + 10];int ww[MAX_N + 10], vv[MAX_N + 10], mm[MAX_N + 10];int main () &#123; int n, s, count = 1, v, w, m; cin &gt;&gt; n &gt;&gt; s; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v &gt;&gt; w &gt;&gt; m; for (int j = 1; j &lt;= m; j &lt;&lt;= 1) &#123; ww[count] = j * w; vv[count++] = j * v; m -= j; &#125; // 处理 二进制拆分不了的 if (m) &#123; ww[count] = m * w; vv[count++] = m * v; &#125; &#125; // 01 背包 模板 for (int i = 1; i &lt; count; i++) &#123; for (int j = s; j &gt;= ww[i]; j--) &#123; dp[j] = max(dp[j], dp[j - ww[i]] + vv[i]); &#125; &#125; cout &lt;&lt; dp[s] &lt;&lt; endl; return 0;&#125; 混合背包题目：如果将 01背包、完全背包、多重背包、混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背1包）。应该怎么求解呢？ 基本思路： 01背包与完全背包的混合 我只需要考虑到在01背包和完全背包中给出的代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可. 12345678if // 如果是 01 背包 for (int j = s; j &gt;= w[i] j--) &#123; dp[j] = max(dp[j], dp[j - w[i]] + v[i]); &#125;else // 如果是 完全背包 for (int j = w[i]; j &lt;= s; j++) &#123; dp[j] = max(dp[j], dp[j - w[i]] + v[i]); &#125; 再加上多重背包 如果再加上有的物品最多可以取有限次，我们就可以用二进制拆分来把多重背包转换成01背包 1234567891011// m = 物品最多能取的个数for (int j = 1; j &lt;= m; j &lt;&lt;= 1) &#123; ww[count] = j * w; vv[count++] = j * v; m -= j;&#125;// 处理 二进制拆分不了的if (m) &#123; ww[count] = m * w; vv[count++] = m * v;&#125; 题解-代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e5;int dp[MAX_N + 10], ww[MAX_N + 10], vv[MAX_N + 10], mark[MAX_N + 10];int main() &#123; int T, t1, t11, t2, t22, n, count = 1; scanf(&quot;%d:%d %d:%d %d&quot;, &amp;t1, &amp;t11, &amp;t2, &amp;t22, &amp;n); T = (t2 * 60 + t22) - (t1 * 60 + t11); for (int i = 1; i &lt;= n; i++) &#123; int w, v, m; cin &gt;&gt; w &gt;&gt; v &gt;&gt; m; if (!m) &#123; ww[count] = w; vv[count] = v; // 标记为 0 代表可以重复观看 完全背包 mark[count++] = 0; &#125; else &#123; // 二进制拆分转换 01背包 for (int j = 1; j &lt;= m; j &lt;&lt;= 1) &#123; ww[count] = j * w; vv[count] = j * v; // 标记为 1 代表每棵树只能看或者不看 01背包 mark[count++] = 1; m -= j; &#125; // 因为二进制拆分 只能是 1 2 4 8 16 32 比如 m = 10 二进制拆分之后还会余下 1 下面 if 就是解决那个多余出来的 if (m) &#123; ww[count] = m * w; vv[count] = m * v; mark[count++] = 1; &#125; &#125; &#125; // 实现 01背包 和 完全背包 模板就行了 for (int i = 1; i &lt; count; i++) &#123; if (mark[i]) &#123; // 如果 mark[i] == 1 就执行 01背包 for (int j = T; j &gt;= ww[i]; j--) &#123; dp[j] = max(dp[j], dp[j - ww[i]] + vv[i]); &#125; &#125; else &#123; for (int j = ww[i]; j &lt;= T; j++) &#123; dp[j] = max(dp[j], dp[j - ww[i]] + vv[i]); &#125; &#125; &#125; cout &lt;&lt; dp[T] &lt;&lt; endl; return 0;&#125; 二维费用背包题目：二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和Q。物品的价值为v[i]。 基本思路：费用加了一维，只需状态也加一维即可。设dp[i][j][k]表示前i件物品付出两种代价分别为m和w时可获得的最大价值。 状态转移方程就是：$f [i][j][k]&#x3D;max{f[i-1][j][k],f[i-1][f-a[i]][k-b[i]]+v[i]}$。 如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量m和w采用顺序的循环。 大概就是 由一维01背包费用推广二维01背包费用还可以推广三维，四维，…..N维。 当物品有如完全背包问题时采用逆序的循环。 当物品有如多重背包问题时拆分物品。 题解-代码：1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e3;int dp[MAX_N + 10][MAX_N + 10];int main() &#123; int V, Q, n; cin &gt;&gt; V &gt;&gt; Q &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; int m, w, v; cin &gt;&gt; m &gt;&gt; w &gt;&gt; v; for (int j = V; j &gt;= m; j--) &#123; for (int k = Q; k &gt;= w; k--) &#123; dp[j][k] = max(dp[j][k], dp[j - m][k - w] + v); &#125; &#125; &#125; cout &lt;&lt; dp[V][Q] &lt;&lt; endl; return 0;&#125; 分组的背包问题题目：有N件物品和一个容量为S的背包。第i件物品的费用是w[i]，价值是v[i]，组别g[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件或者不选,如果同属于v[i]组一共有m个那最多就有m + 1种选法。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路：$dp[i][j]$ 表前 i 组物品，能放下容量为j的背包的最大价值。 朴素算法 对第 i 组物品，容量为 j 的背包，有 m + 1种选法。 $max(dp[i-1][j], dp[i - 1][j - w[1]], dp[i - 1][j - w[2]]…dp[i - 1][j - w[m]])$ 这里基本就是01背包模板直接用01背包优化版的板子就可以了。 题解-代码：123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e3;int dp[MAX_N + 10];int w[MAX_N + 10], v[MAX_N + 10], g[MAX_N + 10], gg[MAX_N + 10][MAX_N + 10];int main() &#123; int n, s, nn = 0; cin &gt;&gt; s &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; int t; scanf(&quot;%d%d%d&quot;, &amp;w[i], &amp;v[i], &amp;t); nn = max(t, nn); g[t]++; gg[t][g[t]] = i; &#125; // 枚举 nn 个组 for (int i = 1; i &lt;= nn; i++) &#123; for (int j = s; j &gt;= 0; j--) &#123; // 背包容量 for (int k = 0; k &lt;= g[i]; k++) &#123; // 决策 if (j &gt;= w[gg[i][k]]) // 不选从 k - 1 个物品中选择一个价值最大的 dp[j] = max(dp[j], dp[j - w[gg[i][k]]] + v[gg[i][k]]); &#125; &#125; &#125; cout &lt;&lt; dp[s] &lt;&lt; endl; return 0;&#125; 问背包容量与决策循环是否可以调换？ 不能 因为更新$dp[j]$时用到$dp[i][j - w[k]]$的值，$dp[j- w[k]]$与$dp[i-1][j-w[k]]$ 有依赖的背包基本思路：这种背包问题的物品间存在某种“依赖”的关系。也就是说，物品 i 依赖于物品 j， 表示若选物品 i，则必须选物品 j。为了简化起见，我们先设没有某个物品既依赖于别 的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。 这个问题由 NOIP2006 中“金明的预算方案”一题扩展而来。遵从该题的提法，将 不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题 的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。 就好比如 你大一学的c\\c++语言完了大二才能学数据结构，就是你不能直接学数据结构要先学完c\\c++这就是依赖关系 可看上面例题 看题, 我们在选择时候会有5种情况： 选或者不选 选 、只选这个主件 不选、直接考虑下一个 选这个主件 选这个主件、并且选附件1 选这个主件、并且选附件2 选这个主件、 并且选附件1和附件2 例题-代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e6;int dp[MAX_N + 10];int w[MAX_N + 10], v[MAX_N + 10], g[MAX_N + 10][3], mark[MAX_N + 10];int main() &#123; int n, s; scanf(&quot;%d%d&quot;, &amp;s, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int p, q; scanf(&quot;%d%d%d&quot;, &amp;w[i], &amp;p, &amp;q); mark[i] = q; v[i] = w[i] * p; if (q) &#123; g[q][0]++; g[q][g[q][0]] = i; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if(mark[i] != 0) continue; for (int j = s; j &gt;= w[i]; j--) &#123; // 1、不选 或者 只选择主件 dp[j] = max(dp[j], dp[j - w[i]] + v[i]); // 2、选择第一个附件 if (j &gt;= w[g[i][1]] + w[i] &amp;&amp; g[i][1] != 0) &#123; dp[j] = max(dp[j], dp[j - w[i] - w[g[i][1]]] + v[i] + v[g[i][1]]); &#125; // 3、选择第二个附件 if (j &gt;= w[g[i][2]] + w[i] &amp;&amp; g[i][2] != 0) &#123; dp[j] = max(dp[j], dp[j - w[i] - w[g[i][2]]] + v[i] + v[g[i][2]]); &#125; // 4、两个附件都选 if (j &gt;= w[g[i][1]] + w[g[i][2]] + w[i] &amp;&amp; g[i][1] != 0 &amp;&amp; g[i][2] != 0) &#123; dp[j] = max(dp[j], dp[j - w[i] - w[g[i][1]] - w[g[i][2]]] + v[i] + v[g[i][1]]+ v[g[i][2]]); &#125; &#125; &#125; cout &lt;&lt; dp[s] &lt;&lt; endl; return 0;&#125; 泛化物品 (了解)定义考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的 费用而变化。这就是泛化物品的概念。 更严格的定义之。在背包容量为 V 的背包问题中，泛化物品是一个定义域为 0 . . . V 中的整数的函数 h，当分配给它的费用为 v 时，能得到的价值就是 h(v)。 这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组 h[0 . . . V ]，给它 费用 v，可得到价值 h[v]。 一个费用为 c 价值为 w 的物品，如果它是 01 背包中的物品，那么把它看成泛化物 品，它就是除了 h(c) &#x3D; w 外，其它函数值都为 0 的一个函数。如果它是完全背包中的 物品，那么它可以看成这样一个函数，仅当 v 被 c 整除时有 h(v) &#x3D; w · v c，其它函数值 均为 0。如果它是多重背包中重复次数最多为 m 的物品，那么它对应的泛化物品的函 数有 h(v) &#x3D; w · v c 仅当 v 被 c 整除且 v c ≤ n，其它情况函数值均为 0。 一个物品组可以看作一个泛化物品 h。对于一个 0 . . . V 中的 v，若物品组中不存在 费用为 v 的物品，则 h(v) &#x3D; 0，否则 h(v) 取值为所有费用为 v 的物品的最大价值。6中 每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。 视频","categories":[{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tutouwang.vercel.app/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"蓝桥杯省赛 B组 十一届 第二场","slug":"蓝桥杯题解/十一届B组-真题/蓝桥杯省赛_B组_十一届_第二场","date":"2021-03-06T04:21:06.000Z","updated":"2022-05-22T15:05:06.430Z","comments":true,"path":"2021/03/06/蓝桥杯题解/十一届B组-真题/蓝桥杯省赛_B组_十一届_第二场/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E8%A7%A3/%E5%8D%81%E4%B8%80%E5%B1%8AB%E7%BB%84-%E7%9C%9F%E9%A2%98/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B_B%E7%BB%84_%E5%8D%81%E4%B8%80%E5%B1%8A_%E7%AC%AC%E4%BA%8C%E5%9C%BA/","excerpt":"","text":"蓝桥杯省赛 B组 十一届 第二场试题A:门牌制作 答案：624 1234567891011121314151617181920212223242526/************************************************************************* &gt; File Name: 十一届—试题A门牌制作.cppz &gt; Author: &gt; Mail: &gt; Created Time: 2021年02月28日 星期日 16时31分53秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;const int MAX_N = 2020;int f[MAX_N + 10];int main() &#123; int n = 0; for (int i = 1; i &lt;= 2020; i++) &#123; int t = i; while (t) &#123; if (t % 10 == 2) n++; t /= 10; &#125; &#125; cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; 试题B:既约分数 答案：2481215 12345678910111213141516171819202122 /************************************************************************* &gt; File Name: 十一届—试题B既约分数.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年02月28日 星期日 19时46分32秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n = 0; for (int i = 1; i &lt;= 2020; i++) &#123; for (int j = 1; j &lt;= 2020; j++) &#123; if(__gcd(i, j) == 1) n++; &#125; &#125; cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; 试题C:蛇形填数 题解思路：有题目可以得出， 红色偶数是斜着向下，蓝色奇数是斜着向上由此可以写出代码。 答案：761 123456789101112131415161718192021222324252627282930313233343536/************************************************************************* &gt; File Name: 蛇形填数.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年02月28日 星期日 20时08分21秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;const int MAX_N = 40;int f[MAX_N][MAX_N];int main() &#123; int n = 1; for (int i = 1; i &lt;= MAX_N; i++) &#123; if (i &amp; 1) &#123; // 奇数的情况 for (int x = i, y = 1; x &gt;= 1 &amp;&amp; y &lt;= i; x--, y++) &#123; f[x][y] = n++; &#125; &#125; else &#123; for (int x = 1, y = i; x &lt;= i &amp;&amp; y &gt;= 1; x++, y--) &#123; f[x][y] = n++; &#125; &#125; &#125; for (int i = 1; i &lt;= 20; i++) &#123; for (int j = 1; j &lt;= 20; j++) &#123; cout &lt;&lt; f[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 试题D:跑步锻炼 答案：8879 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/************************************************************************* &gt; File Name: 跑步锻炼.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年03月01日 星期一 13时00分05秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;// 列出所有月份之后 在特殊处理 2 月int m[13] = &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;int leap_year(int x) &#123; if ((x % 4 == 0 &amp;&amp; x % 100 != 0) || x % 400 == 0) return 1; return 0;&#125;int main() &#123; int s = 0; int mark = 6; // 这里题目给出 2000 年 至 2020 年 因为题目给出 2020年不是整月所以就单处理一下 for (int i = 2000; i &lt; 2020; i++) &#123; if (leap_year(i)) m[2] = 29; else m[2] = 28; for (int j = 1; j &lt;= 12; j++) &#123; for (int k = 1; k &lt;= m[j]; k++) &#123; if (mark % 7 == 1 || k == 1) s += 2; else s++; mark++; &#125; &#125; &#125; // 闰年 29 平年 28 if (leap_year(2020)) m[2] = 29; else m[2] = 28; for (int i = 1; i &lt;= 9; i++) &#123; for (int j = 1; j &lt;= m[i]; j++) &#123; if (mark % 7 == 1 || j == 1) s += 2; else s++; mark++; &#125; &#125; // 题目要求 只道 10 月 1 日 由于还是 月初 所以加上 + 2 cout &lt;&lt; s + 2; return 0;&#125; 试题E:七段码 答案：80 来源于网上一个大佬 枚举出所有情况的做法 $$上面是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一 个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分$$ 试题F:成绩统计 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main() &#123; int n; int E = 0, G = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; int t; cin &gt;&gt; t; if (t &gt; 60) G++; if (t &gt; 85) E++; &#125; int t = E * 100.0 / n + 0.5; int t1 = G * 100.0 / n + 0.5; printf(&quot;%d%%\\n%d%%&quot;, t1, t); return 0;&#125;","categories":[{"name":"蓝桥杯历届真题","slug":"蓝桥杯历届真题","permalink":"https://tutouwang.vercel.app/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://tutouwang.vercel.app/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]}],"categories":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"https://tutouwang.vercel.app/categories/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Linux多线程开发","slug":"Linux多线程开发","permalink":"https://tutouwang.vercel.app/categories/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/"},{"name":"Linux多进程开发","slug":"Linux多进程开发","permalink":"https://tutouwang.vercel.app/categories/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/"},{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"c++OOP","slug":"c-OOP","permalink":"https://tutouwang.vercel.app/categories/c-OOP/"},{"name":"LInux-系统编程入门","slug":"LInux-系统编程入门","permalink":"https://tutouwang.vercel.app/categories/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"},{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++\\OOP","slug":"C-OOP","permalink":"https://tutouwang.vercel.app/categories/C-OOP/"},{"name":"教程","slug":"教程","permalink":"https://tutouwang.vercel.app/categories/%E6%95%99%E7%A8%8B/"},{"name":"蓝桥杯历届真题","slug":"蓝桥杯历届真题","permalink":"https://tutouwang.vercel.app/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98/"},{"name":"算法基础","slug":"算法基础","permalink":"https://tutouwang.vercel.app/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"ACwin题解","slug":"ACwin题解","permalink":"https://tutouwang.vercel.app/categories/ACwin%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"[object Object]","slug":"object-Object","permalink":"https://tutouwang.vercel.app/tags/object-Object/"},{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/tags/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"},{"name":"Linux","slug":"Linux","permalink":"https://tutouwang.vercel.app/tags/Linux/"},{"name":"LInux","slug":"LInux","permalink":"https://tutouwang.vercel.app/tags/LInux/"},{"name":"排序","slug":"排序","permalink":"https://tutouwang.vercel.app/tags/%E6%8E%92%E5%BA%8F/"},{"name":"广义表转二叉树","slug":"广义表转二叉树","permalink":"https://tutouwang.vercel.app/tags/%E5%B9%BF%E4%B9%89%E8%A1%A8%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"树与二叉树","slug":"树与二叉树","permalink":"https://tutouwang.vercel.app/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"栈与队列","slug":"栈与队列","permalink":"https://tutouwang.vercel.app/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"name":"链表","slug":"链表","permalink":"https://tutouwang.vercel.app/tags/%E9%93%BE%E8%A1%A8/"},{"name":"顺序表","slug":"顺序表","permalink":"https://tutouwang.vercel.app/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"},{"name":"教程","slug":"教程","permalink":"https://tutouwang.vercel.app/tags/%E6%95%99%E7%A8%8B/"},{"name":"并查集","slug":"并查集","permalink":"https://tutouwang.vercel.app/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://tutouwang.vercel.app/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"中位数","slug":"中位数","permalink":"https://tutouwang.vercel.app/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tutouwang.vercel.app/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]}