{"meta":{"title":"秃头王","subtitle":"","description":"","author":"John Doe","url":"https://tutouwang.vercel.app","root":"/"},"pages":[{"title":"","date":"2022-05-24T01:43:13.878Z","updated":"2021-03-10T02:47:10.545Z","comments":true,"path":"404.html","permalink":"https://tutouwang.vercel.app/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2022-05-24T01:43:13.900Z","updated":"2021-03-10T02:39:15.459Z","comments":true,"path":"about/index.html","permalink":"https://tutouwang.vercel.app/about/index.html","excerpt":"","text":"啊吧啊吧啊吧！！！"},{"title":"所有分类","date":"2022-05-24T01:43:13.901Z","updated":"2021-03-10T02:43:26.017Z","comments":true,"path":"categories/index.html","permalink":"https://tutouwang.vercel.app/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-24T01:43:13.902Z","updated":"2021-03-10T02:46:22.827Z","comments":true,"path":"mylist/index.html","permalink":"https://tutouwang.vercel.app/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-05-24T01:43:13.903Z","updated":"2021-03-10T02:44:59.392Z","comments":true,"path":"tags/index.html","permalink":"https://tutouwang.vercel.app/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"共享内存","slug":"共享内存","date":"2022-05-26T08:15:54.000Z","updated":"2022-05-27T07:27:03.224Z","comments":true,"path":"2022/05/26/共享内存/","link":"","permalink":"https://tutouwang.vercel.app/2022/05/26/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/","excerpt":"","text":"共享内存共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于 一个共享内存段会成为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介 入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其 他所有共享同一个段的进程可用。 与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据 从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快 共享内存使用步骤调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其 他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。 使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存， 程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间 中该共享内存段的起点的指针。 调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存 了。这一步是可选的，并且在进程终止时会自动完成这一步。 调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之 后内存段才会销毁。只有一个进程需要执行这一步 共享内存操作函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;sys/ipc.h&gt;#inlcude &lt;sys/shm.h&gt;int shmget(key_t key, size_t size, int shmflg); - 功能创建一个新的共享内存段、或者获取一个既有的共享内存段的标识 新创建的内存段中的数据都会被初始化为0 - 参数: - key: key_t 类型是一个整形,通过这个找到或者创建一个共享内存 一般使用16进制表示,非0值 - size: 共享内存大小 分页大小 - shmflg: 属性 - 访问权限 - 附加属性: 创建/判断共享内存是不是存在 - 创建: IPC_CREAT - 判断共享内存是否存在: IPC_EXCL, 需要和IPC_CREAT一起使用 IPC_CREAT | IPC_EXCL | 0664 - 返回值: 失败: -1 并设置错误号 成功: &gt;0 返回共享内存的引用的ID,后面操作共享内存都是通过这个值 void *shmat(int shmid, const void *shmaddr, int shmflg); - 功能: 和当前的进程进行关联 - 参数: - shmid: 共享内存的标识(ID)由shmget返回值获取 - shmaddr: 申请的共享内存的起始地址,指定NULL, 内核指定 - shmflg: 对共享内存的操作 - 读 : SHM_RDONLY, 必须由读权限 - 读写 : 0 - 返回值: 成功: 返回共享内存的首地址(起始)地址。 失败: (void *) -1int shmdt(const void *shmaddr); - 功能: 解除当前进程和共享内存的关联 - 参数: shmaddr: 共享内存的首地址 - 返回值: 成功: 0 失败: -1int shmctl(int shmid, int cmd, struct shmid_ds *buf); - 功能: 对共享内存进行操作。删除共享内存, 共享内存要删除才会消失, 创建共享内存的进行被销毁了对共享内存是没有任何影响 - 参数: - shmid: 共享内存的ID - cmd: 要做的操作 - IPC_STAT:获得共享内存的当前状态 - IPC_SET: 设置共享内存的状态 - IPC_RMID: 标记共享内存被销毁 - buf: 需要设置或者获取的共享内存属性信息 - IPC_STAT:buf存储数据 - IPC_SET: buf中需要初始化数据,设置到内核中 - IPC_RMID: 没有用,NULL struct shmid_ds &#123; struct ipc_perm shm_perm; /* Ownership and permissions */ size_t shm_segsz; /* Size of segment (bytes) */ time_t shm_atime; /* Last attach time */ time_t shm_dtime; /* Last detach time */ time_t shm_ctime; /* Last change time */ pid_t shm_cpid; /* PID of creator */ pid_t shm_lpid; /* PID of last shmat(2)/shmdt(2) */ shmatt_t shm_nattch; /* No. of current attaches */ ... &#125;;key_t ftok(const char *pathname, int proj_id); - 功能: 根据指定的路, 和int值,生成一个共享内存的key - 参数: - pathname: 指定一个存在的路径 /home/qz/test/ / - proj_id: int类型的值,但是这关系调用只会使用其中的1个字符 范围: 0 - 255 一般指定一个字符 &#x27;a&#x27; write_shm.c123456789101112131415161718192021222324252627282930313233343536/************************************************************************* &gt; File Name: read_shm.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月27日 星期五 10时35分18秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;string.h&gt;int main() &#123; // 获取一个共享内存 int shmid = shmget(100, 4096, IPC_CREAT | 0664); printf(&quot;hmid : %d\\n&quot;,shmid); // 和当前进程进行关联 void *ptr = shmat(shmid, NULL, 0); char *str = &quot;hello world&quot;; memcpy(ptr, str, strlen(str) + 1); printf(&quot;按任意键继续\\n&quot;); getchar(); // 解除关联 shmdt(ptr); //删除关联 shmctl(shmid, IPC_RMID, NULL); return 0;&#125; read_shm.c12345678910111213141516171819202122232425262728293031323334/************************************************************************* &gt; File Name: read_shm.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月27日 星期五 10时35分18秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/ipc.h&gt;int main() &#123; // 获取一个共享内存 int shmid = shmget(100, 0, IPC_CREAT); printf(&quot;hmid : %d\\n&quot;,shmid); // 和当前进程进行关联 void *ptr = shmat(shmid, NULL, 0); printf(&quot;%s \\n&quot;, (char *) ptr); printf(&quot;按任意键继续\\n&quot;); getchar(); // 解除关联 shmdt(ptr); //删除关联 shmctl(shmid, IPC_RMID, NULL); return 0;&#125; 问题 yellow::问题1：操作系统如何知道一块共享内存被多少个进程关联？ 共享内存维护了一个结构体struct shmid_ds 这个结构体中由一个成员 shm_nattch","categories":[],"tags":[]},{"title":"信号","slug":"Linux-多线程开放/信号","date":"2022-05-18T06:50:27.000Z","updated":"2022-05-26T04:14:46.191Z","comments":true,"path":"2022/05/18/Linux-多线程开放/信号/","link":"","permalink":"https://tutouwang.vercel.app/2022/05/18/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/%E4%BF%A1%E5%8F%B7/","excerpt":"","text":"信号概述信号是 Linux进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个丘在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。 发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下: 对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C(9号信号)通常会给进程发送一个中断信号。 硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被О除，或者引用了无法访问的内存区域 系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的CPU时间超限，或者该进程的某个子进程退出。 运行 kill 命令或调用 kill 函数。 使用信号的两个主要目的是: 让进程知道已经发生了一个特定的事情。 强迫进程执行它自己代码中的信号处理程序。 信号的特点： 简单 不能携带大量的信息 满足某个特定条件才能发送 优先级比高 查看系统定义的信号列表：kill -l 前31个信号为常规信号,其余为实时信号。 信号一览表 编号 信号名称 对应事件 默认动作 1 SIGHUP 用户退出shell时，由该shell启动的所有进程将 收到这个信号 终止进程 2 SIGINT 当用户按下了组合键时，用户终端向正 在运行中的由该终端启动的程序发出此信号(CTRL + C) 终止进程 3 SIGQUIT 户按下组合键时产生该信号，用户终 端向正在运行中的由该终端启动的程序发出些信号 (CTRL + \\) 终止进程 4 SIGILL CPU检测到某进程执行了非法指令 终止进程并产生core文件 5 SIGTRAP 该信号由断点指令或其他 trap指令产生 终止进程并产生core文件 6 SIGABRT 调用abort函数时产生该信号 终止进程并产生core文件 7 SIGBUS 非法访问内存地址，包括内存对齐出错 终止进程并产生core文件 8 SIGFPE 在发生致命的运算错误时发出。不仅包括浮点运算 错误，还包括溢出及除数为0等所有的算法错误 终止进程并产生core文件 9 SIGKILL 无条件终止进程。该信号不能被忽略，处理和阻塞 终止进程，可以杀死任何进程 10 SIGUSE1 用户定义的信号。即程序员可以在程序中定义并使用该信号 终止进程 11 SIGSEGV 指示进程进行了无效内存访问(段错误) 终止进程并产生core文件 12 SIGUSR2 另外一个用户自定义信号，程序员可以在程序中定义并使用该信号 终止进程 13 SIGPIPE Broken pipe向一个没有读端的管道写数据 终止进程 14 SIGALRM 定时器超时，超时的时间 由系统调用alarm设置 终止进程 15 SIGTERM 程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号 终止进程 16 SIGSTKFLT Linux早期版本出现的信号，现仍保留向后兼容 终止进程 17 SIGCHLD 子进程结束时，父进程会收到这个信号 忽略这个信号 18 SIGCONT 如果进程已停止，则使其继续运行 继续&#x2F;忽略 19 SIGSTOP 停止进程的执行。信号不能被忽略，处理和阻塞 为终止进程 20 SIGTSTP 停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号 暂停进程 21 SIGTTIN 后台进程读终端控制台 暂停进程 22 SIGTTOU 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生 暂停进程 23 SIGURG 套接字上有紧急数据时，向当前正在运行的进程发出些信号，报 告有紧急数据到达。如网络带外数据到达 忽略该信号 24 SIGXCPU 进程执行时间超过了分配给该进程的CPU时间，系统产生该信号并发送给该进程 终止进程 25 SIGXFSZ 超过文件的最大长度设置 终止进程 26 SIGVTALRM 虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间 终止进程 27 SGIPROF 类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间 终止进程 28 SIGWINCH 窗口变化大小时发出 忽略该信号 29 SIGIO 此信号向进程指示发出了一个异步IO事件 忽略该信号 30 SIGPWR 关机 终止进程 31 SIGSYS 无效的系统调用 终止进程并产生core文件 34 ~64 SIGRTMIN ～ SIGRTMAX LINUX的实时信号，它们没有固定的含义（可以由用户自定义） 终止进程 信号的 5 种默认处理动作查看信号的详细信息：man 7 signal 信号的 5 中默认处理动作 Term 终止进程 Ign 当前进程忽略掉这个信号 Core 终止进程，并生成一个Core文件 Stop 暂停当前进程 Cont 继续执行当前被暂停的进程 信号的几种状态：产生、未决、递达 SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。 core0代表不会生成core文件 图2为设置core文件 123456789101112131415/************************************************************************* &gt; File Name: kill.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月18日 星期三 18时39分29秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; char *buf; strcpy(buf, &quot;hello&quot;); return 0;&#125; kill、raise、abort函数因为会抢占cpu的资源不确定执行几次 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/************************************************************************* &gt; File Name: kill.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月18日 星期三 18时39分29秒 ************************************************************************//* * #include &lt;sys/types.h&gt; * #include &lt;signal.h&gt; * int kill(pid_t pid, int sig); * - 功能: 给任何的进程或者进程组pid, 发送某个信号 sig * - 参数: * - pid : 需要发送给的进程的id * &gt; 0 : 将信号发送给指定的进程 * = 0 : 将信号发送给当前的进程组 * = -1 : 表示将信号发送给每一个有权限的接受这个信号的进程 * &lt; -1 : 这个pid等于某个进程组的ID取反(1234) -&gt; (-1234) * - sig : 需要发送的信号的编号或者宏值,如果是0的话不发送任何信号 * kill(getppid(), 9); * kill(getpid(), 9); * * int raise(int sig); * - 功能: 给当前进程发送信号 * - 参数: * - sug : 要发送的信号 * - 返回值; * - 成功 0 * - 失败 非 0 * kill(getpid(), sig); * * void abort(void); * - 功能: 发送SIGABRT信号给当前进程,杀死当前进程 * kill(getpid(), SIGABRT); */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;int main() &#123; pid_t pid = fork(); if(pid == 0) &#123; // 子 for(int i = 0; i &lt; 5; i++) &#123; printf(&quot;child process\\n&quot;); sleep(1); &#125; &#125; else if(pid &gt; 0) &#123; // 父 printf(&quot;parent process\\n&quot;); sleep(2); printf(&quot;kill child process now\\n&quot;); // 父进程返回是子进程的信号 kill(pid, SIGINT); &#125; return 0;&#125; alarm 函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344/************************************************************************* &gt; File Name: alarm.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月19日 星期四 12时59分47秒 ************************************************************************//* * #include &lt;unistd.h&gt; * unisgned int alarm(unsigned int seconds); * - 功能: 设置定时器 (闹钟),函数调用,开始倒计时,倒计时为0的时候函数会给当前的 进程发送一个信号:SIGALARM * - 参数: * seconds: 倒计时的时长, 单位: 秒。 如果参数为0, 定时器无效(不进行倒计时不发信号) * 取消一个定时器,通过alarm(0); * - 返回值: 倒计时剩余的时间 * - 之前没有定时器, 返回0 * - 之前有定时器, 返回之前的定时器剩余时间 * -SIGALARM:默认终止当前的进程, 每一个进程都有且只有唯一的一个定时器 * alarm(10); -&gt; 返回 0 * 过了1秒 - 再定义一个 * alarm(5); -&gt; 返回9 * alarm(100) -&gt; 该函数是不阻塞的 * */#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; int seconds = alarm(5); printf(&quot;seconds = %d \\n&quot;, seconds); // 0 sleep(2); seconds = alarm(2); printf(&quot;seconds = %d \\n&quot;, seconds); // 3 while(1) &#123; &#125; return 0;&#125; 计算机一秒中电脑能数多少个数123456789101112131415161718192021222324252627/************************************************************************* &gt; File Name: alarm_One.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月19日 星期四 18时37分11秒 ************************************************************************//* * 实际时间 = 内核时间 + 用户时间 + 操作IO消耗的时间 * 进行文件IO操作的时间比较浪费时间 * * 定时器,与进程的状态无关 (自然定时法)。无论进程处于什么状态,alarm都会计时 * */#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; alarm(1); // 系统调用 -&gt; 内核 int i = 0; // 内核 -&gt; 用户区 while(1) &#123; printf(&quot;%d\\n&quot;, i++); &#125; return 0;&#125; 建议 g++ xxx.c .&#x2F;a.out &gt;&gt; a.txt setitimer 定时器函数 - 周期1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/************************************************************************* &gt; File Name: setitimer.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月19日 星期四 19时32分31秒 ************************************************************************//* * #include &lt;sys/time.h&gt; * int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value); * - 功能: 设置定时器(闹钟)。可以代替alarm函数。精度微秒us, 可以实现周期性定时 * - 参数: * - which: 定时器可以什么时间计时 * ITIMER_REAL: 真实时间,时间到达, 发送 SIGALRM 常用 * ITIMER_VIRTUAL: 用户时间,时间到达,发送SIGVTALRM * ITIMER_PROF: 以该进程在用户态下所消耗的时间来计算,时间到达, 发送SIGPROF * - new_value: * // 定时器结构体 * struct itimerval &#123; * // 每个阶段的时间,间隔时间 * struct timeval it_intercal; * // 延迟多长时间执行定时器 * struct timeval it_value; * &#125;; * * // 时间结构体 * struct timeval &#123; * // 秒数 * time_t tv_sec; * // 微妙 * suseconds_t tv_usec; * &#125;; * 过10(it_value)秒后,每隔2(it_intercal)秒定时一次 * - old_value: 记录上一次的定时的时间参数一般不使用,指定NULL * * - 返回值 * 成功 0 * 失败 -1 并设置错误号 */#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;stdlib.h&gt;// 过3秒以后,每2秒钟定时一次int main() &#123; struct itimerval new_value; new_value.it_interval.tv_sec = 2; // 微秒不设置就是随机的 new_value.it_interval.tv_usec = 0; // 设置延迟的时间, 3秒之后开始第一次定时 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret = setitimer(ITIMER_REAL, &amp;new_value, NULL); // 非阻塞 printf(&quot;定时器开始了！\\n&quot;); if(ret == -1) &#123; perror(&quot;setitimer&quot;); exit(-1); &#125; getchar(); return 0;&#125; signal 信号捕捉函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/************************************************************************* &gt; File Name: signal.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月24日 星期二 09时34分06秒 ************************************************************************//* * #include &lt;signal.h&gt; * typedef void (*sighandler_t)(int); * sighandler_t signal(int signum, sighandler_t handler); * - 功能: 设置某个信号的捕捉行为 * - 参数: * - signum: 要捕捉的信号 * - handler 捕捉的信号要如何处理 * - SIG_IGN: 忽略信号 * - SIG_DFL: 使用信号默认的行为 * - 回调函数: 这个函数是内核调用的(系统), 程序负责写,捕获到信号后如何去处理信号。 * 回调函数: * - 需要程序员实现,提前准好的,函数的类型根据实际需求,看函数指针的定义 * - 不是程序员调用,而是信号产生由内核调用 * - 函数指针是是现实函数回调的手段,函数实现之后,将函数名 放到函数指针的位置就可以了 * - 返回值: * 成功 返回上一次注册的信号处理函数的地址。第一次调用返回NULL * 失败 返回SIG_ERR,设置错误号 * SIGKILL(9号信号) SIGSTOP不能被捕捉,不能被忽略 */#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;void myalarm(int num) &#123; printf(&quot;捕捉到了信号的编号是: %d \\n&quot;, num); printf(&quot;xxxxxx\\n&quot;); return ;&#125;// 过3秒以后,每2秒钟定时一次int main() &#123; // 注册信号捕捉 // signal(SIGALRM, SIG_IGN); // signal(SIGALRM, SIG_DFL); // void (*sighandler_t)(int); 函数指针,int类型的参数表示捕捉的到的信号 值。 signal(SIGALRM, myalarm); struct itimerval new_value; new_value.it_interval.tv_sec = 2; // 微秒不设置就是随机的 new_value.it_interval.tv_usec = 0; // 设置延迟的时间, 3秒之后开始第一次定时 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret = setitimer(ITIMER_REAL, &amp;new_value, NULL); // 非阻塞 printf(&quot;定时器开始了！\\n&quot;); if(ret == -1) &#123; perror(&quot;setitimer&quot;); exit(-1); &#125; getchar(); return 0;&#125; 信号集许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为 信号集的数据结构来表示，其系统数据类型为 sigset_t。 在 PCB 中有两个非常重要的信号集。一个称之为 “阻塞信号集” ，另一个称之为 “未决信号集” 。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我 们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数 来对 PCB 中的这两个信号集进行修改。 信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。 信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。 信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号， 所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。 阻塞信号集和未决信号未决信号集：信号没被处理之前都会在未决信号集 阻塞信号集：我们需要对某几个信号进行阻塞 阻塞信号集和未决信号集1.用户通过键盘 Ctrl + C, 产生2号信号SIGINT (信号被创建) 2.信号产生但是没有被处理 （未决） - 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集） - SIGINT信号状态被存储在第二个标志位上 - 这个标志位的值为0， 说明信号不是未决状态 - 这个标志位的值为1， 说明信号处于未决状态 3.这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较 - 阻塞信号集默认不阻塞任何的信号 - 如果想要阻塞某些信号需要用户调用系统的API 4.在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了 如果没有阻塞，这个信号就被处理 如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理 号集相关的函数 - 只对自定义的有效123456789101112131415161718192021222324252627282930313233343536373839404142以下信号集相关的函数都是对自定义的信号集进行操作int sigemptyset(sigset_t *set); - 功能: 清空信号集中的数据, 将信号集中的所有的标志位置 清空 - 0 - 参数: set,传出参数,需要操作的信号集 - 返回值: - 成功返回 0 - 失败返回 -1int sigfillset(sigset_t *set); - 功能: 将信号集中的所有的标志位置为 1 - 参数: set,传出参数,需要操作的信号集 - 返回值: - 成功返回 0 - 失败返回 -1int sigaddset(sigset_t *set, int signum); - 功能: 向信号集中的某一个信号对应标志位为1，表示阻塞这个信号 - 参数: - set: 传出参数,需要操作的信号集 - signum: 需要设置阻塞的那个信号 - 返回值: - 成功返回 0 - 失败返回 -1int sigdelset(sigset_t *set, int signum); - 功能: 向信号集中的某一个信号对应标志位为0，表示不阻塞这个信号 - 参数: - set: 传出参数,需要操作的信号集 - signum: 需要设置不阻塞的那个信号 - 返回值: - 成功返回 0 - 失败返回 -1int sigismember(const sigset_t *set, int signum); - 功能: 判断某个信号是否阻塞 - 参数: - set: 需要操作的信号集 - signum: 需要判断的那个信号 - 返回值: - 1 signum 被阻塞 - 0 signum 不阻塞 - -1 signum 调用失败 /***************下面就是系统的API可以操作内核***************/int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);int sigpending(sigset_t *set); sigset - 设置未决信号集、阻塞信号集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/************************************************************************* &gt; File Name: sigset.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月24日 星期二 17时25分15秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;signal.h&gt;int main() &#123; // 创建一个信号集 sigset_t set; // 清空 sigemptyset(&amp;set); // 判断 SIGINT 是否在信号集 set 里 int ret = sigismember(&amp;set, SIGINT); if(ret == 0) &#123; printf(&quot;SIGINT 不阻塞\\n&quot;); &#125; else if(ret == 1) &#123; printf(&quot;SIGINT 阻塞\\n&quot;); &#125; else if(ret == -1) &#123; printf(&quot;调用失败\\n&quot;); &#125; // 添加几个信号到信号集中 sigaddset(&amp;set, SIGINT); sigaddset(&amp;set, SIGQUIT); ret = sigismember(&amp;set, SIGINT); if(ret == 0) &#123; printf(&quot;SIGINT 不阻塞\\n&quot;); &#125; else if(ret == 1) &#123; printf(&quot;SIGINT 阻塞\\n&quot;); &#125; else if(ret == -1) &#123; printf(&quot;调用失败\\n&quot;); &#125; ret = sigismember(&amp;set, SIGQUIT); if(ret == 0) &#123; printf(&quot;SIGQUIT 不阻塞\\n&quot;); &#125; else if(ret == 1) &#123; printf(&quot;SIGQUIT 阻塞\\n&quot;); &#125; else if(ret == -1) &#123; printf(&quot;调用失败\\n&quot;); &#125; // 从信号集中删除一个 sigdelset(&amp;set, SIGQUIT); ret = sigismember(&amp;set, SIGQUIT); if(ret == 0) &#123; printf(&quot;SIGQUIT 不阻塞\\n&quot;); &#125; else if(ret == 1) &#123; printf(&quot;SIGQUIT 阻塞\\n&quot;); &#125; else if(ret == -1) &#123; printf(&quot;调用失败\\n&quot;); &#125; return 0;&#125; sigprocmask - 阻塞信号集 - 内核 所有的常规信号 - 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/************************************************************************* &gt; File Name: sigprocmask.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月24日 星期二 18时42分13秒 ************************************************************************//* sigset_t == long int int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); - 功能: 将自定义信号集中的数据设置到内核中 (设置阻塞、解除阻塞、替换) - 参数: - how: 如何对内核阻塞信号进程处理 SIG_BLOCK: 将用户设置的阻塞信号集添加 到内核中,内核中原来的数据不变 列: 信号集 - mask 1 0 1 0 0 0 0 sigset_t - set | 0 1 0 0 0 0 0 ------------------ 1 1 1 0 0 0 0 假设内核中默认的阻塞信号集是 mask, mask | set SIG_UNBLOCK: 根据用户设置的数据,对内核中的数据进行解除阻塞 mask &amp;= ~set; SIG_SETMASK: 覆盖内核中原来的值 - set: 已经初始化好的用户自定义的信号集 - oldset: 保存设置之前的内核中的阻塞的信号集的状态, 可以是 NULL - 返回值: 成功返回: 0 失败返回: -1 并设置错误号: EFAULF、EINVAL int sigpending(sigset_t *set); - 功能: 获取内核中的未决信号集 - 参数: set, 传出参数, 保存的是内核中的未决信号集中的 信息 */#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt; // 所有的常规信号 kill -l (1 - 31) 未决状态打印到屏幕 // 设置某些信号是阻塞的,通过键盘产生这些信号int main() &#123; // 设置2、3信号阻塞 SIGINT(CTRL + C)、SIGQUIT(CTRL + \\) sigset_t set; sigemptyset(&amp;set); // 将2号和3号信号添加到信号集中 sigaddset(&amp;set, SIGINT); sigaddset(&amp;set, SIGQUIT); // 修改内核中的阻塞信号集 sigprocmask(SIG_BLOCK, &amp;set, NULL); int cnt = 0; while(1) &#123; cnt++; // 获取当前的未决信号集的数据 sigset_t pendingset; sigemptyset(&amp;pendingset); sigpending(&amp;pendingset); // 遍历前31位 for(int i = 1; i &lt;= 31; i++) &#123; if(sigismember(&amp;pendingset, i) == 1) &#123; printf(&quot;1&quot;); &#125;else if(sigismember(&amp;pendingset, i) == 0) &#123; printf(&quot;0&quot;); &#125; else &#123; printf(&quot;sigismember&quot;); exit(0); &#125; &#125; printf(&quot;\\n&quot;); sleep(1); if(cnt == 10) &#123; // 接触阻塞 sigprocmask(SIG_UNBLOCK, &amp;set, NULL); &#125; &#125; return 0;&#125; 前台进程和后台进程 run sigprocmask.c 直接运行程序 CTRL + z 也只是让程序后台运行 run sigprocmask.c &amp; &#x2F;&#x2F; 让程序在后台运行 fg &#x2F;&#x2F; 切换到前台 sigaction信号捕捉 尽量使用 sigaction 因为标准不一样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/************************************************************************* &gt; File Name: sigaction.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月25日 星期三 11时32分35秒 ************************************************************************//* * #include &lt;signal.h&gt; * int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); * - 功能: 检查或者改变信号的处理,信号捕捉 * - 参数: * - signum: 需要捕捉信号的编号或者宏值,不能捕捉的信号(SIGKILL and SIGSTOP) * - act: 捕捉信号之后的处理动作 * - oldact: 上一次对信号的捕捉相关的设置,一般补使用,传递NULL * - 返回值: * 成功 0 * 失败 -1 * * struct sigaction &#123; * 函数指针, 指向的函数就是信号捕捉到之后的处理函数 * void (*sa_handler)(int); * * 不常用 - 信号的编号, 信号的相关的信息, 信号的相关的信息 * void (*sa_sigaction)(int, siginfo_t *, void *); * * 临时阻塞信号集,信号捕捉函数执行过程中, 临时阻塞某些信号 * sigset_t sa_mask; * * 使用那一个信号处理对捕捉到的信号进行处理 * 这个值 0 表示使用sa_handler * 也可以是 SA_SIGINFO 表示使用 sa_sigaction * int sa_flags; * * 呗废弃掉了 * void (*sa_restorer)(void); * &#125;; */#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;void myalarm(int num) &#123; printf(&quot;捕获的信号的编号是: %d \\n&quot;, num); printf(&quot;xxxxxxx\\n&quot;); return ;&#125;int main() &#123; struct sigaction act; act.sa_flags = 0; act.sa_handler = myalarm; // 清空临时信号集 sigemptyset(&amp;act.sa_mask); // 注册信号捕捉 sigaction(SIGALRM, &amp;act, NULL); struct itimerval new_value; // 设置间隔时间 new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; // 设置延迟的时间, 3妙之后开始第一次定时 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; // 非阻塞 int ret = setitimer(ITIMER_REAL, &amp;new_value, NULL); printf(&quot;定时器开始了\\n&quot;); if(ret == -1) &#123; perror(&quot;setitimer&quot;); exit(-1); &#125; // getchar(); while(1); return 0;&#125; 内核实现信号捕捉的过程 SIGCHLD - 解决僵尸进程SIGCHLD信号产生的条件 子进程终止时 子进程接收到 SIGSTOP 信号停止时 子进程处在停止态,接受到SIGCONT后唤醒时 以上三种条件都会给父进程发送 SIGCHLD 信号, 父进程默认会忽略该信号 创建20个子进程12345678910111213141516171819202122232425262728293031323334353637383940414243444546/************************************************************************* &gt; File Name: sigchld.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月25日 星期三 17时19分37秒 ************************************************************************//* * SIGCHLD信号产生的3个条件: * 1.子进程结束 * 2.子进程暂停了 * 3.子进程继续运行 * 都会给父进程发送该信号,父进程默认忽略该信号 * 使用SIGCHLD信号解决僵尸进程的问题 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 创建一些子进程 pid_t pid; for(int i = 0; i &lt; 20; i++) &#123; pid = fork(); if(pid == 0) &#123; // 子 break; &#125; &#125; if(pid &gt; 0) &#123; // 父 while(1) &#123; printf(&quot;parent process pid : %d \\n&quot;, getpid()); sleep(2); &#125; &#125; else if(pid == 0) &#123; // 子 printf(&quot;child process pid : %d \\n&quot;, getpid()); &#125; return 0;&#125; 父进程结束子进程就死了 wait、waitpid 一次只能回收一个子进程 点我带你去看wait - waitpid 段错误(核心内存以转换) - 代码清除僵尸进程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/************************************************************************* &gt; File Name: sigchld.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月25日 星期三 17时19分37秒 ************************************************************************//* * SIGCHLD信号产生的3个条件: * 1.子进程结束 * 2.子进程暂停了 * 3.子进程继续运行 * 都会给父进程发送该信号,父进程默认忽略该信号 * 使用SIGCHLD信号解决僵尸进程的问题 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;void myFun(int num) &#123; printf(&quot;捕捉到的信号 : %d\\n&quot;, num); // 回收子进程PCB的资源 /* while(1) &#123; wait(NULL); &#125; */ while(1) &#123; int ret = waitpid(-1, NULL, WNOHANG); if(ret &gt; 0) &#123; printf(&quot;child die , pid = %d\\n&quot;, ret); &#125; else if(ret == 0) &#123; // printf(&quot;还有子进程活着\\n&quot;); break; &#125; else if(ret == -1) &#123; // 没有子进程了 break; &#125; &#125; return ;&#125;int main() &#123; // 创建一些子进程 pid_t pid; for(int i = 0; i &lt; 20; i++) &#123; pid = fork(); if(pid == 0) &#123; // 子 break; &#125; &#125; if(pid &gt; 0) &#123; // 父 // 捕捉子进程死亡时发送的SIGCHLD信号 struct sigaction act; act.sa_flags = 0; act.sa_handler = myFun; sigemptyset(&amp;act.sa_mask); sigaction(SIGCHLD, &amp;act, NULL); while(1) &#123; printf(&quot;parent process pid : %d \\n&quot;, getpid()); sleep(2); &#125; &#125; else if(pid == 0) &#123; // 子 printf(&quot;child process pid : %d \\n&quot;, getpid()); &#125; return 0;&#125; sigaction(SIGCHLD, &amp;act, NULL); 信号捕捉 信号捕捉还没有去注册成功 子进程就结束了 完了再去信号捕捉 就不能回收子进程了 回收改进12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/************************************************************************* &gt; File Name: sigchld.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月25日 星期三 17时19分37秒 ************************************************************************//* * SIGCHLD信号产生的3个条件: * 1.子进程结束 * 2.子进程暂停了 * 3.子进程继续运行 * 都会给父进程发送该信号,父进程默认忽略该信号 * 使用SIGCHLD信号解决僵尸进程的问题 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;void myFun(int num) &#123; printf(&quot;捕捉到的信号 : %d\\n&quot;, num); // 回收子进程PCB的资源 /* while(1) &#123; wait(NULL); &#125; */ while(1) &#123; int ret = waitpid(-1, NULL, WNOHANG); if(ret &gt; 0) &#123; printf(&quot;child die , pid = %d\\n&quot;, ret); &#125; else if(ret == 0) &#123; // printf(&quot;还有子进程活着\\n&quot;); break; &#125; else if(ret == -1) &#123; // 没有子进程了 break; &#125; &#125; return ;&#125;int main() &#123; // 提前设置好阻塞信号集, 阻塞SIGCHLD,因为有可能子进程很快结束,父进程还没注册好信号捕捉 sigset_t set; sigemptyset(&amp;set); sigaddset(&amp;set, SIGCHLD); sigprocmask(SIG_BLOCK, &amp;set, NULL); // 创建一些子进程 pid_t pid; for(int i = 0; i &lt; 20; i++) &#123; pid = fork(); if(pid == 0) &#123; // 子 break; &#125; &#125; if(pid &gt; 0) &#123; // 父 // 捕捉子进程死亡时发送的SIGCHLD信号 struct sigaction act; act.sa_flags = 0; act.sa_handler = myFun; sigemptyset(&amp;act.sa_mask); sigaction(SIGCHLD, &amp;act, NULL); // 注册完信号捕捉以后,解除阻塞 sigprocmask(SIG_UNBLOCK, &amp;set, NULL); while(1) &#123; printf(&quot;parent process pid : %d \\n&quot;, getpid()); sleep(2); &#125; &#125; else if(pid == 0) &#123; // 子 printf(&quot;child process pid : %d \\n&quot;, getpid()); &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"内存映射","slug":"Linux-多线程开放/内存映射","date":"2022-05-17T03:09:38.000Z","updated":"2022-05-22T15:05:06.447Z","comments":true,"path":"2022/05/17/Linux-多线程开放/内存映射/","link":"","permalink":"https://tutouwang.vercel.app/2022/05/17/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/","excerpt":"","text":"内存映射内存映射(Memory-mapped I&#x2F;O)是将磁盘文件的数据映射到内存,用户通过修改内存就能修改磁盘文件 父子进程间通信123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/************************************************************************* &gt; File Name: mmap-parent-child-ipc.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月15日 星期日 21时25分03秒 ************************************************************************//* * #include &lt;sys/mman.h&gt; * void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); * - 功能: 将一个文件或者设备的数据映射到内存中 * - 参数: * - void *addr : NULL // 由内核指定 * - length : 要映射的数据长度, 这个值不能为0,建议使用文件的长度。 * 获取文件长度 : stat、lseek * - prot : 对申请的内存映 * - PROT_EXEC : 可执行的权限 * - PROT_READ : 读权限 * - PROT_WRITE : 写权限 * - PROT_NONE : 没有权限 * 要操作映射内存,必须要有读的权限 * PROT_READ、PROT_READ|PROT_WRITE * - flags : * - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步,进程间通信,必 需要设置这个选项 * - MAP_PRIVATE : 不同步,内存映射器的数据改变了,对原的文件不会修改, 重新创建一个新的文件。(copy on write) * - fd: 需要映射的文件描述符 * - 通过open得到，open的是一个磁盘文件 * - 注意: 文件的大小不能为0, open指定的权限不能和prot参数有冲突。 * open 只读/读写 prot : PROT_READ(必须有) * prot : PROT_READ open:只读/读写 (小于open的权限) * prot : PROT_READ | PROT_WRITE open: 只能是读写 * - offset: 便宜量, 一般不用。必须指定的是4k的正数倍。0表示不偏移 * - 返回值: 返回创建的内存的首地址 * 失败返回MAP_FAILED, (void *) -1 * int munmap(void *addr, size_t length); * - 功能: 释放内存映射 * - 参数: * - addr : 要释放的内存的首地址 * - length : 要释放的内存大小, 要和 mmap 函数中的length参数的值一样 * *//* * 使用内存映射实现进程通信: * 1.有关系的进程(父子进程) * - 还有没有子进程的时候 * - 通过唯一的父进程, 先创建内存映射区 * - 有了内存映射区以后, 创建子进程 * - 父子进程共享创建的内存映射区 * * 2.没有关系的进程通信 * - 准备一个大小不是0的磁盘文件 * - 进程 1 通过磁盘文件创建内存映射区 * - 得到一个操作这块内存的指针 * - 进程 2 通过磁盘文件创建内存映射区 * - 得到一个操作这块内存的指针 * - 使用内存映射区实现进程通信 * 注意: 内存映射区通信,是非阻塞的 */#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;int main() &#123; // 1. 打开一个文件 int fd = open(&quot;test.txt&quot;, O_RDWR); int size = lseek(fd, 0, SEEK_END); // 获取文件的大小 // 2.创建文件 mmap(地址、大小、权限和open对应起来、同步、文件描述符、偏移量) void *ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(ptr == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if(pid &gt; 0) &#123; wait(NULL); // 父进程 char buf[64]; strcpy(buf, (char*)ptr); printf(&quot;read data : %s\\n&quot;, buf); &#125; else if(pid == 0)&#123; // 子进程 strcpy((char *)ptr, &quot;nihao a, son !!!&quot;); &#125; // 关闭内存映射区 munmap(ptr, size); return 0;&#125; 内存映射的注意事项 如果对mmap的返回值(ptr)做++操作(ptr++),munmap是否能够成功? ​ void *ptr &#x3D; mmap(…) ​ ptr++； 可以对其进行++ 操作 ​ 但是 munmap(ptr, len) &#x2F;&#x2F; 错误，要保存地址 如果open时O_RDONLY，mmap时prot参数指定PROT_READ | PROT_WRITE会怎样? ​ 错误,返回一个宏 MAP_FAILED ​ open() 函数中的权限建议和prot参数的权限保持一致 如果文件偏移量为1000会怎样? 偏移量是4k的整数倍，返回 MAP_FAILED mmap什么情况下会调用失败? ​ - 第二个参数: length &#x3D; 0 （映射数据长度） 不能再内存中映射为 0 ​ - 第三个参数： prot ​ 只指定了写权限 ​ prot PROT_READ | PROT_WRITE ​ 第5个参数(文件描述符) fd 通过open函数时指定的 O_RDONLY 或者 O_WRONLY 可以open的时候O_CREAT一个新文件来创建映射区吗? ​ 可以的，但文件的大小如果为0的话，肯定不行 ​ 可以对新的文件进行扩展 ​ lseek() ​ truncate() mmap后关闭文件描述符，对mmap映射有没有影响? int fd &#x3D; open(“xxx”); mmap(…, fd, 0); close(fd); &#x2F;&#x2F; 关闭不会产生问题 映射区还存在，创建映射区的fd被关闭,没有任何影响 对ptr越界操作会怎样? ​ void * ptr &#x3D; mmap(null, 100, …) ​ 4k ​ 越界操作的是非法的内存 -&gt; 段错误 使用内存映射实现文件拷贝需要先创建一个test.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/************************************************************************* &gt; File Name: copy.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月18日 星期三 10时47分03秒 ************************************************************************//* * 思路: * 1.对原始的文件进行内存映射 * 2.创建一个新文件 (拓展该文件) * 3.把新文件的数据映射要内存中 * 4.通过内存拷贝将第一个文件的内存数据拷贝到新的文件内存中 * 5.释放资源 * */#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 使用内存映射实现文件拷贝int main() &#123; // 对原始的文件进行内存映射 int fd = open(&quot;test.txt&quot;, O_RDWR); if(fd == -1) &#123; perror(&quot;open&quot;); exit(-1); &#125; // 获取原始文件大小 int len = lseek(fd, 0, SEEK_END); // 创建一个新文件 int fd1 = open(&quot;cpy.txt&quot;, O_RDWR | O_CREAT, 0664); // 对新创建文件进程拓展 truncate(&quot;cpy.txt&quot;, len); write(fd1, &quot; &quot;, 1); // 内存映射 void *ptr = mmap(NULL, len, PROT_READ| PROT_WRITE, MAP_SHARED, fd, 0); void *ptr1 = mmap(NULL, len, PROT_READ| PROT_WRITE, MAP_SHARED, fd1, 0); if(ptr == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(-1); &#125; if(ptr1 == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(-1); &#125; // 内存拷贝 memcpy(ptr1, ptr, len); // 释放资源 munmap(ptr, len); munmap(ptr1, len); close(fd1); close(fd); return 0;&#125; 匿名映射只能做父子进程中的通信 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/************************************************************************* &gt; File Name: mmap-anon.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月18日 星期三 13时10分14秒 ************************************************************************//* * 匿名映射: 不需要文件实体进程一个内存映射 */#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;int main() &#123; // 创建匿名映射区 int len = 4069; void *ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); if(ptr == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(-1); &#125; // 父子进程间通信 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父 strcpy((char *)ptr, &quot;hello&quot;); wait(NULL); &#125; else if(pid == 0) &#123; // 子 sleep(1); printf(&quot;%s\\n&quot;, (char *)ptr); &#125; int ret = munmap(ptr, len); if(ret == -1) &#123; perror(&quot;munmap&quot;); exit(-1); &#125; return 0;&#125;","categories":[{"name":"Linux-多线程开放","slug":"Linux-多线程开放","permalink":"https://tutouwang.vercel.app/categories/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/"}],"tags":[]},{"title":"三角形求面积","slug":"有趣的知识/三角形求面积","date":"2022-05-15T12:08:27.000Z","updated":"2022-05-15T12:27:52.792Z","comments":true,"path":"2022/05/15/有趣的知识/三角形求面积/","link":"","permalink":"https://tutouwang.vercel.app/2022/05/15/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%B1%82%E9%9D%A2%E7%A7%AF/","excerpt":"","text":"行列式 - 直角坐标器给定 A(x1, y1) B(x2, y2) C(x3, y3) 以知三角行 底(a) - 高(h)$S &#x3D; (a * h ) &#x2F; 2$ 海伦公式$p &#x3D; (a + b + c) &#x2F; 2$ $S&#x3D;sqrt[p(p-a)(p-b)(p-c)]$ $&#x3D;sqrt[(1&#x2F;16)(a+b+c)(a+b-c)(a+c-b)(b+c-a)]$ $&#x3D; 1 &#x2F; 4 sqrt [(a+b+c)(a+b-c)(a+c-b)(b+c-a)] $ 利用正玄已知三角形两边a,b,这两边夹角C，则 ，即两夹边之积乘夹角正弦值的一半。","categories":[],"tags":[{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/tags/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"STL_二分","slug":"STL剖析/STL-二分","date":"2022-05-06T07:15:03.000Z","updated":"2022-05-06T08:12:33.962Z","comments":true,"path":"2022/05/06/STL剖析/STL-二分/","link":"","permalink":"https://tutouwang.vercel.app/2022/05/06/STL%E5%89%96%E6%9E%90/STL-%E4%BA%8C%E5%88%86/","excerpt":"","text":"数组是升序的情况例：1 3 5 7 7 10 11 lower_bound(begin, ned, key) — 得到第一个 &gt;&#x3D; key 的下标 upper_bound(begin, ned, key) — 得到第一个 &gt; key 的下标 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/************************************************************************* &gt; File Name: 二分.cpp &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年05月06日 星期五 15时18分04秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int f[] = &#123;1, 3, 5, 7, 7, 10, 11&#125;;void printNumber(int *f, int n) &#123; for(int i = 0; i &lt; n; i++) cout &lt;&lt; f[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return ;&#125;int main() &#123; int n = sizeof(f) / sizeof(int); printNumber(f, n); int idx = -1; idx = lower_bound(f, f + sizeof(f) / sizeof(int), 7) - f; cout &lt;&lt; &quot;升序数组 - lower_bound - key = 7, idx = &quot; &lt;&lt; idx &lt;&lt; endl; idx = upper_bound(f, f + sizeof(f) / sizeof(int), 7) - f; cout &lt;&lt; &quot;升序数组 - upper_bound - key = 7, idx = &quot; &lt;&lt; idx &lt;&lt; endl; idx = upper_bound(f, f + sizeof(f) / sizeof(int), 12) - f; cout &lt;&lt; &quot;不存在的情况 - 升序数组 - upper_bound - key = 100, idx = &quot; &lt;&lt; idx &lt;&lt; endl; /***********************************************************************************************/ sort(f, f + n, greater&lt;int&gt;()); printNumber(f, n); idx = lower_bound(f, f + sizeof(f) / sizeof(int), 7) - f; cout &lt;&lt; &quot;降序数组 - lower_bound - key = 7, idx = &quot; &lt;&lt; idx &lt;&lt; endl; idx = upper_bound(f, f + sizeof(f) / sizeof(int), 7) - f; cout &lt;&lt; &quot;降序数组 - upper_bound - key = 7, idx = &quot; &lt;&lt; idx &lt;&lt; endl; idx = upper_bound(f, f + sizeof(f) / sizeof(int), 12) - f; cout &lt;&lt; &quot;不存在的情况 - 升序数组 - upper_bound - key = 100, idx = &quot; &lt;&lt; idx &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]},{"title":"基础博弈","slug":"基础算法/基础博弈","date":"2022-05-04T09:22:50.000Z","updated":"2022-05-04T09:23:43.826Z","comments":true,"path":"2022/05/04/基础算法/基础博弈/","link":"","permalink":"https://tutouwang.vercel.app/2022/05/04/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E5%8D%9A%E5%BC%88/","excerpt":"","text":"博弈论1.简介 博弈博弈&#x2F;博弈论，又称为对策论（Game Theory）、赛局理论等，既是现代数学的一个新分支，也是运筹学的一个重要学科。博弈论主要研究公式化了的激励结构间的相互作用，是研究具有斗争或竞争性质现象的数学理论和方法，博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。 总而言之，博弈，就是两方（或者多方）在为了某一种目标进行的竞争。 在生活中，博弈无处不在，国与国之间的交锋就是一种博弈，在游戏中你与对手的有来有回也是一种博弈，面对老板提出加工资的需求又也是一种博弈，在博弈中，选择去做什么非常重要，这也是十分有研究价值的，一个有趣的题外话：从1994年诺贝尔经济学奖授予3位博弈论专家开始，共有7届的诺贝尔经济学奖与博弈论的研究有关。 2. 基础概念 必胜态：通过某一步可以转移到必败态的局面。 也就是说，对于一个处于必胜态的玩家，他总能找到一种合法操作，将当前局面变成一个必败态然后交给对方，如果中途不出现意外的话，最终自己就会得到胜利。但是处于必胜态并不意味着任意的操作都能将当前局面变成必败态。 必败态：通过某一步只能转移到必胜态的局面。 也就是说，处于必败态的玩家无论做什么操作，都只会将当前的局面变成必胜态，然后交给对方，只要对方足够聪明，那么该玩家将输掉比赛。 对于足够聪明的两个博弈者来说，游戏的胜负在比赛前就已经知道(当然，我这里只是说在题目里，在现实中如果是稍微复杂一点的博弈游戏，单凭人脑是很难达到那种水平)，也就是说胜利的一方总能找到胜利的路径，而输掉的那一方无论怎样走，胜利的一方都能找到对应的方法。也就是说先后手以及起始局面可以决定整场博弈的胜负。 3.思想博弈问题的特点 a) 博弈模型为两人轮流决策的非合作博弈。即两人轮流进行决策，并且两人都使用最优策略来获取胜利 b) 博弈是有限的。即无论两人怎样决策，都会在有限步后决出胜负 c) 公平博弈。即两人进行决策所遵循的规则相同 4.学习方法关于博弈论，最理想的学习方式还当属熟悉模型，几种常用的博弈论模型有：巴什博弈，威佐夫博弈，斐波那契博弈，尼姆博弈，通过理解模型以及他们模型可能产生的变种，面对各种题目也只是“换汤不换药”的思维。 在基本了解各类模型之后，我们可以开始学习“博弈树”和“决策树”这类算法，以及其他一些启发式算法，这与人工智能的思维很接近，此时算法难度已经直线上升，在经过这个瓶颈之后，等待你的是一片星辰大海。 巴什博弈 巴什博弈的主要内容：只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。其中它强调的是只有一堆物品：取光者胜 如果 n % (m + 1) &#x3D;&#x3D; 0 先手必败 ​ n % (m + 1) !&#x3D; 0 先后必败 相信大家看见这个一定有很多疑惑就是为什么这个公式就能看到结局！ 1.如果它能被（m+1）整除，那么假设你先手 取p个，那么对手总能取m+1-p 个（因为1&lt;&#x3D;p&lt;&#x3D;m，那么 1&lt;&#x3D;(m+1-p)&lt;&#x3D;m 也满足对手所取数量的条件限制），这样不断循环下去，最后拿到石头的一定是对手。 2.如果它不能被（m+1）整除，那么你一定可以拿走那个余数k（k&#x3D;n%(m+1)） 这样对手就相当于面对了 n%（m+1）的局面，也就是1的情况。 巴什博弈(例题)巴什博弈-普通http://acm.hdu.edu.cn/showproblem.php?pid=1846 123456789101112131415161718#include &lt;iostream&gt;using namespace std;// 最先取光石子的一方为胜bool Bash(int n, int m) &#123; return n % (m + 1) != 0 ? 1 : 0; // 核心代码&#125;int main() &#123; int t, n, m; // n = 组数 n = 石子个数 m = 每回取最多个数 cin &gt;&gt; t; for (int i = 0; i &lt; t; i++) &#123; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; (Bash(n, m) ? &quot;first&quot; : &quot;second&quot;) &lt;&lt; endl; &#125; return 0;&#125; 巴什博弈-变行http://acm.hdu.edu.cn/showproblem.php?pid=4764 12345678910111213#include &lt;iostream&gt;using namespace std;// 题目的意思就是谁取到最后一个谁输int main() &#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; if (!(n + m)) break; cout &lt;&lt; (((n - 1) % (m + 1)) == 0 ? &quot;Jiang&quot; : &quot;Tang&quot;) &lt;&lt; endl; &#125; return 0;&#125; 尼姆博弈在说尼姆博弈之前我们需要去了解一个什么呢！ 就是异或 异或 英文名字 exclusive OR 缩写 xor 数学符号 ⊕ 计算机符号是 xor 但是到底异或怎么使用 比如说 4 ^ 3 4 的二进制 1 0 0 3 的二进制 0 1 1 xor 异或 1 1 1 就是说他们相同为0不同为1,当然在其中你应该还能看出一个问题是什么呢！ 就是大家可以算一下7的二进制数是什么 1 1 1 对吧！ 从此问题看出他们异或的结果就等于他们两个数相加 对吧 ！！! 就是异或也叫半加运算 这里能大家可以比如再去实验一个数比如说 1 ^ 2 &#x3D; 什么对吧！！！ 现在说了这么多都是什么对吧！！！ 就是为了我们之后要讲的尼姆博弈做的 铺垫！ 什么是尼姆博弈 有n堆石子，两人从某一堆取任意多个，规定至少取走1个之多可以取走这堆的全部最后取光者胜。 在这里大家就可能发现了这和刚刚的巴什博弈不差什么对吧！ 情况 ① 当有 1 堆石子的时候先手可以全部取走，对吧 ， 之后先手胜利 情况 ② 当有 2 堆石子时候 我们令一堆石子为 n 另一堆 m 假设 n &gt; m —– n &#x3D; 4 —- m &#x3D; 3 之后先手先取 因为两个人都是顶尖聪明的人都会去去吧自己利益最大化 就是我们先取 n - m 个剩下的无论后手怎么去取我们都和后手去取相同 个数的石子这样我们一定是必胜局， n &#x3D; 4 - &gt; 二进制 1 0 0 m &#x3D; 3 - &gt; 二进制 0 1 1 xor 1 1 1 3 (4 - 1) 0 1 1 3 0 1 1 xor 0 0 0 我们让异或为0也就是说我们让两个石子数量相对 之后不就像我们之前说的不管后手取多少我们先手都是必胜 情况 ③ 当有 2 堆石子时候 我们令一堆石子为 n 另一堆 m 假设 n &#x3D; m —– n &#x3D; 4 —- m &#x3D; 4 从刚才上图看出一但出现 n &#x3D;&#x3D; m 时候无论先手怎么取 后手就可以取和先手相同的个数 这样先手必败 （就是说因为两个都足够聪明所有说先手一定是什么比败局） 之后咱们不可能说是只有2堆是吧 可能还有 3 堆 ， 4 堆 ， 5 堆，6 堆…..等等 比如说（1， 2 ，3）这种我们能看出 先手必败 1 二进制 0 0 1 2 二进制 0 1 0 3 二进制 0 1 1 +（xor） ​ 0 0 0 随机举例 堆数 n &#x3D; 5 石子个数 182 63 59 22 10 取光者胜 甲 先 乙 后 石子数 128 64 32 16 8 4 2 1 182 1 0 1 1 0 1 1 0 63 0 0 1 1 1 1 1 1 59 0 0 1 1 1 0 1 1 22 0 0 0 1 0 1 1 0 10 0 0 0 0 1 0 1 0 xor 1 0 1 0 1 1 1 0 甲 石子数 128 64 32 16 8 4 2 1 24 (182 - 128 - 32 - 4 - 2 + 8) 158 0 0 0 1 1 0 0 0 63 0 0 1 1 1 1 1 1 59 0 0 1 1 1 0 1 1 22 0 0 0 1 0 1 1 0 10 0 0 0 0 1 0 1 0 xor 0 0 0 0 0 0 0 0 乙 石子数 128 64 32 16 8 4 2 1 24 0 0 0 1 1 0 0 0 31 (63 - 32) 0 0 0 1 1 1 1 1 59 0 0 1 1 1 0 1 1 22 0 0 0 1 0 1 1 0 10 0 0 0 0 1 0 1 0 xor 0 0 1 0 0 0 0 0 甲 石子数 128 64 32 16 8 4 2 1 24 0 0 0 1 1 0 0 0 31 0 0 0 1 1 1 1 1 27 (59 - 32) 0 0 0 1 1 0 1 1 22 0 0 0 1 0 1 1 0 10 0 0 0 0 1 0 1 0 xor 0 0 0 0 0 0 0 0 经过几次后一定会得到情况② 尼姆博弈-代码模板12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int n, t = 0; // n = 堆数 cin &gt;&gt; n; while (n--) &#123; int d; cin &gt;&gt; d; t ^= d; &#125; if (t == 0) cout &lt;&lt; &quot;先手必输&quot;; else cout &lt;&lt; &quot;先手必胜&quot;; return 0;&#125;","categories":[{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"进程间通信-IPC","slug":"Linux-多线程开放/进程间通信","date":"2022-04-17T11:15:03.000Z","updated":"2022-05-22T15:05:06.445Z","comments":true,"path":"2022/04/17/Linux-多线程开放/进程间通信/","link":"","permalink":"https://tutouwang.vercel.app/2022/04/17/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","excerpt":"","text":"进程间通讯的概念进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程)之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信(IPC: Inter Processes Communication )。 GUI：用户图像接口 IDE：集成开发环境 API：应用程序接口 进程间通信的目的： 数据传输:一个进程需要将它的数据发送给另一个进程。 通知事件:一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程)。 资源共享:多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。 (同步(就是排队看病 - 安全)、异步(一个医生一起看多个病人 - 不安全)) 进程控制:有些进程希望完全控制另一个进程的执行（如Debug 进程)，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 Linux进程间通信的方式 匿名管道管道也叫无名（匿名）管道，它是是UNIX系统IPC(进程间通信)的最古老形式,所有的UNIX系统都支持这种通信机制。 统计一个目录中文件的数目命令: ls | wc -l，为了执行该命令, shell创建了两个进程来分别执行 ls 和 wc。 管道特点 匿名管道 - 有名管道 共同特点管道其实是一个在内核&#39;内存中&#39;通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。 管道拥有文件的特质:读操作、写操作，匿名管道没有文件实体(有关系的进程 父进程 - 子进程 - 孙子进程)，有名管道有文件实体(没有关系的进程),但不存储数据。可以按照操作文件的方式对管道进行操作。 一个管道是一个字节流(一个字节 一个字节 在管道里面)，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。 在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。 单工(遥控器发射信号给电视机 但是电视机不能给遥控器发射信号 这就是单工) 双工(打电话 1给2打电话 1 说 二可以听到、2说 1可以听到 同时) 半双工(同一时间只能一个方向就好比那放学 都往出走你就进不去(当然啊 除非你不要命的硬挤进去！！！) 当出来的都走完了进的在往里进) 从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据．在管道中无法使用lseek ()来随机的访问数据。 匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用 为什么可以使用管道进行进程通信 管道(红色长方体) 左侧读 右侧写 父 - 子 进程 管道的数据结构 匿名管道的使用 创建匿名管道 12#include &lt;unistd.h&gt;int pipe(int pipefd[2]); 查看管道缓冲大小命令 1ulimit -a 查看管道缓冲大小函数 123#include &lt;unistd.h&gt;long fpathconf(int fd, int name); 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/************************************************************************* &gt; File Name: pipe.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月18日 星期一 19时08分03秒 ************************************************************************//* * #include &lt;unistd.h&gt; * int pipe(int pipefd[2]); * 功能: 创建一个匿名管道, 用来进程间通信 * 参数: int pipefd[2] 这个数组是一个传出参数。 * - pipefd[0] : 对应管道的读端 * - pipefd[1] : 对应管道的写端 * 返回值: * 成功返回 0 * 失败返回 -1 * 注意: 匿名管道只能用于具有关系的进程之间通信 (父子进程, 兄弟进程, 孙子进程) * */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;// 子进程发送数据给父进程, 父进程读取到数据输出int main() &#123; // 再 fork 之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 // 从管道的读取端读取数据 char buf[1024] = &#123;0&#125;; int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;parent revc : %s, pid : %d\\n&quot;, buf, getpid()); &#125; else if(pid == 0)&#123; // 子进程 char *str = &quot;hello,i am child&quot;; write(pipefd[1], str, strlen(str)); &#125; return 0;&#125; 先猜想: 如果子进程写入前 sleep(10) 后 中端输出什么：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/************************************************************************* &gt; File Name: pipe.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月18日 星期一 19时08分03秒 ************************************************************************//* * #include &lt;unistd.h&gt; * int pipe(int pipefd[2]); * 功能: 创建一个匿名管道, 用来进程间通信 * 参数: int pipefd[2] 这个数组是一个传出参数。 * - pipefd[0] : 对应管道的读端 * - pipefd[1] : 对应管道的写端 * 返回值: * 成功返回 0 * 失败返回 -1 * 注意: 匿名管道只能用于具有关系的进程之间通信 (父子进程, 兄弟进程, 孙子进程) * 管道默认是阻塞的, 如果管道中没有数据, read阻塞, 如果管道满了, write阻塞 * */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;// 子进程发送数据给父进程, 父进程读取到数据输出int main() &#123; // 再 fork 之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 // 从管道的读取端读取数据 char buf[1024] = &#123;0&#125;; int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;parent revc : %s, pid : %d\\n&quot;, buf, getpid()); &#125; else if(pid == 0)&#123; // 子进程 sleep(10); char *str = &quot;hello,i am child&quot;; write(pipefd[1], str, strlen(str)); &#125; return 0;&#125; 多次写入 读取1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/************************************************************************* &gt; File Name: pipe.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月18日 星期一 19时08分03秒 ************************************************************************//* * #include &lt;unistd.h&gt; * int pipe(int pipefd[2]); * 功能: 创建一个匿名管道, 用来进程间通信 * 参数: int pipefd[2] 这个数组是一个传出参数。 * - pipefd[0] : 对应管道的读端 * - pipefd[1] : 对应管道的写端 * 返回值: * 成功返回 0 * 失败返回 -1 * 注意: 匿名管道只能用于具有关系的进程之间通信 (父子进程, 兄弟进程, 孙子进程) * 管道默认是阻塞的, 如果管道中没有数据, read阻塞, 如果管道满了, write阻塞 * */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;// 子进程发送数据给父进程, 父进程读取到数据输出int main() &#123; // 再 fork 之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 // 从管道的读取端读取数据 printf(&quot;i am parent process, pid : %d\\n&quot;, getpid()); char buf[1024] = &#123;0&#125;; // 关闭写端 close(pipefd[1]); while(1) &#123; int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;parent revc : %s, pid : %d\\n&quot;, buf, getpid()); // char *str = &quot;i am parent&quot;; // write(pipefd[1], str, strlen(str)); // sleep(1); &#125; &#125; else if(pid == 0)&#123; // 子进程 printf(&quot;i am child process, pid : %d\\n&quot;, getpid()); char buf[1024]; // 关闭读端 close(pipefd[0]); while(1) &#123; char *str = &quot;hello,i am child&quot;; write(pipefd[1], str, strlen(str)); // sleep(1); int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;pa child recv : %s, pid : %d\\n&quot;, buf, getpid()); bsize(buf, 1024); &#125; &#125; return 0;&#125; &#x2F;&#x2F; 发完数据还没有数字没清空 ps: 如果注释掉 sleep() 就会发现问题！就是自己写的会自己读回去 当然在项目中不会出现这种情况 项目中只会一端读一端写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/************************************************************************* &gt; File Name: pipe.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月18日 星期一 19时08分03秒 ************************************************************************//* * #include &lt;unistd.h&gt; * int pipe(int pipefd[2]); * 功能: 创建一个匿名管道, 用来进程间通信 * 参数: int pipefd[2] 这个数组是一个传出参数。 * - pipefd[0] : 对应管道的读端 * - pipefd[1] : 对应管道的写端 * 返回值: * 成功返回 0 * 失败返回 -1 * 注意: 匿名管道只能用于具有关系的进程之间通信 (父子进程, 兄弟进程, 孙子进程) * 管道默认是阻塞的, 如果管道中没有数据, read阻塞, 如果管道满了, write阻塞 * */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;// 子进程发送数据给父进程, 父进程读取到数据输出int main() &#123; // 再 fork 之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 // 从管道的读取端读取数据 printf(&quot;i am parent process, pid : %d\\n&quot;, getpid()); char buf[1024] = &#123;0&#125;; while(1) &#123; int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;parent revc : %s, pid : %d\\n&quot;, buf, getpid()); char *str = &quot;i am parent&quot;; write(pipefd[1], str, strlen(str)); sleep(1); &#125; &#125; else if(pid == 0)&#123; // 子进程 printf(&quot;i am child process, pid : %d\\n&quot;, getpid()); char buf[1024]; // 关闭读端 close(pipefd[0]); while(1) &#123; char *str = &quot;hello,i am child&quot;; write(pipefd[1], str, strlen(str)); sleep(1); // int len = read(pipefd[0], buf, sizeof(buf)); // printf(&quot;pa child recv : %s, pid : %d\\n&quot;, buf, getpid()); // bsize(buf, 1024); &#125; &#125; return 0;&#125; 查看管道大小 ulimit -a 1234567891011121314151617181920212223/************************************************************************* &gt; File Name: fpathconfig.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月19日 星期二 19时05分50秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main() &#123; int pipefd[2]; int ret = pipe(pipefd); // 获取管道的大小 可以查看man手册来查看宏值 long size = fpathconf(pipefd[0], _PC_PIPE_BUF); printf(&quot;pipe size : %ld&quot;, size); return 0;&#125; 匿名管道 - 案例ls | wc -l - ps aux | grep 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/************************************************************************* &gt; File Name: parent-child-ipc.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月20日 星期三 09时21分59秒 ************************************************************************//* * 实现 ps aux | grep xxx 父子进程通信 * 子进程: ps aux, 子进程结束后, 将数据发送给父进程 * 父进程: 获取到数据, 过滤 * * pipe() * execlp() -&gt; ps aux 会输出到终端 * 子进程将标准输出 stdout_fileno 重定向管道的写端 dup2 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main() &#123; // 创建一个管道 int fd[2]; int ret = pipe(fd); if(ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 // 关闭写端 close(fd[1]); // 从管道中读取数据 char buf[1024]; int len = -1; while((len = read(fd[0], buf, sizeof(buf) - 1)) &gt; 0) &#123; // 因为每次最多只能读取 1024 所以需要循环 // 过滤数据 printf(&quot;%s&quot;, buf); memset(buf, 0, sizeof(buf)); &#125; wait(NULL); &#125; else if(pid == 0) &#123; // 子进程 // 关闭读端 close(fd[0]); // 文件描述符的重定向 stdout_fileno -&gt; fd[1]; // 执行 ps aux dup2(fd[1], STDOUT_FILENO); execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL); perror(&quot;execlp&quot;); exit(0); &#125; else &#123; perror(&quot;fork&quot;); exit(0); &#125; return 0;&#125; 管道的读写特点使用管道时候，需要注意以下几种特殊的情况（假设都是I/O操作） 所有的指向管道写端文件描述符都关闭了 (管道写端引用计数为0)，进程从管道的读端读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样 如果有指向管道的写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，再次read会阻塞，值到管道中有数据可以读了才读取数据并返回。 如果所有指向管道的读端的文件描述符都关闭了（管道的读端引用计数为0）这个时候有进程向管道中写数据，那么该进程会收到一个信号SIGPIPE(管道破裂),通常会导致进程异常终止 如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0）而持有管道读端的进程也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候在次调用write时候就会被阻塞直到管道中有空位置猜能再次写入数据并返回 总结： ​ 读管道： ​ 管道中有数据，red返回实际读到的字节数 ​ 管道中无数据： ​ 写端被全包关闭，read返回0（相当于读到文件末尾） ​ 写端没有完全关闭，read阻塞等待 ​ 写管道： ​ 管道读端全部都关闭，进程异常终止（进程SIGPIPE信号） ​ 管道读端没有完全关闭： ​ 管道已满：writ阻塞 ​ 管道没满：wirt将数据写入，并返回实际写入的字节数。 管道 读非阻塞状态123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/************************************************************************* &gt; File Name: pipe.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月18日 星期一 19时08分03秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;/* * 设置管道非阻塞 * int flags = fcntl(fd[0], F_GETFL); // 获取原来的flags * flags |= O_NONBLOCK; // 修改flags * fcntl(fd[0], F_SETFL, flags); // 设置新的flgas * */// man 2 fcntl // 快捷键 shift + kint main() &#123; // 再 fork 之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 // 关闭写 close(pipefd[1]); // 从管道的读取端读取数据 printf(&quot;i am parent process, pid : %d\\n&quot;, getpid()); char buf[1024] = &#123;0&#125;; int flags = fcntl(pipefd[0], F_GETFL); flags |= O_NONBLOCK; fcntl(pipefd[0], F_SETFL, flags); while(1) &#123; int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;parent revc : %s, pid : %d\\n&quot;, buf, getpid()); printf(&quot;len : %d\\n&quot;, len); memset(buf, 0 ,sizeof(buf)); sleep(2); &#125; &#125; else if(pid == 0)&#123; // 关闭管道读 close(pipefd[0]); // 子进程 printf(&quot;i am child process, pid : %d\\n&quot;, getpid()); char buf[1024]; while(1) &#123; char *str = &quot;hello,i am child&quot;; write(pipefd[1], str, strlen(str)); sleep(5); &#125; &#125; return 0;&#125; 有名管道匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)，也叫命名管道、FIFO文件。 有名管道(FIFO)不同于匿名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO相互通信，因此，通过FIFO不相关的进程也能交换数据。 一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I&#x2F;O系统调用了(如read ( ) 、 write ()和close())。与管道一样, FIFO也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO的名称也由此而来:先入先出。 有名管道(FIFO)和匿名管道 (pipe)有一些特点是相同的，不一样的地方在于: 有名管道（FIFO）和匿名管道（pipe）有一些特点是相同的，不一样的地方在于： FIFO在文件系统中作为一个特殊文件存在，但 FIFO中的内容却存放在内存中。 当使用FIFO的进程退出后，FIFo文件将继续保存在文件系统中以便以后使用。 FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。 有名管道的使用通过命令创建有名管道 mkfifo 名字 文件类型 p 就是一个管道文件 通过函数创建有名管道 123#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;int mkfifo(const char *pathname, mode_t mode); 一旦使用mkfifo创建了一个FIFO就可以使用open打开它，常见的文件I&#x2F;O函数都可以用于fifo。如：close、read、write、unlink等 FIFO严格遵循先进先出（First in First out）, 对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。他们不支持诸如lseek()等文件定位操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/************************************************************************* &gt; File Name: mkfifo.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月24日 星期日 19时24分40秒 ************************************************************************//* * 创建fifo文件 * 1.通过命令: mkfifo 名字 * 2.通过函数: int mkfifo(const char *pathname, mode_t mode); * * #include &lt;sys/types.h&gt; * #include &lt;sys/stat.h&gt; * int mkfifo(const char *pathname, mode_t mode); * 参数: * - pathname: 管道名称的路径 * - mode: 文件的权限 和 opne 的 mode 是一样的 * 是一个八进制的数 * 返回值: * 成功返回: 0 * 失败返回: -1 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 判断文件是否存在 int ret = access(&quot;fifo1&quot;, F_OK); if(ret == -1) &#123; printf(&quot;管道不存在, 创建管道\\n&quot;); ret = mkfifo(&quot;fifo1&quot;, 0664); if(ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; return 0;&#125; 一端读、一端写write 123456789101112131415161718192021222324252627282930313233343536373839404142434445/************************************************************************* &gt; File Name: write.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月24日 星期日 20时20分58秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;// 向管道中写数据int main() &#123; int ret = access(&quot;test&quot;, F_OK); if(ret == -1) &#123; perror(&quot;管道不存在, 创建管道\\n&quot;); // 创建管道文件 ret = mkfifo(&quot;test&quot;, 0664); if(ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; // 打开管道 int fd = open(&quot;test&quot;, O_WRONLY); if(fd == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; for(int i = 0; i &lt; 100; i++) &#123; char buf[1024]; sprintf(buf, &quot;hellow, %d\\n&quot;, i); printf(&quot;write data : %s\\n&quot;, buf); write(fd, buf, strlen(buf)); sleep(1); &#125; close(fd); return 0;&#125; read 12345678910111213141516171819202122232425262728293031323334353637383940/************************************************************************* &gt; File Name: read.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月24日 星期日 20时25分41秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;// 从管道中读数据int main() &#123; // 打开管道文件 int fd = open(&quot;test&quot;, O_RDONLY); if(fd == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; // 读数据 while(1) &#123; char buf[1024] = &#123;0&#125;; int len = read(fd, buf, sizeof(buf)); // if(len == 0) &#123; printf(&quot;写端断开链接了...\\n&quot;); break; &#125; printf(&quot;recv buf : %s\\n&quot;, buf); &#125; close(fd); return 0;&#125; 有名管道的注意事项 一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道 一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道 读管道： ​ 管道中有数据，read返回实际读到的字节数 ​ 管道中无数据: ​ 管道写端被全部关闭，read返回0，（相当于读到文件末尾) ​ 写端没有全部被关闭，read阻塞等待 写管道： ​ 管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号) ​ 管道读端没有全部关闭: ​ 管道已经满了，write会阻塞 ​ 管道没有满,write将数据写入，并返回实际写入的字节数。 有名管道实现简单版聊天功能 - 一问一答 chatA12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/************************************************************************* &gt; File Name: chatA.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月26日 星期二 11时54分44秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main() &#123; // 判断有名管道1是否存在 int ret = access(&quot;fifo1&quot;, F_OK); if(ret == -1) &#123; // 文件不存 printf(&quot;管道文件不存在, 创建对应的有名管道\\n&quot;); // 文件路径 ret = mkfifo(&quot;fifo1&quot;, 0664); if(ret == -1) &#123; perror(&quot;fifo1&quot;); exit(-1); &#125; &#125; // 判断有名管道2是否存在 ret = access(&quot;fifo2&quot;, F_OK); if(ret == -1) &#123; // 文件不存 printf(&quot;管道文件不存在, 创建对应的有名管道\\n&quot;); // 文件路径 ret = mkfifo(&quot;fifo2&quot;, 0664); if(ret == -1) &#123; perror(&quot;fifo2&quot;); exit(-1); &#125; &#125; // 以只写方式打开管道fifo1 --- 1 int fdw = open(&quot;fifo1&quot;, O_WRONLY); if(fdw == -1) &#123; perror(&quot;open - fifo1&quot;); exit(-1); &#125; printf(&quot;打开fifo1成功！等待写入... ...\\n&quot;); // 以只读方式打开管道fifo2 --- 2 int fdr = open(&quot;fifo2&quot;, O_RDONLY); if(fdr == -1) &#123; perror(&quot;open - fifo2&quot;); exit(-1); &#125; printf(&quot;打开fifo2成功！等待读取... ...\\n&quot;); char buf[128]; // 循环写读数据 while(1) &#123; memset(buf, 0, sizeof(buf)); // 获取标准输入(stdin)的数据 fgets(buf, sizeof(buf), stdin); // 写数据 ret = write(fdw, buf, sizeof(buf)); if(ret == -1) &#123; perror(&quot;writ&quot;); exit(-1); &#125; // 读管道数据 memset(buf, 0, sizeof(buf)); ret = read(fdr, buf, sizeof(buf)); if(ret &lt;= 0) &#123; perror(&quot;read&quot;); break; &#125; printf(&quot; buf : %s\\n&quot;, buf); &#125; // 关闭文件描述符 close(fdr); close(fdw); return 0;&#125; chatB1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/************************************************************************* &gt; File Name: chatA.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月26日 星期二 11时54分44秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main() &#123; // 判断有名管道1是否存在 int ret = access(&quot;fifo1&quot;, F_OK); if(ret == -1) &#123; // 文件不存 printf(&quot;管道文件不存在, 创建对应的有名管道\\n&quot;); // 文件路径 ret = mkfifo(&quot;fifo1&quot;, 0664); if(ret == -1) &#123; perror(&quot;fifo1&quot;); exit(-1); &#125; &#125; // 判断有名管道2是否存在 ret = access(&quot;fifo2&quot;, F_OK); if(ret == -1) &#123; // 文件不存 printf(&quot;管道文件不存在, 创建对应的有名管道\\n&quot;); // 文件路径 ret = mkfifo(&quot;fifo2&quot;, 0664); if(ret == -1) &#123; perror(&quot;fifo2&quot;); exit(-1); &#125; &#125; // 以只读方式打开管道fifo1 --- 1 int fdr = open(&quot;fifo1&quot;, O_RDONLY); if(fdr == -1) &#123; perror(&quot;open - fifo1&quot;); exit(-1); &#125; printf(&quot;打开fifo1成功！等待读取... ...\\n&quot;); // 以只写方式打开管道fifo2 --- 2 int fdw = open(&quot;fifo2&quot;, O_WRONLY); if(fdw == -1) &#123; perror(&quot;open - fifo2&quot;); exit(-1); &#125; printf(&quot;打开fifo2成功！等待写入... ...\\n&quot;); char buf[128]; // 循环读写数据 while(1) &#123; // 读管道数据 memset(buf, 0, sizeof(buf)); ret = read(fdr, buf, sizeof(buf)); if(ret &lt;= 0) &#123; perror(&quot;read&quot;); break; &#125; printf(&quot; buf : %s\\n&quot;, buf); memset(buf, 0, sizeof(buf)); // 获取标准输入(stdin)的数据 fgets(buf, sizeof(buf), stdin); // 写数据 ret = write(fdw, buf, strlen(buf)); if(ret == -1) &#123; perror(&quot;writ&quot;); exit(-1); &#125; &#125; // 关闭文件描述符 close(fdr); close(fdw); return 0;&#125; 问！如何实现一方多次发送消息！怎么实现？可以fork创建子进程一起跑 - 有时间我一定代码实现测试一下 代码如下 A - B 无限通信 嗷嗷叫！chatA 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/************************************************************************* &gt; File Name: chatA.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月30日 星期六 19时58分44秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main() &#123; // 判断管道是否存在 - FIFO int ret = access(&quot;fifo1&quot;, F_OK); if(ret == -1) &#123; printf(&quot;FIFO1 文件不存在, 正在创建 ... ... \\n&quot;); ret = mkfifo(&quot;fifo1&quot;, 0664); if(ret == -1) &#123; perror(&quot;mkfifo1&quot;); exit(-1); &#125; &#125; ret = access(&quot;fifo2&quot;, F_OK); if(ret == -1) &#123; printf(&quot;FIFO2 文件不存在, 正在创建 ... ... \\n&quot;); ret = mkfifo(&quot;fifo2&quot;, 0664); if(ret == -1) &#123; perror(&quot;mkfifo2&quot;); exit(-1); &#125; &#125; // 以只写方式打开 FIFO1 int fdw = open(&quot;fifo1&quot;, O_WRONLY); if(fdw == -1) &#123; perror(&quot;open-FIFO1&quot;); exit(-1); &#125; printf(&quot;打开 FIFO1 成功! 等待写入....\\n&quot;); int fdr = open(&quot;fifo2&quot;, O_RDONLY); if(fdr == -1) &#123; perror(&quot;open-FIFO2&quot;); exit(-1); &#125; printf(&quot;打开 FIFO2 成功! 等待读取....\\n&quot;); // 创建进程 pid_t pid = fork(); // char *buf = (char *)malloc(sizeof(char) * 5); char buf[1024]; if(pid &gt; 0) &#123; // 父进程 while(1) &#123; memset(buf, 0, sizeof(buf)); // 获取标准输入(stdin)的数据 fgets(buf, sizeof(buf), stdin); ret = write(fdw, buf, sizeof(buf)); if(ret == -1) &#123; perror(&quot;writ&quot;); exit(-1); &#125; &#125; &#125; else if(pid == 0) &#123; // 创建子进程 while(1) &#123; memset(buf, 0, sizeof(buf)); ret = read(fdr, buf, sizeof(buf)); if(ret &lt;= 0) &#123; perror(&quot;read&quot;); exit(-1); break; &#125; printf(&quot;buf : %s\\n&quot;, buf); &#125; &#125; // 关闭文件描述符 close(fdw); close(fdr); // free(buf); return 0;&#125; chatB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/************************************************************************* &gt; File Name: chatA.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月30日 星期六 19时58分44秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main() &#123; // 判断管道是否存在 - FIFO int ret = access(&quot;fifo1&quot;, F_OK); if(ret == -1) &#123; printf(&quot;FIFO1 文件不存在, 正在创建 ... ... \\n&quot;); ret = mkfifo(&quot;fifo1&quot;, 0664); if(ret == -1) &#123; perror(&quot;mkfifo1&quot;); exit(-1); &#125; &#125; ret = access(&quot;fifo2&quot;, F_OK); if(ret == -1) &#123; printf(&quot;FIFO2 文件不存在, 正在创建 ... ... \\n&quot;); ret = mkfifo(&quot;fifo2&quot;, 0664); if(ret == -1) &#123; perror(&quot;mkfifo2&quot;); exit(-1); &#125; &#125; // 以只读方式打开 FIFO1 int fdr = open(&quot;fifo1&quot;, O_RDONLY); if(fdr == -1) &#123; perror(&quot;open-FIFO1&quot;); exit(-1); &#125; printf(&quot;打开 FIFO1 成功! 等待读取....\\n&quot;); int fdw = open(&quot;fifo2&quot;, O_WRONLY); if(fdw == -1) &#123; perror(&quot;open-FIFO2&quot;); exit(-1); &#125; printf(&quot;打开 FIFO2 成功! 等待写入....\\n&quot;); // 创建进程 pid_t pid = fork(); // char *buf = (char *)malloc(sizeof(char) * 1024); char buf[1024]; if(pid &gt; 0) &#123; // 父进程 while(1) &#123; memset(buf, 0, sizeof(buf)); ret = read(fdr, buf, sizeof(buf)); if(ret &lt;= 0) &#123; perror(&quot;read&quot;); // exit(-1); break; &#125; printf(&quot;buf : %s\\n&quot;, buf); &#125; &#125; else if(pid == 0) &#123; // 创建子进程 while(1) &#123; memset(buf, 0, sizeof(buf)); // 获取标准输入(stdin)的数据 fgets(buf, sizeof(buf), stdin); ret = write(fdw, buf, sizeof(buf)); if(ret == -1) &#123; perror(&quot;writ&quot;); exit(-1); &#125; &#125; &#125; // 关闭文件描述符 close(fdr); close(fdw); return 0;&#125;","categories":[{"name":"Linux-多线程开放","slug":"Linux-多线程开放","permalink":"https://tutouwang.vercel.app/categories/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/"}],"tags":[]},{"title":"wait-waitpid 函数","slug":"Linux-多线程开放/wait函数","date":"2022-04-11T07:49:11.000Z","updated":"2022-05-25T09:42:53.811Z","comments":true,"path":"2022/04/11/Linux-多线程开放/wait函数/","link":"","permalink":"https://tutouwang.vercel.app/2022/04/11/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/wait%E5%87%BD%E6%95%B0/","excerpt":"","text":"wait - 回收子进程资源123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/************************************************************************* &gt; File Name: wait.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月12日 星期二 19时01分25秒 ************************************************************************//* * #include &lt;sys/types.h&gt; * #include &lt;sys/wait.ch&gt; * pid_t wait(int *wstatus); * 功能: 等待任意一个子进程结束, 如果任意一个子进程结束了,此函数会回收子进程的资源 * 参数: int *wstatus * 进程退出时的状态信息,传入的是一个int类型的地址, 传出参数 * 返回值: * - 成功: 返回被回收的子进程的ID * - 失败: -1 (所有的子进程都结束了, 调用函数失败) * 调用wait函数的进程会被挂起(阻塞),直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒(相当于继续执行) * 如果没有子进程了,函数立刻返回,返回-1:如果子进程都已经结束了,也会立即返回-1 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 有一个父进程,创建5个子进程(兄弟) pid_t pid; for(int i = 0; i &lt; 5; i++) &#123; pid = fork(); if(pid == 0) &#123; // 干掉子进程 break; &#125; &#125; if(pid &gt; 0) &#123; // 父进程 while(1) &#123; printf(&quot;i am parent, pid = %d\\n&quot;, getpid()); sleep(1); &#125; &#125; else if(pid == 0) &#123; // 子进程 printf(&quot;child, pid = %d\\n&quot;, getpid()); &#125; return 0;&#125; 5次子进程结束后父进程一直再执行就会出现在5个孤儿进程 结束掉父进程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/************************************************************************* &gt; File Name: wait.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月12日 星期二 19时01分25秒 ************************************************************************//* * #include &lt;sys/types.h&gt; * #include &lt;sys/wait.ch&gt; * pid_t wait(int *wstatus); * 功能: 等待任意一个子进程结束, 如果任意一个子进程结束了,此函数会回收子进程的资 源 * 参数: int *wstatus * 进程退出时的状态信息,传入的是一个int类型的地址, 传出参数 * 返回值: * - 成功: 返回被回收的子进程的ID * - 失败: -1 (所有的子进程都结束了, 调用函数失败) * 调用wait函数的进程会被挂起(阻塞),直到它的一个子进程退出或者收到一个不能被忽略 的信号时才被唤醒(相当于继续执行) * 如果没有子进程了,函数立刻返回,返回-1:如果子进程都已经结束了,也会立即返回-1 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 有一个父进程,创建5个子进程(兄弟) pid_t pid; for(int i = 0; i &lt; 5; i++) &#123; pid = fork(); if(pid == 0) &#123; // 干掉子进程 break; &#125; &#125; if(pid &gt; 0) &#123; // 父进程 while(1) &#123; printf(&quot;i am parent, pid = %d\\n&quot;, getpid()); int ret = wait(NULL); if(ret == -1) &#123; break; &#125; printf(&quot;child die, pid = %d\\n&quot;, ret); sleep(1); &#125; &#125; else if(pid == 0) &#123; // 子进程 printf(&quot;child, pid = %d\\n&quot;, getpid()); sleep(1); &#125; return 0;&#125; 退出信息相关宏函数 正常运行结束代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/************************************************************************* &gt; File Name: wait.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月12日 星期二 19时01分25秒 ************************************************************************//* * #include &lt;sys/types.h&gt; * #include &lt;sys/wait.ch&gt; * pid_t wait(int *wstatus); * 功能: 等待任意一个子进程结束, 如果任意一个子进程结束了,此函数会回收子进程的资 源 * 参数: int *wstatus * 进程退出时的状态信息,传入的是一个int类型的地址, 传出参数 * 返回值: * - 成功: 返回被回收的子进程的ID * - 失败: -1 (所有的子进程都结束了, 调用函数失败) * 调用wait函数的进程会被挂起(阻塞),直到它的一个子进程退出或者收到一个不能被忽略 的信号时才被唤醒(相当于继续执行) * 如果没有子进程了,函数立刻返回,返回-1:如果子进程都已经结束了,也会立即返回-1 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 有一个父进程,创建5个子进程(兄弟) pid_t pid; for(int i = 0; i &lt; 5; i++) &#123; pid = fork(); if(pid == 0) &#123; // 干掉子进程 break; &#125; &#125; if(pid &gt; 0) &#123; // 父进程 while(1) &#123; printf(&quot;i am parent, pid = %d\\n&quot;, getpid()); //int ret = wait(NULL); int st; int ret = wait(&amp;st); if(ret == -1) &#123; break; &#125; if(WIFEXITED(st)) &#123; // 是不是正常退出 printf(&quot;退出的状态码 : %d\\n&quot;, WEXITSTATUS(st)); &#125; if(WIFSIGNALED(st)) &#123; // 是不是异常终止 printf(&quot;被那个信号干掉了: %d\\n&quot;, WTERMSIG(st)); &#125; printf(&quot;child die, pid = %d\\n&quot;, ret); sleep(1); &#125; &#125; else if(pid == 0) &#123; // 子进程 printf(&quot;child, pid = %d\\n&quot;, getpid()); sleep(1); exit(0); &#125; return 0; // exit(0)&#125; 信号干掉代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/************************************************************************* &gt; File Name: wait.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月12日 星期二 19时01分25秒 ************************************************************************//* * #include &lt;sys/types.h&gt; * #include &lt;sys/wait.ch&gt; * pid_t wait(int *wstatus); * 功能: 等待任意一个子进程结束, 如果任意一个子进程结束了,此函数会回收子进程的资 源 * 参数: int *wstatus * 进程退出时的状态信息,传入的是一个int类型的地址, 传出参数 * 返回值: * - 成功: 返回被回收的子进程的ID * - 失败: -1 (所有的子进程都结束了, 调用函数失败) * 调用wait函数的进程会被挂起(阻塞),直到它的一个子进程退出或者收到一个不能被忽略 的信号时才被唤醒(相当于继续执行) * 如果没有子进程了,函数立刻返回,返回-1:如果子进程都已经结束了,也会立即返回-1 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 有一个父进程,创建5个子进程(兄弟) pid_t pid; for(int i = 0; i &lt; 5; i++) &#123; pid = fork(); if(pid == 0) &#123; // 干掉子进程 break; &#125; &#125; if(pid &gt; 0) &#123; // 父进程 while(1) &#123; printf(&quot;i am parent, pid = %d\\n&quot;, getpid()); //int ret = wait(NULL); int st; int ret = wait(&amp;st); if(ret == -1) &#123; break; &#125; if(WIFEXITED(st)) &#123; // 是不是正常退出 printf(&quot;退出的状态码 : %d\\n&quot;, WEXITSTATUS(st)); &#125; if(WIFSIGNALED(st)) &#123; // 是不是异常终止 printf(&quot;被那个信号干掉了: %d\\n&quot;, WTERMSIG(st)); &#125; printf(&quot;child die, pid = %d\\n&quot;, ret); sleep(1); &#125; &#125; else if(pid == 0) &#123; // 子进程 while(1) &#123; printf(&quot;child, pid = %d\\n&quot;, getpid()); sleep(1); &#125; exit(0); &#125; return 0; // exit(0)&#125; waitpid - 回收子进程资源12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/************************************************************************* &gt; File Name: wait_pid.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月15日 星期五 16时38分41秒 ************************************************************************//* * * #include &lt;sys/types.h&gt; * #include &lt;sys/wait.h&gt; * pid_t waitpid(pid_t pid, int *wstatus, int options); * 功能: 回收指定进程号的子进程,可以设置是否阻塞。 * 参数: * - pid: * PID &gt; 0 : 回收某个指定子进程的 PID * PID = 0 : 回收当前进程组的所有子进程 * 进程 A -&gt; B A -&gt; C 放到一个集合 (A - B, A - C) &lt;- D 在把D给别人就不输入当前组 释放时候就与D没有关系了。// ajx 查看组查看进程组 * PID = -1 : 回收所有的子进程 相当于 wait() (最长用) * PID &lt; -1 : 某个进程组的组id的绝对值回收指定进程组中的子进程 * - options: 设置阻塞或者非阻塞 * 0 : 阻塞 * WNOHANG : 非阻塞 * - 返回值: * &gt; 0 : 返回子进程的id * = 0 : options = WNOHANG, 表示还有子进程活着 * = -1 : 错误, 或者没有子进程了 * * */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 有一个父进程, 创建5个子进程 pid_t pid; // 创建5个子进程 for(int i = 0; i &lt; 5; i++) &#123; pid = fork(); if(pid == 0) break; &#125; if(pid &gt; 0) &#123; while(1) &#123; printf(&quot;parent, pid = %d\\n&quot;, getpid()); sleep(1); int st; // int ret = waitpid(-1, &amp;st, 0); // 阻塞 int ret = waitpid(-1, &amp;st, WNOHANG); if(ret == - 1) break; // 还有子进程存在 else if(ret == 0) &#123; continue; &#125; else if(ret &gt; 0) &#123; if(WIFEXITED(st)) &#123; // 是不是正常退出 printf(&quot;退出的状态码 : %d\\n&quot;, WEXITSTATUS(st)); &#125; if(WIFSIGNALED(st)) &#123; // 是不是异常终止 printf(&quot;被那个信号干掉了 : %d\\n&quot;,WTERMSIG(st)); &#125; printf(&quot;child die, pid = %d\\n&quot;, ret); &#125; sleep(1); &#125; &#125; else if(pid == 0) &#123; while(1) &#123; printf(&quot;child , pid = %d\\n&quot;, getpid()); sleep(1); &#125; exit(0); &#125; return 0;&#125;","categories":[{"name":"Linux-多线程开放","slug":"Linux-多线程开放","permalink":"https://tutouwang.vercel.app/categories/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/"}],"tags":[]},{"title":"进程控制","slug":"Linux-多线程开放/进程控制","date":"2022-04-10T10:45:44.000Z","updated":"2022-05-22T15:05:06.447Z","comments":true,"path":"2022/04/10/Linux-多线程开放/进程控制/","link":"","permalink":"https://tutouwang.vercel.app/2022/04/10/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"","text":"进程退出12345#include &lt;stdlib.h&gt;void exit(int status);#include &lt;unistd.h&gt;void _exit(int status); 12345678910111213141516171819202122232425262728293031323334/************************************************************************* &gt; File Name: exit.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月10日 星期日 19时08分41秒 ************************************************************************//* #include &lt;stdlib.h&gt; void exit(int status); #include &lt;unistd.h&gt; void _exit(int status); 父进程回收子进程时候会用到! status参数: 是进程退时的一个状态信息。父进程回收子进程资源时候可以h 获取到。*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main() &#123; printf(&quot;hello\\n&quot;); printf(&quot;world&quot;); //exit(0); // 输出 hello world --- \\n 会刷新缓冲区 吧缓冲区 world 输出到控制台 _exit(0); // 输出 hello return 0;&#125; 孤儿进程父进程运行结束，但子进程还在运行(未运行结束)，这样的子进程就称为孤儿进程(Orphan Process). 每当出现一个孤儿进程时候,内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()(进程资源释放)它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作 因此孤儿进程并不会有什么危害。 对比代码12345678910111213141516171819202122232425262728293031/************************************************************************* &gt; File Name: fork_exit.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月10日 星期日 21时12分28秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main() &#123; pid_t pid = fork(); // 判断是父进程 if(pid &gt; 0) &#123; printf(&quot;i am parent process, pid : %d, ppid : %d\\n&quot;, getpid(), getppid()); &#125; else if(pid == 0) &#123; printf(&quot;i am child process, pid : %d, ppid : %d\\n&quot;, getpid(), getppid()); sleep(1); &#125; for(int i = 0; i &lt; 3; i++) &#123; printf(&quot;i : %d, pid : %d\\n&quot;, i, getpid()); &#125; return 0;&#125; 注意 pid、ppid 变化 12345678910111213141516171819202122232425262728293031/************************************************************************* &gt; File Name: fork_exit.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月10日 星期日 21时12分28秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main() &#123; pid_t pid = fork(); // 判断是父进程 if(pid &gt; 0) &#123; printf(&quot;i am parent process, pid : %d, ppid : %d\\n&quot;, getpid(), getppid()); &#125; else if(pid == 0) &#123; sleep(1); printf(&quot;i am child process, pid : %d, ppid : %d\\n&quot;, getpid(), getppid()); &#125; for(int i = 0; i &lt; 3; i++) &#123; printf(&quot;i : %d, pid : %d\\n&quot;, i, getpid()); &#125; return 0; 僵尸进程每个进程结束之后，都会释放自己地址空间中的用户区数据，内核区的 PCB没有办法自己释放掉，需要父进程去释放。 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸( zombie)进程。 僵尸进程不能被kill -9杀死。 这样就会导致一个问题，如果父进程不调用wait()或waitpid()的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的， 如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。 123456789101112131415161718192021222324252627282930313233/************************************************************************* &gt; File Name: zombie.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月10日 星期日 21时12分28秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main() &#123; pid_t pid = fork(); // 判断是父进程 if(pid &gt; 0) &#123; while(1) &#123; printf(&quot;i am parent process, pid : %d, ppid : %d\\n&quot;, getpid(), getppid()); sleep(1); &#125; &#125; else if(pid == 0) &#123; printf(&quot;i am child process, pid : %d, ppid : %d\\n&quot;, getpid(), getppid()); &#125; for(int i = 0; i &lt; 3; i++) &#123; printf(&quot;i : %d, pid : %d\\n&quot;, i, getpid()); &#125; return 0;&#125; 新打开一个窗口 ps aux 查看进程 可以试着用 kill -9 进程id (测试杀死僵尸进程) 如果父进程结束了 子进程就会被进程为 1 的接替 进程回收在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息(包括进程号、退出状态、运行时间等)。 父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。 wait()和waitpid()函数的功能一样，区别在于, wait()函数会阻塞，waitpid ()可以设置不阻塞, waitpid()还可以指定等待哪个子进程结束。 注意:一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。","categories":[{"name":"Linux-多线程开放","slug":"Linux-多线程开放","permalink":"https://tutouwang.vercel.app/categories/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://tutouwang.vercel.app/tags/Linux/"}]},{"title":"exec函数族","slug":"Linux-多线程开放/exec函数族","date":"2022-04-08T10:26:59.000Z","updated":"2022-05-23T14:17:33.529Z","comments":true,"path":"2022/04/08/Linux-多线程开放/exec函数族/","link":"","permalink":"https://tutouwang.vercel.app/2022/04/08/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/exec%E5%87%BD%E6%95%B0%E6%97%8F/","excerpt":"","text":"函数族族 ： 一族就是一系列函数 相同或者相似的 如oop 函数重载 名字不同 但是实现的功能相似的 exec函数族介绍exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。 exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代．只留下进程ID 等一些表面上的信息仍保持原样，颇有些神似”三十六计”中的”金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。 exec函数族作用图解替换 最后一条才是Linux函数库的 其他都是标准c库的 execl1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/************************************************************************* &gt; File Name: execl.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月10日 星期日 11时37分27秒 ************************************************************************//* #include &lt;unistd.h&gt; * int execl(const char *path, const char *arg, ...); * - 参数: * - path: 需要指定的执行的文件的路径或者名称 * a.out /test/高并发/Linux多线程/exec函数族/execl.aout * 建议写绝对路径 * ./a.out hello world * - arg: 是执行可执行文件所需要的参数列表 * 第一个参数一般没有什么作用, 为了方便, 一般可写的是执行的程序名称 * 从二个参数开始往后, 就是程序执行的所需要的参数列表 * 参数最后要以NULL结束(哨兵) * - 返回值: * 只有调用失败, 才会返回值, 返回-1, 并设置errno * 如果调用成功没有返回值！ * */#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 创建一个子进程, 在子进程中执行exec函数族中的函数 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 printf(&quot;i am paren peocess, pid : %d\\n&quot;, getpid()); sleep(1); &#125; else if(pid == 0) &#123; // 子进程 // 自己的可执行程序 --- 参数 可执行文件 // execl(&quot;test&quot;, &quot;test&quot;, NULL); // which ps --- /usr/bin/ps // or // execl(&quot;/usr/bin/ps&quot;, &quot;ps&quot;, &quot;a&quot;,&quot;u&quot;,&quot;x&quot;, NULL); execl(&quot;/usr/bin/ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL); printf(&quot;i am child proess pid = %d\\n&quot;, getpid()); &#125; for(int i = 0; i &lt; 3; i++) &#123; printf(&quot; i = %d, pid = %d\\n&quot;, i, getpid()); &#125; return 0;&#125; execlpenv // 环境变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/************************************************************************* &gt; File Name: execl.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月10日 星期日 11时37分27秒 ************************************************************************//* #include &lt;unistd.h&gt; * int execl(const char *file, const char *arg, ...); * - 会到环境变量中查找指定的可执行文件, 如果找到了就执行, 找不到就执行不成功。 * - 参数: * - file: 需要执行的可执行文件的文件名 * - arg: 是执行可执行文件所需要的参数列表 * 第一个参数一般没有什么作用, 为了方便, 一般可写的是执行的程序名称 * 从二个参数开始往后, 就是程序执行的所需要的参数列表 * 参数最后要以NULL结束(哨兵) * - 返回值: * 只有调用失败, 才会返回值, 返回-1, 并设置errno * 如果调用成功没有返回值！ * */#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; // 创建一个子进程, 在子进程中执行exec函数族中的函数 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 printf(&quot;i am paren peocess, pid : %d\\n&quot;, getpid()); sleep(1); &#125; else if(pid == 0) &#123; // 子进程 // 自己的可执行程序 --- 参数 可执行文件 // execl(&quot;test&quot;, &quot;test&quot;, NULL); // which ps --- /usr/bin/ps // or // execl(&quot;/usr/bin/ps&quot;, &quot;ps&quot;, &quot;a&quot;,&quot;u&quot;,&quot;x&quot;, NULL); execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL); printf(&quot;i am child proess pid = %d\\n&quot;, getpid()); &#125; for(int i = 0; i &lt; 3; i++) &#123; printf(&quot; i = %d, pid = %d\\n&quot;, i, getpid()); &#125; return 0;&#125; execv1234567/* int execv(const char *path, char *const argv[]);* - argv: 是需要的参数的一个字符串数组** // 使用 execv* char *argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;* execv(&quot;/usr/bin/ps&quot;, argv);*/ execve123456/* * int execve(const char *filename, char *const argv[], char *const envp[]); * 先从指定环境变量中 查找 如果第一个查找不到就到第二个中查找 ... * char *envp[] = &#123;&quot;/usr/bin&quot;, &quot;/usr/bin/test&quot;, &quot;xxxxx&quot;&#125;; */","categories":[{"name":"Linux-多线程开放","slug":"Linux-多线程开放","permalink":"https://tutouwang.vercel.app/categories/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/"}],"tags":[{"name":"[object Object]","slug":"object-Object","permalink":"https://tutouwang.vercel.app/tags/object-Object/"}]},{"title":"STL-Sort解析","slug":"OOP/手动实现Sort","date":"2022-04-08T09:13:49.000Z","updated":"2022-04-08T10:07:10.259Z","comments":true,"path":"2022/04/08/OOP/手动实现Sort/","link":"","permalink":"https://tutouwang.vercel.app/2022/04/08/OOP/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0Sort/","excerpt":"","text":"STL_sort 模板解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428/************************************************************************* &gt; File Name: Sort.cpp &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2021年11月10日 星期三 20时30分05秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;time.h&gt;#include &lt;functional&gt;using namespace std;// MAX_N == 存放数组大小，n == 循环右边边界const int MAX_N = 100, n = 20;#define BEGINS(x) namespace x &#123;#define ENDS(x) &#125; // end of namespace x// 初始化_BEGINESvoid init(int *f) &#123; for(int i = 0; i &lt; n; i++) *(f + i) = rand() % 10; return ;&#125;void output(int *first, int *last, const char *msg) &#123; cout &lt;&lt; msg; while(first != last) &#123; cout &lt;&lt; *first &lt;&lt; &quot; &quot;; ++first; &#125; cout &lt;&lt; endl; return ;&#125;// 初始化_ENDS// STL_自带sort_使用BEGINS(test1)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test1)// 手动实现sort firstEditionBEGINS(test2)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;void sort(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; if(first &gt;= last) return ; int *x = first, *y = last - 1, z = *first; while(x &lt; y) &#123; // while(x &lt; y &amp;&amp; *y &gt;= z) y--; while(x &lt; y &amp;&amp; cmp(z, *y)) y--; if(x &lt; y) *(x++) = *y; // while(x &lt; y &amp;&amp; *x &lt;= z) x++; while(x &lt; y &amp;&amp; cmp(*x, z)) x++; if(x &lt; y) *(y--) = *x; &#125; *x = z; sort(first, x, cmp); sort(x + 1, last, cmp); return ;&#125;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test2)// 手动实现sort secondEdition 单边递归法BEGINS(test3)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;void sort(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; if(first &gt;= last) return ; while(first &lt; last) &#123; int *x = first, *y = last - 1, z = *first; while(x &lt; y) &#123; while(x &lt; y &amp;&amp; cmp(z, *y)) y--; if(x &lt; y) *(x++) = *y; while(x &lt; y &amp;&amp; cmp(*x, z)) x++; if(x &lt; y) *(y--) = *x; &#125; *x = z; sort(first, x, cmp); first = x + 1; &#125; return ;&#125;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test3)// 手动实现sort secondEdition 单边递归法_无监督BEGINS(test4)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;void sort(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; while(first &lt; last) &#123; int *x = first, *y = last - 1, z = *first; do &#123; while(cmp(*x, z)) x++; while(cmp(z, *y)) y--; if(x &lt;= y) &#123; swap(*x, *y); x++, y--; &#125; &#125; while(x &lt;= y); sort(x, last, cmp); last = y + 1; &#125; return ;&#125;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test4)// 手动实现sort secondEdition 单边递归法_无监督_插入排序BEGINS(test5)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;const int threshold = 16;void intro_loop(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; while(last - first &gt; threshold) &#123; int *x = first, *y = last - 1, z = *first; do &#123; while(cmp(*x, z)) x++; while(cmp(z, *y)) y--; if(x &lt;= y) &#123; swap(*x, *y); x++, y--; &#125; &#125; while(x &lt;= y); sort(x, last, cmp); last = y + 1; &#125; return ;&#125;void insertion_sort(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; int *ind = first; // 找到最小值 for(int *i = first + 1; i &lt; last; ++i) &#123; if(cmp(*i, *ind)) ind = i; &#125; while(ind != first) &#123; swap(*ind, *(ind - 1)); --ind; &#125; for(int *i = first + 2; i &lt; last; ++i) &#123; int *j = i; while(cmp(*j, *(j - 1))) &#123; swap(*j, *(j - 1)); --j; &#125; &#125; return ;&#125;void sort(int *first, int *last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; intro_loop(first, last, cmp); insertion_sort(first, last, cmp); return ;&#125;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test5)// 手动实现sort secondEdition 单边递归法_无监督_插入排序_随机迭代器(指针对象)BEGINS(test6)bool cmp1(int a, int b) &#123; return a &gt; b;&#125;class CMP &#123;public : bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;const int threshold = 16;class RandomIter&#123;public : RandomIter(int *ptr) : ptr(ptr)&#123;&#125; int &amp;operator*() &#123;return *ptr; &#125; RandomIter operator-(int x) &#123;return RandomIter(ptr - x); &#125; RandomIter operator+(int x) &#123;return RandomIter(ptr + x); &#125; int operator-(const RandomIter &amp;iter) &#123;return ptr - iter.ptr; &#125; // 前 ++ operator++() // 后 ++ operator++(int) RandomIter &amp;operator++() &#123; ++ptr; return *this; &#125;; RandomIter &amp;operator--() &#123; --ptr; return *this; &#125;; bool operator&lt;(const RandomIter &amp;iter) const &#123; return this-&gt;ptr &lt; iter.ptr; &#125; bool operator&gt;(const RandomIter &amp;iter) const &#123; return iter &lt; *this; &#125; bool operator&lt;=(const RandomIter &amp;iter) const &#123; return !(iter &lt; *this); &#125; bool operator&gt;=(const RandomIter &amp;iter) const &#123; return !(*this &lt; iter); &#125; bool operator==(const RandomIter &amp;iter) const &#123; return !(iter &lt; *this) &amp;&amp; !(*this &lt; iter); &#125; bool operator!=(const RandomIter &amp;iter) &#123; return !(iter == *this); &#125;private : int *ptr;&#125;;void intro_loop(RandomIter first, RandomIter last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; while(last - first &gt; threshold) &#123; RandomIter x = first, y = last - 1; int z = *first; do &#123; while(cmp(*x, z)) ++x; while(cmp(z, *y)) --y; if(x &lt;= y) &#123; swap(*x, *y); ++x, --y; &#125; &#125; while(x &lt;= y); intro_loop(x, last, cmp); last = y + 1; &#125; return ;&#125;void insertion_sort(RandomIter first, RandomIter last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; RandomIter ind = first; // 找到最小值 for(RandomIter i = first + 1; i &lt; last; ++i) &#123; if(cmp(*i, *ind)) ind = i; &#125; while(ind != first) &#123; swap(*ind, *(ind - 1)); --ind; &#125; for(RandomIter i = first + 2; i &lt; last; ++i) &#123; RandomIter j = i; while(cmp(*j, *(j - 1))) &#123; swap(*j, *(j - 1)); --j; &#125; &#125; return ;&#125;void sort(RandomIter first, RandomIter last, function&lt;bool(int, int)&gt; cmp = less&lt;int&gt;()) &#123; intro_loop(first, last, cmp); insertion_sort(first, last, cmp); return ;&#125;int main() &#123; int f[MAX_N]; init(f); output(f, f + n, &quot;default : &quot;); sort(f, f + n); output(f, f + n, &quot;none : &quot;); sort(f, f + n, cmp1); output(f, f + n, &quot;cmp1 : &quot;); CMP cmp2; sort(f, f + n, cmp2); output(f, f + n, &quot;cmp2 : &quot;); return 0;&#125;ENDS(test6)int main() &#123; // test1::main(); // test2::main(); // test3::main(); // test4::main(); // test5::main(); test6::main(); return 0;&#125;","categories":[{"name":"c++OOP","slug":"c-OOP","permalink":"https://tutouwang.vercel.app/categories/c-OOP/"}],"tags":[]},{"title":"GDB多线程调试","slug":"Linux-多线程开放/GDB多线程调试","date":"2022-04-06T09:09:41.000Z","updated":"2022-05-22T15:05:06.449Z","comments":true,"path":"2022/04/06/Linux-多线程开放/GDB多线程调试/","link":"","permalink":"https://tutouwang.vercel.app/2022/04/06/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/GDB%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95/","excerpt":"","text":"GDB多进程调试使用GDB调试的时候，GDB默认只能跟踪一个进程，可以在fork函数调用之前,通过指令设置GDB调试工具跟踪父进程或者跟踪跟踪子进程，默认跟踪父进程。 设置调试父进程或者子进程： set follow-fork-mode [paren(默认) | child] 设置调试模式：set detach-on-fork [on | off] 默认 on,表示调试当前进程的时候,其他的进程继续运行, 如果为off, 调试当前进程的时候, 其他进程被GDB挂起。 查看调试的进程：info inferiors 切换当前调试的进程： inferior id 使进程脱离GDB调试：detach inferiors id 使进程移除GDB调试：remo inferiors id gdb多线程报错8.x 版本调试多进程会有一些BUG inferior 2 info inferiors &#x2F;&#x2F; 查看","categories":[{"name":"Linux-多线程开放","slug":"Linux-多线程开放","permalink":"https://tutouwang.vercel.app/categories/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://tutouwang.vercel.app/tags/Linux/"}]},{"title":"进程状态转换","slug":"Linux-多线程开放/进程状态转换","date":"2022-04-02T11:12:47.000Z","updated":"2022-05-22T15:05:06.446Z","comments":true,"path":"2022/04/02/Linux-多线程开放/进程状态转换/","link":"","permalink":"https://tutouwang.vercel.app/2022/04/02/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"进程状态转换三态模型：就绪态、运行态、阻塞态 五态模型：新建态、就绪态、运行态、阻塞态、终止态 进程的状态 查看进程 man ps ps aux &#x2F; ajx (PPID 父进程的IP、 PID 进程的ID、PGID 进程组的ID、SID 绘话) a：显示终端上的所有进程, 包括其他用户的进程 u: 显示进程的详细信息 x: 显示没有控制终端的进程 j: 列出与作业控制相关的信息 进程状态转换STAT 参数意义：​ D 不可中断 Uninterruptible（usually IO） ​ R 正在运行, 或在队列中的进程 ​ S (大写) 处于休眠状态 ​ T 停止或被追踪 ​ Z 僵尸进程 ​ W 进入内存交换 (从内核2.6开始无效) ​ X 杀掉的进程 ​ &lt; 高优先级 ​ N 底优先级 ​ s 包含子进程 ​ + 位于前台的进程组 实时显示进程状态​ top ​ 可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔，在top命令执行后，可以按下按键对显示的结果排序 按 键 M 根据内存使用量排序 P 根据 CPU 占有率排序 T 根据进程运行时间长短 U 根据用户名来筛选进程 K 输入指定的 PID 杀死进程 杀死进程 kill [-signal] pid kill -l 列出所有信号 kill -SIGKILL 进程ID kill -9 进程ID &#x2F;&#x2F; -l 信号 SIGKILL &#x2F; -9 强制杀死 Killall name 根据进程名杀死进程 进程杀死测试终端 测试 运行代码 12345678910111213141516/************************************************************************* &gt; File Name: whil_lastiung.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月03日 星期日 10时39分54秒 ************************************************************************/#include&lt;stdio.h&gt;int main() &#123; while(1) &#123; printf(&quot;秃头王\\n&quot;); sleep(1); &#125; return 1;&#125; 后台运行./a.out &amp; 进程号和相关函数 pid 进程ID ppid 父进程的ID pgpid 用组的ID 进程创建 - man 2 fork系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成讲程树结构模型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/************************************************************************* &gt; File Name: fork.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年04月03日 星期日 14时14分05秒 ************************************************************************//* * #include &lt;sys/types.h&gt; * #include &lt;unistd.h&gt; * * pid_t fork(void) ; * 函数的作用: 用于创建子进程 * 返回值: * fork()的返回值会返回2次 一次在父进程中、一次在子进程中。 * 在父进程中返回创建的子进程的 ID * 在子进程中返回 0 * 如何区分子进程和父进程: 通过fork的返回值 * 在父进程中返回-1, 表示创建子进程失败, 并设置errno * * 父子进程之间的关系: * 区别: * 1. fork() 函数的返回值不同 * 父进程中: &gt; 0 返回的子进程的ID * 子进程中: = 0 * 2. pcb 中的一些数据 * 当前的进程id pid * 当前的进程的父进程的id ppid * 信号集 * 共同点: * 某些状态下: 子进程中刚被创建出来, 还没有执行任何的写数据的操作 * - 用户区的数据 * - 文件描述表 * 父子进程对变量是不是共享的？ * - 刚开始时候, 是一样的共享。如果修改的数据就不共享了 * - 读时候共享(子进程被创建, 两个进程没有做任何的写的操作), 写时拷贝 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main() &#123; int num = 10; pid_t pid = fork(); if(pid &gt; 0) &#123; printf(&quot;pid : %d\\n&quot;, pid); // 如果大于0,返回的是创建的子进程的进程号, 当前父进程 printf(&quot;i am parent process, pid : %d, ppid % d\\n&quot;, getpid(), getppid()); printf(&quot;parent num : %d \\n&quot;, num); num += 10; printf(&quot;parent num += 10 : %d \\n&quot;, num); &#125; else if(pid == 0) &#123; // 当前是子进程 printf(&quot;i am child process, pid : %d, ppid : %d \\n&quot;, getpid(), getppid()); printf(&quot;child num : %d \\n&quot;, num); num += 100; printf(&quot;child num += 100 : %d \\n&quot;, num); &#125; for(int i = 0; i &lt; 3; i++) &#123; printf(&quot;i : %d, pid : %d\\n&quot;, i, getpid()); sleep(1); &#125; return 0;&#125; fork 执行流程 修改子进程后就会开辟一个新地址","categories":[{"name":"Linux-多线程开放","slug":"Linux-多线程开放","permalink":"https://tutouwang.vercel.app/categories/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/"}],"tags":[]},{"title":"进程概述","slug":"Linux-多线程开放/进程概述","date":"2022-04-01T14:18:54.000Z","updated":"2022-05-22T15:05:06.445Z","comments":true,"path":"2022/04/01/Linux-多线程开放/进程概述/","link":"","permalink":"https://tutouwang.vercel.app/2022/04/01/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0/","excerpt":"","text":"程序和进程并行和并发 并发：有限的资源交替使用 进程控制块 ulimit - a 进程可用资源上限","categories":[{"name":"Linux-多线程开放","slug":"Linux-多线程开放","permalink":"https://tutouwang.vercel.app/categories/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://tutouwang.vercel.app/tags/Linux/"}]},{"title":"标准c库IO函数和Linux系统IO函数对比","slug":"LInux-系统编程入门/标准c库IO函数和Linux系统IO函数对比","date":"2022-03-10T11:48:40.000Z","updated":"2022-05-27T01:54:26.207Z","comments":true,"path":"2022/03/10/LInux-系统编程入门/标准c库IO函数和Linux系统IO函数对比/","link":"","permalink":"https://tutouwang.vercel.app/2022/03/10/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E6%A0%87%E5%87%86c%E5%BA%93IO%E5%87%BD%E6%95%B0%E5%92%8CLinux%E7%B3%BB%E7%BB%9FIO%E5%87%BD%E6%95%B0%E5%AF%B9%E6%AF%94/","excerpt":"","text":"标准C库IO函数 自带帮助文档 第三章 虚拟地址空间 Linux系统IO函数帮助文档 ~Linux : man 2 open停留在函数上Shif + k可进行快速跳转 123456789101112131415161718192021// 为社么定义三个头文件：不同的宏定义在两个文件里#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;// 宏 flags = 标记(只读、可读、可读可写 ...)// 打开一个已经存在的文件int open(const char *pathname, int flags); 参数: - pathname : 要打开的文件路径 - flags : 对文件的操作权限还有其的他设置 O_RDONLY (只读), O_WRONLY (只写), O_RDWR (可读可写) 这三个是互斥的 返回值：返回一个新的文件描述符，如果失败了返回 -1 ，否则返回一个整形文件描述符 errno：属于Linux系统函数库，库里的一个全局变量，记录的是最近的错误号。 #include &lt;stdio.h&gt; void perror(const char *s); 作用：打印errno对应的错误描述 参数:用户描述，比如hello,最终点输出的内容是 hello:xxx(实际的错误描述) // 创建一个新的文件int open(const char *pathname, int flags, mode_t mode); 没有创建 a.txt 代码 1234567891011121314151617181920212223242526/************************************************************************* &gt; File Name: open_test1.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月11日 星期五 22时30分53秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;int main() &#123; int fd = open(&quot;a.txt&quot;, O_RDONLY); if(fd == -1) &#123; perror(&quot;open&quot;); &#125; // 读写操作 // 关闭一个文件描述符 close(fd); return 0;&#125; 创建文件 touch a.txt 设置umask umask 022 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/************************************************************************* &gt; File Name: open_test1.c &gt; Author: &gt; Mail: &gt; Created Time: 2022年03月11日 星期五 22时30分53秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;/* * int open(const char *pathname, int flags, mode_t mode); * 参数 : * - pathname : 要创建的文件路径 * - flags : 对文件操作的权限和其他的设置 * - 必选项 : O_RDONLY, O_WDONLY, O_WEONLY 这三个互斥 * - 可选项 ：O_CREAT (文件不存在，创建新文件) * - mode : 八进制的数, 表示创建出的新的文件的操纵权限, 例如：0775 (0开头表示 八进制) * RWX(读、写、 可执行、三组 当前用户的权限、当前用户所在祖的权限、其他组) = 777 * 最终的权限是 : mode &amp; ~umask(0002) // 不同用户不一样 这个值也能 更改 * 八进制 -&gt; 二进制 * 0777 -&gt; 111 111 111 * &amp; 0775 -&gt; 111 111 101 * -------------------------- * 111 111 101 * 按位与：0和任何数都为0 * * umask : 作用就是抹去某些权限 * flags : 或的作用 * 参数是一个int类型的数据,占4个字节32位。 * 32个位，每一位就是一个标志位。 * 1 - R * 2 - W * 3 - RW * 4 - CR * */int main() &#123; // 创建一个新的文件 int fd = open(&quot;create.txt&quot;, O_RDWR | O_CREAT, 0777); if(fd == -1) &#123; perror(&quot;open&quot;); &#125; // 关闭 close(fd); return 0;&#125; 帮助文档 : man 2 copy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/************************************************************************* &gt; File Name: copyfile.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月17日 星期四 20时48分17秒 ************************************************************************/#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;/* * * #include &lt;unistd.h&gt; * ssize_t read(int fd, void *buf, size_t count); * 参数: * - fd: 文件描述符, open得到的,通过这个文件描述符操作某个文件 * - buf: 缓冲区读取数据存放的地方数组的地址 (传出参数) * - count: 指定的数组大小 * 返回值: * - 成功: * &gt; 0: 返回实际的读取到的字数 * = 0: 文件已经读取完 * - 失败: - 1, 并设置errno * #include &lt;unistd.h&gt; * ssize_t write(int fd, const void *buf, size_t count); * 参数： * - fd: 文件描述, open得到的,y通过这个 * - buf: 要往磁盘写入的数据 * - count: 要写的数据的实际大小 * 返回值: * 成功: 实际写入的大小 * 失败: 返回-1,并设置errno * */int main() &#123; // 1.通过open打开english.txt // 相对路径&quot;文件名.后缀&quot; // 绝对路径&quot;c:/xxx/xxx/文件名.后缀&quot; int srcfd = open(&quot;english.txt&quot;, O_RDONLY); if(srcfd == -1) &#123; perror(&quot;opne&quot;); return -1; &#125; // 2.创建一个新的文件(拷贝文件) int destfd = open(&quot;cpy.txt&quot;, O_WRONLY | O_CREAT, 0664); if(destfd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; // 3.频繁的读写操作 char buf[1024] = &#123;0&#125;; int len = 0; while((len = read(srcfd, buf, sizeof(buf))) &gt; 0) &#123; // destfd: 目标文件文件描述符 write(destfd, buf, len); &#125; // 4.关闭文件 close(destfd); close(srcfd) ; return 0;&#125; 帮助文档 : man 2 lseekLinux 的 lseek 在标准c库中 man 3 fseek 为什么要扩展比如说下载一个大小文件大小为5G(下载时候也正在用磁盘)假如磁盘大小么有5G(就不能正确下载下来)所以会提起占用一点点在替换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/************************************************************************* &gt; File Name: lseek.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月20日 星期日 16时40分30秒 ************************************************************************//* * 标准c库 * #inline &lt;stdio.h&gt; * int fseek(FLE *stream, long offset, int whence); * * Linux系统函数 * #include &lt;sys/types.h&gt; * #include &lt;unistd.h&gt; * oof_t lseek(int fd, oof_t offset, int whence); * 参数: * - fd: 文件描述, 通过open得到的, 通过这个fd操作某个文件 * - offset: 偏移量 * - whence: * SEEK_SET The file offset is set to offset bytes. * 设置文件指针的偏移量 * SEEK_CUR The file offset is set to its current location plus offset bytes. * 设置便宜量: 当前位置 + 第 二个参数 offset的值 * SEEK_END The file offset is set to the size of the file plus offset bytes. * 设置偏移量: 文件大小 + 第 二个参数offse的值 * 返回值: 返回文件指针的位置 * 作用: * 1.移动文件指针 * lseek(fd, 0, SEEL_SET); * * 2.获取当前文件指针位置 * lseek(fd, 0, SEEK_CUR); * * 3.可以获取文件长度 * lseek(fd, 0, SEEK_END); * * 4.拓展文件的长度,当文件10b, 110b, 增加了100个字节 * lseek(fd, 100, SEEK_END); * // 注意：需要些一次数据 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;int main() &#123; int fd = open(&quot;hello.txt&quot;, O_RDWR); if(fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; // 扩展文件的长度 int ret = lseek(fd, 100, SEEK_END); if(ret == -1) &#123; perror(&quot;open&quot;); return -1; &#125; // 写入一个空格数据 write(fd, &quot; &quot;, 1); // 关闭文件 close(fd); return 0;&#125; 帮助文档 : man 2 stat 1234567891011121314151617181920212223242526272829303132333435363738394041424344/************************************************************************* &gt; File Name: stat.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月23日 星期三 16时29分33秒 ************************************************************************//* #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;unistd.h&gt; int stat(const char *pathname, struct stat *statbuf); 作用: 获取一个文件相关的一些信息 参数; - pathname: 操作文件的路径 - statbuf: 结构体变量, 传出参数, 用于保存获取的文件信息 返回值: 成功: 返回0 失败: 返回-1, 并设置errno int fstat(int fd, struct stat *statbuf); int lstat(const char *pathname, struct stat *statbuf);*/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;int main() &#123; struct stat statbuf; int ret = stat(&quot;a.txt&quot;, &amp;statbuf); if(ret == -1) &#123; perror(&quot;stat&quot;); return -1; &#125; printf(&quot;size: %ld\\n&quot;, statbuf.st_size); return 0;&#125; 模拟实现 ls -l 命令 参考文档 man 3 getpwuid 参考文档 man 3 getgrgid 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/************************************************************************* &gt; File Name: ls-l.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月26日 星期六 15时29分49秒 -***********************************************************************/// 模拟实现 ls -l 指令// -rw-r--r-- 1 qz qz 11 3月 26 15:30 a.txt#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;pwd.h&gt;#include &lt;grp.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;int main(int argc, char* argv[]) &#123; // 判断输入的参数是否正确 if(argc &lt; 2) &#123; printf(&quot;%s filename\\n&quot;, argv[0]); return -1; &#125; // 通过stat函数获取用户传入的文件信息 struct stat st; int ret = stat(argv[1], &amp;st); if(ret == -1) &#123; perror(&quot;stat&quot;); return -1; &#125; // 获取文件类型和文件权限 char *perms = (char *)calloc(sizeof(char), 11); switch(st.st_mode &amp; S_IFMT) &#123; case S_IFLNK: perms[0] = &#x27;l&#x27;; break; case S_IFDIR: perms[0] =&#x27;d&#x27;; break; case S_IFREG: perms[0] =&#x27;-&#x27;; break; case S_IFBLK: perms[0] =&#x27;b&#x27;; break; case S_IFCHR: perms[0] =&#x27;c&#x27;; break; case S_IFSOCK: perms[0] =&#x27;s&#x27;; break; case S_IFIFO: perms[0] =&#x27;p&#x27;; break; default: perms[0] = &#x27;?&#x27;; &#125; // 判断文件的访问权限 // 文件所有者 perms[1] = (st.st_mode &amp; S_IRUSR) ? &#x27;r&#x27; : &#x27;-&#x27;; perms[2] = (st.st_mode &amp; S_IWUSR) ? &#x27;w&#x27; : &#x27;-&#x27;; perms[3] = (st.st_mode &amp; S_IXUSR) ? &#x27;x&#x27; : &#x27;-&#x27;; // 文件所有组 perms[4] = (st.st_mode &amp; S_IRGRP) ? &#x27;r&#x27; : &#x27;-&#x27;; perms[5] = (st.st_mode &amp; S_IWGRP) ? &#x27;w&#x27; : &#x27;-&#x27;; perms[6] = (st.st_mode &amp; S_IXGRP) ? &#x27;x&#x27; : &#x27;-&#x27;; // 其他人 perms[7] = (st.st_mode &amp; S_IROTH) ? &#x27;r&#x27; : &#x27;-&#x27;; perms[8] = (st.st_mode &amp; S_IWOTH) ? &#x27;w&#x27; : &#x27;-&#x27;; perms[9] = (st.st_mode &amp; S_IXOTH) ? &#x27;x&#x27; : &#x27;-&#x27;; // 硬链接数 int linkNum = st.st_nlink; // 文件所有者 char *fileUser = getpwuid(st.st_uid)-&gt;pw_name; // 文件所在组 char *fileGrp = getgrgid(st.st_gid)-&gt;gr_name; // 文件大小 long int fileSize = st.st_size; // 修改的时间 从 1970年 会自带一个换行 char *time = ctime(&amp;st.st_mtime); char mtime[512] =&#123;0&#125;; strncpy(mtime, time, strlen(time) - 1); char buf[1024]; sprintf(buf, &quot;%s %d %s %s %ld %s %s&quot;, perms, linkNum, fileUser, fileGrp, fileSize, mtime, argv[1]); printf(&quot;%s\\n&quot;, buf); return 0;&#125; 文件属性man 2 access 12345678910111213141516171819202122232425262728293031/************************************************************************* &gt; File Name: chmod.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月27日 星期日 11时21分04秒 ************************************************************************//* include &lt;sys/stat.h&gt; int chmod(const char *pathname, mode_t mode); 修改文件的权限 参数: - pathname: 需要修改的文件路径 - mode: 需要修改的权限值, 八进制的数 返回: h成功返回0, 失败返回-1*/#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;int main() &#123; int ret = chmod(&quot;a.txt&quot;, 0775); if(ret == -1) &#123; perror(&quot;chmod&quot;); return -1; &#125; return 0;&#125; man 2 truncate 1234567891011121314151617181920212223242526272829303132333435/************************************************************************* &gt; File Name: truncate.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月27日 星期日 17时35分17秒 ************************************************************************//* #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; int truncate(const char *path, off_t length); 作用: 缩减或者扩展文件的尺寸至指定的大小 参数: - path: 需要修改的文件的k路径 - length: 需要最终文件变成的大小 如果 一个文件(10K) 想变成一个(5k)就会把后面截取掉 返回: 成功0,失败-1*/#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main() &#123; int ret = truncate(&quot;b.txt&quot;, 20); // int ret = truncate(&quot;b.txt&quot;, 5); if(ret == -1) &#123; perror(&quot;truncat&quot;); return -1; &#125; return 0;&#125; 目录操作函数man 2 mkdir 1234567891011121314151617181920212223242526272829303132333435363738394041/************************************************************************* &gt; File Name: mkdir.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月28日 星期一 11时39分42秒 ************************************************************************//* include &lt;sys/stat.h&gt; #include &lt;sys/types.h&gt; int mkdir(const char *pathname, mode_t mode); 作用: 创建一个目录 参数: pathname: 创建的目录的路径 mode: 权限, 八进制 返回: 成功返回0, 失败返回-1 // 删除 int rmdir(const char *pathname); // 更名 第一个参数旧的名字 第二个参数新的名字 int rename(const char *oldpath, const char *newpath);*/#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;int main() &#123; // 0777 0是八进制 // 一定要有可执行权限 x 要不就永不了 你不信试试 int ret = mkdir(&quot;aaa&quot;, 0777); if(ret == -1) &#123; perror(&quot;mkdir&quot;); return -1; &#125; return 0;&#125; man 2 getcwd 工作路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/************************************************************************* &gt; File Name: getcwd.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月29日 星期二 09时27分16秒 ************************************************************************//* #include &lt;unistd.h&gt; int chdir(const char *path); 作用: 修改进程的工作目录 比如在/home/root 启动了一个可执程序 a.out, 进程的工作目录 参数: path: 需要修改的工作目录 #nclude &lt;unistd.h&gt; char *getcwd(char *buf, size_t size); 作用: 获取当前工作目录 参数: - buf: 存储的路径, 指向的是一个数组(传出参数) - size: 数组大小 返回值: 返回的指向的一块内存, 这个数据就是第一个参数*/#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;int main() &#123; // 获取当前工作目录 char buf[128]; getcwd(buf, sizeof(buf)); printf(&quot;当前的工作目录是 : %s\\n&quot;, buf); // 修改工作目录 下面是相对路径 不是绝对路径 int ret = chdir(&quot;../test&quot;); if(ret == -1) &#123; perror(&quot;chdir&quot;); return -1; &#125; // 创建一个新的文件 int fd = open(&quot;w.txt&quot;, O_CREAT| O_RDWR, 0664); if(fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; // 关闭文件描述符 close(fd); // 获取当前工作目录 char buf1[128]; getcwd(buf1, sizeof(buf1)); printf(&quot;当前的工作目录是 : %s\\n&quot;, buf1); return 0;&#125; man 3 opendir 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/************************************************************************* &gt; File Name: readFileNum.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月30日 星期三 10时01分49秒 ************************************************************************//* // 打开目录 #nclude &lt;sys/types.h&gt; #include &lt;dirent.h&gt; DIR *opendir(const char *name); 参数: - name: 需要打开的目录名称 返回值: DIR * 类型理解为目录流 失败返回 NULL // 读取目录中的数据 #include &lt;dirent.h&gt; struct diren *readdir(DIR *dirp); 参数: - dirp 是 opendir 返回的结果 返回值: struct dirent 代表读取到的文件的信息 读取到了末尾或者失败了, 返回NULL // 关闭目录 #include &lt;sys/types.h&gt; #include &lt;dirent.h&gt; int closedir(DIR *dirp);*/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int getFileNum(const char *path);// 读取某个目录下的普通文件的个数int main(int argc, char *argv[]) &#123; if(argc &lt; 2) &#123; printf(&quot;%s path\\n&quot;, argv[0]); return -1; &#125; int num = getFileNum(argv[1]); printf(&quot;普通文件的个数: %d \\n&quot;, num); return 0;&#125;// 用于获取目录下所有普通文件的个数int getFileNum(const char *path) &#123; // 打开目录 DIR *dir = opendir(path); if(dir == NULL) &#123; perror(&quot;opendir&quot;); exit(0); &#125; struct dirent *ptr; // 记录普通文件的个数 int total = 0; while((ptr = readdir(dir)) != NULL) &#123; // 获取名称 char *dname = ptr-&gt;d_name; // 忽略掉 .和 .. if(strcmp(dname, &quot;.&quot;) == 0 || strcmp(dname, &quot;..&quot;) == 0) continue; // 判断是否是普通文件 if(ptr-&gt;d_type == DT_DIR) &#123; // 目录, 需要继续读取这个目录 char newpath[256]; sprintf(newpath, &quot;%s%s&quot;, path, dname); total += getFileNum(newpath); &#125; if(ptr-&gt;d_type == DT_REG) &#123; // 普通文件 total++; &#125; &#125; // 关闭目录 closedir(dir); return total;&#125; dup，dup2函数man 2 dup 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/************************************************************************* &gt; File Name: dup.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月30日 星期三 16时03分03秒 ************************************************************************//* * #include &lt;unistd.h&gt; * int dup(int oldfd); * 作用: 复制一个新的文件描述符 * fd = 3, fd1 = dup(fd); * fd指向的是a.txt, fd1也是指向的a.txt * 从空闲的文件描述符表中找到一个最小的, 作为新的拷贝的文件描述 符 * * */#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;// 创建文件#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;int main() &#123; // 第一个读写 第二创建 int fd = open(&quot;a.txt&quot;, O_RDWR | O_CREAT, 0664); int fd1 = dup(fd); if(fd1 == -1) &#123; perror(&quot;dup&quot;); return -1; &#125; printf(&quot;fd : %d \\n fd1 : %d&quot;, fd, fd1); close(fd); char *str = &quot;hello, world&quot;; int ret = write(fd1, str, strlen(str)); if(ret == -1) &#123; perror(&quot;write&quot;); return -1; &#125; close(fd1); return 0;&#125; man 2 dup2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/************************************************************************* &gt; File Name: dup2.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月31日 星期四 14时25分22秒 ************************************************************************//* * #include &lt;unistd.h&gt; * int dup2(int oldfd, int newfd); * 作用: 重定向文件描述符 * oldfd 指向 a.txt, newfd 指向 b.txt * 调用函数成功后: newfd 和 b.txt 做 close(), newfd 指向了 a.txt * oldfd 必须是一个有效的文件描述符 * oldfd 和 newfd 值相同相当于什么也没做 */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main() &#123; int fd = open(&quot;1.txt&quot;, O_RDWR | O_CREAT, 0664); if(fd == -1) &#123; perror(&quot;open&quot;); &#125; int fd1 = open(&quot;2.txt&quot;, O_RDWR | O_CREAT, 0664); if(fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; printf(&quot;fd : %d, fd1 : %d\\n&quot;, fd, fd1); int fd2 = dup2(fd, fd1); if(fd2 == -1) &#123; perror(&quot;dup2&quot;); return -1; &#125; // 通过fd1去写数据, 实际操作的是1.txt, 而不是2.txt char * str = &quot;hello, dup2&quot;; int len = write(fd1, str, strlen(str)); if(len == -1) &#123; perror(&quot;write&quot;); return -1; &#125; printf(&quot;fd : %d, fd1 : %d, fd2 : %d \\n&quot;, fd, fd1, fd2); close(fd); close(fd1); return 0;&#125; man 2 fucnt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/************************************************************************* &gt; File Name: fcntl.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月31日 星期四 18时55分53秒 ************************************************************************//* * #include &lt;unistd.h&gt; * #include &lt;fcntl.h&gt; * * int fcntl(int fd, int cmd, ...); * 参数: * - fd: 表示需要操作的文件描述符 * - cmd: 表示文件描述符进行如何操作 * 1. F_DUPFD: 复制文件描述符,复制的是一个参数fd,得到一个新的 * int ret = fcntl(fd, F_DUPFD); * 2. F_GETFL: 获取指定的文件描述符文件状态flag * 获取的flag和通过open函数传递的flag是一个东西 * 3. F_SETFL: 设置文件描述符文件状态falg * 必选项: O_RDONLY, O_WRODNLY, O_RDWR 不可以被修改 * 可选性: O_APPEND, O_NONBLOCK * O_APPEND: 表示追加数据 * O_NONBLOCK: 设置成非阻塞 * 阻塞和非阻塞: 指的是函数调用的行为。add() */#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main() &#123; // 1.复制文件描述符 // int fd = open(&quot;1.txt&quot;, O_RDONLY); // int ret = fcntl(fd, F_DUPFD); // 2.修改或者获取文件状态flag --- 当前文件只读 int fd = open(&quot;1.txt&quot;, O_RDWR); if(fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; // 获取文件描述符状态 int flag = fcntl(fd,F_GETFL); if(flag == -1) &#123; perror(&quot;fcntl_GET&quot;); return -1; &#125; flag |= O_APPEND; // 修改文件描述符状态的flag, 给flag加入O_APPEND这个标记 int ret = fcntl(fd, F_SETFL, flag); if(ret == -1) &#123; perror(&quot;fcntl_SET&quot;); return -1; &#125; char *str = &quot;nihao&quot;; write(fd, str, strlen(str)); close(fd); return 0;&#125;","categories":[{"name":"LInux-系统编程入门","slug":"LInux-系统编程入门","permalink":"https://tutouwang.vercel.app/categories/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"LInux","slug":"LInux","permalink":"https://tutouwang.vercel.app/tags/LInux/"}]},{"title":"Vim复制代码错位问题","slug":"复制代码错位问题","date":"2022-03-09T02:10:56.000Z","updated":"2022-03-09T06:37:32.830Z","comments":true,"path":"2022/03/09/复制代码错位问题/","link":"","permalink":"https://tutouwang.vercel.app/2022/03/09/%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E9%94%99%E4%BD%8D%E9%97%AE%E9%A2%98/","excerpt":"","text":"Vim中复制粘贴缩进错乱问题的解决方Vim中复制粘贴缩进错乱问题的解决方案 当你把这段缩进优美的代码直接ctrl+c(ctrl+shift + c)，ctrl+v到Vim的时候，就会出现如下恶心的情况 可以看到，这种直接粘贴的方式会导致代码丢失和缩进错乱等情况。 解决方案vim进入paste模式，命令如下： :set paste 进入paste模式之后，再按i进入插入模式，进行复制、粘贴就很正常了。命令模式下，输入 :set nopaste 解除paste模式。 paste模式主要帮我们做了如下事情： textwidth设置为0wrapmargin设置为0set noaiset nosisofttabstop设置为0revins重置ruler重置showmatch重置formatoptions使用空值","categories":[{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"GDB调试","slug":"LInux-系统编程入门/GDB调试","date":"2022-03-08T09:34:18.000Z","updated":"2022-05-27T01:27:02.221Z","comments":true,"path":"2022/03/08/LInux-系统编程入门/GDB调试/","link":"","permalink":"https://tutouwang.vercel.app/2022/03/08/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/GDB%E8%B0%83%E8%AF%95/","excerpt":"","text":"什么是 GDB GDB是由 GNU软件系统社区提供的调试工具，同GCC 配套组成了一套完整的开发环境，GDB是 Linux和许多类Unix系统中的标准开发环境。 一般来说，GDB主要帮助你完成下面四个方向的功能： 启动程序，可以按照自定义的要求随心所欲的运行程序 可让被调试的程序在指定的调置的断点处停住(断点可以是条件表达式) 当程序被停住时,可以检查此时程序中发生的事 可以改变程序，将一个BUG产生的影响修正从而测试其他 BUG 准备工作 通常，在为调试而编译时，我们会关掉编译器的优化选项（’-o’) ，并打开调试选项(‘-g’)。另外， ‘-Wall’在尽量不影响程序行为的情况下选项打开所有warning(警告)，也可以发现许多问题，避免一些不必要的 BUG。 gcc -g -Wall program.c -o program ‘g’ 选项的作用是在执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，可以在调试时必须保证 gdb 能找打源文件 -w 的意思是关闭编译时的警告，也就是编译后不显示任何warning，因为有时在编译之后编译器会显示一些例如数据转换之类的警告，这些警告是我们平时可以忽略的。 -Wall选项意思是编译后显示所有警告。 -W选项类似-Wall，会显示警告，但是只显示编译器认为会出现错误的警告。 在编译一些项目的时候可以-W和-Wall选项一起使用。 GDB命令-启动、退出、查看代码 启动和退出 gdb 可执行程序 quit 给程序设置参数&#x2F;获取设置参数 set args 10 20 show args GDB 使用帮助 help 查看当前文件代码 (回车继续执行上一行命令) list&#x2F;l (从默认位置显示) list&#x2F;l 行号 (从指定的行显示) list&#x2F;l 函数名 (从指定的函数显示) 查看非当前文件文件 list&#x2F;l 文件名：行号 list&#x2F;l 文件名：函数名 设置显示行数 show list&#x2F;listsize set list&#x2F;listsize 行数 gdb 调试代码12345678910111213141516171819202122232425262728293031323334353637383940/************************************************************************* &gt; File Name: gdb_test1.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年03月09日 星期三 10时19分28秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int test(int a) &#123; int sum = 0; for(int i = 0; i &lt; a; i++) &#123; sum += i; &#125; return sum;&#125;// ./test1 10 20 // 传递参数就会给main里面int main(int argc, char* argv[]) &#123; int a, b; printf(&quot;argc = %d\\n&quot;, argc); if(argc &lt; 3) &#123; a = 10; b = 30; &#125; else &#123; a = atoi(argv[1]); b = atoi(argv[2]); &#125; printf(&quot;a = %d, b = %d\\n&quot;, a, b); printf(&quot;a + b = %d \\n&quot;, a + b); for(int i = 0; i &lt; a; i++) &#123; printf(&quot;i = %d\\n&quot;, i); int res = test(i); printf(&quot;res value : %d \\n&quot;, res); &#125; printf(&quot;THE END !!! \\n&quot;); return 0;&#125; vim 下 set nu gcc test1.c -o test1 -g 加上调试信息 &#x2F;&#x2F; 源代码文件要要和可执行程序在一起否则 gdb 中命令不可使用 gcc test1.c -o test2 不加调试信息 可以 ll 对比一下两个文件大小 ssh命令 gdb 可执行程序(test1) 进入到gdb模式 GDB调试中设置参数 ：set args 10 20 GDB 获取设置参数 ： show args 可以看上面 点我跳转 调试多个文件1234567gcc main.c a.c b.c -o main -ggdb main&#x2F;&#x2F; 查看其中一个文件&#x2F;&#x2F; 注意不能是一个文件例如 list mian.cl a.c:1 &#x2F;&#x2F; 就会进入 a.c 的第一行 以行号为中心显示orl a.c:函数名 &#x2F;&#x2F; 就会进入 a.c 的第函数为中心显示 GDB命令-断电操作 设置断点 b&#x2F;break 行号 b&#x2F;break 函数名 b&#x2F;break 文件名：行号 b&#x2F;break 文件名: 函数 查看断点 i&#x2F;info b&#x2F;break 删除断点 d&#x2F;del&#x2F;delete 断点编号 设置断点无效 dis&#x2F;disable 断点编号 设置断点生效 ena&#x2F;enable 断电编号 设置条件断点(一般在循环的位置) b&#x2F;break 10 if i &#x3D;&#x3D; 5 断点设置 断点编号：Num 下面数字(断电编号) 设置断点无效 End &#x3D; n 正常是 y 想要断点再次生效 设置断点生效 (命令)end&#x2F;enable 断电编号 GDB命令-调试命令 运行GDB程序 start (程序停在第一行) run (遇到断点才停) 继续运行，到下一个断点停 c&#x2F;continue 向下执行一行代码 (不会进入函数体) n&#x2F;next 变量操作 p&#x2F;print 变量名 (打印变量值) ptype 变量名 (打印变量类型) 向下单步调试 (遇到函数进入函数体) s&#x2F;step finish (跳出函数体) 自动变量操作 display num (自动打印指定变量的值) i&#x2F;info display undisplay 编号 其他操作 set var 变量名 &#x3D; 变量值 until (跳出循环)","categories":[{"name":"LInux-系统编程入门","slug":"LInux-系统编程入门","permalink":"https://tutouwang.vercel.app/categories/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"LInux","slug":"LInux","permalink":"https://tutouwang.vercel.app/tags/LInux/"}]},{"title":"Makefile","slug":"LInux-系统编程入门/Makefile","date":"2022-03-04T10:24:52.000Z","updated":"2022-04-01T13:30:29.028Z","comments":true,"path":"2022/03/04/LInux-系统编程入门/Makefile/","link":"","permalink":"https://tutouwang.vercel.app/2022/03/04/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/Makefile/","excerpt":"","text":"什么是Makefile 一个工程中的源文件不计其数．其按类型、功能、模块分别放在若干个目录中，Makefile文件定义了一系列的规则来指定哪些文件要生编扁i译.哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 Makefile文件就像一个Shell 脚本一样,也可以执行操作系统的命 Makefile带来的好处就是“自动化编译”，一旦写好只需要一个make命令，整个工程完全自动编译．极大的提高了软件开发的效率。make 是一个命令工具，是一个解释Makefile文件中指令的命令工具，一般来说，大多数的IDE都有这个命令.比如Delphi 的 make，Visual C++的nmake,Linux 下GNU的make。 Makefile文件命名和规则 文件命名 makefile 或者 Makefile Makefile 规则 一个Makefile文件中可以有一个或者多个规则 目标 …:依赖 … (… 表示多个依赖) ​ (Tab)命令(Shell 命令) ​ … 目标 : 最终要生成的文件(伪目标除外) 依赖 ：生成目标所需要的文件或者是目标 命令 ：通过执行命令对依赖操作生成目标(命令前必须 Tab 缩进) make安装sudo apt install make make 使用 - 第一版 Makefile12app:sub.c add.c mult.c div.c main.c gcc sub.c mult.c div.c main.c -o app sub.c 1234567#include &lt;stdio.h&gt;#include &quot;head.h&quot;int subtract(int a, int b)&#123; return a-b;&#125; mult.c 1234567#include &lt;stdio.h&gt;#include &quot;head.h&quot;int multiply(int a, int b)&#123; return a*b;&#125; div.c 1234567#include &lt;stdio.h&gt;#include &quot;head.h&quot;double divide(int a, int b)&#123; return (double)a/b;&#125; main.c 1234567891011121314#include &lt;stdio.h&gt;#include &quot;head.h&quot;int main()&#123; int a = 20; int b = 12; printf(&quot;a = %d, b = %d\\n&quot;, a, b); printf(&quot;a + b = %d\\n&quot;, add(a, b)); printf(&quot;a - b = %d\\n&quot;, subtract(a, b)); printf(&quot;a * b = %d\\n&quot;, multiply(a, b)); printf(&quot;a / b = %f\\n&quot;, divide(a, b)); return 0;&#125; head.h 1234567891011#ifndef _HEAD_H#define _HEAD_H// 加法int add(int a, int b);// 减法int subtract(int a, int b);// 乘法int multiply(int a, int b);// 除法double divide(int a, int b);#endif 工作原理 命令在执行前，需要检查规则中的依赖是否u才能在 如果存在，执行命令 如果不存在，向下检查其它命令规则，检查有没有一个规则用来生成这个依赖的，如果找到则执行该规则中的命令 检测更新，在执行规则的命令时，会比较目标和依赖的文件的时间(直接输入 make) 如果依赖的时间比目标时间晚，需要重新生成目标 如果依赖的时间比目标时间早，目标不需要更新，对应规则中的命令不需要执行 第二版 Makefile123456789101112app:sub.o add.o mult.o div.o main.o gcc sub.o mult.o div.o main.o -o appusb.o:sub.c gcc -c sub.c -o sub.oadd.o:add.c gcc -c add.c -o add.omult.o:mult.c gcc -c mult.c -o mult.odiv.o:div.c gcc -c div.c -o div.omain.o:main.c gcc -c main.c -o main.o 变量 自定义变量 变量名 &#x3D; 变量值 var &#x3D; hello $(var) 预定义变量 AR : 归档维护程序的名称，默认值 ar CC ： C 编译器的名称，默认值为 cc CXX : C++ 编译器的名称。默认值为 g++ $@ : 目标的完整名称 $&lt; : 第一个依赖文件名称 $^ : 所有依赖文件 获取变量的值 $(变量名) 1234app:main.c a.c b.c gcc -c main.c a.c b.c#自动变量只能在规则的命令中使用 目标就是(app) $(cc) -c $^ -o $@ 第三版 Makefile1234567891011121314151617# 定义变量src = sub.o add.o mult.o div.o main.otarget = app$(target):$(src) $(CC) $(src) -o $(target)sub.o:sub.c gcc -c sub.c -o sub.oadd.o:add.c gcc -c add.c -o add.omult.o:mult.c gcc -c mult.c -o mult.odiv.o:div.c gcc -c div.c -o div.omain.o:main.c gcc -c main.c -o main.o 模式匹配12345678# %.o:%.c# - %:通配符，匹配一个字符# - 两个%匹配的是同一个字符串# %.o:%.c# gcc -c %&lt; -o $@sub.o:sub.c gcc -c sub.c -o sub.o %&lt;啥意思请点我 第四版 Makefile12345678# 定义变量src = sub.o add.o mult.o div.o main.otarget = app$(target):$(src) $(CC) $(src) -o $(target)%.o:%.c $(CC) -c $&lt; -o $@ 函数 $(wildcard PATTERN…) 功能:获取指定目录下指定类型的文件列表 参数：PATTERN指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔 返回：得到的若干个文件的文件列表，文件之间使用空格间隔 示例 $(wildcard *.c ./sub/*.c)(第一个*.获取当前目录下的所有.c文件 第二个是.&#x2F;sub 下的所有文件 多个目录可以用空格隔开) 返回值格式：a.c b.c c.c d.c f.c $(patsubst &lt;pattern&gt;, &lt;replacement&gt;, &lt;text&gt;) 功能：查找&lt;text&gt;中的单词（单词以”空格”、”Tab”或”回车””换行”分割）是否符合模式&lt;pattern&gt;,如果匹配的话，则可以&lt;replacemnt&gt;替换。 &lt;sattern&gt;可以包括通配符$,表示任意长度的字串。如果&lt;replacement&gt;中包含$,那么，&lt;replacemnt&gt;中的这个$将是&lt;pattern&gt;中的那个$所代表的字串。(可以用’\\‘来转义，以’\\%’来表示真实含义的’%’字符) 返回：函数返回被替换过的字符串 示例： $(patsubst %.c, %.o, x.c bar.c) 返回值格式：x.o bar.o 第五版 Makefile12345678910# 定义变量src = $(wildcard ./*.c)objs = $(patsubst %.c, %.o, $(src))target = app$(target):$(objs) $(CC) $(objs) -o $(target)%.o:%.c $(CC) -c $&lt; -o $@ 第五版 Makefile12345678910# 定义变量src = $(wildcard ./*.c)objs = $(patsubst %.c, %.o, $(src))target = app$(target):$(objs) $(CC) $(objs) -o $(target)%.o:%.c $(CC) -c $&lt; -o $@ 第六版 Makefile12345678910111213141516# 定义变量# 可以单独直行一段 make cleansrc = $(wildcard ./*.c)objs = $(patsubst %.c, %.o, $(src))target = app$(target):$(objs) $(CC) $(objs) -o $(target)%.o:%.c $(CC) -c $&lt; -o $@ # 因为clean没有依赖可以设置一个尾目标.PHONY:clean clean: rm $(objs) -f","categories":[{"name":"LInux-系统编程入门","slug":"LInux-系统编程入门","permalink":"https://tutouwang.vercel.app/categories/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"LInux","slug":"LInux","permalink":"https://tutouwang.vercel.app/tags/LInux/"}]},{"title":"sscanf/spintf妙用","slug":"有趣的知识/sscanf-spintf妙用","date":"2022-02-25T02:12:40.000Z","updated":"2022-04-03T10:26:52.077Z","comments":true,"path":"2022/02/25/有趣的知识/sscanf-spintf妙用/","link":"","permalink":"https://tutouwang.vercel.app/2022/02/25/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/sscanf-spintf%E5%A6%99%E7%94%A8/","excerpt":"","text":"leetcode-力扣(537)123456789int a1,b1,a2,b2;sscanf(num1,&quot;%d+%di&quot;,&amp;a1,&amp;b1); sscanf(num2,&quot;%d+%di&quot;,&amp;a2,&amp;b2);string s;sscanf(s.c_str(), &quot;%d:%d&quot;, ); //读取实部和虚部 char* ans=(char*)malloc(sizeof(char)*13); sprintf(ans,&quot;%d+%di&quot;,a1*a2-b1*b2,a1*b2+a2*b1);","categories":[{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"gcc/g++区别与流程","slug":"LInux-系统编程入门/gcc-g-区别与流程","date":"2022-02-20T12:50:35.000Z","updated":"2022-05-22T15:05:06.445Z","comments":true,"path":"2022/02/20/LInux-系统编程入门/gcc-g-区别与流程/","link":"","permalink":"https://tutouwang.vercel.app/2022/02/20/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/gcc-g-%E5%8C%BA%E5%88%AB%E4%B8%8E%E6%B5%81%E7%A8%8B/","excerpt":"","text":"gcc&#x2F;G++gcc工作流程源代码(.h, .c, .cpp) - &gt; 预处理器 - &gt; 预处理后源代码 (.i) - &gt; 编译器 - &gt; 汇编代码（.s) - &gt; 汇编器 - &gt; 目标代码（.o) 处理指令 gcc&#x2F;g++的区别 -D 宏的名字","categories":[{"name":"LInux-系统编程入门","slug":"LInux-系统编程入门","permalink":"https://tutouwang.vercel.app/categories/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"LInux","slug":"LInux","permalink":"https://tutouwang.vercel.app/tags/LInux/"}]},{"title":"二维矩阵映射成一维","slug":"有趣的知识/二维矩阵映射成一维","date":"2022-02-16T06:56:35.000Z","updated":"2022-05-23T14:24:24.358Z","comments":true,"path":"2022/02/16/有趣的知识/二维矩阵映射成一维/","link":"","permalink":"https://tutouwang.vercel.app/2022/02/16/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E6%98%A0%E5%B0%84%E6%88%90%E4%B8%80%E7%BB%B4/","excerpt":"","text":"二维数组映射成一维 - (0，0)开始 设一维数组下标为index,二维长度为$n*m$则 一维数组转为二维数组 12row = index / m // 行col = index % m // 列 二维数组转换为一维数组 1index = row * m + col","categories":[{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"并查集 — 1","slug":"基础数据结构/并查集_1","date":"2022-01-23T08:21:07.000Z","updated":"2022-05-22T15:05:06.443Z","comments":true,"path":"2022/01/23/基础数据结构/并查集_1/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/23/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86_1/","excerpt":"","text":"并查集连通性问题： 基于染色的思想，一开始所有点的颜色不同 连接两个点的操作，可以看成将一种颜色的点染成另一种颜色 如果两个点颜色一样，证明联通，否则不联通 这种方法叫做并查集的:【Quick-Find算法】 Quick-Find 近似$ O(1) $查询 Quick-Find 默认的做法吧前一个数字的颜色改成后一个颜色(大白话：就是让4接到3后面，让3作为根节点) 这里要说明一下 ： 无论以 4 还是以 3 作为根节点都是可以的这个不重要 - 节点的链接其实是两个集合的链接 4 和 8 链接是直接吧4接到8下面么？(其实不对) 相当于 4 和 3已经属于一个集合那么你要改4当然3也要改变所以3和4的下标都要改成8 Quick-Find 时间复杂度分析 联通判断：近似$O(1)$ 合并操作：$O(n)$ Quick-Union Quick-Unionu算法是选先找根节点判断是否处在同一根节点猜能在合并 Quick-Union 总结问题思考：(需要自己手动模拟一下) 如果不看上述 Quick-Union 正常合并情况在极端情况下会退化成一条链 - 这就是一个$O(n)$操作 将节点数量多的接到少的树上面，导致了退化 将树高深度的接到浅的上面，导致退化 问题思考：若要改进，是按照节点数量还是节点高度合并？ 可以得到： 树高合并到树矮的上面(树高不变) 如果一棵树很矮但是包含了很多节点和一颗高树有较少节点在这种情况下就需要节点数量为合并条件 谁的节点数量多就往那个树上合并 平均查找次数每个节点深度相加之和除总节点数量 按秩合并下图 但是要把0接到3下面就路径压缩 + 按秩合并了就开头所看到的样子 并查集四种算法 代码见 并查集2","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"并查集 — 2","slug":"基础数据结构/并查集_2","date":"2022-01-23T08:21:07.000Z","updated":"2022-05-22T15:05:06.441Z","comments":true,"path":"2022/01/23/基础数据结构/并查集_2/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/23/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86_2/","excerpt":"","text":"[TOC] 并查集(Union Find)并查集主要讲的就是连通性问题 比如说现在咱们这个教学楼，被大水淹了比如说一楼和其它楼层都被大水淹了，就唯独咱们教室没有，可以说明什么，咱们现在就是与世隔绝了，之后呢就被大水淹没的个个楼层水是不是都可以来回走，比如流到了咱们教室恰巧关上了们，之后水就没流进来，说明什么咱们现在是与这个教学楼的一间教室都不连图，如果说咱们与隔壁是连通的，而且咱们隔壁还被大水淹没了，你说咱们这屋是不是也被淹没了。 若某个家族人员过于庞大，要判断两个是否是亲戚，确实不容易，给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。 树形结构在春秋战国时期有各种思想学术流派的成就，有 孔子 墨子 老子 还有谁比如 韩非子等等 从我们当前图中我门可以看出我们有几个连同块 有3个对把 比如说有一天 2 号 跟 4号 打起来来了说你写的东西不如我，（这里有个规定就是说徒弟一定不如师傅）完了4号本身就是1号的徒弟肯定不如2号 当然 4号有师傅 之后4号找到自己的师傅 1 号 说今天我被人羞辱了对吧那当师傅的肯定不能做事不管对吧 之后一看 说这2号也老孔的徒弟一看这不是就是一个师傅么那就别报仇了 让 4 号 给 2 号认个错 就是下次的时候我们可以怎么看 就是先知道自己的师傅的师傅是谁对吧 在看你要找的人的师傅的师傅（这师傅可能还有师傅所有要找到最后一个师傅）是谁 如果他们最后的师傅都是同一个人那他们是不是就是一家人属于同一个师傅 （可以说明他们在通一课树中说明它们俩个连同） 其实我们在连同性中不在乎连接成什么样子谁是谁的徒弟我只在乎他们能不能连同最后的祖师，祖师爷是不是同一个人 这个两个点能不能连同 Ps 比如 （1， 2） 为一个集合 数组表示 （1，4） （4，7） 这里代表两个集合链接，这里链接的时候你说是 1 当作根节点还是 4 当作根节点 1 其实是无所谓的。这里假定 4为根节点我们可以得到 图 这两个点的连同不仅仅是两个点的连同而是两个集合的连通（其实他们都属一个个体） 比如你的爸和你妈是两个姓对吧 他们在没结婚之前是什么，两个家的人就可以比作什么两个集合，之后他们结婚了 是只有他俩是一家人么 不是吧 是两家人，这就好比我们两个点的链接。 我们可以用数组表示 初始化把每个点所在的集合初始化为其自身。 初始化加粗 为下标 我们可以用用它自身去初始化（也可以用 -1 但是后期在优化的时候会有点麻烦） 0 1 2 3 0 1 2 3 4 5 6 7 4 5 6 7 0 1 2 3 0 4 2 3 4 5 6 7 4 5 6 4 竞赛阶段我们会用到的算法 find union123456789101112131415161718// 朴素int find_root(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;// 查找--优化int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x]; // return x == parent[x] ? x : parent[x] = find_root(parent[x], parent); // return parent[x] = (x == parent[x] ? x : find_root(parent[x], parent));&#125; 123456789101112131415161718192021// 合并void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; // parent[x_root] = y_root; // 原先代码 // 安秩合并 if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; return ; &#125; mark = 1; return ;&#125; 路径压缩–按秩合并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int mark = 0;// 初始化void inital(int n, int parent[], int height[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; height[i] = 0; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x]; // &#125;// 路径压缩--非递归版int find_root1(int x, int parent[]) &#123; int k = x; while (parent[k] != k) &#123; k = parent[k]; &#125; while (x != k) &#123; int temp = parent[x]; parent[x] = k; x = temp; &#125; return k;&#125;void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; // parent[x_root] = y_root; // 原先代码 // 按秩合并 if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; return ; &#125; mark = 1; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10], height[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; inital(m, parent, height); for (int i = 0; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(x, y, parent, height); &#125; if (mark) cout &lt;&lt; &quot;有环！&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;无环！&quot; &lt;&lt; endl; return 0;&#125; 路径压缩是怎么实现的 检测是否存在环我们如何去检测一个图是否存在环环路 如下 我们有 0️⃣ 1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 把每个点看成单个集合比如我们相连（0 ，1） （1，2） （1，3）（2，4）（2，3） 我们在合并时候需要先查询一下他们是否属于同一集合，如果不属于同一集合我才能合并，反之要是它们在合并就会构成回路。 如果不考虑链接红色两点，合并集合之后是{0，1，2，3，4} 我们可以得到站在任意点到达另一任意点。不构成环 如果说我们在已连接中任意选择两个去链接他一定会成环对吧。🔶 比如红色两点链接，我们可以看到 1， 2， 3 点形成了环。 形成环路 我们怎么知道他是成环了呢我们把 1 当做根结点 ，0， 2，4，3 都属于 1 的孩子或者是孙子 当你去链接 （2， 3）时候你会发现他们都属于 1 下就如我们刚才所说 🔶因为我们知道两个集合在合并的时候一定会先去找根节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int mark = 0;int parent[MAX_N + 10];// 初始化void inital(int n, int parent[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; &#125; return ;&#125;int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;void merge(int x, int y, int parent[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; parent[x_root] = y_root; return ; &#125; mark = 1; return ;&#125;int main() &#123; int n, m; // 组数 最大值 cin &gt;&gt; n &gt;&gt; m; inital(m, parent); for (int i = 0; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(x, y, parent); &#125; if (mark) cout &lt;&lt; &quot;有环！&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;无环！&quot; &lt;&lt; endl; return 0;&#125; 并查集–数据结构实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;struct UnionSet &#123; int *parent;&#125;;// 初始化UnionSet *init(int n) &#123; UnionSet *U = (UnionSet *)malloc(sizeof(UnionSet)); U-&gt;parent = (int *)malloc(sizeof(int) * (n + 1)); for (int i = 1; i &lt;= n; i++) &#123; U-&gt;parent[i] = i; &#125; return U;&#125;int find_root(UnionSet *U, int x) &#123; if (U-&gt;parent[x] != x) &#123; return find_root(U, U-&gt;parent[x]); &#125; return x;&#125;void merge(UnionSet *U, int x, int y) &#123; int x_root = find_root(U, x); int y_root = find_root(U, y); if (x_root != y_root) &#123; U-&gt;parent[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); UnionSet *U = init(n); // 进行 M 次操作 for (int i = 1; i &lt;= m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); switch(a) &#123; case 1: merge(U, b, c); break; // 合并操作 case 2: printf(&quot;%s\\n&quot;, find_root(U, b) == find_root(U, c) ? &quot;Yes&quot; : &quot;No&quot;); &#125; &#125; return 0;&#125; 例题–题解海贼 #71 朋友圈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/************************************************************************* &gt; File Name: 海贼_#71并查集_路径压缩优化.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年01月18日 星期一 15时33分00秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e4;// 初始化void initialization(int n, int parent[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;// 朴素算法int find_root1(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;void merge(int x, int y, int parent[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; parent[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; initialization(n, parent); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if (a == 1) &#123; // 添加 merge(b, c, parent); &#125; else &#123; // 查看 if (find_root(b, parent) - find_root(c, parent)) &#123; printf(&quot;No\\n&quot;); &#125; else printf(&quot;Yes\\n&quot;); &#125; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/************************************************************************* &gt; File Name: 海贼_#71并查集_路径压缩_安秩合并_优化.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年01月18日 星期一 21时33分00秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e4;// 初始化 void initialization(int n, int parent[], int height[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; // 开始树高为 0 height[i] = 0; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;// 朴素算法int find_root1(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; &#125; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10], height[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; initialization(n, parent, height); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if (a == 1) &#123; // 添加 merge(b, c, parent, height); &#125; else &#123; // 查看 if (find_root(b, parent) - find_root(c, parent)) &#123; printf(&quot;No\\n&quot;); &#125; else printf(&quot;Yes\\n&quot;); &#125; &#125; return 0;&#125; 洛谷 P1551 亲戚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int arr[MAX_N];void initial(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; arr[i] = i; &#125;&#125;int find(int x) &#123; if (arr[x] != x) &#123; x = find(arr[x]); &#125; return arr[x];&#125;void merge(int x, int y) &#123; int x_root = find(x); int y_root = find(y); if (x_root != y_root) &#123; arr[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; initial(n); while (m--) &#123; int mi, mj; cin &gt;&gt; mi &gt;&gt; mj; merge(mi, mj); &#125; while (p--) &#123; int mi, mj; cin &gt;&gt; mi &gt;&gt; mj; if (find(mi) == find(mj)) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"由数据范围反推算法复杂度以及算法内容","slug":"有趣的知识/由数据范围反推算法复杂度以及算法内容","date":"2022-01-22T07:51:38.000Z","updated":"2022-01-22T07:53:23.211Z","comments":true,"path":"2022/01/22/有趣的知识/由数据范围反推算法复杂度以及算法内容/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/22/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E7%94%B1%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/","excerpt":"","text":"一般ACM或者笔试题的时间限制是1秒或2秒。在这种情况下，C++代码中的操作次数控制在 107∼108107∼108 为最佳。 下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择： n≤30n≤30, 指数级别, dfs+剪枝，状态压缩dp n≤100n≤100 &#x3D;&gt; O(n3)O(n3)，floyd，dp，高斯消元 n≤1000n≤1000 &#x3D;&gt; O(n2)O(n2)，O(n2logn)O(n2logn)，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford n≤10000n≤10000 &#x3D;&gt; O(n∗n√)O(n∗n)，块状链表、分块、莫队 n≤100000n≤100000 &#x3D;&gt; O(nlogn)O(nlogn) &#x3D;&gt; 各种sort，线段树、树状数组、set&#x2F;map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树 n≤1000000n≤1000000 &#x3D;&gt; O(n)O(n), 以及常数较小的 O(nlogn)O(nlogn) 算法 &#x3D;&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O(nlogn)O(nlogn) 的做法：sort、树状数组、heap、dijkstra、spfa n≤10000000n≤10000000 &#x3D;&gt; O(n)O(n)，双指针扫描、kmp、AC自动机、线性筛素数n≤109n≤109 &#x3D;&gt; O(n√)O(n)，判断质数 n≤1018n≤1018 &#x3D;&gt; O(logn)O(logn)，最大公约数，快速幂，数位DP n≤101000n≤101000 &#x3D;&gt; O((logn)2)O((logn)2)，高精度加减乘除 n≤10100000n≤10100000 &#x3D;&gt; O(logk×loglogk)，k表示位数O(logk×loglogk)，k表示位数，高精度加减、FFT&#x2F;NTT 来源：AcWing","categories":[{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"STL-简介","slug":"有趣的知识/STL-简介","date":"2022-01-22T07:49:05.000Z","updated":"2022-01-22T07:53:34.820Z","comments":true,"path":"2022/01/22/有趣的知识/STL-简介/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/22/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/STL-%E7%AE%80%E4%BB%8B/","excerpt":"","text":"C++ STL简介123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()&#x2F;back() push_back()&#x2F;pop_back() begin()&#x2F;end() [] 支持比较运算，按字典序pair&lt;int, int&gt; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序）string，字符串 size()&#x2F;length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素priority_queue, 优先队列，默认是大根堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素deque, 双端队列 size() empty() clear() front()&#x2F;back() push_back()&#x2F;pop_back() push_front()&#x2F;pop_front() begin()&#x2F;end() []set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()&#x2F;end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set&#x2F;multiset insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()&#x2F;upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map&#x2F;multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()&#x2F;upper_bound()unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()&#x2F;upper_bound()， 迭代器的++，--bitset, 圧位 bitset&lt;10000&gt; s; ~, &amp;, |, ^ &gt;&gt;, &lt;&lt; &#x3D;&#x3D;, !&#x3D; [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 来自Acwing","categories":[{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"堆与优先队列","slug":"基础数据结构/堆与优先队列","date":"2022-01-22T04:03:52.000Z","updated":"2022-05-22T15:05:06.444Z","comments":true,"path":"2022/01/22/基础数据结构/堆与优先队列/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/22/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","excerpt":"","text":"回顾 - 二叉树完全二叉树 编号为 i 的字节点 左孩子编号 ：2 * i 右孩子编号 ：2 * i + 1 可以使用连续空间存储 (数组) 堆 大顶堆 在任意一个三元组中 根 大于左孩子和右孩子 12 - 11 - 10 根节点 (极大) 全局最大 小顶堆 在任意一个三元组中 根 小于左孩子和右孩子 3 - 7 - 4 根节点 (极小) 全局最小 堆 - 尾部插入调整 (自下向上)依次和和根比较 13 &gt; 7 交换 13 &gt; 11 交换 13 &gt; 12 交换 堆 - 头部弹出调整 (自上向下)从堆的最后元素直接放到堆顶 之后在在根节点的三元组中比较是是否满足条件 如果不满足最大值和根交换一直操作 12 &gt; 7 交换 11 &gt; 7 交换 时间复杂度分析 插入调整时间复杂度 - 层序遍历 ： $O(log^N)$ 删除调整时间复杂度 $O(log^N)$ 建堆时间复杂度 ： $O(Nlog^N)$ 堆排序 - (大顶堆情况)口诀： 将堆顶元素与堆尾元素交换 将此操作看最做是堆顶元素弹出操作 按照头部弹出以后的策略调整推 如果想要一个从小到大的排序 那么就建立一个大顶堆 如果想要一个从大到小的排序 那么就建立一个小顶堆 堆 - 优先队列 堆代码实现 - (大顶堆举例)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/************************************************************************* &gt; File Name: 堆-优先队列.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月22日 星期六 15时45分42秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;typedef struct priority_queue &#123; int *data; int cnt, size;&#125; priority_queue;priority_queue *init(int n) &#123; priority_queue *q = (priority_queue *)malloc(sizeof(priority_queue)); q-&gt;data = (int *)malloc(sizeof(int) * n + 1); q-&gt;size =n; q-&gt;cnt = 0; return q;&#125;int empty(priority_queue *q) &#123; return q-&gt;cnt == 0;&#125;int top(priority_queue *q) &#123; return q-&gt;data[1];&#125;int push(priority_queue *q, int val) &#123; if(q == NULL) return 0; if(q-&gt;cnt == q-&gt;size) return 0; q-&gt;data[++(q-&gt;cnt)] = val; int ind = q-&gt;cnt; // 大顶堆 while(ind &gt;&gt; 1 &amp;&amp; q-&gt;data[ind] &gt; q-&gt;data[ind &gt;&gt; 1]) &#123; swap(q-&gt;data[ind], q-&gt;data[ind &gt;&gt; 1]); ind &gt;&gt;= 1; &#125; return 1;&#125;int pop(priority_queue *q) &#123; if(q == NULL) return 0; if(empty(q)) return 0; q-&gt;data[1] = q-&gt;data[q-&gt;cnt--]; int ind = 1; // ind &lt;&lt; 1 &lt;= q-&gt;cnt 证明左孩子存在 while((ind &lt;&lt; 1) &lt;= q-&gt;cnt) &#123; int temp = ind, l = ind &lt;&lt; 1, r = ind &lt;&lt; 1 | 1; if(q-&gt;data[l] &gt; q-&gt;data[temp]) temp = l; // r &lt;= q-&gt;cnt 证明右孩子存在 if(r &lt;= q-&gt;cnt &amp;&amp; q-&gt;data[r] &gt; q-&gt;data[temp]) temp = r; if(ind == temp) break; swap(q-&gt;data[ind], q-&gt;data[temp]); ind = temp; &#125; return 1;&#125;void clear(priority_queue * q) &#123; if(q == NULL) return ; free(q-&gt;data); free(q); return ;&#125;int main() &#123; srand(time(0)); #define MAX_OP 20 priority_queue *q = init(MAX_OP); for(int i = 0; i &lt; MAX_OP; i++) &#123; int val = rand() % 100; push(q, val); printf(&quot;insert %d to the priority_queue!\\n&quot;, val); &#125; for(int i = 0; i &lt; MAX_OP; i++) &#123; printf(&quot;%d &quot;, top(q)); pop(q); &#125; printf(&quot;\\n&quot;); return 0;&#125; 线性建堆法 - (自上向下) 向上调整次数分析 在第 1 层时候(0表示向上调整0次) $0 * 2^0$ ($2^0$代表第一层有多少个节点) 第三次层每个节点最多向上调整2次 $0 * 2^1 + 1 * 2^1 + 2 * 2^2 + 3 + 2^3 + … + (n - 1) * 2^{n-1}$ 0次 1个节点 1次 2个节点 … n - 1次 $2^{n-1}$节点 $0 * 2^{n - 1} + 1 * 2^{n - 2}$ 堆排序 - 代码实现(线性建堆法)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/************************************************************************* &gt; File Name: 堆-排序.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月22日 星期六 19时34分46秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;void downUpdate(int *arr, int n, int ind) &#123; while((ind &lt;&lt; 1) &lt;= n) &#123; int temp = ind, l = ind &lt;&lt; 1, r = (ind &lt;&lt; 1) + 1; // if(arr[l] &gt; arr[temp]) temp = l; if(arr[l] &lt; arr[temp]) temp = l; // if(r &lt;= n &amp;&amp; arr[r] &gt; arr[temp]) temp = r; if(r &lt;= n &amp;&amp; arr[r] &lt; arr[temp]) temp = r; if(ind == temp) break; swap(arr[ind], arr[temp]); ind = temp; &#125; return ;&#125;void heap_Sort(int *arr, int n) &#123; arr -= 1; for(int i = n &gt;&gt; 1; i &gt;= 1; i--) &#123; downUpdate(arr, n, i); &#125; for(int i = n; i &gt; 1; i--) &#123; swap(arr[i], arr[1]); downUpdate(arr, i - 1, 1); &#125; return ;&#125;void output(int *arr, int n) &#123; for(int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, arr[i]); &#125; printf(&quot;\\n&quot;);&#125;int main() &#123; srand(time(0)); #define MAX_N 20 int *arr = (int *)malloc(sizeof(int) * MAX_N); for(int i = 0; i &lt; MAX_N; i++) &#123; arr[i] = rand() % 100; &#125; output(arr, MAX_N); printf(&quot;\\n&quot;); heap_Sort(arr, MAX_N); output(arr, MAX_N); free(arr); #undef MAX_N return 0;&#125; 时间复杂度分析 $O(log^N)$","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"哈希表","slug":"基础数据结构/哈希表","date":"2022-01-20T13:51:03.000Z","updated":"2022-01-21T10:20:16.993Z","comments":true,"path":"2022/01/20/基础数据结构/哈希表/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/20/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/","excerpt":"","text":"哈希表 通过数组下标索引到值 任意类型映射成一个整型 (下标) 简单举例 val % size 假如 val &#x3D; 16、size &#x3D; 9 16 % 9 &#x3D; 7 (下标) 假如 val &#x3D; 7、size &#x3D; 9 7 % 9 &#x3D; 7 (下标) 产生冲突了 - 优秀的哈希都会冲突 下标 0 1 2 3 4 5 6 7 8 16 解决哈希冲突的 四 种 方法 开放定值法 拉链法 在哈希法 (在散列法) 建立公共溢出区 解决哈希冲突方法 - 开放定值法可以使用开放定值法 (二次探测法) - 不好用会堆聚 下标7后面8是空着的所以7可以存放到此处 下标 0 1 2 3 4 5 6 7 8 16 7 解决哈希冲突方法 - 拉链法顾名思义拉链法就是以下标为7的位置做成一个链表 下标 0 1 2 3 4 5 6 7 8 16 7 解决哈希冲突方法 - 在哈希法 (在散列法)如果第一个哈希函数冲突了，那么就可以利用第二个哈希函数在去做映射，如果在冲突了那么就利用第三个哈希函数在做。。。(禁止套娃)🤐 解决哈希冲突方法 - 建立公共溢出区将冲突的元素集中去管理 时间复杂度 平均复杂度 ： $O(1)$ 字符串-哈希123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/************************************************************************* &gt; File Name: 哈希.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月21日 星期五 16时28分39秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct Node &#123; char *str; struct Node *next;&#125; Node;typedef struct HashTable &#123; Node **data; int size;&#125; HashTable;Node *init_node(char *str, Node *head) &#123; Node *p =(Node *)malloc(sizeof(Node)); // 深拷贝 p-&gt;str = strdup(str); p-&gt;next = head; return p;&#125;HashTable *init_hash(int n) &#123; HashTable *h = (HashTable *)malloc(sizeof(HashTable)); // 利用率 h-&gt;size = (n &lt;&lt; 1); h-&gt;data = (Node **)calloc(h-&gt;size, sizeof(Node *)); return h;&#125;int BKDRHash(char *str) &#123; // seed 可以是任意一质数 int seed = 31, hash = 0; for(int i = 0; str[i]; i++) hash = hash * seed + str[i]; // 确保 head 是一个正数 return hash &amp; 0x7fffffff;&#125;int insert(HashTable *h, char *str) &#123; if(h == NULL) return 0; int hash = BKDRHash(str); int ind = hash % h-&gt;size; h-&gt;data[ind] = init_node(str, h-&gt;data[ind]); return 1;&#125;int search(HashTable *h, char *str) &#123; if(h == NULL) return 0; int hash = BKDRHash(str); int ind = hash % h-&gt;size; Node *p = h-&gt;data[ind]; while(p &amp;&amp; strcmp(p-&gt;str, str)) p = p-&gt;next; return p != NULL;&#125;void clear_node(Node *node) &#123; if(node == NULL) return ; Node *p = node, *t; while(p) &#123; t = p-&gt;next; free(p-&gt;str); free(p); p = t; &#125; return ;&#125;void clear(HashTable *h) &#123; if(h == NULL) return ; for(int i = 0; i &lt; h-&gt;size; i++) &#123; clear_node(h-&gt;data[i]); &#125; free(h); return ;&#125;int main() &#123; #define MAX_N 100 int op; char str[MAX_N + 5] = &#123;0&#125;; HashTable *h = init_hash(MAX_N); while(~scanf(&quot;%d%s&quot;, &amp;op, str)) &#123; switch(op) &#123; case 0 : &#123; printf(&quot;insert %s to HashTable\\n&quot;, str); insert(h, str); &#125; break; case 1 : &#123; printf(&quot;search %s from HashTable result = %d\\n&quot;, str, search(h, str)); &#125;break; &#125; &#125; #undef MAX_N clear(h); return 0;&#125;","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"二分查找与三分查找","slug":"基础数据结构/二分查找与三分查找","date":"2022-01-20T07:51:45.000Z","updated":"2022-05-22T15:05:06.444Z","comments":true,"path":"2022/01/20/基础数据结构/二分查找与三分查找/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/20/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%B8%89%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"二分查找 (折半查找)条件 单调性 - (一般单调递减) 特殊情况 - 1 查找第最后出现的 1 如果待查值不存在的情况可以设置一个虚拟头 特殊情况 - 2 查找第一个 1 如果待查值不存在的情况可以设置一个虚拟尾 时间复杂度 平均复杂度 ： $O(log^N)$ 三分查找","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"排序合集 5 种 - 插入、冒泡、归并、选择、快排","slug":"基础数据结构/排序合集","date":"2022-01-19T02:32:08.000Z","updated":"2022-05-22T15:05:06.438Z","comments":true,"path":"2022/01/19/基础数据结构/排序合集/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/19/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/","excerpt":"","text":"排序算法分类 稳定 ：( 插入、冒泡、归并) 非稳定 (不稳定) ：(选择、快排) 内部 ：(整体一次性的加入到内存当中,整体的去排序) 外部 ： (对一个数据文件排序的话可以不将整个文件都加载到内存里面进行排序 - 归并！ ) 插入排序 (insert_Sort)口诀 : 将数组分成【已排序区】 和 【待排序区】 将【待排序区】第一个元素，向前插入到【已排序区】 直到【待排序区】没有元素为止 时间复杂度分析 最好 ：0 次 最坏 ：n - 1 次 平均复杂度 ：( 最好 + 最坏 ) &#x2F; 2 : $\\frac{(n - 1)}{2} * N$ : $O(N^2)$ 代码实现 - 模块123456789// 插入排序void insert_Sort(int *num, int n) &#123; for(int i = 1; i &lt; n; i++) &#123; for(int j = i; j &gt; 0 &amp;&amp; num[j] &lt; num[j - 1]; j--) &#123; swap(num[j], num[j - 1]); &#125; &#125; return ;&#125; 冒泡排序 (bubble_Sort)口诀 : 将数组分成【已排序区】 和 【待排序区】 从头到尾扫描【待排序区】，若前面元素比后面元素大，则交换 每一轮都会将【待排序区】中最大的放到【已排序区】的开头 直到【待排序区】没有元素为止 小优化 ： 如果一轮中一次交换都没有就证明序列已经有序可以提前结束 时间复杂度 平均复杂度 ： $O(N^2)$ 代码实现 - 模块12345678910111213// 冒泡排序void bubble_Sort(int *num, int n) &#123; int falg = 1; for(int i = 1; i &lt; n &amp;&amp; falg; i++) &#123; falg = 0; for(int j = 0; j &lt; n - i; j++) &#123; if(num[j] &lt;= num[j + 1]) continue; swap(num[j], num[j + 1]); falg++; &#125; &#125; return ;&#125; 归并排序 - 二路归并 (merge_Sort)核心思想分治 将【待排序数组】分为两个部分 如 ： 9 7 8 5 4 1 2 3 6 5 分为 : 9 7 8 5 4 — 1 2 3 6 5 再分：9 7 — 8 5 4 — 1 2 — 365 达到足够小并且立马能拿到答案的规模 上一层 ： 【 — 我是空数组 — 】 可以得到 7 9 — 4 5 8 — 1 2 — 3 5 6 组内有序组间无序 一个指向👆 ____👆 合并成一个有序数组 - 在拷贝到原数组 他们两个比较谁小就插入到上面数组 时间复杂度 平均复杂度 ： $O(Nlog^N)$ 代码实现 - 模块12345678910111213141516171819202122232425// 归并排序void merge_Sort(int *num, int l, int r) &#123; if(r - l &lt;= 1) &#123; if(r - l == 1 &amp;&amp; num[r] &lt; num[l]) &#123; swap(num[r], num[l]); &#125; return ; &#125; int mid = (r + l) &gt;&gt; 1; merge_Sort(num, l, mid); merge_Sort(num, mid + 1, r); int *temp = (int *)malloc(sizeof(int) * (r - l + 1)); int p1 = l, p2 = mid + 1, cnt = 0; while(p1 &lt;= mid || p2 &lt;= r) &#123; if(p2 &gt; r || (p1 &lt;= mid &amp;&amp; num[p1] &lt;= num[p2])) &#123; temp[cnt++] = num[p1++]; &#125; else &#123; temp[cnt++] = num[p2++]; &#125; &#125; memcpy(num + l, temp, sizeof(int) * (r - l + 1)); free(temp); return ;&#125; 稳定排序代码合集 - 插入、冒泡、归并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/************************************************************************* &gt; File Name: 稳定排序合集-插入、冒泡、归并.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月19日 星期三 17时02分43秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;// typeof(a) 相当于获取 a 的类型 在定义一个变量 __temp#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b, b = __temp;\\&#125;#define TEST(arr, n, func, args...) &#123;\\ int *num = (int *)malloc(sizeof(int) * n);\\ memcpy(num, arr, sizeof(int) * n);\\ output(num, n);\\ printf(&quot;%s = &quot;, #func);\\ func(args);\\ output(num, n);\\ free(num);\\ printf(&quot;\\n&quot;);\\&#125;// 插入排序void insert_Sort(int *num, int n) &#123; for(int i = 1; i &lt; n; i++) &#123; for(int j = i; j &gt; 0 &amp;&amp; num[j] &lt; num[j - 1]; j--) &#123; swap(num[j], num[j - 1]); &#125; &#125; return ;&#125;// 冒泡排序void bubble_Sort(int *num, int n) &#123; int falg = 1; for(int i = 1; i &lt; n &amp;&amp; falg; i++) &#123; falg = 0; for(int j = 0; j &lt; n - i; j++) &#123; if(num[j] &lt;= num[j + 1]) continue; swap(num[j], num[j + 1]); falg++; &#125; &#125; return ;&#125;// 归并排序void merge_Sort(int *num, int l, int r) &#123; if(r - l &lt;= 1) &#123; if(r - l == 1 &amp;&amp; num[r] &lt; num[l]) &#123; swap(num[r], num[l]); &#125; return ; &#125; int mid = (r + l) &gt;&gt; 1; merge_Sort(num, l, mid); merge_Sort(num, mid + 1, r); int *temp = (int *)malloc(sizeof(int) * (r - l + 1)); int p1 = l, p2 = mid + 1, cnt = 0; while(p1 &lt;= mid || p2 &lt;= r) &#123; if(p2 &gt; r || (p1 &lt;= mid &amp;&amp; num[p1] &lt;= num[p2])) &#123; temp[cnt++] = num[p1++]; &#125; else &#123; temp[cnt++] = num[p2++]; &#125; &#125; memcpy(num + l, temp, sizeof(int) * (r - l + 1)); free(temp); return ;&#125;void randint(int *arr, int n) &#123; while(n--) arr[n] = rand() % 100; return ;&#125;void output(int *arr, int n) &#123; for(int i = 0; i &lt; n; i++) &#123; i &amp;&amp; printf(&quot;, &quot;); printf(&quot;%d&quot;, arr[i]); &#125; printf(&quot;\\n&quot;);&#125;int main() &#123; srand(time(0)); #define MAX_N 20 int arr[MAX_N]; randint(arr, MAX_N); TEST(arr, MAX_N, insert_Sort, num, MAX_N); TEST(arr, MAX_N, bubble_Sort, num, MAX_N); TEST(arr, MAX_N, merge_Sort, num, 0, MAX_N - 1); #undef MAX_N return 0;&#125; 分界线👇不稳定了 选择排序 (select_Sort)口诀 : 将数组分成【已排序区】 和 【待排序区】 每一轮从【待排序区】中选择一个最小的元素方到【已排序区】的尾部 直到【待排序区】没有元素为止 时间复杂度 平均复杂度 ： $O(N^2)$ 代码实现 - 模块1234567891011// 选择排序void select_Sort(int *num, int n) &#123; for(int i = 0; i &lt; n - 1; i++) &#123; int ind = i; for(int j = i + 1; j &lt; n; j++) &#123; if(num[ind] &gt; num[j]) ind = j; &#125; swap(num[i], num[ind]); &#125; return ;&#125; 快速排序 (quick_Sort)口诀 : 选择基准数 ： 一般选择序列的第一个数 (基准值) 进行（partition）操作：作用就是使得待排序的序列分为了两部分 前部分都小于基准值 — 后面一部分都大于基准值 (一轮partition 操作) head &#x3D; 第一个数(基准值) tail &#x3D; 最后一个元素 tail 操作 从后往前找第一个小于基准值的数 - 找到之后填到头指针的位置 head 操作 从前往后找到找到一个大于基准值的数 - 找到之后填到尾针的位置 时间复杂度 平均复杂度 ： $O(Nlog^N)$ 完全逆序 ： $ O(N^2)$ - (就变成了选择排序) 代码实现 - 模块 - 未优化 - 填坑法1234567891011121314151617// 快排 — 第一版void quick_Sort(int *num, int l, int r) &#123; if(l &gt; r) return ; int x = l, y = r, z = num[l]; while(x &lt; y) &#123; // 先从后往前扫因为第一个位置是空着可以覆盖掉 while(x &lt; y &amp;&amp; num[y] &gt; z) y--; if(x &lt; y) num[x++] = num[y]; while(x &lt; y &amp;&amp; num[x] &lt; z) x++; if(x &lt; y) num[y--] = num[x]; &#125; // 头尾指针重合 num[x] = z; quick_Sort(num, l, x - 1); quick_Sort(num, x + 1, r); return ;&#125; 代码实现 - 模块 - 优化 - 基准值两点取中法、无监督优化(去掉x &lt; y)、单边递归法123456789101112131415161718// 快排 — 第二版 基准值两点取中法、无监督优化(去掉x &lt; y)、单 边递归法void quick_Sort1(int *num, int l, int r) &#123; while(l &lt; r) &#123; int x = l, y = r, z = num[(l + r) &gt;&gt; 1]; do &#123; while(num[x] &lt; z) x++; while(num[y] &gt; z) y--; if(x &lt;= y) &#123; swap(num[x], num[y]); x++, y--; &#125; &#125; while(x &lt;= y); quick_Sort1(num, l, y); l = x; &#125; return ;&#125; 不稳定排序代码合集 - 选择、快速、快速优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/************************************************************************* [0] &gt; File Name: 稳定排序合集-插入、冒泡、归并.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月19日 星期三 17时02分43秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;// typeof(a) 相当于获取 a 的类型 在定义一个变量 __temp#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b, b = __temp;\\&#125;#define TEST(arr, n, func, args...) &#123;\\ int *num = (int *)malloc(sizeof(int) * n);\\ memcpy(num, arr, sizeof(int) * n);\\ output(num, n);\\ printf(&quot;%s = &quot;, #func);\\ func(args);\\ output(num, n);\\ free(num);\\ printf(&quot;\\n&quot;);\\&#125;// 选择排序void select_Sort(int *num, int n) &#123; for(int i = 0; i &lt; n - 1; i++) &#123; int ind = i; for(int j = i + 1; j &lt; n; j++) &#123; if(num[ind] &gt; num[j]) ind = j; &#125; swap(num[i], num[ind]); &#125; return ;&#125;// 快排 — 第一版void quick_Sort(int *num, int l, int r) &#123; if(l &gt; r) return ; int x = l, y = r, z = num[l]; while(x &lt; y) &#123; // 先从后往前扫因为第一个位置是空着可以覆盖掉 while(x &lt; y &amp;&amp; num[y] &gt; z) y--; if(x &lt; y) num[x++] = num[y]; while(x &lt; y &amp;&amp; num[x] &lt; z) x++; if(x &lt; y) num[y--] = num[x]; &#125; // 头尾指针重合 num[x] = z; quick_Sort(num, l, x - 1); quick_Sort(num, x + 1, r); return ;&#125;// 快排 — 第二版 基准值两点取中法、无监督优化(去掉x &lt; y)、单 边递归法void quick_Sort1(int *num, int l, int r) &#123; while(l &lt; r) &#123; int x = l, y = r, z = num[(l + r) &gt;&gt; 1]; do &#123; while(num[x] &lt; z) x++; while(num[y] &gt; z) y--; if(x &lt;= y) &#123; swap(num[x], num[y]); x++, y--; &#125; &#125; while(x &lt;= y); quick_Sort1(num, l, y); l = x; &#125; return ;&#125;void randint(int *arr, int n) &#123; while(n--) arr[n] = rand() % 100; return ;&#125;void output(int *arr, int n) &#123; for(int i = 0; i &lt; n; i++) &#123; i &amp;&amp; printf(&quot;, &quot;); printf(&quot;%d&quot;, arr[i]); &#125; printf(&quot;\\n&quot;);&#125;int main() &#123; srand(time(0)); #define MAX_N 20 int arr[MAX_N]; randint(arr, MAX_N); TEST(arr, MAX_N, select_Sort, num, MAX_N); TEST(arr, MAX_N, quick_Sort, num, 0, MAX_N - 1); TEST(arr, MAX_N, quick_Sort1, num, 0, MAX_N - 1); #undef MAX_N return 0;&#125; 有趣的知识12345g++ test.cpptime .&#x2F;a.out &gt; out_1&#x2F;&#x2F; 比较两个文件是否相等diff out_1 out_2","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://tutouwang.vercel.app/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"广义表转二叉树","slug":"基础数据结构/广义表转二叉树","date":"2022-01-18T04:02:39.000Z","updated":"2022-05-22T15:05:06.438Z","comments":true,"path":"2022/01/18/基础数据结构/广义表转二叉树/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/18/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%BF%E4%B9%89%E8%A1%A8%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"代码实现广义表还原二叉树 (栈原理)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190/************************************************************************* &gt; File Name: 广义表转二叉树.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月18日 星期二 14时33分25 秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;typedef struct Node &#123; char data; struct Node *lchild, *rchild;&#125; Node;typedef struct Tree &#123; Node *root; int length;&#125; Tree;typedef struct Stack &#123; Node **data; int top, size;&#125; Stack;Node *getNewNode(char val) &#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;data = val; p-&gt;lchild = p-&gt;rchild = NULL; return p;&#125;Tree *getNewTree() &#123; Tree *tree = (Tree *)malloc(sizeof(Tree)); tree-&gt;root = NULL; tree-&gt;length = 0; return tree;&#125;Stack *init_stack(int n) &#123; Stack *s = (Stack *)malloc(sizeof(Stack)); s-&gt;data = (Node **)malloc(sizeof(Node *) * n); s-&gt;top = -1; s-&gt;size = n; return s;&#125;Node *top(Stack *s) &#123; return s-&gt;data[s-&gt;top];&#125;int empty(Stack *s) &#123; return s-&gt;top == -1;&#125;int push(Stack *s, Node *val) &#123; if(s == NULL) return 0; if(s-&gt;size - 1 == s-&gt;top) return 0; s-&gt;data[++(s-&gt;top)] = val; return 1;&#125;int pop(Stack *s) &#123; if(s == NULL) return 0; if(empty(s)) return 0; s-&gt;top--; return 1;&#125;void clear_stack(Stack *s) &#123; if(s == NULL) return ; free(s-&gt;data); free(s); return ;&#125;void clear_node(Node *root) &#123; if(root == NULL) return ; clear_node(root-&gt;lchild); clear_node(root-&gt;rchild); free(root); return ;&#125;void clear_tree(Tree *tree) &#123; if(tree == NULL) return ; clear_node(tree-&gt;root); free(tree); return ;&#125;Node *build(const char *str, int *node_num) &#123; Stack *s = init_stack(strlen(str)); int falg = 0; Node *temp = NULL, *p =NULL; while(str[0]) &#123; switch(str[0]) &#123; case &#x27;(&#x27; : &#123; push(s, temp); falg = 0; &#125; break; case &#x27;)&#x27; : &#123; p = top(s); pop(s); &#125; break; case &#x27;,&#x27; : falg = 1; break; case &#x27; &#x27; : break; default : temp = getNewNode(str[0]); if(!empty(s) &amp;&amp; !falg) &#123; top(s)-&gt;lchild = temp; &#125; else if(!empty(s) &amp;&amp; falg)&#123; top(s)-&gt;rchild = temp; &#125; ++(*node_num); &#125; ++str; &#125; clear_stack(s); if(temp &amp;&amp; p == NULL) p = temp; return p;&#125;// 前 根 左 右void pre_order_node(Node *root) &#123; if(root == NULL) return ; printf(&quot;%c &quot;, root-&gt;data); pre_order_node(root-&gt;lchild); pre_order_node(root-&gt;rchild); return ;&#125;// 前void pre_order(Tree *tree) &#123; if(tree == NULL) return ; printf(&quot;pre_order (%d) : &quot;, tree-&gt;length); pre_order_node(tree-&gt;root); printf(&quot;\\n&quot;); return ;&#125;// 中 左 根 右void in_order_node(Node *root) &#123; if(root == NULL) return ; in_order_node(root-&gt;lchild); printf(&quot;%c &quot;, root-&gt;data); in_order_node(root-&gt;rchild); return ;&#125;// 中void in_order(Tree *tree) &#123; if(tree == NULL) return ; printf(&quot;in_order (%d) : &quot;, tree-&gt;length); in_order_node(tree-&gt;root); printf(&quot;\\n&quot;); return ;&#125;// 后 左 右 根void post_order_node(Node *root) &#123; if(root == NULL) return ; in_order_node(root-&gt;lchild); in_order_node(root-&gt;rchild); printf(&quot;%c &quot;, root-&gt;data); return ;&#125;// 后void post_order(Tree *tree) &#123; if(tree == NULL) return ; printf(&quot;post_order (%d) : &quot;, tree-&gt;length); post_order_node(tree-&gt;root); printf(&quot;\\n&quot;); return ;&#125;int main() &#123; char str[1000] = &#123;0&#125;; int node_num = 0; scanf(&quot;%[^\\n]s&quot;, str); getchar(); Tree *tree = getNewTree(); tree-&gt; root = build(str, &amp;node_num); tree-&gt;length = node_num; pre_order(tree); in_order(tree); post_order(tree); return 0;&#125;","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"广义表转二叉树","slug":"广义表转二叉树","permalink":"https://tutouwang.vercel.app/tags/%E5%B9%BF%E4%B9%89%E8%A1%A8%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"树与二叉树","slug":"基础数据结构/树与二叉树","date":"2022-01-17T06:34:23.000Z","updated":"2022-05-22T15:05:06.433Z","comments":true,"path":"2022/01/17/基础数据结构/树与二叉树/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/17/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"树根节点 可以看成一个集合 链接的线可以看成关系 跟节点下面的子集 怎么判断机叉树：其中某个节点最多的子孩子个数 下面就是一个三叉树 树的高度-深度 节点4深度 2 是从根节点向下看 节点4高度 4 是从节点8向上看是4 从节点6向上看是 2 取最大 4 节点4高度 分层看 也是4 什么是节点的度 数据结构的理解 度 &#x3D; 出度 + 入度 图 在数据结构树的描述中 度 &#x3D;&#x3D; 出度 从当前节点有多少条出边 节点数量等于边数+1 树 转 二叉树树 转换成 二叉树 左孩子 - 右兄弟 十字链表法 二叉树 最多有2个子孩子叫二叉树 - 度最大为2 节点1出度指向 节点 2 和 节点3 分别为 左孩子 和 右孩子 为什么要讲二叉树 因为所有的树都可以转换成2叉树 度为0的节点比度为2的节点多1个 二叉树中 有度为0 (n0)， 1(n1)， 2(n0) 节点个数等于边数加1 n0 + n1 + n2 &#x3D; 0 + n1 + 2 * n2 + 1 n0 &#x3D; n2 + 1 二叉树 - 遍历 前序遍历 ： 根、左、右 — 根、左子树、右子树 ： 1， 2， 4，5，3，6 中序遍历 ： 左、根、右 — 左子树、根、右子树 ： 4，2，5，1，3，6 后序遍历 ： 左、右、根 — 左子树、右子树 、根 ：4，5，2，6，3，1 1.先序遍历- root - 左 - 右 123456void dfs(root) &#123; if(root) return ; f.push_back(roo-&gt;val); dfs(root-&gt;left); dfs(root-&gt;right);&#125; 2.中序遍历 左 - root - 右 123456void dfs(root) &#123; if(root) return ; dfs(root-&gt;left); f.push_back(root-&gt;val); dfs(root-&gt;right);&#125; 3.后序遍历 左 - 右 - root 123456void dfs(root) &#123; if(root) return ; dfs(root-&gt;left); dfs(root-&gt;right); f.push_back(root-&gt;val);&#125; 二叉树 - 中国版 完全二叉 只会有一个度为 1 的节点 缺省的只会是右孩子 满二叉树 每一个层都会满满的 二叉树 - 国际版 二叉树 - 完全二叉树 编号为 i 的子节点 左孩子编号 ：2 * i 右孩子编号 ： 2 * i + 1 可以用连续空间存储（数组）可以用顺序表实现！(更节省空间) 二叉树 - 广义表 广义表如何还原成一科二叉树 推荐使用第一种和第二种 二叉树代码实现 引入二叉排序树的概念 存在一课二叉树中三元组 广义表中 A, B, C A &gt; B &amp;&amp; A &lt; C (维护性质) 中序遍历就可以得到一个有序序列 前、中、后 遍历序列 得到中序和任意两种就可以还原出一课树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/************************************************************************* &gt; File Name: 二叉树.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月17日 星期一 16时25分06秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Node &#123; int data; struct Node *lchild, *rchild;&#125; Node;typedef struct Tree &#123; Node *root; int length;&#125; Tree;Node *getNewNode(int val) &#123; // 为什么使用calloc(对象数目, 每个对象大小)可以自动初始化。 Node *p = (Node *)calloc(1, sizeof(Node)); p-&gt;data = val; // 可省去 // p-&gt;lchild = NULL; // p-&gt;rchild = NULL; return p;&#125;Tree *getNewTree() &#123; Tree *tree = (Tree *)malloc(sizeof(Tree)); tree-&gt;root = NULL; tree-&gt;length = 0; return tree;&#125;void clear_node(Node *root) &#123; if(root == NULL) return ; clear_node(root-&gt;lchild); clear_node(root-&gt;rchild); free(root); return ;&#125;void clear(Tree *tree) &#123; if(tree == NULL) return ; clear_node(tree-&gt;root); free(tree); return ;&#125;// A &gt; B &amp;&amp; A &lt; CNode *insert_node(Node *root, int val, int *falg) &#123; if(root == NULL) &#123; *falg = 1; return getNewNode(val); &#125; if(root-&gt;data == val) return root; if(root-&gt;data &lt; val) root-&gt;rchild = insert_node(root-&gt;rchild, val, falg); else root-&gt;lchild = insert_node(root-&gt;lchild, val,falg); return root;&#125;// 这插入是根据二叉排序树 不会插入重复元素 falg = 标记void insert(Tree *tree, int val) &#123; if(tree == NULL) return ; int falg = 0; tree-&gt;root = insert_node(tree-&gt;root, val, &amp;falg); tree-&gt;length += falg; return ;&#125;// 前序void pre_order_node(Node *root) &#123; if(root == NULL) return ; printf(&quot;%d &quot;, root-&gt;data); pre_order_node(root-&gt;lchild); pre_order_node(root-&gt;rchild); return ;&#125;// 前序 根 左 右void pre_order(Tree *tree) &#123; if(tree == NULL) return ; printf(&quot;pre_order : [&quot;); pre_order_node(tree-&gt;root); printf(&quot;]\\n&quot;); return ;&#125;// 中序void in_order_node(Node *root) &#123; if(root == NULL) return ; in_order_node(root-&gt;lchild); printf(&quot;%d &quot;, root-&gt;data); in_order_node(root-&gt;rchild); return ;&#125;// 中序 左 根 右void in_order(Tree *tree) &#123; if(tree == NULL) return ; printf(&quot;in_order : [&quot;); in_order_node(tree-&gt;root); printf(&quot;]\\n&quot;); return ;&#125;// 后序void post_order_node(Node *root) &#123; if(root == NULL) return ; post_order_node(root-&gt;lchild); post_order_node(root-&gt;rchild); printf(&quot;%d &quot;, root-&gt;data); return ;&#125;// 后序 左 右 根void post_order(Tree *tree) &#123; if(tree == NULL) return ; printf(&quot;post_order : [&quot;); post_order_node(tree-&gt;root); printf(&quot;]\\n&quot;); return ;&#125;void output_node(Node *root) &#123; if(root == NULL) return ; printf(&quot;%d &quot;, root-&gt;data); if(root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) return ; printf(&quot;(&quot;); output_node(root-&gt;lchild); printf(&quot;, &quot;); output_node(root-&gt;rchild); printf(&quot;)&quot;); return ;&#125;// 广义表打印void output(Tree *tree) &#123; if(tree == NULL) return ; printf(&quot;tree(%d) : &quot;, tree-&gt;length); output_node(tree-&gt;root); return ;&#125;int main() &#123; srand(time(0)); #define MAX_OP 5 Tree *tree = getNewTree(); for(int i = 0; i &lt; MAX_OP; i++) &#123; int val = rand() % 100; insert(tree, val); output(tree), printf(&quot;\\n&quot;); &#125; pre_order(tree); in_order(tree); post_order(tree); #undef MAX_OP clear(tree); return 0;&#125;","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树与二叉树","slug":"树与二叉树","permalink":"https://tutouwang.vercel.app/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"栈与队列","slug":"基础数据结构/栈与队列","date":"2022-01-16T01:45:23.000Z","updated":"2022-05-22T15:05:06.437Z","comments":true,"path":"2022/01/16/基础数据结构/栈与队列/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/16/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","excerpt":"","text":"队列 (FIFO)结构操作：尾部入队、头部出队（排队做核酸！捅一个走一个 哈哈哈！） FIFO first in firas out : 先进先出 结构定义： 队列长度 (length) 队头位置 (head) 队尾位置 (tail) 任意类型元素 (data_type) (int \\ char) 连续空间存储 循环队列在队列结构定义之上 count 计数 (count) 可判断满和空 tail % leng 出队操作 - 入队操作 出队 (head +&#x3D; 1) 入队 (tail +&#x3D; 1) 假溢出出队操作 - 入队操作 - 假溢出优化 入队 (q-&gt;count !&#x3D; q-&gt;length) 当前队列数据总长度 (count)、队列总长度 (q-&gt;length) 满足条件情况： q-&gt;data[q-&gt;tail++] &#x3D; val; if(q-&gt;tail &#x3D;&#x3D; q-&gt;leng ) q-&gt;tail &#x3D; 0; q-&gt;count++; 出队 empty(q) 是否存在元素 满足条件情况： q-&gt;head++; if(q-&gt;head &#x3D;&#x3D; q-&gt;leng) q-&gt;head &#x3D; 0; q-&gt;count–; 队列代码演示 - 无假溢出优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/************************************************************************* &gt; File Name: 队列 - 假溢出.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月16日 星期日 09时44分03秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Queue &#123; int *data; int head, tail; int length;&#125; Queue;Queue *init(int n) &#123; Queue *q = (Queue *)malloc(sizeof(Queue)); q-&gt;data = (int *)malloc(sizeof(int) * n); q-&gt;head = 0; q-&gt;tail = 0; q-&gt;length = n; return q;&#125;int push(Queue *q, int val) &#123; // 空 if(q == NULL) return 0; // 满 if(q-&gt;tail == q-&gt;length) return 0; q-&gt;data[q-&gt;tail++] = val; return 1;&#125;int empty(Queue *q) &#123; return q-&gt;tail == q-&gt;head;&#125;int pop(Queue *q) &#123; if(q == NULL) return 0; if(empty(q)) return 0; q-&gt;head++; return 1;&#125;int front(Queue *q) &#123; if(q == NULL) return -1; return q-&gt;data[q-&gt;head];&#125;void clear(Queue *q) &#123; if(q == NULL) return ; free(q-&gt;data); free(q); return ;&#125;void output(Queue *q) &#123; if(q == NULL) return ; printf(&quot;Queue(%d) [&quot;, q-&gt;length); for(int i = q-&gt;head; i &lt; q-&gt;tail; i++) &#123; i != q-&gt;head &amp;&amp; printf(&quot;,&quot;); printf(&quot;%d&quot;, q-&gt;data[i]); &#125; printf(&quot;]&quot;); printf(&quot;\\n&quot;); return ;&#125;int main() &#123; #define MAX_OP 20 srand(time(0)); Queue *q = init(MAX_OP); for(int i = 0; i &lt; MAX_OP; i++) &#123; // 0 1 2 int op = rand() % 3; int val = rand() % 100; switch(op) &#123; case 0: &#123; if(!empty(q)) &#123; printf(&quot;pop front from the Queue = %d \\n&quot;, pop(q)); &#125; &#125; break; case 1: &#123; printf(&quot;push %d to the Queue = %d\\n&quot;, val, push(q, val)); &#125; break; case 2: &#123; printf(&quot;front one from Queue = %d\\n&quot;, front(q)); &#125; break; &#125; output(q), printf(&quot;\\n&quot;); &#125; #undef MAX_OP clear(q); return 0;&#125; 队列代码演示 - 假溢出优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/************************************************************************* &gt; File Name: 队列 - 假溢出优化.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月16日 星期日 09时44分03秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Queue &#123; int *data; int head, tail; int length; int count;&#125; Queue;Queue *init(int n) &#123; Queue *q = (Queue *)malloc(sizeof(Queue)); q-&gt;data = (int *)malloc(sizeof(int) * n); q-&gt;head = 0; q-&gt;tail = 0; q-&gt;count = 0; q-&gt;length = n; return q;&#125;int push(Queue *q, int val) &#123; // 空 if(q == NULL) return 0; // 满 if(q-&gt;length == q-&gt;count) return 0; q-&gt;data[q-&gt;tail++] = val; if(q-&gt;tail == q-&gt;length) q-&gt;tail = 0; q-&gt;count++; return 1;&#125;int empty(Queue *q) &#123; return q-&gt;count == 0;&#125;int pop(Queue *q) &#123; if(q == NULL) return 0; if(empty(q)) return 0; q-&gt;head++; if(q-&gt;head == q-&gt;length) q-&gt;head = 0; q-&gt;count--; return 1;&#125;int front(Queue *q) &#123; if(q == NULL) return -1; return q-&gt;data[q-&gt;head];&#125;void clear(Queue *q) &#123; if(q == NULL) return ; free(q-&gt;data); free(q); return ;&#125;void output(Queue *q) &#123; if(q == NULL) return ; printf(&quot;Queue(%d) [&quot;, q-&gt;length); for(int i = q-&gt;head, j = 0; j &lt; q-&gt;count; j++) &#123; j &amp;&amp; printf(&quot;,&quot;); printf(&quot;%d&quot;, q-&gt;data[(i + j) % q-&gt;length]); &#125; printf(&quot;]&quot;); printf(&quot;\\n&quot;); return ;&#125;int main() &#123; #define MAX_OP 20 srand(time(0)); Queue *q = init(4); for(int i = 0; i &lt; MAX_OP; i++) &#123; // 0 1 2 int op = rand() % 3; int val = rand() % 100; switch(op) &#123; case 0: &#123; if(!empty(q)) &#123; printf(&quot;pop front from the Queue = %d \\n&quot;, pop(q)); &#125; &#125; break; case 1: &#123; printf(&quot;push %d to the Queue = %d\\n&quot;, val, push(q, val)); &#125; break; case 2: &#123; printf(&quot;front one from Queue = %d\\n&quot;, front(q)); &#125; break; &#125; output(q), printf(&quot;\\n&quot;); &#125; #undef MAX_OP clear(q); return 0;&#125; 队列代码演示 - 假溢出优化 - 自动扩容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/************************************************************************* &gt; File Name: 栈与队列.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月16日 星期日 09时44分03秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Queue &#123; int *data; int head, tail; int length; int count;&#125; Queue;Queue *init(int n) &#123; Queue *q = (Queue *)malloc(sizeof(Queue)); q-&gt;data = (int *)malloc(sizeof(int) * n); q-&gt;head = 0; q-&gt;tail = 0; q-&gt;count = 0; q-&gt;length = n; return q;&#125;int expand(Queue *q) &#123; int extr_size = q-&gt;length; int *p; while(extr_size) &#123; p = (int *)malloc(sizeof(int) * (extr_size + q-&gt;length)); // 不能用 realloc if(p != NULL) break; extr_size &gt;&gt;= 1; &#125; if(p == NULL) return 0; for(int i = q-&gt;head, j = 0; j &lt; q-&gt;count; j++) &#123; p[j] = q-&gt;data[(i + j) % q-&gt;length]; &#125; q-&gt;data = p; q-&gt;head = 0, q-&gt;tail = q-&gt;count; q-&gt;length += extr_size; return 1;&#125;int push(Queue *q, int val) &#123; // 空 if(q == NULL) return 0; // 满 if(q-&gt;length == q-&gt;count) &#123; if(!expand(q)) &#123; printf(&quot;自动扩容失败！\\n&quot;); return 0; &#125; printf(&quot;自动扩容成功！\\n&quot;); &#125; q-&gt;data[q-&gt;tail++] = val; if(q-&gt;tail == q-&gt;length) q-&gt;tail = 0; q-&gt;count++; return 1;&#125;int empty(Queue *q) &#123; return q-&gt;count == 0;&#125;int pop(Queue *q) &#123; if(q == NULL) return 0; if(empty(q)) return 0; q-&gt;head++; if(q-&gt;head == q-&gt;length) q-&gt;head = 0; q-&gt;count--; return 1;&#125;int front(Queue *q) &#123; if(q == NULL) return -1; return q-&gt;data[q-&gt;head];&#125;void clear(Queue *q) &#123; if(q == NULL) return ; free(q-&gt;data); free(q); return ;&#125;void output(Queue *q) &#123; if(q == NULL) return ; printf(&quot;Queue(%d) [&quot;, q-&gt;length); for(int i = q-&gt;head, j = 0; j &lt; q-&gt;count; j++) &#123; j &amp;&amp; printf(&quot;,&quot;); printf(&quot;%d&quot;, q-&gt;data[(i + j) % q-&gt;length]); &#125; printf(&quot;]&quot;); printf(&quot;\\n&quot;); return ;&#125;int main() &#123; #define MAX_OP 20 srand(time(0)); Queue *q = init(1); for(int i = 0; i &lt; MAX_OP; i++) &#123; // 0 1 2 int op = rand() % 3; int val = rand() % 100; switch(op) &#123; case 0: &#123; if(!empty(q)) &#123; printf(&quot;pop front from the Queue = %d \\n&quot;, pop(q)); &#125; &#125; break; case 1: &#123; printf(&quot;push %d to the Queue = %d\\n&quot;, val, push(q, val)); &#125; break; case 2: &#123; printf(&quot;front one from Queue = %d\\n&quot;, front(q)); &#125; break; &#125; output(q), printf(&quot;\\n&quot;); &#125; #undef MAX_OP clear(q); return 0;&#125; 栈 (FILO) - (手枪弹夹🔫)FILO first in last out : 先进后出 结构定义： 栈大小 (size) 栈顶指针 (top) 栈中元素 (data_type) 连续空间存储 栈代码演示 - 自动扩容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/************************************************************************* &gt; File Name: 栈.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月16日 星期日 17时20分08秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Stack &#123; int *data; int size; int top;&#125; Stack;Stack *init(int n) &#123; Stack *s = (Stack *) malloc(sizeof(Stack)); s-&gt;data = (int *)malloc(sizeof(int) * n); s-&gt;size = n; s-&gt;top = -1; return s;&#125;void clear(Stack *s) &#123; if(s == NULL) return ; free(s-&gt;data); free(s); return ;&#125;int expand(Stack *s) &#123; int extr_size = s-&gt;size; int *p; while(extr_size) &#123; p = (int *) realloc(s-&gt;data,sizeof(int) * ( extr_size * s-&gt;size)); if(p != NULL) break; extr_size &gt;&gt;= 1; &#125; if(p == NULL) return 0; s-&gt;data = p; s-&gt;size += extr_size; return 1;&#125;int push(Stack *s, int val) &#123; if(s == NULL) return 0; if(s-&gt;top == s-&gt;size - 1) &#123; if(!expand(s)) &#123; printf(&quot;自动扩容失败！\\n&quot;); return 0; &#125; printf(&quot;自带扩容成功！\\n&quot;); &#125; s-&gt;data[++(s-&gt;top)] = val; return 1;&#125;int empty(Stack *s) &#123; if(s == NULL) return 1; return s-&gt;top == -1;&#125;int pop(Stack *s) &#123; if(s == NULL) return 0; if(empty(s)) return 0; s-&gt;top--; return 1;&#125;int top(Stack *s) &#123; if(s == NULL) return 0; if(empty(s)) return 0; return s-&gt;data[s-&gt;top];&#125;void output(Stack *s) &#123; if(s == NULL) return ; printf(&quot;Stack(%d, %d) : [&quot;, s-&gt;size, s-&gt;top); for(int i = s-&gt;top; ~i; i--) &#123; i != s-&gt;top &amp;&amp; printf(&quot;, &quot;); printf(&quot;%d&quot;, s-&gt;data[i]); &#125; printf(&quot;]\\n&quot;); return ;&#125;int main() &#123; srand(time(0)); #define MAX_OP 20 Stack *s = init(1); for(int i = 0; i &lt; MAX_OP; i++) &#123; int val = rand() % 100; int op = rand() % 3; switch(op) &#123; case 0: &#123; if(s != NULL) printf(&quot;top %d from the Stack \\n&quot;, top(s)); &#125; break; case 1: &#123; printf(&quot;push %d to the Stack = %d\\n&quot;, val, push(s, val)); &#125; break; case 2: &#123; if(s != NULL) printf(&quot;pop %d from the Stack \\n&quot;, pop(s)); &#125; break; &#125; output(s), printf(&quot;\\n&quot;); &#125; #undef MAX_OP clear(s); return 0;&#125; 链栈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/************************************************************************* &gt; File Name: 链栈.cpp &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月18日 星期二 16时28分15 秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct StackNode &#123; int data; StackNode *next;&#125; StackNode;typedef struct LinkStack &#123; StackNode *top; int length;&#125; LinkStack;StackNode *init_node(int val) &#123; StackNode *p = (StackNode * )malloc(sizeof(StackNode)); p-&gt;data = val; p-&gt;next = NULL; return p;&#125;LinkStack *init_stack() &#123; LinkStack *l = (LinkStack *)malloc(sizeof(LinkStack)); l-&gt;top = NULL; l-&gt;length = 0; return l;&#125;int empty(LinkStack *l) &#123; return l-&gt;top == NULL;&#125;int Stack_top(LinkStack *l) &#123; if(empty(l)) return -1; return l-&gt;top-&gt;data;&#125;int push(LinkStack *l, int val) &#123; if(l == NULL) return 0; StackNode *node = init_node(val); node-&gt;next = l-&gt;top; l-&gt;top = node; l-&gt;length += 1; return 1;&#125;void clear_node(StackNode *node) &#123; if(node == NULL) return ; free(node); return ;&#125;void clear(LinkStack *l) &#123; if(l == NULL) return ; StackNode *p = l-&gt;top, *t; while(p) &#123; t = p-&gt;next; clear_node(p); p = t; &#125; free(l); return ;&#125;int pop(LinkStack *l) &#123; if(l == NULL) return 0; if(empty(l)) return 0; StackNode *p = l-&gt;top; l-&gt;top = l-&gt;top-&gt;next; clear_node(p); l-&gt;length -= 1; return 1;&#125;void output_node(StackNode *p) &#123; if(p == NULL) return ; while(p) &#123; printf(&quot;%d &quot;, p-&gt;data); p = p-&gt;next; &#125; return ;&#125;void output(LinkStack *l) &#123; if(l == NULL) return ; printf(&quot;LinkStack(%d) : &quot;, l-&gt;length); output_node(l-&gt;top); printf(&quot;\\n&quot;); return ;&#125;int main() &#123; srand(time(0)); #define MAX_OP 20 LinkStack *s = init_stack(); for(int i = 0; i &lt; MAX_OP; i++) &#123; int op = rand() % 2; int val = rand() % 100; switch(op) &#123; case 0 : &#123; printf(&quot;pop %d from the LinkStack = &quot;, Stack_top(s)); printf(&quot;%d\\n&quot;, pop(s)); &#125; break; case 1 : &#123; printf(&quot;push %d to the form LinkStack = %d\\n&quot;, val, push(s, val)); &#125; break; &#125; output(s), printf(&quot;\\n&quot;); &#125; return 0;&#125; &#x2F;&#x2F; 待做 链栈、链队列、循环队列扩容、还没实现","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈与队列","slug":"栈与队列","permalink":"https://tutouwang.vercel.app/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"}]},{"title":"链表","slug":"基础数据结构/链表","date":"2022-01-15T02:32:20.000Z","updated":"2022-05-22T15:05:06.433Z","comments":true,"path":"2022/01/15/基础数据结构/链表/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/15/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"单向链表结点组成部分 数据域 - data 指针域 - next &#x2F; 后继 插入 - 结点 把待插入数据创建成一个结点 把待插入结点指向新建结点的next 把待插入结点前一个结点的next指向新建结点 代码演示 - 单向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/************************************************************************* &gt; File Name: 链表.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月15日 星期六 11时09分25秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define COLOR_HL(a, b) &quot;\\033[1;&quot; #b &quot;m&quot; a &quot;\\033[0m&quot;#define GREEN_HL(a) COLOR_HL(a, 32)typedef struct ListNode &#123; int data; struct ListNode *next;&#125; ListNode;typedef struct List &#123; // 虚拟头 ListNode head; int length;&#125; List;ListNode *getNewNode(int);List *getLinkList();void clear_node(ListNode *);void clear(List *);int insert(List*, int, int);int erase(List *, int);void reverse(List *);ListNode* getNewNode(int val) &#123; // sizeof ListNode 可以不加括号 可能是在c语言中不行 ListNode *p = (ListNode *) malloc(sizeof (ListNode)); p-&gt;data = val; p-&gt;next = NULL; return p;&#125;List *getLinkList() &#123; List *l = (List *)malloc(sizeof(List)); l-&gt;head.next = NULL; l-&gt;length = 0; return l;&#125;void clear_node(ListNode *node) &#123; if(node == NULL) return ; free(node); return ;&#125;void clear(List * l) &#123; if(l == NULL) return ; ListNode *p = l-&gt;head.next; ListNode *t = NULL; if(p != NULL) &#123; t = p-&gt;next; clear_node(p); p = t; &#125; free(l); return ;&#125;int insert(List *l, int ind, int val) &#123; if(l == NULL) return 0; if(ind &lt; 0 || ind &gt; l-&gt;length) return 0; ListNode *p = getNewNode(val); ListNode *h = &amp;(l-&gt;head); while(ind--) h = h-&gt;next; p-&gt;next = h-&gt;next; h-&gt;next = p; l-&gt;length++; return 1;&#125;int erase(List *l, int ind) &#123; if(l == NULL) return 0; if(ind &lt; 0 || ind &gt;= l-&gt;length) return 0; ListNode *h = &amp;(l-&gt;head); // 这里说明一下为什么不 直接 h-&gt;next = h-&gt;next-&gt;next; // 1. 这个操作是合法的 但是要这样操作的就会发生内存泄漏 // 2. 所有我们这里需要一个临时变量 t 来存储待删除结点 之后好free掉 ListNode *t = NULL; while(ind--) h = h-&gt;next; t = h-&gt;next; h-&gt;next = t-&gt;next; l-&gt;length--; clear_node(t); return 1;&#125;void output(List *l) &#123; if(l == NULL) return ; printf(&quot;List(%d) : &quot;, l-&gt;length); ListNode *h = l-&gt;head.next; while(h != NULL) &#123; printf(&quot;%d-&gt;&quot;, h-&gt;data); h = h-&gt;next; &#125; printf(&quot;NULL\\n\\n&quot;);&#125;void reverse(List *l) &#123; if(l == NULL) return ; ListNode *h = l-&gt;head.next; l-&gt;head.next = NULL; ListNode *t = NULL; while(h != NULL) &#123; t = h-&gt;next; t = l-&gt;head.next; l-&gt;head.next = h; h = t; &#125; return ;&#125;int main() &#123; srand(time(0)); // 20 次测试 #define MAX_OP 20 List *l = getLinkList(); for(int i = 0; i &lt; MAX_OP; i++) &#123; int val = rand() % 100; int ind = rand() % (l-&gt;length + 3) - 1; // 想变大插入概率 可以把 2 变成 4 // case 0 1 2 3 int op = rand() % 3; switch(op) &#123; case 0: &#123; printf(&quot;erase a iterm at %d from List = %d \\n&quot;, ind, erase(l, ind)); break; &#125; case 1: &#123; printf(&quot;insert %d at %d to List = %d \\n&quot;, val, ind, insert(l, ind, val)); break; &#125; case 2: &#123; printf(GREEN_HL(&quot;reverse the list ! \\n&quot;)); reverse(l); break; &#125; &#125; output(l); &#125; #undef MAX_OP clear(l); return 0;&#125; 单线循环链表 头- -&gt; 尾 双向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/************************************************************************* &gt; File Name: 双向链表.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月18日 星期二 17时05分55 秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Node &#123; int data; struct Node *next, *pre;&#125; Node;typedef struct Dlist &#123; Node head; int length;&#125; Dlist;Node *getNewNode(int val) &#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;data = val; p-&gt;next = p-&gt;pre = NULL; return p;&#125;Dlist *init_list() &#123; Dlist *l = (Dlist *)malloc(sizeof(Dlist)); l-&gt;head.next = NULL; l-&gt;length = 0; return l;&#125;int insert(Dlist *l, int ind, int val) &#123; if(l == NULL) return 0; if(ind &lt; 0 || ind &gt; l-&gt;length) return 0; Node *p = &amp;(l-&gt;head), *node = getNewNode(val); while(ind--) p = p-&gt;next; node-&gt;next = p-&gt;next; p-&gt;next = node; node-&gt;pre = p; if(node-&gt;next != NULL) node-&gt;next-&gt;pre = node; l-&gt;length ++; return 1;&#125;void clear_node(Node *node) &#123; if(node == NULL) return ; free(node); return ;&#125;void clear(Dlist *l) &#123; if(l == NULL) return ; Node *p = l-&gt;head.next, *t; while(p) &#123; t = p-&gt;next; clear_node(p); p = t; &#125; free(l); return ;&#125;int erase(Dlist *l, int ind) &#123; if(l == NULL ) return 0; if(ind &lt; 0 || ind &gt;= l-&gt;length) return 0; Node *p= &amp;(l-&gt;head), *t; while(ind--) p = p-&gt;next; t = p-&gt;next; p-&gt;next = t-&gt;next; if(t-&gt;next != NULL) t-&gt;next-&gt;pre = p; clear_node(t); l-&gt;length--; return 1;&#125;void l_output(Dlist *l) &#123; if(l == NULL) return ; printf(&quot;L-Dlist(%d) : &quot;, l-&gt;length); for(Node *p = l-&gt;head.next; p; p = p-&gt;next) &#123; printf(&quot;%d-&gt;&quot;, p-&gt;data); &#125; printf(&quot;NULL\\n&quot;); return ;&#125;void r_output(Dlist *l) &#123; if(l == NULL) return ; printf(&quot;L-Dlist(%d) : &quot;, l-&gt;length); int ind = 0; Node *p = &amp;(l-&gt;head); while(ind++ != l-&gt;length) p = p-&gt;next; for(; p != &amp;(l-&gt;head); p = p-&gt;pre) &#123; printf(&quot;%d-&gt;&quot;, p-&gt;data); &#125; printf(&quot;head\\n&quot;); return ;&#125;int main() &#123; #define MAX_OP 20 Dlist *l = init_list(); for(int i = 0; i &lt; MAX_OP; i++) &#123; int val = rand() % 100; int ind = rand() % (l-&gt;length + 3) - 1; int op = rand() % 2; switch(op) &#123; case 0 : &#123; printf(&quot;erase a iterm at %d form lis = %d&quot;, ind, erase(l, ind)); &#125; break; case 1 : &#123; printf(&quot;insert %d at %d to Lis = %d\\n&quot;, val, ind, insert(l, ind, val)); &#125; break; &#125; l_output(l); r_output(l), printf(&quot;\\n&quot;); &#125; #undef MAX_OP clear(l); return 0;&#125; 链表翻转 力扣206","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://tutouwang.vercel.app/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"顺序表","slug":"基础数据结构/顺序表","date":"2022-01-14T03:11:14.000Z","updated":"2022-01-19T03:29:03.317Z","comments":true,"path":"2022/01/14/基础数据结构/顺序表/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/14/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/","excerpt":"","text":"数据结构 &#x3D; 结构定义 + 结构操作cppreference https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5 顺序表 - 线性结构：一对一1.什么是顺序表？ 是一个更高级的数组 结构定义： 一片连续存储空间 可以存储任意类型值 (类型需要一致，int、char、结构体…) (data_type) 顺序表大小 (size) 顺序表以存储个数 (length) 结构操作： 插入元素 (insert) 如果第一个满足只执行1不满足可以直接执行 2 可以通过整理 直接用2来实现 如果代插入数据i 等于i == length 那么直接在后面添加length++ 在待插入位置i 把i + 1 后数据全部向后移动一位,并且legth++ 删除元素 (clear) 待删位置 i 把i + 1之后位置的数据向前移动一位 覆盖掉 length-- 新知识1234567891011121314151617181920212223242526272829#include &lt;stdlib.h&gt; // malloc 需要头文件#include &lt;stdio.h&gt;#demine MAX_N 20/* 函数中 // int arr[n + 1]; // 栈区 在Linux系统中只有 8M 很小 * malloc 动态开辟空间 如果不用需要主动释放 返回值是一块连续的地址(逻辑上) void* * calloc 参数size为申请地址的单元元素长度，nmemb为元素个数，即在内存中申请nmemb *size字节大小的连续地址空间， 并赋值0-相当于自带初始化； * realloc 给一个已经分配了地址的指针重新分配空间，参数ptr为原有的空间地址，size为重新申请的地址长度； * free 释放 **/int main() &#123; // 函数 malloc int *v = (int *) malloc(sizeof(int) * MAX_N); free(v); v = NULL; // 函数 calloc int *v1 = (int *) calloc(20, MAX_N * sizeof(int)); free(v); v = NULL; // 函数 realloc 在 malloc 基础上 // 数字数量大于当前 malloc 大小 重新分配 int *v = (int *) malloc(sizeof(int) * MAX_N); v = (int *) realloc (v, 5 * sizeof(int) * MAX_N); free(v); v = NULL; return 0;&#125; 代码演示-顺序表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/************************************************************************* &gt; File Name: 顺序表.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月14日 星期五 12时03分03秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define COLOR(a, b) &quot;\\033[&quot; #b &quot;m&quot; a&quot;\\033[0m&quot;#define GREEN(a) COLOR(a, 32)#define RED(a) COLOR(a, 31)typedef int Type;typedef struct Vector &#123; Type *data; int size, length;&#125; Vec;Vec *init(int n) &#123; // int arr[n + 1]; // 栈区 在Linux系统中只有 8M 很小 Vec *v = (Vec *)malloc(sizeof(Vec)); v-&gt;data = (Type *)malloc(sizeof(Type) * n); v-&gt;size = n; v-&gt;length = 0; return v;&#125;void clear(Vec *v) &#123; if(v == NULL) return ; // 如果内存申请失败 free(v-&gt;data); // 申请了2个空间 free(v); return ;&#125;// 扩容int expand(Vec *v) &#123; int extr_size = v-&gt;size; Type *p; while(extr_size) &#123; p = (Type *)realloc(v-&gt;data, sizeof(Type) * (v-&gt;size + extr_size)); if(p != NULL) break; extr_size &gt;&gt;= 1; &#125; if(p == NULL) &#123; printf(RED(&quot;扩容失败\\n&quot;)); return 0; &#125; v-&gt;size += extr_size; v-&gt;data = p; printf(GREEN(&quot;当前容量 : %d -- 扩容到 : %d\\n&quot;), v-&gt;size - extr_size, v-&gt;size); return 1;&#125;int insert(Vec *v, int ind, Type val) &#123; // ind 需要插入的位置 if(v == NULL) return 0; if(ind &lt; 0 || ind &gt; v-&gt;length) return 0; if(v-&gt;length == v-&gt;size) &#123; if(!expand(v)) return 0; &#125; for(int i = v-&gt;length; i &gt; ind; i--) &#123; v-&gt;data[i] = v-&gt;data[i - 1]; &#125; v-&gt;data[ind] = val; v-&gt;length +=1; return 1;&#125;int erase(Vec *v, int ind) &#123; if(v == NULL) return 0; if(ind &lt; 0 || ind &gt;= v-&gt;length) return 0; for(int i = ind + 1; i &lt; v-&gt;length; i++) &#123; v-&gt;data[i - 1] = v-&gt;data[i]; &#125; v-&gt;length--; return 1;&#125;void output(Vec *v) &#123; if(v == NULL) return ; printf(&quot;Vector(%d) :[&quot;, v-&gt;length); for(int i = 0; i &lt; v-&gt;length; i++) &#123; i &amp;&amp; printf(&quot;,&quot;); printf(&quot;%d&quot;, v-&gt;data[i]); &#125; printf(&quot;]\\n&quot;); return ;&#125;int main() &#123; #define MAX_N 20 Vec *v = init(1); srand(time(0)); for(int i = 0; i &lt; MAX_N; i++) &#123; int op = rand() % 2; int ind = rand() % (v-&gt;length + 3) - 1; int val = rand() % 100; switch(op) &#123; case 0: printf(&quot;insert %d at %d to Vector = %d \\n&quot;, val, ind, insert(v, ind, val)); break; case 1: printf(&quot;erase a iterm at %d from Vector = %d\\n&quot;, ind, erase(v, ind)); break; &#125; output(v), printf(&quot;\\n&quot;); &#125; clear(v); #undef MAX_N return 0;&#125;","categories":[{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"顺序表","slug":"顺序表","permalink":"https://tutouwang.vercel.app/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}]},{"title":"StackReverse","slug":"有趣的知识/StackReverse","date":"2022-01-06T02:14:14.000Z","updated":"2022-01-19T02:40:43.592Z","comments":true,"path":"2022/01/06/有趣的知识/StackReverse/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/06/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/StackReverse/","excerpt":"","text":"Stack - 翻转1234567891011121314151617181920212223242526272829303132333435363738394041424344/************************************************************************* &gt; File Name: stackRecerse.cpp &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2022年01月06日 星期四 10时15分16秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;void reverseStack(stack&lt;string&gt; &amp;f, string &amp;res) &#123; // 当然这里 string res 也可以写成另一个 栈 这里这个引用会加点速 if(!f.empty()) &#123; string t = f.top(); f.pop(); reverseStack(f, res); res += t + &quot; &quot;; &#125; return ;&#125;int main() &#123; stack&lt;string&gt; f, f1; f.push(&quot;a&quot;); f.push(&quot;b&quot;); f.push(&quot;c&quot;); f.push(&quot;d&quot;); f.push(&quot;e&quot;); f.push(&quot;f&quot;); f1 = f; while(!f1.empty()) &#123; cout &lt;&lt; f1.top() &lt;&lt; &quot; &quot;; f1.pop(); &#125; cout &lt;&lt; endl; string res; reverseStack(f, res); cout &lt;&lt; res; return 0;&#125;","categories":[{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"将b进制数转化成十进制","slug":"有趣的知识/将b进制数转化成十进制","date":"2022-01-05T12:38:52.000Z","updated":"2022-01-19T02:42:48.862Z","comments":true,"path":"2022/01/05/有趣的知识/将b进制数转化成十进制/","link":"","permalink":"https://tutouwang.vercel.app/2022/01/05/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E5%B0%86b%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E5%8C%96%E6%88%90%E5%8D%81%E8%BF%9B%E5%88%B6/","excerpt":"","text":"秦九韶算法-将b进制数转化成十进制有二进制1010 取出 第一位 1 1 * 2 + 0 &#x3D; 2 10 * 2 + 1 &#x3D;&#x3D; 2 * 2 + 1 10 &#x3D; 5 5 * 2 + 0 &#x3D; 10 有二进制1010 二进制转换成十进制:基数乘以权,然后相加 $$ 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0$$ $$ &#x3D; ((1 * 2 + 0) * 2 + 1 ) * 2 + 0$$ 123456int get(string s, b) &#123; int res = 0; for(auto c : s) res = res * b + c- &#x27;0&#x27;; return res;&#125;","categories":[{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"继承","slug":"OOP/继承","date":"2021-11-19T11:50:51.000Z","updated":"2022-05-22T15:05:06.444Z","comments":true,"path":"2021/11/19/OOP/继承/","link":"","permalink":"https://tutouwang.vercel.app/2021/11/19/OOP/%E7%BB%A7%E6%89%BF/","excerpt":"","text":"继承123456789// 派生类 B 基类 Aclass B&#123;public : &#125;;// class A : public B &#123; &#125;; 继承权限影响的什么 类外对于访问子类对继承父类的方法和属性的访问权限 继承的好处： 代码的复用性 逻辑上的递进关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172/************************************************************************* &gt; File Name: 继承.cpp &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2021年11月19日 星期五 19时55分12秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;#define BEGINS(x) namespace x &#123; // namesoace of x#define ENDS(x) &#125; // namespace of xBEGINS(test1)class Base &#123;public : int x;protected : int y;private : int z;&#125;;class public_Bace : public Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected //z = 2; // no, z private &#125;&#125;;class protected_Bace : protected Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected //z = 2; // no, z private &#125;&#125;;class private_Bace : private Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected // z = 2; // no, z private &#125;&#125;;int main() &#123; public_Bace a; // 都是继承父类的方法 // 继承 + x 在父类中的权限 = 表现出来的 a.x = 3; // ok, putback + public = public // a.y = 4; // no, public + protected = protected // a.z = 5; // no, public + private = private protected_Bace b; // b.x = 3; // no, protected + public = protected // b.y = 4; // no, protected + protected = protected // b.z = 5; // no, protected + private = private private_Bace c; // c.x = 3; // no, private + public = private // c.y = 4; // no, private + protected = private // c.z = 5; // no, private + private = private return 0;&#125;ENDS(test1)BEGINS(test2)class Base &#123;public : Base(string name) : class_name(name)&#123;&#125; int x; string class_name;private : int y;&#125;;class A : public Base &#123;public: A() : Base(&quot;class_A&quot;)&#123;&#125;&#125;;class B : public Base &#123;public: B() : Base(&quot;class_B&quot;)&#123;&#125;&#125;;class C : public Base &#123;public: C() : Base(&quot;class_C&quot;)&#123;&#125;&#125;;void func(Base &amp;b) &#123; cout &lt;&lt; &quot;nput class : &quot; &lt;&lt; b.class_name &lt;&lt; endl; return ;&#125;int main() &#123; A a; B b; C c; // 隐式类型转换 子类 -&gt; 父类 func(a); func(b); func(c); cout &lt;&lt; &quot;sizeof(Base) = &quot; &lt;&lt; sizeof(Base) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(A) = &quot; &lt;&lt; sizeof(A) &lt;&lt; endl; return 0;&#125;ENDS(test2)BEGINS(test3)class Base &#123;public : Base(string name) : class_name(name)&#123;&#125; int x; string class_name;private : int y;&#125;;class A : public Base &#123;public: A() : Base(&quot;class_A&quot;)&#123;&#125;&#125;;class B : public Base &#123;public: B() : Base(&quot;class_B&quot;)&#123;&#125;&#125;;class C : public Base &#123;public: C() : Base(&quot;class_C&quot;)&#123;&#125;&#125;;void func(Base *b) &#123; cout &lt;&lt; &quot;nput class : &quot; &lt;&lt; b-&gt;class_name &lt;&lt; endl; return ;&#125;int main() &#123; A a; B b; C c; // 子类的地址也是可以转换成父类的地址 func(&amp;a); func(&amp;b); func(&amp;c); return 0;&#125;ENDS(test3)int main() &#123; // test1::main(); // test2::main(); test3::main(); return 0;&#125; 继承-构造函数构造顺序与析构顺序一定是相反的 先构造一定后析构 先析构子类的属性后析构父类的属性 菱形继承-多继承是不是所有的面向对象语言都允许多继承? 不是 C#、java 是不允许多继承的 A ( run () ) B ( run () ) C ( run () ) D ( run () ) 菱形继承有些场景是可以编译通过但是输出不确定 先是完成 基类构造 在完成 派生类构造 拷贝&amp;赋值–继承先完成父类的拷贝行为 在完成子类的拷贝行为 拷贝行为 拷贝构造函数：显示调用父类拷贝构造 赋值运算符：显示调用父类的赋值运算函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232/************************************************************************* &gt; File Name: 继承.cpp &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2021年11月19日 星期五 19时55分12秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;#define BEGINS(x) namespace x &#123; // namesoace of x#define ENDS(x) &#125; // namespace of xBEGINS(test1)class Base &#123;public : int x;protected : int y;private : int z;&#125;;class public_Bace : public Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected //z = 2; // no, z private &#125;&#125;;class protected_Bace : protected Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected //z = 2; // no, z private &#125;&#125;;class private_Bace : private Base &#123;public : void main() &#123; x = 2; // ok, x public y = 2; // ok, y protected // z = 2; // no, z private &#125;&#125;;int main() &#123; public_Bace a; // 都是继承父类的方法 // 继承 + x 在父类中的权限 = 表现出来的 a.x = 3; // ok, putback + public = public // a.y = 4; // no, public + protected = protected // a.z = 5; // no, public + private = private protected_Bace b; // b.x = 3; // no, protected + public = protected // b.y = 4; // no, protected + protected = protected // b.z = 5; // no, protected + private = private private_Bace c; // c.x = 3; // no, private + public = private // c.y = 4; // no, private + protected = private // c.z = 5; // no, private + private = private return 0;&#125;ENDS(test1)BEGINS(test2)class Base &#123;public : Base(string name) : class_name(name)&#123;&#125; int x; string class_name;private : int y;&#125;;class A : public Base &#123;public: A() : Base(&quot;class_A&quot;)&#123;&#125;&#125;;class B : public Base &#123;public: B() : Base(&quot;class_B&quot;)&#123;&#125;&#125;;class C : public Base &#123;public: C() : Base(&quot;class_C&quot;)&#123;&#125;&#125;;void func(Base &amp;b) &#123; cout &lt;&lt; &quot;nput class : &quot; &lt;&lt; b.class_name &lt;&lt; endl; return ;&#125;int main() &#123; A a; B b; C c; // 隐式类型转换 子类 -&gt; 父类 func(a); func(b); func(c); cout &lt;&lt; &quot;sizeof(Base) = &quot; &lt;&lt; sizeof(Base) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(A) = &quot; &lt;&lt; sizeof(A) &lt;&lt; endl; return 0;&#125;ENDS(test2)BEGINS(test3)class Base &#123;public : Base(string name) : class_name(name)&#123;&#125; int x; string class_name;private : int y;&#125;;class A : public Base &#123;public: A() : Base(&quot;class_A&quot;)&#123;&#125;&#125;;class B : public Base &#123;public: B() : Base(&quot;class_B&quot;)&#123;&#125;&#125;;class C : public Base &#123;public: C() : Base(&quot;class_C&quot;)&#123;&#125;&#125;;void func(Base *b) &#123; cout &lt;&lt; &quot;nput class : &quot; &lt;&lt; b-&gt;class_name &lt;&lt; endl; return ;&#125;int main() &#123; A a; B b; C c; // 子类的地址也是可以转换成父类的地址 func(&amp;a); func(&amp;b); func(&amp;c); return 0;&#125;ENDS(test3)// 父类子类的构造顺序BEGINS(test4)class ATTR_BASE &#123;public: ATTR_BASE(string name) : name(name)&#123; cout &lt;&lt; &quot;construct &quot; &lt;&lt; name &lt;&lt; endl; &#125; ~ATTR_BASE() &#123; cout &lt;&lt; &quot;destructor&quot; &lt;&lt; name &lt;&lt; endl; &#125; string name;&#125;;class ATTR1 : public ATTR_BASE&#123;public : ATTR1(string name) : ATTR_BASE(name) &#123;&#125;&#125;;class ATTR2 : public ATTR_BASE&#123;public : ATTR2(string name) : ATTR_BASE(name) &#123;&#125;&#125;;class Base &#123;public: Base() : attr1(&quot;attr1 in Base&quot;), attr2(&quot;attr2 in Base&quot;) &#123; cout &lt;&lt; &quot;Base constructor done&quot; &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; &quot;Base destructor don&quot; &lt;&lt; endl; &#125;private : ATTR1 attr1; ATTR2 attr2;&#125;;// Base 派生类class A : public Base &#123;public : A() : attr1(&quot;attr1 in A&quot;), attr2(&quot;attr2 in A&quot;)&#123; cout &lt;&lt; &quot;A constructor don&quot; &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;A destructor don&quot; &lt;&lt; endl; &#125;private : ATTR1 attr1; ATTR2 attr2;&#125;;int main() &#123; A a; return 0;&#125;ENDS(test4)int main() &#123; // test1::main(); // test2::main(); // test3::main(); test4::main(); return 0;&#125; 构造析构顺序 拷贝构造拷贝构造行为方式 ： 默认的 ： 默认调用每一个属性的拷贝函数默认的调用父类的拷贝函数","categories":[{"name":"C++\\OOP","slug":"C-OOP","permalink":"https://tutouwang.vercel.app/categories/C-OOP/"}],"tags":[]},{"title":"静态链接库-静态链接库","slug":"LInux-系统编程入门/静态链接库","date":"2021-11-14T11:49:27.000Z","updated":"2022-05-02T02:21:29.084Z","comments":true,"path":"2021/11/14/LInux-系统编程入门/静态链接库/","link":"","permalink":"https://tutouwang.vercel.app/2021/11/14/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/","excerpt":"","text":"命名规则Linux Linux : libxxxx.so lib : 前缀（固定） xxxx : 库的名字，自己起 .so ： 后缀（固定） 在Linux下是一个可执行文件 Windwos Windows ： libxxxx.dll 静态链接库把所有.c文件 进行编译、汇编 不进行链接 1gcc -c test1.c test1.c test2.c test3.c r 插入 c 创建 s建立索引 lib库的名称.a 1ar rcs libcalc.a add.o sub.o mult.o gcc main.c -o app -I .&#x2F;头文件 动态库的制作gcc 得到 .o文件 ， 得到和位置无关的代码 1gcc -c -fpic&#x2F;-fpIC a.c b.c gcc 得到动态库 1gcc -shared a.o b.o -o libxxxx.so","categories":[{"name":"LInux-系统编程入门","slug":"LInux-系统编程入门","permalink":"https://tutouwang.vercel.app/categories/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"LInux","slug":"LInux","permalink":"https://tutouwang.vercel.app/tags/LInux/"}]},{"title":"Windows子系统搭建Vim","slug":"教程/Windows子系统搭建Vim","date":"2021-11-07T14:01:42.000Z","updated":"2022-05-22T15:15:04.323Z","comments":true,"path":"2021/11/07/教程/Windows子系统搭建Vim/","link":"","permalink":"https://tutouwang.vercel.app/2021/11/07/%E6%95%99%E7%A8%8B/Windows%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BAVim/","excerpt":"","text":"注意：本文档没有任何问题，请仔细阅读文档，按步骤完成，不要轻易质疑文档的正确性；遇到问题，请大家先仔细阅读屏幕输出，不要直接提问 Windows10下Linux子系统1、启用开发者模式设置-更新和安全-针对开发人员-开发人员模式-等待完成（可以不开） 2、设置-程序和功能-启用或关闭windows功能-适用于Linux的Windows子系统-确定-等待安装完成并重启PC 3、安装Linux打开windows10的应用商店，搜索ubuntu，选择需要的版本点击-获取 我这里选择的是ubuntu20.04，点击获取后等待安装完成 4、启动在开始菜单中找到安装的ubuntu点击启动，第一次启动需要设置用户和密码按照提示设置即可。 换源Ubuntu系统自带的源都是国外的网址，国内用户在使用的时候网速比较慢，这样我们在下载或更新软件时就会十分痛苦。所以对于一个新手来说，给Ubuntu换源，就显得十分必要了。 一：备份原来的源1sudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources_init.list 注意，我们操作Ubuntu一般都是要在管理员权限下进行操作的，尤其是要对系统文件进行更改。sudo就是告诉系统使用管理员权限运行后面的命令。敲入回车后输入我们之前设置的密码即可运行。 二：查看版本号1lsb_release -a 三：更换阿里源进入更换阿里数据源 打开网站 找到对应版本数据源 12&#x2F;&#x2F;阿里源地址https:&#x2F;&#x2F;developer.aliyun.com&#x2F;mirror&#x2F;ubuntu?spm&#x3D;a2c6h.13651102.0.0.3e221b11dHF7v5 12&#x2F;&#x2F;清华源地址https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;help&#x2F;ubuntu&#x2F; 1sudo vim /etc/apt/sources.list 将文件里的内容全部删除（可在vim的命令模式下，使用gg将光标移到文件首行，使用dG命令清空文件），敲入i进入编辑模式，将下面内容粘贴(ctrl + shift + v)进文件 保持原有格式粘贴（esc 后 输入： set paste 在按下i键 ctrl + shift + v） 123456789101112131415//阿里源20.04LTSdeb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse 按ESC（或Ctrl + [）退出编辑模式进入命令模式，然后先按“:”，再输入wq，敲入回车，文件即写入成功。 三：更新系统输入下列命令，等待更新完毕~ 12sudo apt-get updatesudo apt-get upgrade 安装系统后的环境准备配置sshd Vim的简单使用，请百度 使用命令sudo vim /etc/ssh/sshd_config打开sshd的配置文件，找到ClientAliveInterval和ClientAliveCountMax并将其修改为（如果没有直接添加即可）：60 3 重启sshd服务 1sudo service sshd restart 如果上述命令报错，大致内容为sshd这个服务不存在的话，就执行sudo service ssh restart 以下所有配置，都是为了优化终端，提升使用效率，如果你已经能独立对bash，zsh，vim等进行配置优化，可自行选择方案，无需完全按照这个方案 GitHub访问优化 请进入这个网址：点击这里 找到图中的IP1 在上面的网站上搜索github.com,找到IP2 使用命令sudo vim /etc/hosts打开hosts文件，并在最后加入以下信息 12199.232.69.194 github.global.ssl.fastly.net140.82.112.4 github.com 保存并退出 vim###配置Vim（使用新添加的用户操作） 在后续的学习过程中，会使用vim写程序 Vim配置推荐 - ma6174（不用打开这个官方网站） 更新apt源信息 1sudo apt update 配置vim，执行下面命令配置安装vim sudo apt-get install git 12wget 47.93.11.51:88/install_vim.shbash install_vim.sh vim的配置因为需要安装较多插件，所以需要等较多时间，大家耐心等待 如果出现括号不能自动匹配情况重新安装第二条命令即可 zsh的安装及配置 安装zsh &#x2F;&#x2F; 主题 1sudo apt install zsh 修改默认shell为zsh &#x2F;&#x2F; 应该是修改主题 1chsh -s /bin/zsh 安装oh-my-zsh &#x2F;&#x2F; 1234sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;##如果不成功，请执行下面两条命令，成功了就不需要做下面两条wget 47.93.11.51:88/install_zsh.shbash install_zsh.sh 安装zsh-syntax-highlighting &#x2F;&#x2F; 代码高亮插件 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 使用命令vim .zshrc打开.zshrc文件，找到plugins=()这一行，将zsh-syntax-highlighting添加进去 1plugins=(git zsh-syntax-highlighting) 安装其他插件 1234567##命令自动补全插件mkdir ~/.oh-my-zsh/plugins/incrwget http://mimosa-pudica.net/src/incr-0.2.zsh -O ~/.oh-my-zsh/plugins/incr/incr.plugin.zsh##命令自动推荐，根据历史记录git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions##目录自动跳转插件sudo apt install autojump 使用命令vim .zshrc，打开后在最后插入以下内容： 123456789#设置终端颜色，提示符，及上一条指令返回码提示autoload -U colors &amp;&amp; colorsPROMPT=&quot;%&#123;$fg[red]%&#125;%n%&#123;$reset_color%&#125;@%&#123;$fg[blue]%&#125;%m %&#123;$fg[yellow]%&#125;%1~ %&#123;$reset_color%&#125;%# &quot;RPROMPT=&quot;[%&#123;$fg[yellow]%&#125;%?%&#123;$reset_color%&#125;]&quot;# Useful support for interacting with Terminal.app or other terminal programs[ -r &quot;/etc/zshrc_$TERM_PROGRAM&quot; ] &amp;&amp; . &quot;/etc/zshrc_$TERM_PROGRAM&quot;source ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.plugin.zshsource /usr/share/autojump/autojump.shsource ~/.oh-my-zsh/plugins/incr/incr*.zsh 注意，复制后可能会因为Vim的配置导致以上内容被注释，也就是在前面加上了#,如果有的话，删掉就行。 ctags安装与配置 使用以下命令安装ctags 1sudo apt install ctags 执行以下命令 1ctags -I __THROW -I __attribute_pure__ -I __nonnull -I __attribute__ --file-scope=yes --langmap=c:+.h --languages=c,c++ --links=yes --c-kinds=+p --c++-kinds=+p --fields=+iaS --extra=+q -f ~/.vim/systags /usr/include/* /usr/include/x86_64-linux-gnu/sys/* /usr/include/x86_64-linux-gnu/bits/* /usr/include/arpa/* 使用命令vim .vimrc编辑.vimrc，在最后添加以下内容 1set tags+=~/.vim/systags 安装 gcc&#x2F;g++gcc 安装命令 1sudo apt install gcc g++ 安装命令 1sudo apt install g++ 运行各种程序的run脚本查看环境变量echo $PATH，在任意一个目录下创建一个run文件 或者在环境变量里面新建一个文件 run文件内容 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/bin/bash#0 c#1 c++#2 bash#3 pyCC=&quot;gcc -lm -Wall&quot;GPP=&quot;g++ -std=c++11 -Wall&quot;function CheckType() &#123; type=`echo $1 | tr &quot;.&quot; &quot;\\n&quot; | tail -1` if [[ $&#123;type&#125; == &quot;c&quot; ]]; then return 0 elif [[ $&#123;type&#125; == &quot;cpp&quot; ]]; then return 1 elif [[ $&#123;type&#125; == &quot;sh&quot; ]]; then return 2 elif [[ $&#123;type&#125; == &quot;py&quot; ]]; then return 3 else exit fi&#125;File=$1Args=($@)unset Args[0]OutFile=`echo $&#123;File&#125; | tr &quot;.&quot; &quot;\\n&quot; | head -1 | tr &quot;\\n&quot; &quot;.&quot;`CheckType $&#123;File&#125;re=$?if [[ $&#123;re&#125; -eq 0 ]]; then $&#123;CC&#125; $&#123;File&#125; -o $&#123;OutFile&#125;exe &amp;&amp; time ./$&#123;OutFile&#125;exe $&#123;Args[*]&#125; &amp;&amp; rm -f $&#123;OutFile&#125;exeelif [[ $&#123;re&#125; -eq 1 ]]; then $&#123;GPP&#125; $&#123;File&#125; -o $&#123;OutFile&#125;exe &amp;&amp; time ./$&#123;OutFile&#125;exe $&#123;Args[*]&#125;&amp;&amp; rm -f $&#123;OutFile&#125;exeelif [[ $&#123;re&#125; -eq 2 ]]; then time bash $&#123;File&#125; $&#123;Args[*]&#125;else time python3 $&#123;File&#125; $&#123;Args[*]&#125;fi 保存后给run文件加上x权限chmod +x run 以后执行.c .cpp .sh .py文件时就直接run + 源文件名就可以了 安装glibc-doc 使用以下命令安装 1sudo apt install glibc-doc Vim下字体修改windows + r打开运行输入regedit 找到这个 1计算机\\HKEY_CURRENT_USER\\Console\\C:_Program Files_WindowsApps_CanonicalGroupLimited.Ubuntu20.04onWindows_2004.2021.825.0_x64__79rhkp1fndgsc_ubuntu2004.exe 这里是我更新之后的个个版本(每次更新都需要重新设置一下字体) 在右侧添加新建一个Dword键 CodePage是用来设置终端代码页的选项，65001是UTF-8，这个可以支持各种字体。这是关键。 保存，退出，再次打开Ubuntu，就可以自由的设置喜欢的字体了，连VIM也一并搞定。 自己设置的是 Cascadia Code 字体还挺好用的~ 中文设置 - 在20.04中好像时效了因为是刚刚安装的需要更新下软件源和软件包：时间可能会久点 12sudo apt updatesudo apt upgrade 安装中文语言包1sudo apt install -y language-pack-zh-hans language-pack-zh-hans-base 设置中文环境变量vi ~&#x2F;.profile 1在末尾新增一行:LANG=zh_CN.UTF-8 设置完毕重新打开ubuntu即可，部分软件及命令不支持汉化以ls命令为例： 中文设置先查找一下是否有apt-cache search language-pack-zh-hans中文包，如果没有则需要更新一下软件源。 之后执行 sudo apt install -y language-pack-zh-hans 安装中文包，需要管理员密码。 之后会提示是否安装，输入y。 安装完成会看到语言的名字。 sudo update-locale LANG&#x3D;zh_CN.UTF-8 之后看一下帮助信息，已有中文显示了。 vim设置代码文件作者信息等vim .vimrc 创建文件 vim test.c","categories":[{"name":"教程","slug":"教程","permalink":"https://tutouwang.vercel.app/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://tutouwang.vercel.app/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"并查集","slug":"基础算法/并查集","date":"2021-03-27T10:08:15.000Z","updated":"2022-05-22T15:05:06.431Z","comments":true,"path":"2021/03/27/基础算法/并查集/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/27/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集(Union Find)并查集主要讲的就是连通性问题 比如说现在咱们这个教学楼，被大水淹了比如说一楼和其它楼层都被大水淹了，就唯独咱们教室没有，可以说明什么，咱们现在就是与世隔绝了，之后呢就被大水淹没的个个楼层水是不是都可以来回走，比如流到了咱们教室恰巧关上了们，之后水就没流进来，说明什么咱们现在是与这个教学楼的一间教室都不连图，如果说咱们与隔壁是连通的，而且咱们隔壁还被大水淹没了，你说咱们这屋是不是也被淹没了。 若某个家族人员过于庞大，要判断两个是否是亲戚，确实不容易，给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。 树形结构在春秋战国时期有各种思想学术流派的成就，有 孔子 墨子 老子 还有谁比如 韩非子等等 从我们当前图中我门可以看出我们有几个连同块 有3个对把 比如说有一天 2 号 跟 4号 打起来来了说你写的东西不如我，（这里有个规定就是说徒弟一定不如师傅）完了4号本身就是1号的徒弟肯定不如2号 当然 4号有师傅 之后4号找到自己的师傅 1 号 说今天我被人羞辱了对吧那当师傅的肯定不能做事不管对吧 之后一看 说这2号也老孔的徒弟一看这不是就是一个师傅么那就别报仇了 让 4 号 给 2 号认个错 就是下次的时候我们可以怎么看 就是先知道自己的师傅的师傅是谁对吧 在看你要找的人的师傅的师傅（这师傅可能还有师傅所有要找到最后一个师傅）是谁 如果他们最后的师傅都是同一个人那他们是不是就是一家人属于同一个师傅 （可以说明他们在通一课树中说明它们俩个连同） 其实我们在连同性中不在乎连接成什么样子谁是谁的徒弟我只在乎他们能不能连同最后的祖师，祖师爷是不是同一个人 这个两个点能不能连同 Ps 比如 （1， 2） 为一个集合 数组表示 （1，4） （4，7） 这里代表两个集合链接，这里链接的时候你说是 1 当作根节点还是 4 当作根节点 1 其实是无所谓的。这里假定 4为根节点我们可以得到 图 这两个点的连同不仅仅是两个点的连同而是两个集合的连通（其实他们都属一个个体） 比如你的爸和你妈是两个姓对吧 他们在没结婚之前是什么，两个家的人就可以比作什么两个集合，之后他们结婚了 是只有他俩是一家人么 不是吧 是两家人，这就好比我们两个点的链接。 我们可以用数组表示 初始化把每个点所在的集合初始化为其自身。 初始化加粗 为下标 我们可以用用它自身去初始化（也可以用 -1 但是后期在优化的时候会有点麻烦） 0 1 2 3 0 1 2 3 4 5 6 7 4 5 6 7 0 1 2 3 0 4 2 3 4 5 6 7 4 5 6 4 竞赛阶段我们会用到的算法 find union123456789101112131415161718// 朴素int find_root(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;// 查找--优化int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x]; // return x == parent[x] ? x : parent[x] = find_root(parent[x], parent); // return parent[x] = (x == parent[x] ? x : find_root(parent[x], parent));&#125; 123456789101112131415161718192021// 合并void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; // parent[x_root] = y_root; // 原先代码 // 安秩合并 if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; return ; &#125; mark = 1; return ;&#125; 路径压缩–按秩合并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int mark = 0;// 初始化void inital(int n, int parent[], int height[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; height[i] = 0; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x]; // &#125;// 路径压缩--非递归版int find_root1(int x, int parent[]) &#123; int k = x; while (parent[k] != k) &#123; k = parent[k]; &#125; while (x != k) &#123; int temp = parent[x]; parent[x] = k; x = temp; &#125; return k;&#125;void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; // parent[x_root] = y_root; // 原先代码 // 按秩合并 if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; return ; &#125; mark = 1; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10], height[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; inital(m, parent, height); for (int i = 0; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(x, y, parent, height); &#125; if (mark) cout &lt;&lt; &quot;有环！&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;无环！&quot; &lt;&lt; endl; return 0;&#125; 路径压缩是怎么实现的 检测是否存在环我们如何去检测一个图是否存在环环路 如下 我们有 0️⃣ 1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 把每个点看成单个集合比如我们相连（0 ，1） （1，2） （1，3）（2，4）（2，3） 我们在合并时候需要先查询一下他们是否属于同一集合，如果不属于同一集合我才能合并，反之要是它们在合并就会构成回路。 如果不考虑链接红色两点，合并集合之后是{0，1，2，3，4} 我们可以得到站在任意点到达另一任意点。不构成环 如果说我们在已连接中任意选择两个去链接他一定会成环对吧。🔶 比如红色两点链接，我们可以看到 1， 2， 3 点形成了环。 形成环路 我们怎么知道他是成环了呢我们把 1 当做根结点 ，0， 2，4，3 都属于 1 的孩子或者是孙子 当你去链接 （2， 3）时候你会发现他们都属于 1 下就如我们刚才所说 🔶因为我们知道两个集合在合并的时候一定会先去找根节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int mark = 0;int parent[MAX_N + 10];// 初始化void inital(int n, int parent[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; &#125; return ;&#125;int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;void merge(int x, int y, int parent[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; parent[x_root] = y_root; return ; &#125; mark = 1; return ;&#125;int main() &#123; int n, m; // 组数 最大值 cin &gt;&gt; n &gt;&gt; m; inital(m, parent); for (int i = 0; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(x, y, parent); &#125; if (mark) cout &lt;&lt; &quot;有环！&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;无环！&quot; &lt;&lt; endl; return 0;&#125; 并查集–数据结构实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;struct UnionSet &#123; int *parent;&#125;;// 初始化UnionSet *init(int n) &#123; UnionSet *U = (UnionSet *)malloc(sizeof(UnionSet)); U-&gt;parent = (int *)malloc(sizeof(int) * (n + 1)); for (int i = 1; i &lt;= n; i++) &#123; U-&gt;parent[i] = i; &#125; return U;&#125;int find_root(UnionSet *U, int x) &#123; if (U-&gt;parent[x] != x) &#123; return find_root(U, U-&gt;parent[x]); &#125; return x;&#125;void merge(UnionSet *U, int x, int y) &#123; int x_root = find_root(U, x); int y_root = find_root(U, y); if (x_root != y_root) &#123; U-&gt;parent[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); UnionSet *U = init(n); // 进行 M 次操作 for (int i = 1; i &lt;= m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); switch(a) &#123; case 1: merge(U, b, c); break; // 合并操作 case 2: printf(&quot;%s\\n&quot;, find_root(U, b) == find_root(U, c) ? &quot;Yes&quot; : &quot;No&quot;); &#125; &#125; return 0;&#125; 例题–题解海贼 #71 朋友圈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/************************************************************************* &gt; File Name: 海贼_#71并查集_路径压缩优化.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年01月18日 星期一 15时33分00秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e4;// 初始化void initialization(int n, int parent[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;// 朴素算法int find_root1(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;void merge(int x, int y, int parent[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; parent[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; initialization(n, parent); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if (a == 1) &#123; // 添加 merge(b, c, parent); &#125; else &#123; // 查看 if (find_root(b, parent) - find_root(c, parent)) &#123; printf(&quot;No\\n&quot;); &#125; else printf(&quot;Yes\\n&quot;); &#125; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/************************************************************************* &gt; File Name: 海贼_#71并查集_路径压缩_安秩合并_优化.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年01月18日 星期一 21时33分00秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e4;// 初始化 void initialization(int n, int parent[], int height[]) &#123; for (int i = 1; i &lt;= n; i++) &#123; parent[i] = i; // 开始树高为 0 height[i] = 0; &#125; return ;&#125;// 路径压缩int find_root(int x, int parent[]) &#123; if (parent[x] != x) &#123; parent[x] = find_root(parent[x], parent); &#125; return parent[x];&#125;// 朴素算法int find_root1(int x, int parent[]) &#123; while (parent[x] != x) &#123; x = parent[x]; &#125; return x;&#125;void merge(int x, int y, int parent[], int height[]) &#123; int x_root = find_root(x, parent); int y_root = find_root(y, parent); if (x_root != y_root) &#123; if (height[x_root] == height[y_root]) &#123; parent[x_root] = y_root; // 相等让y的树高 +1 height[y_root]++; &#125; else if (height[x_root] &gt; height[y_root]) &#123; parent[y_root] = x_root; &#125; else &#123; parent[x_root] = y_root; &#125; &#125; return ;&#125;int main() &#123; int n, m, parent[MAX_N + 10], height[MAX_N + 10]; cin &gt;&gt; n &gt;&gt; m; initialization(n, parent, height); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if (a == 1) &#123; // 添加 merge(b, c, parent, height); &#125; else &#123; // 查看 if (find_root(b, parent) - find_root(c, parent)) &#123; printf(&quot;No\\n&quot;); &#125; else printf(&quot;Yes\\n&quot;); &#125; &#125; return 0;&#125; 洛谷 P1551 亲戚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;int arr[MAX_N];void initial(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; arr[i] = i; &#125;&#125;int find(int x) &#123; if (arr[x] != x) &#123; x = find(arr[x]); &#125; return arr[x];&#125;void merge(int x, int y) &#123; int x_root = find(x); int y_root = find(y); if (x_root != y_root) &#123; arr[x_root] = y_root; &#125; return ;&#125;int main() &#123; int n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; initial(n); while (m--) &#123; int mi, mj; cin &gt;&gt; mi &gt;&gt; mj; merge(mi, mj); &#125; while (p--) &#123; int mi, mj; cin &gt;&gt; mi &gt;&gt; mj; if (find(mi) == find(mj)) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://tutouwang.vercel.app/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"蓝桥杯省赛_B组组_十届","slug":"蓝桥杯题解/十届B组-真题/蓝桥杯省赛_B组组_十届","date":"2021-03-21T09:07:43.000Z","updated":"2022-01-19T02:47:14.198Z","comments":true,"path":"2021/03/21/蓝桥杯题解/十届B组-真题/蓝桥杯省赛_B组组_十届/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/21/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E8%A7%A3/%E5%8D%81%E5%B1%8AB%E7%BB%84-%E7%9C%9F%E9%A2%98/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B_B%E7%BB%84%E7%BB%84_%E5%8D%81%E5%B1%8A/","excerpt":"","text":"试题A:平方序列","categories":[{"name":"蓝桥杯历届真题","slug":"蓝桥杯历届真题","permalink":"https://tutouwang.vercel.app/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://tutouwang.vercel.app/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"排序合集","slug":"基础算法/排序合集","date":"2021-03-14T01:48:14.000Z","updated":"2021-04-03T07:38:30.808Z","comments":true,"path":"2021/03/14/基础算法/排序合集/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/","excerpt":"","text":"怎么区分稳定还是不稳定如果在原序列里面两个数是相同的，那么排完序位置没有发生变化那么 这个排序就是稳定的，如果发生变化那么这个排序就是不稳定的。 冒泡排序（稳定） 考虑冒泡排序的复杂度，对于拥有N个字母的字符串，最多需要交换 N*(N - 1) &#x2F; 2 次（完全逆序） 快速排序（不稳定）随机快速排序过程 确定分界点（也叫选择基准数）：$q[L], q[(L + R) &#x2F; 2], q[R]$ 调整区间： 递归：处理左右两端排序，如果左右两侧都排序好了在合并一起那么就是一个有序的序列了 （暴力）版 可以先开辟两个空的数组 a[] 和 b[] 在 L 到 R 区间内扫描一遍 把 &gt;&#x3D; x 和 &lt;&#x3D; x 的数拆分出来放到 a, b 数组 $q[L - R] $ $q[i] &lt;&#x3D; x, q[i] - &gt; a[]$ &#x2F;&#x2F; q[i] &lt;&#x3D; x 就它放到 a 数组里面 $q[i] &gt;&#x3D; x, q[i] -&gt; b[]$ &#x2F;&#x2F; q[i] &gt;&#x3D; x 就它放到 b 数组里面 $a[] -&gt; q[], b[]-&gt;q[]$ &#x2F;&#x2F;在把 a，b 数组数据在合并到 q 数组里面 （基础）版我们可以定义两个指针从线段两侧往中间走只要（i &lt; j) 红色i 蓝色j，如果红色指针要小于基准数那么i++, 如果红色指针要大于基准数了，那么判断j指针数是否大于基准值如果大于那么j++, 如果小于那么 交换i, j 指针。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/************************************************************************* &gt; File Name: Demo15.c &gt; Author: 秃头王 &gt; Mail: 1658339000@qq.com &gt; Created Time: 2021年03月16日 星期二 20时37分05秒 ************************************************************************/#include&lt;stdio.h&gt;#define MAX_N 100000#define swap(a, b) &#123;\\ a ^= b, b ^= a, a ^= b;\\&#125;int q[MAX_N + 10];void quick_sort(int l, int r) &#123; if (l &gt;= r) return ; // 如果下面递归左右 选的是j的话 基准指数一定不能选 q[r] 要不然回发生边界问题 int x = q[l], i = l - 1, j = r + 1; while (i &lt; j) &#123; do i++; while (q[i] &lt; x); do j--; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); &#125; // 遍历左侧 quick_sort(l, j); // 遍历右侧 quick_sort(j + 1, r); return ;&#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, q + i); &#125; quick_sort(0, n - 1); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, q[i]); &#125; return 0;&#125; 归并排序（稳定） 确定分界点 mid(L + R) &#x2F; 2 (这里的分界点是数组下标的位置)而快排是随机确定数组里面数。 递归排序左右两面。 归并（把排序好的左右两侧合并到一起）。","categories":[{"name":"算法基础","slug":"算法基础","permalink":"https://tutouwang.vercel.app/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"ACwin104_货仓选址","slug":"ACwin题解/ACwin104_货仓选址","date":"2021-03-13T09:39:11.000Z","updated":"2022-01-19T02:51:41.482Z","comments":true,"path":"2021/03/13/ACwin题解/ACwin104_货仓选址/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/13/ACwin%E9%A2%98%E8%A7%A3/ACwin104_%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80/","excerpt":"","text":"原题链接 题目：在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN。 现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。 为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。 输入格式第一行输入整数 N。 第二行 N 个整数 A1∼ AN 输出格式输出一个整数，表示距离之和的最小值。 数据范围$1≤N≤1000001≤N≤100000$$0 ≤ Ai ≤ 400000 ≤ Ai ≤ 40000$ 输入样例：1246 2 9 1 输出样例：112 解题思路:那面如何选择中位数仓库x如果当n等于奇数那么中间的数就是中位数，如果n是偶数那么现在中间两个其实一都可以。 首先考虑在坐标轴上建立仓库$x$如图 假设货仓在中间可得$|a - x| + |b - x| &gt;&#x3D; |a - b|$，$|a - x|$就是a 到 x的距离 同理 $|b - x|、 |a - b|$ 如果货仓在最左侧或者最右侧情况，那么可以看出$|x - a|$的距离就走了两遍所有放在中间才是最优解。 第一种做法：12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#define MAX_N 100000int f[MAX_N + 10];int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, f + i); &#125; std::sort(f, f + n); int res = 0; for (int i = 0; i &lt; n; i++) &#123; res += abs(f[i] - f[n &gt;&gt; 1]); &#125; printf(&quot;%d\\n&quot;, res); return 0;&#125;","categories":[{"name":"ACwin题解","slug":"ACwin题解","permalink":"https://tutouwang.vercel.app/categories/ACwin%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"中位数","slug":"中位数","permalink":"https://tutouwang.vercel.app/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"}]},{"title":"背包九讲","slug":"基础算法/背包九讲","date":"2021-03-07T04:21:06.000Z","updated":"2022-05-22T15:05:06.431Z","comments":true,"path":"2021/03/07/基础算法/背包九讲/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/07/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","excerpt":"","text":"动态规划 动态规划（Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息 学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题）， 再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归 的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少 计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查 表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 在大家看完什么是动态规划后就是说我们在之前也做题中可能也遇到过动态规划的题比如斐波那契数列 如 1，1， 2， 3… 就是这个 2 怎么来的就是 1 + 1 &#x3D; 2 之后 3 的下一项是什么？就是 2 + 3 &#x3D; 5 也就是说 3 的下一项就是 5 之后下几项就是 8，13，21…就会得到这组序列 我们如果相求第n斐波那契数列可以得到转移公式 $Fib(n) &#x3D; Fib(n - 1) + Fib(n - 2);$ (Fib(1) &#x3D; 1 和 Fib(2) &#x3D; 1是由题目给出的，n &gt; 2 ) 完整的斐波那契数列 加上出口就是 n &#x3D; 1 or n &#x3D; 2 返回 1 , 就是说我们这里为什么提出这个斐波那契数列呢就是我们在递归时候，我们呢会发现他的递归式中会出现重叠的子问题，为什么会这么说我来计算一下斐波那契数列 第 5 项 Fib(5) 可得出如下 假如说我们用数组去求解Fib(6) 是不就可以直接用之前求Fib(5) + Fib(4) 的 直接得到 Fib(6) 这样我是不是就可以省去求重叠子问题的时间，这样我们的时间复杂度就从o(2^n^) 变成 o(n)(当然这个时间复杂度也是能弄记忆化搜索优化的)。 例题 01 背包 只又 2 种选择一种选一种不选。 洛谷 P1048 采药 完全背包 每件物品可以无限选（只要不超过背包的总体积）。 洛谷 P1616 疯狂的采药 多重背包 每个物品有相应的个数。 洛谷 P1776 宝物筛选 混合背包 基于以上上面三种背包。 洛谷 P1833 樱花 二维费用背包 类比以一维费用01背包，推广二维费用01背包。 洛谷 P1507 NASA的食物计划 分组背包 有 n 组物品 每组物品有若干个，同一组内互相冲突，同一组最多只能选一个或者不选 洛谷 P1757 通天之分组背包 有依赖的背包 类似捆绑销售 买附必须买主，买主可以不买附 洛谷 P1064 金明的预算方案 背包九讲0-1背包题目：有一天小鲁同学在家里学习算法，小鲁的妈妈就叫这个铲屎官小鲁去收拾一下，但是小鲁很不想去就说我在学习算法，小鲁的妈妈就说你要是在不去我就把你一起也铲出去，小鲁就想被你铲除去还不如我自己走，这样小鲁就回到了自己的房间，打破了储存已久的小猪储存罐🐖。 小鲁的背包可容纳下总重量为 20（ s ） 他需要带尽可能多的钱走。（没种钱可以重复的选取没有上限）。 简单的说： 有N件物品和一个容量为T的背包。第i件物品的费用是t[i]，价值是v[i]。求解将哪些物品装入背包可使价值总和最大。 下标 重量（w） 价值 （v） 1 2 3 2 3 4 3 4 5 4 5 8 5 9 10 这里为什么不用贪心而用动态规划？ 首先贪心他是局部最优解，而我所讲的动态规划可以达到全局最优解。 基本思路： 首先我们考虑什么，取不取第 n 件物品？ 取 $-&gt; n - 1$ 个物品，背包大小 $s - w[n]$ 不取$ -&gt; n - 1$ 个物品，背包大小 s 定义状态：$dp[i][j]$ 表示考虑前 i 个物品，背包大小 $0 -&gt; j $, 获得最大价值。 转移方程：$dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])$ 代码实现：无优化-代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;#define MAX_N 1000int dp[MAX_N + 10][MAX_N + 10];int t[MAX_N + 10], v[MAX_N + 10];void backpack(int k, int T) &#123; for (int i = 1; i &lt;= k; i++) &#123; for (int j = 1; j &lt;= T; j++) &#123; if (t[i] &gt; j) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; int Y = dp[i - 1][j - t[i]] + v[i]; int T = dp[i - 1][j]; dp[i][j] = Y &gt; T ? Y : T; // dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); &#125; &#125; &#125;&#125;int main() &#123; int T, n; cin &gt;&gt; T &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; t[i] &gt;&gt; v[i]; &#125; backpack(n, T); cout &lt;&lt; dp[n][T];&#125; 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;const int MAX_N = 1e3;int n, m;int f[MAX_N + 10][MAX_N + 10], w[MAX_N + 10], v[MAX_N + 10];int main() &#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; w[i] &gt;&gt; v[i]; &#125; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; f[i][j] = f[i - 1][j]; if(j &gt;= w[i]) f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]); &#125; &#125; cout &lt;&lt; f[m][n] &lt;&lt; endl; return 0;&#125; 优化-代码12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;#define MAX_N 1000int dp[MAX_N];int T[MAX_N], V[MAX_N];void backpack(int k, int s) &#123; for (int i = 1; i &lt;= k; i++) &#123; for (int j = s; j &gt;= T[i]; j--) &#123; dp[j] = max(dp[j], dp[j - T[i]] + V[i]); &#125; &#125; return ;&#125;int main() &#123; int t, n; cin &gt;&gt; t &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; T[i] &gt;&gt; V[i]; &#125; backpack(n, t); cout &lt;&lt; dp[t]; return 0;&#125; 上面朴素算法时间复杂度与空间复杂度皆为 O(t*n) 其中时间复杂度不能再优化, 而空间复杂度可以 优化为O(t), 下面我们来讲解如何优化到一维数组 细节问题 1 我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。如果是第一种问法，要求恰好装满背包，那么在初始化时除了f[0]为0其它f[1..V]均设为-∞，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。 2 如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f[0..V]全部设为0。为什么呢？ 3 可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的（相当于没装东西），其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。这个小技巧完全可以推广到其它类型的背包问题，后面也就不再对进行状态转移之前的初始化进行讲解。 完全背包题目：有N种物品和一个容量为T的背包，每种物品都有无限件可用。第i种物品的费用是t[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路：和 01背包很相似 转移方程相同 转移方程：$dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])$ 与 01背包的区别–第二个循环 01背包 在更新时候倒序因为是需要用之前元素 代码实现：无优化-代码123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e4;long long dp[MAX_N + 10][MAX_N +10];long long t[MAX_N + 10], v[MAX_N + 10];void backpack(int k, int s) &#123; for (int i = 1; i &lt;= k; i++) &#123; for (int j = 1; j &lt;= s; j++) &#123; if (j &lt; t[i]) dp[i][j] = dp[i - 1][j]; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - t[i]] + v[i]); &#125; &#125; &#125; return ;&#125;int main() &#123; int T, n; cin &gt;&gt; T &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; t[i] &gt;&gt; v[i]; &#125; backpack(n, T); cout &lt;&lt; dp[n][T] &lt;&lt; endl; return 0;&#125; 优化-代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e7;long long B[MAX_N + 10];int t[MAX_N + 10], v[MAX_N + 10];void backpack(int k, int s) &#123; for (int i = 1; i &lt;= k; i++) &#123; for (int j = t[i]; j &lt;= s; j++) &#123; B[j] = max(B[j], B[j - t[i]] + v[i]); &#125; &#125; return ;&#125;int main() &#123; int T, n; cin &gt;&gt; T &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; t[i] &gt;&gt; v[i]; &#125; backpack(n, T); cout &lt;&lt; B[T] &lt;&lt; endl; return 0;&#125; 多重背包题目：有N种物品和一个容量为s的背包。第i种物品最多有m[i]件可用，每件费用是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路：这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有m[i]+1种策略：取0件，取1件……取n[i]件。令f[i][j]表示前i种物品恰放入一个容量为v的背包的最大权值。 则转移方程： $dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - k * w] + k * v);$ 代码实现：无优化-代码1234567891011121314151617181920212223242526// 多重背包 朴素 算法#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e3;int dp[MAX_N + 10][MAX_N + 10];int main() &#123; int n, s; cin &gt;&gt; n &gt;&gt; s; for (int i = 1; i &lt;= n; i++) &#123; // 价值 重量 组数 int v, w, m; cin &gt;&gt; v &gt;&gt; w &gt;&gt; m; for (int j = s; j &gt;= w; j--) &#123; // 背包容量 for (int k = 0; k &lt;= m &amp;&amp; j &gt;= k * w; k++) &#123; // 决策 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * w] + k * v); &#125; &#125; &#125; cout &lt;&lt; dp[n][s] &lt;&lt; endl; return 0;&#125; 转化为01背包问题 另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成log(m)件01背包中的物品. 但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想. 二进制优化 假设有50个苹果，现在要取n个苹果(n≤50），如何取?朴素的做法应该是将苹果一个一个拿出来，直到n个苹果被取出来。再假设有50个苹果和6只箱子，利用箱子进行某些预备工作，可以在每个箱子中放2(k≥0)个苹果，也就是1、2、4、8、16、19（剩余的数），取任意n个苹果时，只要推出忆只箱子就可以了。 lg45÷lg2&#x3D;1.6532125÷0.301029996&#x3D;5.49185 优化-代码123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e5;int dp[MAX_N + 10];int ww[MAX_N + 10], vv[MAX_N + 10], mm[MAX_N + 10];int main () &#123; int n, s, count = 1, v, w, m; cin &gt;&gt; n &gt;&gt; s; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v &gt;&gt; w &gt;&gt; m; for (int j = 1; j &lt;= m; j &lt;&lt;= 1) &#123; ww[count] = j * w; vv[count++] = j * v; m -= j; &#125; // 处理 二进制拆分不了的 if (m) &#123; ww[count] = m * w; vv[count++] = m * v; &#125; &#125; // 01 背包 模板 for (int i = 1; i &lt; count; i++) &#123; for (int j = s; j &gt;= ww[i]; j--) &#123; dp[j] = max(dp[j], dp[j - ww[i]] + vv[i]); &#125; &#125; cout &lt;&lt; dp[s] &lt;&lt; endl; return 0;&#125; 混合背包题目：如果将 01背包、完全背包、多重背包、混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背1包）。应该怎么求解呢？ 基本思路： 01背包与完全背包的混合 我只需要考虑到在01背包和完全背包中给出的代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可. 12345678if // 如果是 01 背包 for (int j = s; j &gt;= w[i] j--) &#123; dp[j] = max(dp[j], dp[j - w[i]] + v[i]); &#125;else // 如果是 完全背包 for (int j = w[i]; j &lt;= s; j++) &#123; dp[j] = max(dp[j], dp[j - w[i]] + v[i]); &#125; 再加上多重背包 如果再加上有的物品最多可以取有限次，我们就可以用二进制拆分来把多重背包转换成01背包 1234567891011// m = 物品最多能取的个数for (int j = 1; j &lt;= m; j &lt;&lt;= 1) &#123; ww[count] = j * w; vv[count++] = j * v; m -= j;&#125;// 处理 二进制拆分不了的if (m) &#123; ww[count] = m * w; vv[count++] = m * v;&#125; 题解-代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e5;int dp[MAX_N + 10], ww[MAX_N + 10], vv[MAX_N + 10], mark[MAX_N + 10];int main() &#123; int T, t1, t11, t2, t22, n, count = 1; scanf(&quot;%d:%d %d:%d %d&quot;, &amp;t1, &amp;t11, &amp;t2, &amp;t22, &amp;n); T = (t2 * 60 + t22) - (t1 * 60 + t11); for (int i = 1; i &lt;= n; i++) &#123; int w, v, m; cin &gt;&gt; w &gt;&gt; v &gt;&gt; m; if (!m) &#123; ww[count] = w; vv[count] = v; // 标记为 0 代表可以重复观看 完全背包 mark[count++] = 0; &#125; else &#123; // 二进制拆分转换 01背包 for (int j = 1; j &lt;= m; j &lt;&lt;= 1) &#123; ww[count] = j * w; vv[count] = j * v; // 标记为 1 代表每棵树只能看或者不看 01背包 mark[count++] = 1; m -= j; &#125; // 因为二进制拆分 只能是 1 2 4 8 16 32 比如 m = 10 二进制拆分之后还会余下 1 下面 if 就是解决那个多余出来的 if (m) &#123; ww[count] = m * w; vv[count] = m * v; mark[count++] = 1; &#125; &#125; &#125; // 实现 01背包 和 完全背包 模板就行了 for (int i = 1; i &lt; count; i++) &#123; if (mark[i]) &#123; // 如果 mark[i] == 1 就执行 01背包 for (int j = T; j &gt;= ww[i]; j--) &#123; dp[j] = max(dp[j], dp[j - ww[i]] + vv[i]); &#125; &#125; else &#123; for (int j = ww[i]; j &lt;= T; j++) &#123; dp[j] = max(dp[j], dp[j - ww[i]] + vv[i]); &#125; &#125; &#125; cout &lt;&lt; dp[T] &lt;&lt; endl; return 0;&#125; 二维费用背包题目：二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和Q。物品的价值为v[i]。 基本思路：费用加了一维，只需状态也加一维即可。设dp[i][j][k]表示前i件物品付出两种代价分别为m和w时可获得的最大价值。 状态转移方程就是：$f [i][j][k]&#x3D;max{f[i-1][j][k],f[i-1][f-a[i]][k-b[i]]+v[i]}$。 如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量m和w采用顺序的循环。 大概就是 由一维01背包费用推广二维01背包费用还可以推广三维，四维，…..N维。 当物品有如完全背包问题时采用逆序的循环。 当物品有如多重背包问题时拆分物品。 题解-代码：1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;const int MAX_N = 1e3;int dp[MAX_N + 10][MAX_N + 10];int main() &#123; int V, Q, n; cin &gt;&gt; V &gt;&gt; Q &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; int m, w, v; cin &gt;&gt; m &gt;&gt; w &gt;&gt; v; for (int j = V; j &gt;= m; j--) &#123; for (int k = Q; k &gt;= w; k--) &#123; dp[j][k] = max(dp[j][k], dp[j - m][k - w] + v); &#125; &#125; &#125; cout &lt;&lt; dp[V][Q] &lt;&lt; endl; return 0;&#125; 分组的背包问题题目：有N件物品和一个容量为S的背包。第i件物品的费用是w[i]，价值是v[i]，组别g[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件或者不选,如果同属于v[i]组一共有m个那最多就有m + 1种选法。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路：$dp[i][j]$ 表前 i 组物品，能放下容量为j的背包的最大价值。 朴素算法 对第 i 组物品，容量为 j 的背包，有 m + 1种选法。 $max(dp[i-1][j], dp[i - 1][j - w[1]], dp[i - 1][j - w[2]]…dp[i - 1][j - w[m]])$ 这里基本就是01背包模板直接用01背包优化版的板子就可以了。 题解-代码：123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e3;int dp[MAX_N + 10];int w[MAX_N + 10], v[MAX_N + 10], g[MAX_N + 10], gg[MAX_N + 10][MAX_N + 10];int main() &#123; int n, s, nn = 0; cin &gt;&gt; s &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; int t; scanf(&quot;%d%d%d&quot;, &amp;w[i], &amp;v[i], &amp;t); nn = max(t, nn); g[t]++; gg[t][g[t]] = i; &#125; // 枚举 nn 个组 for (int i = 1; i &lt;= nn; i++) &#123; for (int j = s; j &gt;= 0; j--) &#123; // 背包容量 for (int k = 0; k &lt;= g[i]; k++) &#123; // 决策 if (j &gt;= w[gg[i][k]]) // 不选从 k - 1 个物品中选择一个价值最大的 dp[j] = max(dp[j], dp[j - w[gg[i][k]]] + v[gg[i][k]]); &#125; &#125; &#125; cout &lt;&lt; dp[s] &lt;&lt; endl; return 0;&#125; 问背包容量与决策循环是否可以调换？ 不能 因为更新$dp[j]$时用到$dp[i][j - w[k]]$的值，$dp[j- w[k]]$与$dp[i-1][j-w[k]]$ 有依赖的背包基本思路：这种背包问题的物品间存在某种“依赖”的关系。也就是说，物品 i 依赖于物品 j， 表示若选物品 i，则必须选物品 j。为了简化起见，我们先设没有某个物品既依赖于别 的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。 这个问题由 NOIP2006 中“金明的预算方案”一题扩展而来。遵从该题的提法，将 不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题 的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。 就好比如 你大一学的c\\c++语言完了大二才能学数据结构，就是你不能直接学数据结构要先学完c\\c++这就是依赖关系 可看上面例题 看题, 我们在选择时候会有5种情况： 选或者不选 选 、只选这个主件 不选、直接考虑下一个 选这个主件 选这个主件、并且选附件1 选这个主件、并且选附件2 选这个主件、 并且选附件1和附件2 例题-代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int MAX_N = 1e6;int dp[MAX_N + 10];int w[MAX_N + 10], v[MAX_N + 10], g[MAX_N + 10][3], mark[MAX_N + 10];int main() &#123; int n, s; scanf(&quot;%d%d&quot;, &amp;s, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int p, q; scanf(&quot;%d%d%d&quot;, &amp;w[i], &amp;p, &amp;q); mark[i] = q; v[i] = w[i] * p; if (q) &#123; g[q][0]++; g[q][g[q][0]] = i; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if(mark[i] != 0) continue; for (int j = s; j &gt;= w[i]; j--) &#123; // 1、不选 或者 只选择主件 dp[j] = max(dp[j], dp[j - w[i]] + v[i]); // 2、选择第一个附件 if (j &gt;= w[g[i][1]] + w[i] &amp;&amp; g[i][1] != 0) &#123; dp[j] = max(dp[j], dp[j - w[i] - w[g[i][1]]] + v[i] + v[g[i][1]]); &#125; // 3、选择第二个附件 if (j &gt;= w[g[i][2]] + w[i] &amp;&amp; g[i][2] != 0) &#123; dp[j] = max(dp[j], dp[j - w[i] - w[g[i][2]]] + v[i] + v[g[i][2]]); &#125; // 4、两个附件都选 if (j &gt;= w[g[i][1]] + w[g[i][2]] + w[i] &amp;&amp; g[i][1] != 0 &amp;&amp; g[i][2] != 0) &#123; dp[j] = max(dp[j], dp[j - w[i] - w[g[i][1]] - w[g[i][2]]] + v[i] + v[g[i][1]]+ v[g[i][2]]); &#125; &#125; &#125; cout &lt;&lt; dp[s] &lt;&lt; endl; return 0;&#125; 泛化物品 (了解)定义考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的 费用而变化。这就是泛化物品的概念。 更严格的定义之。在背包容量为 V 的背包问题中，泛化物品是一个定义域为 0 . . . V 中的整数的函数 h，当分配给它的费用为 v 时，能得到的价值就是 h(v)。 这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组 h[0 . . . V ]，给它 费用 v，可得到价值 h[v]。 一个费用为 c 价值为 w 的物品，如果它是 01 背包中的物品，那么把它看成泛化物 品，它就是除了 h(c) &#x3D; w 外，其它函数值都为 0 的一个函数。如果它是完全背包中的 物品，那么它可以看成这样一个函数，仅当 v 被 c 整除时有 h(v) &#x3D; w · v c，其它函数值 均为 0。如果它是多重背包中重复次数最多为 m 的物品，那么它对应的泛化物品的函 数有 h(v) &#x3D; w · v c 仅当 v 被 c 整除且 v c ≤ n，其它情况函数值均为 0。 一个物品组可以看作一个泛化物品 h。对于一个 0 . . . V 中的 v，若物品组中不存在 费用为 v 的物品，则 h(v) &#x3D; 0，否则 h(v) 取值为所有费用为 v 的物品的最大价值。6中 每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。 视频","categories":[{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tutouwang.vercel.app/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"蓝桥杯省赛 B组 十一届 第二场","slug":"蓝桥杯题解/十一届B组-真题/蓝桥杯省赛_B组_十一届_第二场","date":"2021-03-06T04:21:06.000Z","updated":"2022-05-22T15:05:06.430Z","comments":true,"path":"2021/03/06/蓝桥杯题解/十一届B组-真题/蓝桥杯省赛_B组_十一届_第二场/","link":"","permalink":"https://tutouwang.vercel.app/2021/03/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E8%A7%A3/%E5%8D%81%E4%B8%80%E5%B1%8AB%E7%BB%84-%E7%9C%9F%E9%A2%98/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B_B%E7%BB%84_%E5%8D%81%E4%B8%80%E5%B1%8A_%E7%AC%AC%E4%BA%8C%E5%9C%BA/","excerpt":"","text":"蓝桥杯省赛 B组 十一届 第二场试题A:门牌制作 答案：624 1234567891011121314151617181920212223242526/************************************************************************* &gt; File Name: 十一届—试题A门牌制作.cppz &gt; Author: &gt; Mail: &gt; Created Time: 2021年02月28日 星期日 16时31分53秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;const int MAX_N = 2020;int f[MAX_N + 10];int main() &#123; int n = 0; for (int i = 1; i &lt;= 2020; i++) &#123; int t = i; while (t) &#123; if (t % 10 == 2) n++; t /= 10; &#125; &#125; cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; 试题B:既约分数 答案：2481215 12345678910111213141516171819202122 /************************************************************************* &gt; File Name: 十一届—试题B既约分数.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年02月28日 星期日 19时46分32秒 ************************************************************************/#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n = 0; for (int i = 1; i &lt;= 2020; i++) &#123; for (int j = 1; j &lt;= 2020; j++) &#123; if(__gcd(i, j) == 1) n++; &#125; &#125; cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; 试题C:蛇形填数 题解思路：有题目可以得出， 红色偶数是斜着向下，蓝色奇数是斜着向上由此可以写出代码。 答案：761 123456789101112131415161718192021222324252627282930313233343536/************************************************************************* &gt; File Name: 蛇形填数.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年02月28日 星期日 20时08分21秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;const int MAX_N = 40;int f[MAX_N][MAX_N];int main() &#123; int n = 1; for (int i = 1; i &lt;= MAX_N; i++) &#123; if (i &amp; 1) &#123; // 奇数的情况 for (int x = i, y = 1; x &gt;= 1 &amp;&amp; y &lt;= i; x--, y++) &#123; f[x][y] = n++; &#125; &#125; else &#123; for (int x = 1, y = i; x &lt;= i &amp;&amp; y &gt;= 1; x++, y--) &#123; f[x][y] = n++; &#125; &#125; &#125; for (int i = 1; i &lt;= 20; i++) &#123; for (int j = 1; j &lt;= 20; j++) &#123; cout &lt;&lt; f[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 试题D:跑步锻炼 答案：8879 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/************************************************************************* &gt; File Name: 跑步锻炼.cpp &gt; Author: &gt; Mail: &gt; Created Time: 2021年03月01日 星期一 13时00分05秒 ************************************************************************/#include &lt;iostream&gt;using namespace std;// 列出所有月份之后 在特殊处理 2 月int m[13] = &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;int leap_year(int x) &#123; if ((x % 4 == 0 &amp;&amp; x % 100 != 0) || x % 400 == 0) return 1; return 0;&#125;int main() &#123; int s = 0; int mark = 6; // 这里题目给出 2000 年 至 2020 年 因为题目给出 2020年不是整月所以就单处理一下 for (int i = 2000; i &lt; 2020; i++) &#123; if (leap_year(i)) m[2] = 29; else m[2] = 28; for (int j = 1; j &lt;= 12; j++) &#123; for (int k = 1; k &lt;= m[j]; k++) &#123; if (mark % 7 == 1 || k == 1) s += 2; else s++; mark++; &#125; &#125; &#125; // 闰年 29 平年 28 if (leap_year(2020)) m[2] = 29; else m[2] = 28; for (int i = 1; i &lt;= 9; i++) &#123; for (int j = 1; j &lt;= m[i]; j++) &#123; if (mark % 7 == 1 || j == 1) s += 2; else s++; mark++; &#125; &#125; // 题目要求 只道 10 月 1 日 由于还是 月初 所以加上 + 2 cout &lt;&lt; s + 2; return 0;&#125; 试题E:七段码 答案：80 来源于网上一个大佬 枚举出所有情况的做法 $$上面是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一 个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分$$ 试题F:成绩统计 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main() &#123; int n; int E = 0, G = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; int t; cin &gt;&gt; t; if (t &gt; 60) G++; if (t &gt; 85) E++; &#125; int t = E * 100.0 / n + 0.5; int t1 = G * 100.0 / n + 0.5; printf(&quot;%d%%\\n%d%%&quot;, t1, t); return 0;&#125;","categories":[{"name":"蓝桥杯历届真题","slug":"蓝桥杯历届真题","permalink":"https://tutouwang.vercel.app/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://tutouwang.vercel.app/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]}],"categories":[{"name":"Linux-多线程开放","slug":"Linux-多线程开放","permalink":"https://tutouwang.vercel.app/categories/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/"},{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"c++OOP","slug":"c-OOP","permalink":"https://tutouwang.vercel.app/categories/c-OOP/"},{"name":"LInux-系统编程入门","slug":"LInux-系统编程入门","permalink":"https://tutouwang.vercel.app/categories/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"},{"name":"基础数据结构","slug":"基础数据结构","permalink":"https://tutouwang.vercel.app/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++\\OOP","slug":"C-OOP","permalink":"https://tutouwang.vercel.app/categories/C-OOP/"},{"name":"教程","slug":"教程","permalink":"https://tutouwang.vercel.app/categories/%E6%95%99%E7%A8%8B/"},{"name":"蓝桥杯历届真题","slug":"蓝桥杯历届真题","permalink":"https://tutouwang.vercel.app/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98/"},{"name":"算法基础","slug":"算法基础","permalink":"https://tutouwang.vercel.app/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"ACwin题解","slug":"ACwin题解","permalink":"https://tutouwang.vercel.app/categories/ACwin%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"有趣的知识","slug":"有趣的知识","permalink":"https://tutouwang.vercel.app/tags/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/"},{"name":"Linux","slug":"Linux","permalink":"https://tutouwang.vercel.app/tags/Linux/"},{"name":"[object Object]","slug":"object-Object","permalink":"https://tutouwang.vercel.app/tags/object-Object/"},{"name":"LInux","slug":"LInux","permalink":"https://tutouwang.vercel.app/tags/LInux/"},{"name":"排序","slug":"排序","permalink":"https://tutouwang.vercel.app/tags/%E6%8E%92%E5%BA%8F/"},{"name":"广义表转二叉树","slug":"广义表转二叉树","permalink":"https://tutouwang.vercel.app/tags/%E5%B9%BF%E4%B9%89%E8%A1%A8%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"树与二叉树","slug":"树与二叉树","permalink":"https://tutouwang.vercel.app/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"栈与队列","slug":"栈与队列","permalink":"https://tutouwang.vercel.app/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"name":"链表","slug":"链表","permalink":"https://tutouwang.vercel.app/tags/%E9%93%BE%E8%A1%A8/"},{"name":"顺序表","slug":"顺序表","permalink":"https://tutouwang.vercel.app/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"},{"name":"教程","slug":"教程","permalink":"https://tutouwang.vercel.app/tags/%E6%95%99%E7%A8%8B/"},{"name":"并查集","slug":"并查集","permalink":"https://tutouwang.vercel.app/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"基础算法","slug":"基础算法","permalink":"https://tutouwang.vercel.app/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://tutouwang.vercel.app/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"中位数","slug":"中位数","permalink":"https://tutouwang.vercel.app/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tutouwang.vercel.app/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]}