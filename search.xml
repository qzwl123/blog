<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IO多路复用</title>
      <link href="2022/07/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
      <url>2022/07/01/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-I-x2F-O多路复用（I-x2F-O多路转接）"><a href="#1-I-x2F-O多路复用（I-x2F-O多路转接）" class="headerlink" title="1. I&#x2F;O多路复用（I&#x2F;O多路转接）"></a>1. I&#x2F;O多路复用（I&#x2F;O多路转接）</h2><p>I&#x2F;O 多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能，Linux 下实现 I&#x2F;O 多路复用的 系统调用主要有 select、poll 和 epoll。</p><h2 id="IO多路复用图解"><a href="#IO多路复用图解" class="headerlink" title="IO多路复用图解"></a>IO多路复用图解</h2><h3 id="阻塞-BIO模型"><a href="#阻塞-BIO模型" class="headerlink" title="阻塞 BIO模型"></a>阻塞 BIO模型</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220701112457144.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220701112457144.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220701112457144"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220701112504556.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220701112504556.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220701112504556"></p><h3 id="非阻塞，忙轮询"><a href="#非阻塞，忙轮询" class="headerlink" title="非阻塞，忙轮询"></a>非阻塞，忙轮询</h3><blockquote><p>accept() &#x2F;&#x2F; 不断的检测客户的连接 - 不阻塞 </p><p>read() &#x2F;&#x2F; 不断的循环 - 不阻塞 </p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220701112632841.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220701112632841.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220701112632841"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220701114725894.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220701114725894.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220701114725894"></p><h3 id="IO多路转接技术-select-x2F-poll-epoll"><a href="#IO多路转接技术-select-x2F-poll-epoll" class="headerlink" title="IO多路转接技术 - select&#x2F;poll - epoll"></a>IO多路转接技术 - select&#x2F;poll - epoll</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220701114811065.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220701114811065.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220701114811065"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220701120108819.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220701120108819.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220701120108819"></p><h2 id="2-select"><a href="#2-select" class="headerlink" title="2.  select"></a>2.  select</h2><blockquote><p>主旨思想:</p><p>​1 .首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。</p><p>​2. 调用系统函数(select), 监听该列表中的文件描述符,直到这些描述符中的一个或者多个进行I\O操作时, 该函数才会返回</p><p>​a. 这个函数是阻塞的</p><p>​b. 函数对文件描述符的检测的操作是由内核完成</p><p>​3. 在返回时, 它会告诉进程有多少(哪些)描述符要进行I&#x2F;O操作</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sizeof(fd_set) = 128位1024 (bt位)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line">- 参数:</span><br><span class="line">- nfds: 委托内核的检测最大文件描述符的值 + <span class="number">1</span></span><br><span class="line">- readfds: 要检测的文件描述符的读的集合,委托内核检测哪些文件描述符的读的属性</span><br><span class="line">- 一班检测读操作</span><br><span class="line">             - 对应的是对方发送来的数据, 因为读被的接收数据, 检测的就是读缓冲区</span><br><span class="line">             - 是一个传入传出参数 </span><br><span class="line">- writefds: 要检测的文件描述符的写的集合, 委托内核检测哪些文件描述符的写的属性</span><br><span class="line">- 委托内核检测写缓存区是不是还可以写数据 (不满就可以写)</span><br><span class="line">- exceptfds: 检测发生异常的文件描述符的集合</span><br><span class="line">- timeout:  要设置的超时时间</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeout</span> &#123;</span></span><br><span class="line">                <span class="keyword">long</span> tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line">                <span class="keyword">long</span> tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">            &#125;</span><br><span class="line">- 值为 <span class="literal">NULL</span>: 永久阻塞, 直到检测到了文件描述符的变化</span><br><span class="line">- tv_sec = <span class="number">0</span>, tv_usec: = <span class="number">0</span> : 表示不阻塞</span><br><span class="line">- tv_sec &gt; <span class="number">0</span>, tv_usec: &gt; <span class="number">0</span> : 阻塞对应的时间</span><br><span class="line">- 返回值:</span><br><span class="line">- <span class="number">-1</span>: 失败</span><br><span class="line">             - &gt;<span class="number">0</span> (n): 检测的集合中n个文件描述符发生了变化</span><br><span class="line">               </span><br><span class="line"><span class="comment">// 将参数文件描述符fd对应的标志位设置为0</span></span><br><span class="line"><span class="keyword">void</span> FD_CLR(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line"><span class="comment">// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">// 将参数文件描述符fd 对应的标志位，设置为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">// fd_set一共有1024 bit, 全部初始化为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>; </span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220701222536002.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220701222536002.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220701222536002"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220702164919541.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220702164919541.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220702164919541"></p><h3 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: select.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年07月02日 星期六 11时52分50秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET,SOCK_STREAM ,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = <span class="number">0</span>; <span class="comment">// INADDR_ANY</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">5200</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个fd_set的集合, 存放的是需要检测的文件描述符</span></span><br><span class="line"></span><br><span class="line">    fd_set rdset, tmp;</span><br><span class="line">    FD_ZERO(&amp;rdset);</span><br><span class="line">    FD_SET(lfd, &amp;rdset);</span><br><span class="line">    <span class="keyword">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        tmp = rdset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用select系统函数, 让内核帮忙检测哪些文件描述符有数据</span></span><br><span class="line">        ret = select(maxfd + <span class="number">1</span>, &amp;tmp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置的超时时间到了, 返回值才是, 才会执行, 设置的为NULL之 后检测到消息才会不阻塞</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(lfd, &amp;tmp)) &#123;</span><br><span class="line">                <span class="comment">// 检测有新客户端连接进来了</span></span><br><span class="line">                <span class="comment">// 接受连接</span></span><br><span class="line">                struct sockaddr_in cliaddr;</span><br><span class="line">                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">                <span class="keyword">char</span> cliIP[<span class="number">16</span>];</span><br><span class="line">                <span class="keyword">int</span> cliport = ntohs(cliaddr.sin_port);</span><br><span class="line">                inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIP, <span class="keyword">sizeof</span>(cliIP));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;client IP : %s, prok %d\n&quot;</span>, cliIP, cliport);</span><br><span class="line">                <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新新的文件描述符加入的集合中</span></span><br><span class="line">                FD_SET(cfd, &amp;rdset);</span><br><span class="line">                <span class="comment">// 更新最大文件描述符</span></span><br><span class="line">                maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = lfd + <span class="number">1</span>; i &lt;= maxfd; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(FD_ISSET(i, &amp;tmp)) &#123;</span><br><span class="line">                    <span class="comment">// 说明这个文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">int</span> len = read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed ... ...\n&quot;</span>);</span><br><span class="line">                        FD_CLR(i, &amp;rdset);</span><br><span class="line">                        close(i);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                        write(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="client-c"><a href="#client-c" class="headerlink" title="client.c"></a>client.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: client.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年06月23日 星期四 14时41分42秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// TCP 通信客户端</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">        <span class="keyword">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.连接服务</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">        serveraddr.sin_family = AF_INET;</span><br><span class="line">        serveraddr.sin_port = htons(<span class="number">5200</span>);</span><br><span class="line">        inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">        <span class="keyword">int</span> ret = connect(fd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通信</span></span><br><span class="line">        <span class="keyword">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> data[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">                <span class="comment">// 获取标准输入(stdin)的数据</span></span><br><span class="line">                fgets(data, <span class="keyword">sizeof</span>(data), <span class="built_in">stdin</span>);</span><br><span class="line">                write(fd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">                <span class="keyword">int</span> readLen = read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(readLen == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(readLen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(readLen == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 表示服务端断开连接</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;server closed ... ...\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        close(fd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-poll"><a href="#3-poll" class="headerlink" title="3.poll"></a>3.poll</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> fd; <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line"><span class="keyword">short</span> events; <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line"><span class="keyword">short</span> revents; <span class="comment">/* 文件描述符实际发生的事件 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>;</span></span><br><span class="line">myfd.fd = <span class="number">5</span>;</span><br><span class="line">myfd.events = POLLIN | POLLOUT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">- 参数：</span><br><span class="line">- fds : 是一个<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> 结构体数组，这是一个需要检测的文件描述符的集合</span></span><br><span class="line"><span class="class">- <span class="title">nfds</span> :</span> 这个是第一个参数数组中最后一个有效元素的下标 + <span class="number">1</span></span><br><span class="line">- timeout : 阻塞时长(毫秒)</span><br><span class="line"><span class="number">0</span> : 不阻塞</span><br><span class="line"><span class="number">-1</span> : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</span><br><span class="line">&gt;<span class="number">0</span> : 阻塞的时长</span><br><span class="line">- 返回值：</span><br><span class="line"><span class="number">-1</span> : 失败</span><br><span class="line">&gt;<span class="number">0</span>（n） : 成功,n表示检测到集合中有n个文件描述符发生变化</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220702180026781.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220702180026781.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220702180026781"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220702215413782.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220702215413782.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220702215413782"></p><h3 id="poll-server-c"><a href="#poll-server-c" class="headerlink" title="poll_server.c"></a>poll_server.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: select.c</span></span><br><span class="line"><span class="comment">&gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">&gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">&gt; Created Time: 2022年07月02日 星期六 11时52分50秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET,SOCK_STREAM ,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; --- %d ---\n&quot;</span>, lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = <span class="number">0</span>; <span class="comment">// INADDR_ANY</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">5200</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">8</span>);    </span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化检测文件描述符数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1024</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[<span class="title">MAX_N</span>];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_N; ++i) &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line">    <span class="keyword">int</span> nfds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用poll系统函数, 让内核帮忙检测哪些文件描述符有数据</span></span><br><span class="line">       ret = poll(fds, nfds + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置的超时时间到了, 返回值才是, 才会执行, 设置的为NULL之后检测到消息才会不阻塞</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="comment">// 不能用 ==  </span></span><br><span class="line">            <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="comment">// 检测有新客户端连接进来了</span></span><br><span class="line">                <span class="comment">// 接受连接</span></span><br><span class="line">                struct sockaddr_in cliaddr;</span><br><span class="line">                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">                <span class="keyword">char</span> cliIP[<span class="number">16</span>];</span><br><span class="line">                <span class="keyword">int</span> cliport = ntohs(cliaddr.sin_port);</span><br><span class="line">                inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIP, <span class="keyword">sizeof</span>(cliIP));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;client IP : %s, prok : %d fd : %d\n&quot;</span>, cliIP, cliport, cfd);</span><br><span class="line">                <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新新的文件描述符加入的集合中</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAX_N; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(fds[i].fd != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    fds[i].fd = cfd;</span><br><span class="line">                    fds[i].events = POLLIN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新最大文件描述符</span></span><br><span class="line">                nfds = nfds &gt; cfd ? nfds : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nfds; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                    <span class="comment">// 说明这个文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">int</span> len = read(fds[i].fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed ... ...\n&quot;</span>);</span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                        close(fds[i].fd);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                        write(fds[i].fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="client-c-1"><a href="#client-c-1" class="headerlink" title="client.c"></a>client.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: client.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年06月23日 星期四 14时41分42秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// TCP 通信客户端</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">        <span class="keyword">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.连接服务</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">        serveraddr.sin_family = AF_INET;</span><br><span class="line">        serveraddr.sin_port = htons(<span class="number">5200</span>);</span><br><span class="line">        inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">        <span class="keyword">int</span> ret = connect(fd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通信</span></span><br><span class="line">        <span class="keyword">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> data[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">                <span class="comment">// 获取标准输入(stdin)的数据</span></span><br><span class="line">                fgets(data, <span class="keyword">sizeof</span>(data), <span class="built_in">stdin</span>);</span><br><span class="line">                write(fd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">                <span class="keyword">int</span> readLen = read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(readLen == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(readLen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(readLen == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 表示服务端断开连接</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;server closed ... ...\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        close(fd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-epoll"><a href="#4-epoll" class="headerlink" title="4. epoll"></a>4. epoll</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向链表）。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">- 参数：</span><br><span class="line">size : (以前是使用哈希实现的需要用到size)目前没有意义了。随便写一个数，必须大于<span class="number">0</span></span><br><span class="line">- 返回值：</span><br><span class="line"><span class="number">-1</span> : 失败</span><br><span class="line">&gt; <span class="number">0</span> : 文件描述符，操作epoll实例的</span><br><span class="line">            </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">常见的Epoll检测事件：</span><br><span class="line">    - EPOLLIN</span><br><span class="line">    - EPOLLOUT</span><br><span class="line">    - EPOLLERR</span><br><span class="line">    ... ... </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line">- 参数：</span><br><span class="line">- epfd : epoll实例对应的文件描述符</span><br><span class="line">- op : 要进行什么操作</span><br><span class="line">            EPOLL_CTL_ADD: 添加</span><br><span class="line">            EPOLL_CTL_MOD: 修改</span><br><span class="line">            EPOLL_CTL_DEL: 删除</span><br><span class="line">        - fd : 要检测的文件描述符</span><br><span class="line">        - event : 检测文件描述符什么事情</span><br><span class="line"><span class="comment">// 检测函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">timeout)</span></span>;</span><br><span class="line">- 参数:</span><br><span class="line">    - epfd : epoll实例对应的文件描述符</span><br><span class="line">    - events : 传出参数，保存了发送 了变化的文件描述符的信息</span><br><span class="line">    - maxevents : 第二个参数结构体数组的大小</span><br><span class="line">    - timeout : 阻塞时间</span><br><span class="line">        -  <span class="number">0</span>  : 不阻塞</span><br><span class="line">        - <span class="number">-1</span>  : 阻塞，直到检测到fd数据发生变化，解除阻塞</span><br><span class="line">        - &gt; <span class="number">0</span> : 阻塞的时长（毫秒）</span><br><span class="line">    - 返回值:</span><br><span class="line">        - 成功，返回发送变化的文件描述符的个数 &gt; <span class="number">0</span></span><br><span class="line">        - 失败 <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="epoll-server-c"><a href="#epoll-server-c" class="headerlink" title="epoll_server.c"></a>epoll_server.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: epoll.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年07月03日 星期日 15时07分46秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">        saddr.sin_family = AF_INET;</span><br><span class="line">        saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">        saddr.sin_port = htons(<span class="number">5200</span>);</span><br><span class="line">        <span class="keyword">int</span> ret = bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听</span></span><br><span class="line">        ret = listen(lfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个epoll实例 调用epoll_create</span></span><br><span class="line">        <span class="keyword">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">        epev.events = EPOLLIN;</span><br><span class="line">        epev.data.fd = lfd;</span><br><span class="line">        epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于放检测后的数据</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e3</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[<span class="title">MAX_N</span>];</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                ret = epoll_wait(epfd, epevs, MAX_N, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 有几个改变了</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ret = %d \n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 监听的文件描述符有数据到达, 有客户端连接</span></span><br><span class="line">                                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                                <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *) &amp;cliaddr, &amp;len);</span><br><span class="line">                                epev.events = EPOLLIN;</span><br><span class="line">                                epev.data.fd = cfd;</span><br><span class="line">                                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">char</span> cliIP[<span class="number">16</span>];</span><br><span class="line">                <span class="keyword">int</span> cliport = ntohs(cliaddr.sin_port);</span><br><span class="line">                inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIP, <span class="keyword">sizeof</span>(cliIP));</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;client IP : %s, prok %d\n&quot;</span>, cliIP, cliport);</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 有数据到达了, 需要通信</span></span><br><span class="line">                                <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                                <span class="keyword">int</span> len = read(curfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                                        <span class="built_in">printf</span>(<span class="string">&quot;client closed ... ...\n&quot;</span>);</span><br><span class="line">                                        epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                                        close(curfd);</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                                        write(curfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(lfd);</span><br><span class="line">        close(epfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#client.c">client.c 点我向上</a></p><h3 id="Epoll-的工作模式："><a href="#Epoll-的工作模式：" class="headerlink" title="Epoll 的工作模式："></a>Epoll 的工作模式：</h3><ul><li>LT 模式 （水平触发）</li></ul><p>​假设委托内核检测读事件 -&gt; 检测fd的读缓冲区</p><p>​读缓冲区有数据 - &gt; epoll检测到了会给用户通知</p><p>​a.用户不读数据，数据一直在缓冲区，epoll 会一直通知</p><p>​b.用户只读了一部分数据，epoll会通知 </p><p>​c.缓冲区的数据读完了，不通知</p><blockquote><p>LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这 种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操 作。如果你不作任何操作，内核还是会继续通知你的。</p></blockquote><ul><li>ET 模式（边沿触发）</li></ul><p>​假设委托内核检测读事件 -&gt; 检测fd的读缓冲区</p><p>​读缓冲区有数据 - &gt; epoll检测到了会给用户通知</p><p>​a.用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了</p><p>​b.用户只读了一部分数据，epoll不通知</p><p>​c.缓冲区的数据读完了，不通知</p><blockquote><p>ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述 符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪， 并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述 符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成 未就绪），内核不会发送更多的通知（only once）。 ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写 操作把处理多个文件描述符的任务饿死。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">常见的Epoll检测事件：</span><br><span class="line">    - EPOLLIN</span><br><span class="line">    - EPOLLOUT</span><br><span class="line">    - EPOLLERR</span><br><span class="line">    - EPOLLET <span class="comment">// 边沿触发</span></span><br></pre></td></tr></table></figure><h3 id="epoll-LT"><a href="#epoll-LT" class="headerlink" title="epoll_LT"></a>epoll_LT</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: epoll.c</span></span><br><span class="line"><span class="comment">&gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">&gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">&gt; Created Time: 2022年07月03日 星期日 15时07分46秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">saddr.sin_family = AF_INET;</span><br><span class="line">saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">saddr.sin_port = htons(<span class="number">5200</span>);</span><br><span class="line"><span class="keyword">int</span> ret = bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听</span></span><br><span class="line">ret = listen(lfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个epoll实例 调用epoll_create</span></span><br><span class="line"><span class="keyword">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">epev.events = EPOLLIN;</span><br><span class="line">epev.data.fd = lfd;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于放检测后的数据</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e3</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[<span class="title">MAX_N</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">ret = epoll_wait(epfd, epevs, MAX_N, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有几个改变了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ret = %d \n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听的文件描述符有数据到达, 有客户端连接</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line"><span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *) &amp;cliaddr, &amp;len);</span><br><span class="line">epev.events = EPOLLIN;</span><br><span class="line">epev.data.fd = cfd;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> cliIP[<span class="number">16</span>];</span><br><span class="line">                <span class="keyword">int</span> cliport = ntohs(cliaddr.sin_port);</span><br><span class="line">                inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIP, <span class="keyword">sizeof</span>(cliIP));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;client IP : %s, prok %d\n&quot;</span>, cliIP, cliport);</span><br><span class="line"><span class="built_in">memset</span>(cliIP, <span class="number">0</span>, <span class="keyword">sizeof</span>(cliIP));</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 有数据到达了, 需要通信</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// memset(buf, 0, sizeof(buf));</span></span><br><span class="line"><span class="keyword">int</span> len = read(curfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;client closed ... ...\n&quot;</span>);</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">close(curfd);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">write(curfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(lfd);</span><br><span class="line">close(epfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="epoll-ET"><a href="#epoll-ET" class="headerlink" title="epoll_ET"></a>epoll_ET</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: epoll.c</span></span><br><span class="line"><span class="comment">&gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">&gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">&gt; Created Time: 2022年07月03日 星期日 15时07分46秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">saddr.sin_family = AF_INET;</span><br><span class="line">saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">saddr.sin_port = htons(<span class="number">5200</span>);</span><br><span class="line"><span class="keyword">int</span> ret = bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听</span></span><br><span class="line">ret = listen(lfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个epoll实例 调用epoll_create</span></span><br><span class="line"><span class="keyword">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">epev.events = EPOLLIN;</span><br><span class="line">epev.data.fd = lfd;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于放检测后的数据</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e3</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[<span class="title">MAX_N</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">ret = epoll_wait(epfd, epevs, MAX_N, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有几个改变了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ret = %d \n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听的文件描述符有数据到达, 有客户端连接</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line"><span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *) &amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置cfd属性非阻塞</span></span><br><span class="line"><span class="keyword">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line">fcntl(cfd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">epev.events = EPOLLIN | EPOLLET; <span class="comment">// 设置边沿触发</span></span><br><span class="line">epev.data.fd = cfd;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> cliIP[<span class="number">16</span>];</span><br><span class="line">                <span class="keyword">int</span> cliport = ntohs(cliaddr.sin_port);</span><br><span class="line">                inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIP, <span class="keyword">sizeof</span>(cliIP));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;client IP : %s, prok %d\n&quot;</span>, cliIP, cliport);</span><br><span class="line"><span class="built_in">memset</span>(cliIP, <span class="number">0</span>, <span class="keyword">sizeof</span>(cliIP));</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取所有的数据</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>((len = read(curfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 打印数据</span></span><br><span class="line"><span class="comment">// printf(&quot;recv data : %s \n&quot;, buf);</span></span><br><span class="line">write(STDOUT_FILENO, buf, len);</span><br><span class="line">write(curfd, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;client closed ... ...\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">// 数据读完又读非阻塞的就会产生一个错误</span></span><br><span class="line"><span class="keyword">if</span>(errno == EAGAIN) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;data over ... ...\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(lfd);</span><br><span class="line">close(epfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>socket通信基础</title>
      <link href="2022/06/17/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/"/>
      <url>2022/06/17/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-socket介绍"><a href="#1-socket介绍" class="headerlink" title="1.socket介绍"></a>1.socket介绍</h2><blockquote><p>所谓 socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。 一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处 的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口， 是应用程序与网络协议根进行交互的接口。 socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概 念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接 字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在 主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台 主机的 socket 中，使对方能够接收到这段信息。socket 是由 IP 地址和端口结合的，提供向应用 层进程传送数据包的机制。 socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为 内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接 字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文 件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传 递。</p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220618195502521.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220618195502521.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220618195502521"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 套接字通信分两部分：</span></span><br><span class="line">- 服务器端：被动接受连接，一般不会主动发起连接</span><br><span class="line">- 客户端：主动向服务器发起连接</span><br><span class="line">socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别</span><br></pre></td></tr></table></figure><h2 id="2-字节序"><a href="#2-字节序" class="headerlink" title="2. 字节序"></a>2. 字节序</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>现代 CPU 的累加器一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。那么这 4 字节在内存中排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题。在各种计算机 体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问 题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如</p><p>果不达成一致的规则，通信双方将无法进行正确的编码&#x2F;译码从而导致通信失败。 <font color='red'>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数 据当然就无需谈顺序的问题了)。</font></p><p>字节序分为大端字节序（Big-Endian） 和小端字节序（Little-Endian）。大端字节序是指一个整 数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地 址处；小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地 址处。</p></blockquote><h3 id="字节序举例"><a href="#字节序举例" class="headerlink" title="字节序举例"></a>字节序举例</h3><ul><li>小端字节序</li></ul><p>​0x 01 02 03 04 - ff &#x3D; 255 </p><p>​内存的方向 —–&gt; </p><p>​内存的低位 —–&gt; 内存的高位 </p><p>​04 03 02 01 </p><p>​0x 11 22 33 44 12 34 56 78</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220618201124424.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220618201124424.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220618201124424"></p><ul><li>大端字节序</li></ul><p>​0x 01 02 03 04</p><p>​内存的方向—– &gt;</p><p>​内存的低位  —–&gt;  内存的高位</p><p>​01 02 03 04</p><p>​0x 12 34 56 78 11 22 33 44</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220618201628398.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220618201628398.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220618201628398"></p><h3 id="查看本机是-大端字节序-or-小端字节序"><a href="#查看本机是-大端字节序-or-小端字节序" class="headerlink" title="查看本机是 大端字节序 or 小端字节序"></a>查看本机是 大端字节序 or 小端字节序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: byteorder.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年06月18日 星期六 14时51分19秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  字节序: 字节在内存中存储的顺序</span></span><br><span class="line"><span class="comment"> *  小端字节序: 数据的高位字节存储在内存的高位地址,低位字节</span></span><br><span class="line"><span class="comment">存储在内存的底位地址。</span></span><br><span class="line"><span class="comment"> *  大端字节序: 数据的底位字节存储在内存的高位地址,高位字节</span></span><br><span class="line"><span class="comment">存储在内存的底位地址。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过代码检测当前主机的字节序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="comment">// 2 字节</span></span><br><span class="line">        <span class="keyword">short</span> value;</span><br><span class="line">        <span class="comment">// 2 字节</span></span><br><span class="line">        <span class="keyword">char</span> bytes[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">    &#125; test;</span><br><span class="line"></span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, test.bytes[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((test.bytes[<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (test.bytes[<span class="number">1</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端字节序\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>((test.bytes[<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (test.bytes[<span class="number">1</span>] == <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端字节序\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d --- %d \n&quot;</span>, test.bytes[<span class="number">0</span>], test.bytes[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未知\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h3><p>当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的 方法是：发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数 据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小 端机转换，大端机不转换）。</p><p><strong>网络字节顺序是</strong> TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而 可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。 BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数： htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h - host 主机，主机字节序</span><br><span class="line">to - 转换成什么</span><br><span class="line">n - network 网络字节序</span><br><span class="line">s - <span class="keyword">short</span> <span class="keyword">unsigned</span> <span class="keyword">short</span></span><br><span class="line">l - <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 转换端口</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>; <span class="comment">// 网络字节序 - 主机字节序 </span></span><br><span class="line"><span class="comment">// 转IP</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>; <span class="comment">// 网络字节序 - 主机字节序</span></span><br></pre></td></tr></table></figure><h3 id="代码实现-网络字节序-与-主机字节序-转换"><a href="#代码实现-网络字节序-与-主机字节序-转换" class="headerlink" title="代码实现 网络字节序 与 主机字节序 转换"></a>代码实现 网络字节序 与 主机字节序 转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: byterans.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年06月18日 星期六 22时47分04秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    网络通信时,需要将主机字节序转换成网络字节序(大端),另外一端获取到数据以后根据情况将网络字节序转换成主机字节序。</span></span><br><span class="line"><span class="comment">        #include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">        // 转换端口</span></span><br><span class="line"><span class="comment">        uint16_t htons(uint16_t hostshort); // 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="comment">        uint16_t ntohs(uint16_t netshort); // 网络字节序 - 主机字节序</span></span><br><span class="line"><span class="comment">        // 转IP</span></span><br><span class="line"><span class="comment">        uint32_t htonl(uint32_t hostlong); // 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="comment">        uint32_t ntohl(uint32_t netlong); // 网络字节序 - 主机字节序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// htons 转换端口</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> a = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> b = htons(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0xa = %x \n0xb = %x\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n==================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// htol 转换ID</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4</span>] = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> num = *(<span class="keyword">int</span> *)buf;</span><br><span class="line">    <span class="comment">// printf(&quot;%d&quot;, num);</span></span><br><span class="line">    <span class="keyword">int</span> sum = htonl(num);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)&amp;sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p + <span class="number">1</span>), *(p + <span class="number">2</span>), *(p + <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n==================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ntohl</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf1[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">168</span>, <span class="number">192</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> num1 = *(<span class="keyword">int</span> *)buf1;</span><br><span class="line">    <span class="keyword">int</span> sum1 = ntohl(num1);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p1 = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) &amp;sum1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p1, *(p1 + <span class="number">1</span>), *(p1 + <span class="number">2</span>), *(p1 + <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n==================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ntohs</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> a1 = <span class="number">0x0201</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> b1 = ntohs(a1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0xa1 = %x\n0xb1 = %x\n&quot;</span>, a1, b1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-socket-地址"><a href="#3-socket-地址" class="headerlink" title="3. socket 地址"></a>3. socket 地址</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket地址其实是一个结构体，封装端口号和IP等信息。后面的socket相关的api中需要使用到这个</span></span><br><span class="line">socket地址。</span><br><span class="line"><span class="comment">// 客户端 -&gt; 服务器（IP, Port）</span></span><br></pre></td></tr></table></figure><h3 id="通用-socket-地址"><a href="#通用-socket-地址" class="headerlink" title="通用 socket 地址"></a>通用 socket 地址</h3><p>socket 网络编程接口中表示 socket 地址的是结构体 sockaddr，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">sa_family_t</span>;</span><br></pre></td></tr></table></figure><p>sa_family 成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议 族（protocol family，也称 domain）和对应的地址族入下所示：</p><table><thead><tr><th align="left"><strong>协议族</strong></th><th align="left"><strong>地址族</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">PF_UNIX</td><td align="left">AF_UNIX</td><td align="left">UNIX本地域协议族</td></tr><tr><td align="left">PF_INET</td><td align="left">AF_INET</td><td align="left">TCP&#x2F;IPv4协议族</td></tr><tr><td align="left">PF_INET6</td><td align="left">AF_INET6</td><td align="left">TCP&#x2F;IPv6协议族</td></tr></tbody></table><p>宏 PF_* 和 AF_* 都定义在 bits&#x2F;socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混 用。</p><p>sa_data 成员用于存放 socket 地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下所 示：</p><table><thead><tr><th><strong>协议族</strong></th><th><strong>地址值含义和长度</strong></th></tr></thead><tbody><tr><td>PF_UNIX</td><td>文件的路径名，长度可达到108字节</td></tr><tr><td>PF_INET</td><td>16bit端口号和32bitIPv4地址，共6字节</td></tr><tr><td>PF_INET6</td><td>16bit端口号，32bit流标识，128bitIPv6地址，32bit范围ID，共26字节</td></tr></tbody></table><p>由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新的 通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __ss_align;</span><br><span class="line">    <span class="keyword">char</span> __ss_padding[ <span class="number">128</span> - <span class="keyword">sizeof</span>(__ss_align) ];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">sa_family_t</span>;</span><br></pre></td></tr></table></figure><h3 id="专用-socket-地址"><a href="#专用-socket-地址" class="headerlink" title="专用 socket 地址"></a>专用 socket 地址</h3><p>很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现 在sockaddr 退化成了（void *）的作用，传递一个地址给函数，至于这个函数是 sockaddr_in 还是 sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220619113259517.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220619113259517.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220619113259517"></p><p>UNIX 本地域协议族使用如下专用的 socket 地址结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;</span><br><span class="line">    <span class="keyword">char</span> sun_path[<span class="number">108</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TCP&#x2F;IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和 IPv6：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family; <span class="comment">/* __SOCKADDR_COMMON(sin_) */</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port; <span class="comment">/* Port number. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* Internet address. */</span></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (struct sockaddr) - __SOCKADDR_COMMON_SIZE -</span><br><span class="line">    <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) - <span class="keyword">sizeof</span> (struct in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin6_family;</span><br><span class="line">    <span class="keyword">in_port_t</span> sin6_port; <span class="comment">/* Transport layer port # */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span> <span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id; <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br></pre></td></tr></table></figure><p>所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地 址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。</p><h2 id="4-IP地址转换（字符串ip-整数-，主机、网络-字节序的转换）"><a href="#4-IP地址转换（字符串ip-整数-，主机、网络-字节序的转换）" class="headerlink" title="4. IP地址转换（字符串ip-整数 ，主机、网络 字节序的转换）"></a>4. IP地址转换（字符串ip-整数 ，主机、网络 字节序的转换）</h2><p>通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用 十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录 日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字 符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure><p>下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串， n:表示network，网络字节序的整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line">    af:地址族： AF_INET AF_INET6</span><br><span class="line">    src:需要转换的点分十进制的IP字符串</span><br><span class="line">    dst:转换后的结果保存在这个里面</span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> size)</span></span>;</span><br><span class="line">    af:地址族： AF_INET AF_INET6</span><br><span class="line">    src: 要转换的ip的整数的地址</span><br><span class="line">    dst: 转换成IP地址字符串保存的地方</span><br><span class="line">    size：第三个参数的大小（数组的大小）</span><br><span class="line">    返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span><br></pre></td></tr></table></figure><h3 id="C代码-实现-IP地址转换函数"><a href="#C代码-实现-IP地址转换函数" class="headerlink" title="C代码-实现 IP地址转换函数"></a>C代码-实现 IP地址转换函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: iptrans.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年06月20日 星期一 19时45分21秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // p:点分十进制的IP字符串， n:表示network，网络字节序 的整数</span></span><br><span class="line"><span class="comment">    int inet_pton(int af, const char *src, void *dst);</span></span><br><span class="line"><span class="comment">        af:地址族： AF_INET AF_INET6</span></span><br><span class="line"><span class="comment">        src:需要转换的点分十进制的IP字符串</span></span><br><span class="line"><span class="comment">        dst:转换后的结果保存在这个里面</span></span><br><span class="line"><span class="comment">    // 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="comment">    const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</span></span><br><span class="line"><span class="comment">        af:地址族： AF_INET AF_INET6</span></span><br><span class="line"><span class="comment">        src: 要转换的ip的整数的地址</span></span><br><span class="line"><span class="comment">        dst: 转换成IP地址字符串保存的地方</span></span><br><span class="line"><span class="comment">        size：第三个参数的大小（数组的大小）</span></span><br><span class="line"><span class="comment">        返回值：返回转换后的数据的地址（字符串），和 dst  是一样的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个ip字符串,点分十进制的</span></span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">&quot;192.168.1.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将点分十进制的IP字符串</span></span><br><span class="line">    inet_pton(AF_INET, buf, &amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d \n&quot;</span>, *p, *(p + <span class="number">1</span>), *(p + <span class="number">2</span>), *(p + <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将网络字节序的IP整数</span></span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = inet_ntop(AF_INET, &amp;num, ip, <span class="keyword">sizeof</span>(ip));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str : %s\n&quot;</span>, str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip : %s\n&quot;</span>, ip);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip == str = %d\n&quot;</span>, str == ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-TCP通信流程"><a href="#5-TCP通信流程" class="headerlink" title="5. TCP通信流程"></a>5. TCP通信流程</h2><h3 id="TCP-UDP-特点区别"><a href="#TCP-UDP-特点区别" class="headerlink" title="TCP - UDP 特点区别"></a>TCP - UDP 特点区别</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP 和 UDP -&gt; 传输层的协议</span></span><br><span class="line">UDP:用户数据报协议，面向无连接，可以单播，多播，广播， 面向数据报，不可靠</span><br><span class="line">TCP:传输控制协议，面向连接的，可靠的，基于字节流，仅支持单播传输 </span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th align="center">UDP</th><th align="center">TCP</th></tr></thead><tbody><tr><td>是否创建连接</td><td align="center">无连接</td><td align="center">面向连接</td></tr><tr><td>是否可靠</td><td align="center">不可靠</td><td align="center">可靠的</td></tr><tr><td>连接的对象个数</td><td align="center">一对一、一对多、多对多、多对一</td><td align="center">支持一对一</td></tr><tr><td>传输方式</td><td align="center">面向数据报</td><td align="center">面向字节流</td></tr><tr><td>首部开销</td><td align="center">8个字节</td><td align="center">最少20个字节</td></tr><tr><td>适用场景</td><td align="center">实时应用（视频会议，直播）</td><td align="center">可靠性高的应用（文件传输）</td></tr></tbody></table><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220621115812206.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220621115812206.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220621115812206"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP 通信的流程</span></span><br><span class="line"><span class="comment">// 服务器端 （被动接受连接的角色）</span></span><br><span class="line"><span class="number">1.</span> 创建一个用于监听的套接字</span><br><span class="line">- 监听: 监听有客户端的连接</span><br><span class="line">- 套接字: 这个套接字其实就是一个文件描述符</span><br><span class="line"><span class="number">2.</span> 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）</span><br><span class="line">- 客户端连接服务器的时候使用的就是这个IP和端口</span><br><span class="line"><span class="number">3.</span> 设置监听，监听的fd开始工作</span><br><span class="line"><span class="number">4.</span> 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字（fd）</span><br><span class="line"><span class="number">5.</span> 通信</span><br><span class="line">- 接收数据</span><br><span class="line">- 发送数据</span><br><span class="line"><span class="number">6.</span> 通信结束，断开连接</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="number">1.</span>创建一个用于通信的套接字(fd)</span><br><span class="line">不需要绑定IP和端口</span><br><span class="line">客户端IP会有的但是端口是随机的、连接到服务器刚开始会进行<span class="number">3</span>次握手、两端都记录了两端的IP和端口</span><br><span class="line"><span class="number">2.</span>连接服务器，需要指定的连接的服务器的 IP 和 端口</span><br><span class="line"><span class="number">3.</span> 连接成功，客户端可以和服务器直接铜线</span><br><span class="line">- 接受数据</span><br><span class="line">- 发送数据</span><br><span class="line"><span class="number">6.</span>通信结束，断开连接</span><br></pre></td></tr></table></figure><h2 id="6-套接字函数"><a href="#6-套接字函数" class="headerlink" title="6. 套接字函数"></a>6. 套接字函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt; // 包含了这个头文件，上面两个就可以省略</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">- 功能：创建一个套接字</span><br><span class="line">- 参数：</span><br><span class="line">- domain: 协议族</span><br><span class="line">AF_INET : ipv4</span><br><span class="line">AF_INET6 : ipv6</span><br><span class="line">AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）</span><br><span class="line">... ...</span><br><span class="line">- type: 通信过程中使用的协议类型</span><br><span class="line">SOCK_STREAM : 流式协议 - TCP</span><br><span class="line">SOCK_DGRAM : 报式协议 - UDP</span><br><span class="line">... ... </span><br><span class="line">- protocol: 具体的一个协议。一般写 <span class="number">0</span> 情况下</span><br><span class="line">- SOCK_STREAM : 流式协议默认使用 TCP</span><br><span class="line">- SOCK_DGRAM : 报式协议默认使用 UDP</span><br><span class="line">- 返回值: </span><br><span class="line">- 成功：返回文件描述符，操作的就是内核缓冲区。</span><br><span class="line">- 失败：<span class="number">-1</span></span><br><span class="line">                </span><br><span class="line"><span class="comment">// 绑定也叫 - socket命名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">- 功能: 绑定，将fd 和本地的IP + 端口进行绑定</span><br><span class="line">- 参数:</span><br><span class="line">- sockfd : 通过socket函数得到的文件描述符</span><br><span class="line">- addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息</span><br><span class="line">- addrlen : 第二个参数结构体占的内存大小</span><br><span class="line">- 返回值:</span><br><span class="line">- 成功: 返回 <span class="number">0</span></span><br><span class="line">- 失败: 返回 <span class="number">-1</span> 并设置错误号</span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line">- 功能：监听这个socket上的连接</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 通过socket()函数得到的文件描述符</span><br><span class="line">- backlog : 未连接的和已经连接的和的最大值, 一般指定 <span class="number">5</span> 就够了,不能超过下面查看的值</span><br><span class="line">查看最大连接  <span class="comment">// cat /proc/sys/net/core/somaxconn   </span></span><br><span class="line">- 返回值:</span><br><span class="line">- 成功: 返回 <span class="number">0</span></span><br><span class="line">- 失败: 返回 <span class="number">-1</span> 并设置错误号</span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 用于监听的文件描述符</span><br><span class="line">- addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）</span><br><span class="line">- addrlenvv : 指定第二个参数的对应的内存大小</span><br><span class="line">- 返回值：</span><br><span class="line">- 成功: 用于通信的文件描述符</span><br><span class="line">- 失败: <span class="number">-1</span></span><br><span class="line">                </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">- 功能: 客户端连接服务器</span><br><span class="line">- 参数:</span><br><span class="line">- sockfd: 用于通信的文件描述符</span><br><span class="line">- addr: 客户端要连接的服务器的地址信息</span><br><span class="line">- addrlen: 第二个参数的内存大小</span><br><span class="line">- 返回值:</span><br><span class="line">- 成功: <span class="number">0</span></span><br><span class="line">- 失败: <span class="number">-1</span></span><br><span class="line">                </span><br><span class="line"><span class="comment">// 写数据</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 读数据</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>; </span><br></pre></td></tr></table></figure><h2 id="TCP-手动输入消息-回射"><a href="#TCP-手动输入消息-回射" class="headerlink" title="TCP - 手动输入消息 - 回射"></a>TCP - 手动输入消息 - 回射</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: server.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年06月22日 星期三 18时45分38秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// TCP 通信的服务器端E</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建socket(用于监听套接字)</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定 IP 和 端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// inet_net_pton(AF_INET, &quot;192.168.3.206&quot;, saddr.sin_addr.s_addr);</span></span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY; <span class="comment">// = 0; // 0.0.0.0 任意地址 客户端不能这面写</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.接受客户端的连接 - 阻塞</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;clientaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出客户端的信息</span></span><br><span class="line">    <span class="keyword">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    inet_ntop(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, <span class="keyword">sizeof</span>(clientIP));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> clientPort = ntohs(clientaddr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is %s, prot is %d\n&quot;</span>, clientIP, clientPort);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 5.通信</span></span><br><span class="line">        <span class="comment">// 获取客户的数据</span></span><br><span class="line">        <span class="keyword">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> readLen = read(cfd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(readLen == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(readLen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(readLen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 客户端断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed ... ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 给客户端发送数据</span></span><br><span class="line">        <span class="keyword">char</span> *data = <span class="string">&quot;hello, i am server&quot;</span>;</span><br><span class="line">        write(cfd, recvBuf, <span class="built_in">strlen</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: client.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年06月23日 星期四 14时41分42秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// TCP 通信客户端</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">        <span class="keyword">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.连接服务</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">        serveraddr.sin_family = AF_INET;</span><br><span class="line">        serveraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">        inet_pton(AF_INET, <span class="string">&quot;192.168.222.139&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">        <span class="keyword">int</span> ret = connect(fd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通信</span></span><br><span class="line">        <span class="keyword">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> data[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">                <span class="comment">// 获取标准输入(stdin)的数据</span></span><br><span class="line">                fgets(data, <span class="keyword">sizeof</span>(data), <span class="built_in">stdin</span>);</span><br><span class="line">                write(fd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">                <span class="keyword">int</span> readLen = read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(readLen == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(readLen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(readLen == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 表示服务端断开连接</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;server closed ... ...\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        close(fd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-TCP-三次握手"><a href="#7-TCP-三次握手" class="headerlink" title="7. TCP 三次握手"></a>7. TCP 三次握手</h2><p>TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连 接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。 </p><p>TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程 中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。 </p><p>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 四次挥手 来关闭一个连接。</p><p>三次握手的目的是保证双方互相之间建立了连接</p><p>三次握手发生在客户端连接的时候，当调用connect(),底层会通过TCP协议进行三次握手。</p><h3 id="TCP三次握手四次挥手-图解"><a href="#TCP三次握手四次挥手-图解" class="headerlink" title="TCP三次握手四次挥手 - 图解"></a>TCP三次握手四次挥手 - 图解</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.pdf_%E9%A1%B5%E9%9D%A2_1.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.pdf_%E9%A1%B5%E9%9D%A2_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="TCP三次握手四次挥手.pdf_页面_1"></p><h4 id="为社么不能2次握手"><a href="#为社么不能2次握手" class="headerlink" title="为社么不能2次握手"></a>为社么不能2次握手</h4><blockquote><p>直接说你做我女朋友行吗？</p><p>回复 好的</p><p>答:客户端要知道自己能发数据也能收数据 服务端也是一样的</p><p><strong>客户端</strong>给服务器发能确保的是客户端可以发送数据，但是不能确定<strong>服务端</strong>的收和发是否是好使的</p><p><strong>服务端</strong>收到信息了服务端可以确定自己收是好的还能确定<strong>客户端</strong>的发是好的</p><p>(客) C -&gt; S(服)</p><p><strong>服务端</strong>回一个数据就能确定自己发也是没有问题的</p><p><strong>客户端</strong>收到信息能确定自己的收是没有问题也能确定<strong>服务端</strong>的收发是没有问题的</p><p>(客) C &lt;- S(服)</p><p><strong>服务端</strong>收到客户发来的数据就知道客户端的收是好的</p><p>(客) C -&gt; S(服)</p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220624111003498.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220624111003498.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220624111003498"></p><blockquote><p>ACK: 用来做确认的</p><p>SYN: 用来做连接的</p><p>FIN: 用来做四次挥手的 断开连接的</p></blockquote><ul><li>16 位端口号（port number）：告知主机报文段是来自哪里（源端口）以及传给哪个上层协议或 应用程序（目的端口）的。进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号。 </li><li>32 位序号（sequence number）：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输 方向上的字节流的每个字节的编号。假设主机 A 和主机 B 进行 TCP 通信，A 发送给 B 的第一个 TCP 报文段中，序号值被系统初始化为某个随机值 ISN（Initial Sequence Number，初始序号 值）。那么在该传输方向上（从 A 到 B），后续的 TCP 报文段中序号值将被系统设置成 ISN 加上 该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个 TCP 报文段传送的数据是字 节流中的第 1025 ~ 2048 字节，那么该报文段的序号值就是 ISN + 1025。另外一个传输方向（从 B 到 A）的 TCP 报文段的序号值也具有相同的含义。 </li><li>32 位确认号（acknowledgement number）：用作对另一方发送来的 TCP 报文段的响应。其值是 收到的 TCP 报文段的序号值 + 标志位长度（SYN，FIN） + 数据长度 。假设主机 A 和主机 B 进行 TCP 通信，那么 A 发送出的 TCP 报文段不仅携带自己的序号，而且包含对 B 发送来的 TCP 报文段 的确认号。反之，B 发送出的 TCP 报文段也同样携带自己的序号和对 A 发送来的报文段的确认序 号。 </li><li>4 位头部长度（head length）：标识该 TCP 头部有多少个 32 bit(4 字节)。因为 4 位最大能表示 15，所以 TCP 头部最长是60 字节。 - 功能： 客户端连接服务器 - 参数： - sockfd : 用于通信的文件描述符 - addr : 客户端要连接的服务器的地址信息 - addrlen : 第二个参数的内存大小 - 返回值：成功 0， 失败 -1 ssize_t write(int fd, const void *buf, size_t count); &#x2F;&#x2F; 写数据 ssize_t read(int fd, void *buf, size_t count); &#x2F;&#x2F; 读数据 </li><li>6 位标志位包含如下几项： <ul><li>URG 标志，表示紧急指针（urgent pointer）是否有效。 </li><li>ACK 标志，表示确认号是否有效。我们称携带 ACK 标志的 TCP 报文段为确认报文段。 </li><li>PSH 标志，提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为接收后续数据腾 出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在 TCP 接收缓冲区中）。 </li><li>RST 标志，表示要求对方重新建立连接。我们称携带 RST 标志的 TCP 报文段为复位报文段。 </li><li>SYN 标志，表示请求建立一个连接。我们称携带 SYN 标志的 TCP 报文段为同步报文段。 </li><li>FIN 标志，表示通知对方本端要关闭连接了。我们称携带 FIN 标志的 TCP 报文段为结束报文 段。 </li><li>16 位窗口大小（window size）：是 TCP 流量控制的一个手段。这里说的窗口，指的是接收 通告窗口（Receiver Window，RWND）。它告诉对方本端的 TCP 接收缓冲区还能容纳多少 字节的数据，这样对方就可以控制发送数据的速度。 </li><li>16 位校验和（TCP checksum）：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以校验 TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。 这也是 TCP 可靠传输的一个重要保障。 </li><li>16 位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一 个紧急数据的下一个字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏 移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。</li></ul></li></ul><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220624111928654.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220624111928654.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220624111928654"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一次握手:</span><br><span class="line"><span class="number">1.</span>客户端将SYN标志为<span class="number">1</span></span><br><span class="line"><span class="number">2.</span>生成一个随机的<span class="number">32</span>位的序号seq = J，这序号后边是可以携带数据 (数据的大小)</span><br><span class="line">第二个次握手:</span><br><span class="line"><span class="number">1.</span>服务器端接收客户端的连接: ACK = <span class="number">1</span></span><br><span class="line"><span class="number">2.</span>服务器会回发一个确认序号: ack = 客户的序号 + 数据的长度 + SYN/FIN(按一个字节来算)</span><br><span class="line"><span class="number">3.</span>服务器端会向客户端发起连接请求: SYN = <span class="number">1</span></span><br><span class="line"><span class="number">4.</span>服务器也会生成一个随机序号: seq = K</span><br><span class="line">第三次握手:</span><br><span class="line"><span class="number">1.</span>客户端应答服务器的连接请求: ACK = <span class="number">1</span></span><br><span class="line"><span class="number">2.</span>客户端回复收到了服务端的数据: ack = 服务端的序号 + 数据长度 + SYN/FIN(按一个字节算)</span><br></pre></td></tr></table></figure><h3 id="序号-和-确认序号-通信的过程"><a href="#序号-和-确认序号-通信的过程" class="headerlink" title="序号 和 确认序号 通信的过程"></a>序号 和 确认序号 通信的过程</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.pdf_%E9%A1%B5%E9%9D%A2_2.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.pdf_%E9%A1%B5%E9%9D%A2_2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="TCP三次握手四次挥手.pdf_页面_2"></p><h2 id="8-TCP-滑动窗口"><a href="#8-TCP-滑动窗口" class="headerlink" title="8. TCP 滑动窗口"></a>8. TCP 滑动窗口</h2><blockquote><p>滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的 拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包， 谁也发不了数据，所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种 技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包 （称窗口尺寸）。 TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于 接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报。 </p><p>滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构。</p></blockquote><p>窗口理为缓冲区的大小</p><p>滑动窗口的大小会随着发送数据和接受数据而变化</p><p>通信的双方都有发送的缓冲区和接收数据的缓冲区</p><p>​服务器:</p><p>​发送缓冲区 (发送缓冲区的窗口)</p><p>​接受缓冲区 (接收缓冲区的窗口)</p><p>​客户端</p><p>​发送缓冲区 (发送缓冲区的窗口)</p><p>​接受缓冲区 </p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220625160402642.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220625160402642.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220625160402642"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">发送方的缓冲区:</span><br><span class="line">白色格子: 空闲的空间</span><br><span class="line">灰色格子: 数据已经被发送出去，但是还没有被接收,服务-回复ack确认收到那了</span><br><span class="line">紫色格子: 还没有发送出去的数据</span><br><span class="line">        </span><br><span class="line">接受收方的缓冲区:</span><br><span class="line">白色格子: 空闲空间</span><br><span class="line">紫色格子: 已经接收到的数据</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220625160441838.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220625160441838.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220625160441838"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mss: Maximum Segment Size(一条数据的最大的数据量)</span></span><br><span class="line"><span class="meta"># win: 滑动窗口 </span></span><br><span class="line"><span class="number">1.</span> 客户端向服务器发起连接，客户端的滑动窗口是<span class="number">4096</span>,一次发送的最大的数据是<span class="number">1460</span></span><br><span class="line"><span class="number">2.</span> 服务器接收连接情况,告诉客户端服务的窗口大小是<span class="number">6144</span>，一次发送的最大的数据是<span class="number">1024</span></span><br><span class="line"><span class="number">3.</span> 第三次握手</span><br><span class="line"><span class="number">4.</span> 第<span class="number">4</span> - <span class="number">9</span>客户端连续给服务器发送了<span class="number">6</span>k的数据, 每次发送<span class="number">1</span>k</span><br><span class="line"><span class="number">5.</span> 第<span class="number">10</span>次, 服务器告诉客户端: 发送的<span class="number">6</span>k数据以及接收到, 存储在缓冲区中, 缓冲区数据已经处理了<span class="number">2</span>k, 窗口大小是<span class="number">2</span>k</span><br><span class="line"><span class="number">6.</span> 第<span class="number">11</span>次, 服务器告诉客户端: 发送的<span class="number">6</span>k数据以及接收到, 存储在缓冲区中, 缓冲区数据已经处理了<span class="number">4</span>k, 窗口大小是<span class="number">4</span>k</span><br><span class="line"><span class="number">7.</span> 第<span class="number">12</span>次, 给服务器发送了<span class="number">1</span>k数据</span><br><span class="line"># 客户端发送请求断开连接 - 第一次挥手</span><br><span class="line"><span class="number">8.</span> 第<span class="number">13</span>次, 客户端主动发起请求和服务器断开连接, 并且给服务器发送了<span class="number">1</span>k数据</span><br><span class="line"><span class="number">9.</span> 第<span class="number">14</span>次, 服务器回复ACK <span class="number">8194</span>  a:同意断开请求 b:告诉客户端已经接受到对方的才发的<span class="number">2</span>k数据 c: 滑动窗口<span class="number">2</span>k</span><br><span class="line"># 客户端一方断开后是不能发送数据了,但是可以接受数据</span><br><span class="line"><span class="number">10.</span> 第<span class="number">15</span>、<span class="number">16</span>, 通知客户端</span><br><span class="line"><span class="number">11.</span> 第<span class="number">17</span>次, 第三次挥手服务器给客户端发送FIN请求断开连接</span><br><span class="line"><span class="number">12.</span> 第<span class="number">18</span>次, 第四次回收, 客户端同意了服务器的断开</span><br><span class="line"># 第一次握手 不能携带数据</span><br><span class="line">因为: 三次握手还没建立连接就不能携带数据</span><br><span class="line"># 第二次握手之后</span><br><span class="line">左边就可以给右面发送数据了, 但是右面不能给给左面发送数据, 只能等三次握手结束后右面才能给左面发送数据</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="9-TCP-四次挥手"><a href="#9-TCP-四次挥手" class="headerlink" title="9. TCP 四次挥手"></a>9. TCP 四次挥手</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">四次挥手发生在断开连接的时候，在程序中调用了close()会使用TCP协议进行四次挥手。</span><br><span class="line">客户端和服务器都可以主动发起断开连接,谁先调用close()谁就是发起。</span><br><span class="line">因为在TCP连接的时候, 采用三次握手建立的连接是双向的, 在断开的时候也需要双向断开。</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.pdf_%E9%A1%B5%E9%9D%A2_3.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.pdf_%E9%A1%B5%E9%9D%A2_3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="TCP三次握手四次挥手.pdf_页面_3"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220626124846475.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220626124846475.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220626124846475">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </p><h2 id="TCP-通信并发-进程"><a href="#TCP-通信并发-进程" class="headerlink" title="TCP 通信并发 - 进程"></a>TCP 通信并发 - 进程</h2><blockquote><p>TCP多用户和服务器传输</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">要实现TCP通信服务器处理并发的任务, 使用多线程或者多进程来解决。</span><br><span class="line"></span><br><span class="line">思路:</span><br><span class="line"><span class="number">1.</span> 一个父进程, 多个子进程</span><br><span class="line"><span class="number">2.</span> 父进程负责等待并接受客户端的连接</span><br><span class="line"><span class="number">3.</span> 子进程: 完成通信, 接受一个客户端连接, 就创建一个子进程用于通信</span><br></pre></td></tr></table></figure><h3 id="server-process-c"><a href="#server-process-c" class="headerlink" title="server_process.c"></a>server_process.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: server_process.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年06月26日 星期日 21时33分58秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recyleChild</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 所有的子进程都回收了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还有子进程活着</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 被回收的子进程的 PID</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程: %d 被回收了\n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = recyleChild;</span><br><span class="line"></span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个socket PF 和 AF 是一样的可以混用</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">5210</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    ret = bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断循环 等待接受客户端</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存连接进来的客户端的信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="comment">// int len = sizeof(cliaddr);</span></span><br><span class="line">        <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一个连接进来, 都创建一个子进程跟客户端通信</span></span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            <span class="comment">// 获取客户端的信息</span></span><br><span class="line">            <span class="keyword">char</span> cliIP[<span class="number">16</span>];</span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIP, <span class="keyword">sizeof</span>(cliIP));</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> cliProt = ntohs(cliaddr.sin_port);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is : %d\n&quot;</span>, cliIP, cliProt);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接受客户端发来的数据</span></span><br><span class="line">            <span class="keyword">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(recvBuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">                <span class="keyword">int</span> len = read(cfd, &amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;IP : %s\n recv client Data : %s\n\n&quot;</span>, cliIP, recvBuf);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed ... ...\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 回射</span></span><br><span class="line">                write(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf));</span><br><span class="line">            &#125;</span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="comment">// 退出当前子进程</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="client-c"><a href="#client-c" class="headerlink" title="client.c"></a>client.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: client.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年06月23日 星期四 14时41分42秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// TCP 通信客户端</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">        <span class="keyword">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.连接服务</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">        serveraddr.sin_family = AF_INET;</span><br><span class="line">        serveraddr.sin_port = htons(<span class="number">5210</span>);</span><br><span class="line">        inet_pton(AF_INET, <span class="string">&quot;192.168.222.1&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">        <span class="keyword">int</span> ret = connect(fd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通信</span></span><br><span class="line">        <span class="keyword">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> data[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">        <span class="built_in">memset</span>(recvBuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">                <span class="comment">// 获取标准输入(stdin)的数据</span></span><br><span class="line">                fgets(data, <span class="keyword">sizeof</span>(data), <span class="built_in">stdin</span>);</span><br><span class="line">                write(fd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">                <span class="keyword">int</span> readLen = read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(readLen == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(readLen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(readLen == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 表示服务端断开连接</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;server closed ... ...\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        close(fd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP-通信并发-线程"><a href="#TCP-通信并发-线程" class="headerlink" title="TCP 通信并发 - 线程"></a>TCP 通信并发 - 线程</h2><h3 id="server-thread-c"><a href="#server-thread-c" class="headerlink" title="server_thread.c"></a>server_thread.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: server_thread.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年06月27日 星期一 18时00分07秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> &#123;</span></span><br><span class="line">        <span class="comment">// 通信的文件描述符</span></span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="comment">// 线程号</span></span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        <span class="comment">// 客户端的信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> <span class="title">sockinfos</span>[128];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">working</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子线程和客户端通信 cfd、客户端的信息、线程号</span></span><br><span class="line">        <span class="comment">// 获取客户端信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> *<span class="title">pinfo</span> =</span> (struct sockInfo *) arg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> cliIP[<span class="number">16</span>];</span><br><span class="line">        inet_ntop(AF_INET, &amp;pinfo-&gt;addr.sin_addr.s_addr, cliIP, <span class="keyword">sizeof</span>(cliIP));</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span> cliPort = pinfo-&gt;addr.sin_port;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;clien ip is : %s, prot is %d\n&quot;</span>, cliIP, cliPort);</span><br><span class="line">        <span class="keyword">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(recvBuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">                <span class="keyword">int</span> len = read(pinfo-&gt;fd, &amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;IP : %s\n recv client Data : %s\n\n&quot;</span>, cliIP, recvBuf);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed ... ...\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 回射</span></span><br><span class="line">                write(pinfo-&gt;fd, recvBuf, <span class="built_in">strlen</span>(recvBuf));</span><br><span class="line">        &#125;</span><br><span class="line">        pinfo-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">        pinfo-&gt;tid = <span class="number">-1</span>;</span><br><span class="line">        close(pinfo-&gt;fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个socket()</span></span><br><span class="line">        <span class="keyword">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">        saddr.sin_family = AF_INET;</span><br><span class="line">        saddr.sin_port = htons(<span class="number">5200</span>);</span><br><span class="line">        saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">        <span class="keyword">int</span> ret = bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听</span></span><br><span class="line">        ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化数据</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="keyword">sizeof</span>(sockinfos) / <span class="keyword">sizeof</span>(sockinfos[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">                bzero(&amp;sockinfos[i], <span class="keyword">sizeof</span>(sockinfos[i]));</span><br><span class="line">                sockinfos[i].fd = <span class="number">-1</span>;</span><br><span class="line">                sockinfos[i].tid = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环等待客户端连接, 一旦一个客户端连接进来, 就创建一个线程进行通信</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *) &amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 文件描述符fd、客户端的信息addr、线程号tid</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> *<span class="title">pinfo</span>;</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 从这个数组中找到一个可以用的sockInfo变量/元素</span></span><br><span class="line">                        <span class="keyword">if</span>(sockinfos[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                                pinfo = &amp;sockinfos[i];</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(i == max - <span class="number">1</span>) &#123;</span><br><span class="line">                                sleep(<span class="number">1</span>);</span><br><span class="line">                                i--;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pinfo-&gt;fd = cfd;</span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;pinfo-&gt;addr, &amp;cliaddr, len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建子线程</span></span><br><span class="line">                <span class="comment">// pthread_t tid;</span></span><br><span class="line">                pthread_create(&amp;pinfo-&gt;tid, <span class="literal">NULL</span>, working, pinfo);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 线程分离 - 使线程在结束时候自动回收</span></span><br><span class="line">                pthread_detach(pinfo-&gt;tid);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>gcc server_thread.c -o server_thread -pthread </p></blockquote><h3 id="client-c-1"><a href="#client-c-1" class="headerlink" title="client.c"></a>client.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: client.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年06月23日 星期四 14时41分42秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// TCP 通信客户端</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">        <span class="keyword">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.连接服务</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">        serveraddr.sin_family = AF_INET;</span><br><span class="line">        serveraddr.sin_port = htons(<span class="number">5200</span>);</span><br><span class="line">        inet_pton(AF_INET, <span class="string">&quot;192.168.222.1&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">        <span class="keyword">int</span> ret = connect(fd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通信</span></span><br><span class="line">        <span class="keyword">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> data[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">        <span class="built_in">memset</span>(recvBuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">                <span class="comment">// 获取标准输入(stdin)的数据</span></span><br><span class="line">                fgets(data, <span class="keyword">sizeof</span>(data), <span class="built_in">stdin</span>);</span><br><span class="line">                write(fd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">                <span class="keyword">int</span> readLen = read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(readLen == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(readLen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(readLen == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 表示服务端断开连接</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;server closed ... ...\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        close(fd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-TCP-状态转换"><a href="#11-TCP-状态转换" class="headerlink" title="11. TCP 状态转换"></a>11. TCP 状态转换</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220629123236025.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220629123236025.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220629123236025"></p><blockquote><p>红色线: 客户端</p><p>绿色线: 服务器</p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220629124303869.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220629124303869.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220629124303869"></p><ul><li><p>2MSL（Maximum Segment Lifetime）</p><p>主动断开连接的一方, 最后进出入一个 TIME_WAIT状态, 这个状态会持续: 2ms</p><ul><li>msl: 官方建议: 2分钟, 实际是30s</li></ul></li></ul><blockquote><p>当 TCP 连接主动关闭方接收到被动关闭方发送的 FIN 和最终的 ACK 后，连接的主动关闭方 必须处于TIME_WAIT 状态并持续 2MSL 时间。 </p><p>这样就能够让 TCP 连接的主动关闭方在它发送的 ACK 丢失的情况下重新发送最终的 ACK。 主动关闭方重新发送的最终 ACK 并不是因为被动关闭方重传了 ACK（它们并不消耗序列号， 被动关闭方也不会重传），而是因为被动关闭方重传了它的 FIN。事实上，被动关闭方总是 重传 FIN 直到它收到一个最终的 ACK。</p></blockquote><ul><li>半关闭</li></ul><blockquote><p>当 TCP 链接中 A 向 B 发送 FIN 请求关闭，另一端 B 回应 ACK 之后（A 端进入 FIN_WAIT_2 状态），并没有立即发送 FIN 给 A，A 方处于半连接状态（半开关），此时 A 可以接收 B 发 送的数据，但是 A 已经不能再向 B 发送数据。</p></blockquote><p>从程序的角度，可以使用 API 来控制实现半连接状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br><span class="line">sockfd: 需要关闭的socket的描述符</span><br><span class="line">how: 允许为shutdown操作选择以下几种方式:</span><br><span class="line">SHUT_RD(<span class="number">0</span>)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。</span><br><span class="line">该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span><br><span class="line">SHUT_WR(<span class="number">1</span>): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发</span><br><span class="line">出写操作。</span><br><span class="line">SHUT_RDWR(<span class="number">2</span>):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。</span><br></pre></td></tr></table></figure><p>使用 close 中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用 计数为 0 时才关闭连接。shutdown 不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方 向的连接，只中止读或只中止写。 </p><p>注意: </p><ol><li>如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用 进程都调用了 close，套接字将被释放。 </li><li>在多进程中如果一个进程调用了 shutdown(sfd, SHUT_RDWR) 后，其它的进程将无法进行通信。 但如果一个进程 close(sfd) 将不会影响到其它进程。</li></ol><h2 id="12-端口复用"><a href="#12-端口复用" class="headerlink" title="12. 端口复用"></a>12. 端口复用</h2><blockquote><p>端口复用最常用的用途是:</p><ul><li>防止服务器重启时之前绑定的端口还未释放 </li><li>程序突然退出而系统没有释放端口</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 设置套接字的属性 (不仅仅能设置端口的复用)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">- socket: 要操作的文件描述符</span><br><span class="line">- level: 级别 - SOL_SOCKET (端口复用的级别)</span><br><span class="line">- optname: 选项的命称</span><br><span class="line">- SO_REUSEADDR</span><br><span class="line">- SO_REUSEPORT</span><br><span class="line">- optval: 端口复用的值(整形)</span><br><span class="line">- <span class="number">1</span>: 可以复用</span><br><span class="line">- <span class="number">0</span>: 不可以复用</span><br><span class="line">- oprlen: optval参数的大小</span><br><span class="line">端口复用: 设置的时机是在服务器绑定端口之前。</span><br><span class="line">setsockopt();</span><br><span class="line">bind();</span><br></pre></td></tr></table></figure><h3 id="查看网络相关信息相关的命令"><a href="#查看网络相关信息相关的命令" class="headerlink" title="查看网络相关信息相关的命令"></a>查看网络相关信息相关的命令</h3><p>netstat</p><ul><li>参数:<ul><li>-a 显示所有连接的socke</li><li>-p 显示正在使用socket的程序的名称</li><li>-n 直接使用IP</li><li>-t 显示TCP</li><li>-u 显示UDP</li></ul></li></ul><blockquote><p>netstat -anp | grep 端口</p></blockquote><h3 id="TCP-服务端-和-客户端-网络连接状态及其相关信息"><a href="#TCP-服务端-和-客户端-网络连接状态及其相关信息" class="headerlink" title="TCP - 服务端 和 客户端 - 网络连接状态及其相关信息"></a>TCP - 服务端 和 客户端 - 网络连接状态及其相关信息</h3><h4 id="正常通信下状态是不回改变"><a href="#正常通信下状态是不回改变" class="headerlink" title="正常通信下状态是不回改变"></a>正常通信下状态是不回改变</h4><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220630183734709.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220630183734709.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220630183734709"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为什么有两个 server</span><br><span class="line">第一个是监听的</span><br><span class="line">第二个是建立连接的 ESTABLISHED</span><br></pre></td></tr></table></figure><h4 id="断开服务器端"><a href="#断开服务器端" class="headerlink" title="断开服务器端"></a>断开服务器端</h4><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220630224056500.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220630224056500.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220630224056500"></p><p>可看上面图解 - 状态</p>]]></content>
      
      
      <categories>
          
          <category> Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络基础</title>
      <link href="2022/06/15/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
      <url>2022/06/15/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-网络结构模式"><a href="#1-网络结构模式" class="headerlink" title="1.网络结构模式"></a>1.网络结构模式</h2><h3 id="C-x2F-S结构"><a href="#C-x2F-S结构" class="headerlink" title="C&#x2F;S结构"></a>C&#x2F;S结构</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote><p>服务器 - 客户机，即 Client - Server（C&#x2F;S）结构。C&#x2F;S 结构通常采取两层结构。服务器负责数据的 管理，客户机负责完成与用户的交互任务。客户机是因特网上访问别人信息的机器，服务器则是提 供信息供人访问的计算机。 客户机通过局域网与服务器相连，接受用户的请求，并通过网络向服务器提出请求，对数据库进行 操作。服务器接受客户机的请求，将数据提交给客户机，客户机将数据进行计算并将结果呈现给用 户。服务器还要提供完善安全保护及对数据完整性的处理等操作，并允许多个客户机同时访问服务 器，这就对服务器的硬件处理数据能力提出了很高的要求。 在C&#x2F;S结构中，应用程序分为两部分：服务器部分和客户机部分。服务器部分是多个用户共享的信 息与功能，执行后台服务，如控制共享数据库的操作等；客户机部分为用户所专有，负责执行前台 功能，在出错提示、在线帮助等方面都有强大的功能，并且可以在子程序间自由切换。</p></blockquote><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>能充分发挥客户端 PC 的处理能力，很多工作可以在客户端处理后再提交给服务器，所以 C&#x2F;S 结构 客户端响应速度快； </li><li>操作界面漂亮、形式多样，可以充分满足客户自身的个性化要求； </li><li>C&#x2F;S 结构的管理信息系统具有较强的事务处理能力，能实现复杂的业务流程； </li><li>安全性较高，C&#x2F;S 一般面向相对固定的用户群，程序更加注重流程，它可以对权限进行多层次校 验，提供了更安全的存取模式，对信息安全的控制能力很强，一般高度机密的信息系统采用 C&#x2F;S 结 构适宜。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>客户端需要安装专用的客户端软件。首先涉及到安装的工作量，其次任何一台电脑出问题，如病 毒、硬件损坏，都需要进行安装或维护。系统软件升级时，每一台客户机需要重新安装，其维护和 升级成本非常高； </li><li>对客户端的操作系统一般也会有限制，不能够跨平台。</li></ol><h3 id="B-x2F-S结构"><a href="#B-x2F-S结构" class="headerlink" title="B&#x2F;S结构"></a>B&#x2F;S结构</h3><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><blockquote><p>B&#x2F;S 结构（Browser&#x2F;Server，浏览器&#x2F;服务器模式），是 WEB 兴起后的一种网络结构模式，WEB 浏览器是客户端最主要的应用软件。这种模式统一了客户端，将系统功能实现的核心部分集中到服 务器上，简化了系统的开发、维护和使用。客户机上只要安装一个浏览器，如 Firefox 或 Internet Explorer，服务器安装 SQL Server、Oracle、MySQL 等数据库。浏览器通过 Web Server 同数据 库进行数据交互</p></blockquote><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>B&#x2F;S 架构最大的优点是总体拥有成本低、维护方便、 分布性强、开发简单，可以不用安装任何专门的软 件就能实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能 使用。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li>通信开销大、系统和数据的安全性较难保障; </li><li>个性特点明显降低，无法实现具有个性化的功能要求； </li><li>协议一般是固定的：http&#x2F;https </li><li>客户端服务器端的交互是请求-响应模式，通常动态刷新页面，响应速度明显降低。</li></ol><h2 id="2-MAC-地址"><a href="#2-MAC-地址" class="headerlink" title="2. MAC 地址"></a>2. MAC 地址</h2><blockquote><p>网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件，又称为网络适配器或网 络接口卡NIC。其拥有 MAC 地址，属于 OSI 模型的第 2 层，它使得用户可以通过电缆或无线相互 连接。每一个网卡都有一个被称为 MAC 地址的独一无二的 48 位串行号。网卡的主要功能：1.数 据的封装与解封装、2.链路管理、3.数据编码与译码。</p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220615110431847.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220615110431847.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220615110431847"></p><blockquote><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220615110431847.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220615110431847.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></blockquote><blockquote><p>MAC 地址（Media Access Control Address），直译为媒体存取控制位址，也称为局域网地址、 以太网地址、物理地址或硬件地址，它是一个用来确认网络设备位置的位址，由网络设备制造商生 产时烧录在网卡中。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 位址 。MAC 地址用于在网络中唯一标识一个网卡，一台设备若有一或多个网卡，则每个网卡都需 要并会有一个唯一的 MAC 地址。 MAC 地址的长度为 48 位（6个字节），通常表示为 12 个 16 进制数，如：00-16-EA-AE-3C-40 就 是一个MAC 地址，其中前 3 个字节，16 进制数 00-16-EA 代表网络硬件制造商的编号，它由 IEEE（电气与电子工程师协会）分配，而后 3 个字节，16进制数 AE-3C-40 代表该制造商所制造的 某个网络产品（如网卡）的系列号。只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。 形象地说，MAC 地址就如同身份证上的身份证号码，具有唯一性。</p></blockquote><h2 id="3-IP-地址"><a href="#3-IP-地址" class="headerlink" title="3. IP 地址"></a>3. IP 地址</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><blockquote><p>IP 协议是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所 有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任 何厂家生产的计算机系统，只要遵守 IP 协议就可以与因特网互连互通。各个厂家生产的网络系统 和设备，如以太网、分组交换网等，它们相互之间不能互通，不能互通的主要原因是因为它们所传 送数据的基本单元（技术上称之为“帧”）的格式不同。IP 协议实际上是一套由软件程序组成的协议 软件，它把各种不同“帧”统一转换成“IP 数据报”格式，这种转换是因特网的一个最重要的特点，使 所有各种计算机都能在因特网上实现互通，即具有“开放性”的特点。正是因为有了 IP 协议，因特 网才得以迅速发展成为世界上最大的、开放的计算机通信网络。因此，IP 协议也可以叫做“因特网 协议”。 IP 地址（Internet Protocol Address）是指互联网协议地址，又译为网际协议地址。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以 此来屏蔽物理地址的差异。 IP 地址是一个 32 位的二进制数，通常被分割为 4 个“ 8 位二进制数”（也就是 4 个字节）。IP 地址 通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是 0~255 之间的十进制整数。 例：点分十进IP地址（100.4.5.6），实际上是 32 位二进制数 （01100100.00000100.00000101.00000110）。</p></blockquote><h3 id="IP-地址编址方式"><a href="#IP-地址编址方式" class="headerlink" title="IP 地址编址方式"></a>IP 地址编址方式</h3><p>最初设计互联网络时，为了便于寻址以及层次化构造网络，每个 IP 地址包括两个标识码（ID），即网络 ID 和主机 ID。同一个物理网络上的所有主机都使用同一个网络 ID，网络上的一个主机（包括网络上工 作站，服务器和路由器等）有一个主机 ID 与其对应。Internet 委员会定义了 5 种 IP 地址类型以适合不 同容量的网络，即 A 类~ E 类。 其中 A、B、C 3类（如下表格）由 InternetNIC 在全球范围内统一分配，D、E 类为特殊地址。</p><table><thead><tr><th align="center"><strong>类别</strong></th><th align="center"><strong>最大网络数</strong></th><th align="center"><strong>IP</strong>地址范围</th><th align="center"><strong>单个网段最大主机数</strong></th><th align="center"><strong>私有</strong>IP<strong>地址范围</strong></th></tr></thead><tbody><tr><td align="center">A</td><td align="center">126(2^7-2)</td><td align="center">1.0.0.1-126.255.255.254</td><td align="center">16777214</td><td align="center">10.0.0.0-  10.255.255.255</td></tr><tr><td align="center">B</td><td align="center">16384(2^14)</td><td align="center">128.0.0.1- 191.255.255.254</td><td align="center">65534</td><td align="center">172.16.0.0-  172.31.255.255</td></tr><tr><td align="center">C</td><td align="center">2097152(2^21)</td><td align="center">192.0.0.1-223.255.255.254</td><td align="center">254</td><td align="center">192.168.0.0-  192.168.255.255</td></tr></tbody></table><h4 id="A类IP地址"><a href="#A类IP地址" class="headerlink" title="A类IP地址"></a>A类IP地址</h4><p>一个 A 类 IP 地址是指， 在 IP 地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算 机的号码。如果用二进制表示 IP 地址的话，A 类 IP 地址就由 1 字节的网络地址和 3 字节主机地址组 成，网络地址的最高位必须是“0”。A 类 IP 地址中网络的标识长度为 8 位，主机标识的长度为 24 位，A 类网络地址数量较少，有 126 个网络，每个网络可以容纳主机数达 1600 多万台。 A 类 IP 地址 地址范围 1.0.0.1 - 126.255.255.254（二进制表示为：00000001 00000000 00000000 00000001 - 01111111 11111111 11111111 11111110）。最后一个是广播地址。 A 类 IP 地址的子网掩码为 255.0.0.0，每个网络支持的最大主机数为 256 的 3 次方 - 2 &#x3D; 16777214 台。</p><h4 id="B类IP地址"><a href="#B类IP地址" class="headerlink" title="B类IP地址"></a>B类IP地址</h4><p>一个 B 类 IP 地址是指，在 IP 地址的四段号码中，前两段号码为网络号码。如果用二进制表示 IP 地址的 话，B 类 IP 地址就由 2 字节的网络地址和 2 字节主机地址组成，网络地址的最高位必须是“10”。B 类 IP 地址中网络的标识长度为 16 位，主机标识的长度为 16 位，B 类网络地址适用于中等规模的网络，有 16384 个网络，每个网络所能容纳的计算机数为 6 万多台。 B 类 IP 地址地址范围 128.0.0.1 - 191.255.255.254 （二进制表示为：10000000 00000000 00000000 00000001 - 10111111 11111111 11111111 11111110）。 最后一个是广播地址。 B 类 IP 地址的子网掩码为 255.255.0.0，每个网络支持的最大主机数为 256 的 2 次方 - 2 &#x3D; 65534 台。</p><h4 id="C类IP地址"><a href="#C类IP地址" class="headerlink" title="C类IP地址"></a>C类IP地址</h4><p>一个 C 类 IP 地址是指，在 IP 地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算 机的号码。如果用二进制表示 IP 地址的话，C 类 IP 地址就由 3 字节的网络地址和 1 字节主机地址组 成，网络地址的最高位必须是“110”。C 类 IP 地址中网络的标识长度为 24 位，主机标识的长度为 8 位， C 类网络地址数量较多，有 209 万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台 计算机。 C 类 IP 地址范围 192.0.0.1-223.255.255.254 （二进制表示为: 11000000 00000000 00000000 00000001 - 11011111 11111111 11111111 11111110）。 C类IP地址的子网掩码为 255.255.255.0，每个网络支持的最大主机数为 256 - 2 &#x3D; 254 台。</p><h4 id="D类IP地址"><a href="#D类IP地址" class="headerlink" title="D类IP地址"></a>D类IP地址</h4><p>D 类 IP 地址在历史上被叫做多播地址（multicast address），即组播地址。在以太网中，多播地址命 名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是 “1110”，范围从 224.0.0.0 - 239.255.255.255。</p><h3 id="特殊的网址"><a href="#特殊的网址" class="headerlink" title="特殊的网址"></a>特殊的网址</h3><p>每一个字节都为 0 的地址（ “0.0.0.0” ）对应于当前主机； </p><p>IP 地址中的每一个字节都为 1 的 IP 地址（ “255.255.255.255” ）是当前子网的广播地址； </p><p>IP 地址中凡是以 “11110” 开头的 E 类 IP 地址都保留用于将来和实验使用。 </p><p>IP地址中不能以十进制 “127” 作为开头，该类地址中数字 127.0.0.1 到 127.255.255.255 用于回路测 试，如：127.0.0.1可以代表本机IP地址。</p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><blockquote><p>子网掩码（subnet mask）又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个 IP 地 址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存 在，它必须结合 IP 地址一起使用。子网掩码只有一个作用，就是将某个 IP 地址划分成网络地址和 主机地址两部分。 子网掩码是一个 32 位地址，用于屏蔽 IP 地址的一部分以区别网络标识和主机标识，并说明该 IP 地址是在局域网上，还是在广域网上。</p></blockquote><p>子网掩码是在 IPv4 地址资源紧缺的背景下为了解决 lP 地址分配而产生的虚拟 lP 技术，通过子网掩码将 A、B、C 三类地址划分为若干子网，从而显著提高了 IP 地址的分配效率，有效解决了 IP 地址资源紧张 的局面。另一方面，在企业内网中为了更好地管理网络，网管人员也利用子网掩码的作用，人为地将一 个较大的企业内部网络划分为更多个小规模的子网，再利用三层交换机的路由功能实现子网互联，从而 有效解决了网络广播风暴和网络病毒等诸多网络管理方面的问题。 在大多数的网络教科书中，一般都将子网掩码的作用描述为通过逻辑运算，将 IP 地址划分为网络标识 (Net.ID) 和主机标识(Host.ID)，只有网络标识相同的两台主机在无路由的情况下才能相互通信。 根据 RFC950 定义，子网掩码是一个 32 位的 2 进制数， 其对应网络地址的所有位都置为 1，对应于主 机地址的所有位置都为 0。子网掩码告知路由器，地址的哪一部分是网络地址，哪一部分是主机地址， 使路由器正确判断任意 IP 地址是否是本网段的，从而正确地进行路由。网络上，数据从一个地方传到另 外一个地方，是依靠 IP 寻址。从逻辑上来讲，是两步的。第一步，从 IP 中找到所属的网络，好比是去 找这个人是哪个小区的；第二步，再从 IP 中找到主机在这个网络中的位置，好比是在小区里面找到这个 人。 </p><p>子网掩码的设定必须遵循一定的规则。与二进制 IP 地址相同，子网掩码由 1 和 0 组成，且 1 和 0 分别 连续。子网掩码的长度也是 32 位，左边是网络位，用二进制数字 “1” 表示，1 的数目等于网络位的长 度；右边是主机位，用二进制数字 “0” 表示，0 的数目等于主机位的长度。这样做的目的是为了让掩码 与 IP 地址做按位与运算时用 0 遮住原主机数，而不改变原网络段数字，而且很容易通过 0 的位数确定子 网的主机数（ 2 的主机位数次方 - 2，因为主机号全为 1 时表示该网络广播地址，全为 0 时表示该网络 的网络号，这是两个特殊地址）。通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使 网络正常工作。</p><h2 id="4-端口"><a href="#4-端口" class="headerlink" title="4. 端口"></a>4. 端口</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>“端口” 是英文 port 的意译，可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理 端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见，是特指TCP&#x2F;IP协议中的端 口，是逻辑意义上的端口。例如计算机中的 80 端口、21 端口、23 端口等。物理端口又称为接 口，是可见端口，计算机背板的 RJ45 网口，交换机路由器集线器等 RJ45 端口。电话使用 RJ11 插 口也属于物理端口的范畴。 如果把 IP 地址比作一间房子，端口就是出入这间房子的门。真正的房子只有几个门，但是一个 IP 地址的端口可以有 65536（即：2^16）个之多！端口是通过端口号来标记的，端口号只有整数， 范围是从 0 到65535（2^16-1）。</p><h3 id="端口类型"><a href="#端口类型" class="headerlink" title="端口类型"></a>端口类型</h3><ol><li>周知端口（Well Known Ports）</li></ol><p>周知端口是众所周知的端口号，也叫知名端口、公认端口或者常用端口，范围从 0 到 1023，它们紧密 绑定于一些特定的服务。例如 80 端口分配给 WWW 服务，21 端口分配给 FTP 服务，23 端口分配给 Telnet服务等等。我们在 IE 的地址栏里输入一个网址的时候是不必指定端口号的，因为在默认情况下 WWW 服务的端口是 “80”。网络服务是可以使用其他端口号的，如果不是默认的端口号则应该在地址栏 上指定端口号，方法是在地址后面加上冒号“:”（半角），再加上端口号。比如使用 “8080” 作为 WWW 服务的端口，则需要在地址栏里输入“网址:8080”。但是有些系统协议使用固定的端口号，它是不能被改 变的，比如 139 端口专门用于 NetBIOS 与 TCP&#x2F;IP 之间的通信，不能手动改变。 </p><ol><li>注册端口（Registered Ports）</li></ol><p>端口号从 1024 到 49151，它们松散地绑定于一些服务，分配给用户进程或应用程序，这些进程主要是 用户选择安装的一些应用程序，而不是已经分配好了公认端口的常用程序。这些端口在没有被服务器资 源占用的时候，可以用用户端动态选用为源端口。 </p><ol><li>动态端口 &#x2F; 私有端口（Dynamic Ports &#x2F; Private Ports）</li></ol><p>动态端口的范围是从 49152 到 65535。之所以称为动态端口，是因为它一般不固定分配某种服务，而是 动态分配</p><h2 id="5-网络模型"><a href="#5-网络模型" class="headerlink" title="5. 网络模型"></a>5. 网络模型</h2><h3 id="OSI-七层参考模型"><a href="#OSI-七层参考模型" class="headerlink" title="OSI 七层参考模型"></a>OSI 七层参考模型</h3><blockquote><p>七层模型，亦称 OSI（Open System Interconnection）参考模型，即开放式系统互联。参考模型 是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为 OSI 参 考模型或七层模型。 它是一个七层的、抽象的模型体，不仅包括一系列抽象的术语或概念，也包括具体的协议。</p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220615134421761.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220615134421761.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220615134421761"></p><ol><li>物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率 等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为 1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 </li><li>数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。定义了如何让格式化数据以帧 为单位进行传输，以及如何让控制对物理介质的访问。将比特组合成字节进而组合成帧，用MAC地 址访问介质。 </li><li>网络层：进行逻辑地址寻址，在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选 择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的 层。</li><li>传输层：定义了一些传输数据的协议和端口号（ WWW 端口 80 等），如：TCP（传输控制协议， 传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方 式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这 一层数据叫做段。 </li><li>会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间 发起会话或者接受会话请求。 </li><li>表示层：数据的表示、安全、压缩。主要是进行对接收的数据进行解释、加密与解密、压缩与解压 缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）。 </li><li>应用层：网络服务与最终用户的一个接口。这一层为用户的应用程序（例如电子邮件、文件传输和 终端仿真）提供网络服务。</li></ol><h2 id="TCP-x2F-IP-四层模型"><a href="#TCP-x2F-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a>TCP&#x2F;IP 四层模型</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><blockquote><p>现在 Internet（因特网）使用的主流协议族是 TCP&#x2F;IP 协议族，它是一个分层、多协议的通信体 系。TCP&#x2F;IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用 层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务。</p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220615150345756.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220615150345756.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220615150345756"></p><p>TCP&#x2F;IP 协议在一定程度上参考了 OSI 的体系结构。OSI 模型共有七层，从下到上分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。但是这显然是有些复杂的，所以在 TCP&#x2F;IP 协议中， 它们被简化为了四个层次。 </p><p>（1）应用层、表示层、会话层三个层次提供的服务相差不是很大，所以在 TCP&#x2F;IP 协议中，它们被合并 为应用层一个层次。 </p><p>（2）由于传输层和网络层在网络协议中的地位十分重要，所以在 TCP&#x2F;IP 协议中它们被作为独立的两个 层次。 </p><p>（3）因为数据链路层和物理层的内容相差不多，所以在 TCP&#x2F;IP 协议中它们被归并在网络接口层一个层 次里。只有四层体系结构的 TCP&#x2F;IP 协议，与有七层体系结构的 OSI 相比要简单了不少，也正是这样， TCP&#x2F;IP 协议在实际的应用中效率更高，成本更低。</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220615151135413.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220615151135413.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220615151135413"></p><h3 id="四层介绍"><a href="#四层介绍" class="headerlink" title="四层介绍"></a>四层介绍</h3><ol><li>应用层：应用层是 TCP&#x2F;IP 协议的第一层，是直接为应用进程提供服务的。</li></ol><p>（1）  对不同种类的应用程序它们会根据自己的需要来使用应用层的不同协议，邮件传输应用使用 了 SMTP 协议、万维网应用使用了 HTTP 协议、远程登录服务应用使用了有 TELNET 协议。</p><p>（2）  应用层还能加密、解密、格式化数据。</p><p>（3）  应用层可以建立或解除与其他节点的联系，这样可以充分节省网络资源。</p><ol start="2"><li><p>传输层：作为 TCP&#x2F;IP 协议的第二层，运输层在整个 TCP&#x2F;IP 协议中起到了中流砥柱的作用。且在运输层中， TCP 和 UDP 也同样起到了中流砥柱的作用。</p></li><li><p>网络层：网络层在 TCP&#x2F;IP 协议中的位于第三层。在 TCP&#x2F;IP 协议中网络层可以进行网络连接的建立和终止以及 IP 地址的寻找等功能。</p></li><li><p>网络接口层：在 TCP&#x2F;IP 协议中，网络接口层位于第四层。由于网络接口层兼并了物理层和数据链路层所以，网络接口层既是传输数据的物理媒介，也可以为网络层提供一条准确无误的线路。</p></li></ol><h2 id="6-协议"><a href="#6-协议" class="headerlink" title="6. 协议"></a>6. 协议</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><blockquote><p>协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连 接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。它的三要素是：语 法、语义、时序。 为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议 （protocol），它最终体现为在网络上传输的数据包的格式。 协议往往分成几个层次进行定义，分层定义是为了使某一层协议的改变不影响其他层次的协议。</p></blockquote><p>常见协议</p><p>应用层常见的协议有：FTP协议（File Transfer Protocol 文件传输协议）、HTTP协议（Hyper Text Transfer Protocol 超文本传输协议）、NFS（Network File System 网络文件系统）。 传输层常见协议有：TCP协议（Transmission Control Protocol 传输控制协议）、UDP协议（User Datagram Protocol 用户数据报协议）。 网络层常见协议有：IP 协议（Internet Protocol 因特网互联协议）、ICMP 协议（Internet Control Message Protocol 因特网控制报文协议）、IGMP 协议（Internet Group Management Protocol 因特 网组管理协议）。 网络接口层常见协议有：ARP协议（Address Resolution Protocol 地址解析协议）、RARP协议 （Reverse Address Resolution Protocol 反向地址解析协议）。</p><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220615154059122.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220615154059122.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220615154059122"></p><ol><li><p>源端口号：发送方端口号</p></li><li><p>目的端口号：接收方端口号</p></li><li><p>长度：UDP用户数据报的长度，最小值是8（仅有首部）</p></li><li><p>校验和：检测UDP用户数据报在传输中是否有错，有错就丢弃</p></li></ol><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220615154414002.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220615154414002.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220615154414002"></p><ol><li><p>源端口号：发送方端口号</p></li><li><p>目的端口号：接收方端口号</p></li><li><p>序列号：本报文段的数据的第一个字节的序号</p></li><li><p>确认序号：期望收到对方下一个报文段的第一个数据字节的序号</p></li><li><p>首部长度（数据偏移）：TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，即首部长度。单位：32位，即以 4 字节为计算单位</p></li><li><p>保留：占 6 位，保留为今后使用，目前应置为 0</p></li><li><p>紧急 URG ：此位置 1 ，表明紧急指针字段有效，它告诉系统此报文段中有紧急数据，应尽快传送</p></li><li><p>确认 ACK：仅当 ACK&#x3D;1 时确认号字段才有效，TCP 规定，在连接建立后所有传达的报文段都必须把 ACK 置1</p></li><li><p>推送 PSH：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作，这时，发送方TCP 把 PSH 置 1，并立即创建一个报文段发送出去，接收方收到 PSH &#x3D; 1 的报文段，就尽快地</p></li></ol><p>（即“推送”向前）交付给接收应用进程，而不再等到整个缓存都填满后再向上交付</p><ol start="10"><li><p>复位 RST：用于复位相应的 TCP 连接</p></li><li><p>同步 SYN：仅在三次握手建立 TCP 连接时有效。当 SYN &#x3D; 1 而 ACK &#x3D; 0 时，表明这是一个连接请求报文段，对方若同意建立连接，则应在相应的报文段中使用 SYN &#x3D; 1 和 ACK &#x3D; 1。因此，SYN 置1 就表示这是一个连接请求或连接接受报文</p></li><li><p>终止 FIN：用来释放一个连接。当 FIN &#x3D; 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p></li><li><p>窗口：指发送本报文段的一方的接收窗口（而不是自己的发送窗口）</p></li><li><p>校验和：校验和字段检验的范围包括首部和数据两部分，在计算校验和时需要加上 12 字节的伪头部</p></li><li><p>紧急指针：仅在 URG &#x3D; 1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据），即指出了紧急数据的末尾在报文中的位置，注意：即使窗口为零时也可发送紧急数 据</p></li><li><p>选项：长度可变，最长可达 40 字节，当没有使用选项时，TCP 首部长度是 20 字节</p></li></ol><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220616103129793.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220616103129793.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220616103129793">                                  </p><ol><li><p>版本：IP 协议的版本。通信双方使用过的 IP 协议的版本必须一致，目前最广泛使用的 IP 协议版本号为 4（即IPv4)</p></li><li><p>首部长度：单位是 32 位（4 字节）</p></li><li><p>服务类型：一般不适用，取值为 0</p></li><li><p>总长度：指首部加上数据的总长度，单位为字节</p></li><li><p>标识（identification）：IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1， 并将此值赋给标识字段</p></li><li><p>标志（flag）：目前只有两位有意义。</p></li></ol><p>标志字段中的最低位记为 MF。MF &#x3D; 1 即表示后面“还有分片”的数据报。MF &#x3D; 0 表示这已是若干数据报片中的最后一个。</p><p>标志字段中间的一位记为 DF，意思是“不能分片”，只有当 DF &#x3D; 0 时才允许分片</p><ol start="7"><li><p>片偏移：指出较长的分组在分片后，某片在源分组中的相对位置，也就是说，相对于用户数据段的 起点，该片从何处开始。片偏移以 8 字节为偏移单位。</p></li><li><p>生存时间：TTL，表明是数据报在网络中的寿命，即为“跳数限制”，由发出数据报的源点设置这个字段。路由器在转发数据之前就把 TTL 值减一，当 TTL 值减为零时，就丢弃这个数据报。</p></li><li><p>协议：指出此数据报携带的数据时使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程，常用的 ICMP(1)，IGMP(2)，TCP(6)，UDP(17)，IPv6（41）</p></li></ol><p>10.首部校验和：只校验数据报的首部，不包括数据部分。</p><ol start="11"><li><p>源地址：发送方 IP 地址</p></li><li><p>目的地址：接收方 IP 地址</p></li></ol><h3 id="以太网帧协议"><a href="#以太网帧协议" class="headerlink" title="以太网帧协议"></a>以太网帧协议</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220616132947068.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220616132947068.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220616132947068"></p><p>类型：0x800表示 IP、0x806表示 ARP、0x835表示 RARP</p><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220616133010344.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220616133010344.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220616133010344"></p><ol><li><p>硬件类型：1 表示 MAC 地址</p></li><li><p>协议类型：0x800 表示 IP 地址</p></li><li><p>硬件地址长度：6</p></li><li><p>协议地址长度：4</p></li><li><p>操作：1 表示 ARP 请求，2 表示 ARP 应答，3 表示 RARP 请求，4 表示 RARP 应答</p></li></ol><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>上层协议是如何使用下层协议提供的服务的呢？其实这是通过封装（encapsulation）实现的。应用程序 数据在发送到物理网络上之前，将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加 上自己的头部信息（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装。</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220616133158139.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220616133158139.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220616133158139"></p><h3 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h3><p>当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据， 以获取所需的信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用（demultiplexing）。分用是依靠头部信息中的类型字段实现的。</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220616133221624.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220616133221624.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220616133221624"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220616133232335.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220616133232335.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220616133232335"></p><h2 id="网络通信流程"><a href="#网络通信流程" class="headerlink" title="网络通信流程"></a>网络通信流程</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="网络通信的过程"></p><h2 id="ARP请求"><a href="#ARP请求" class="headerlink" title="ARP请求"></a>ARP请求</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/arp%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/arp%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="arp请求封装"></p>]]></content>
      
      
      <categories>
          
          <category> Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多表操作</title>
      <link href="2022/06/04/MySql/%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/"/>
      <url>2022/06/04/MySql/%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h2><p>实际开发中，一个项目通常需要很多张表才能完成。</p><p>例如：一个<strong>商城项目</strong>就需要分类表(category)、商品表(products)、订单表(orders)等多张表。且这些表 的数据之间存在一定的关系，接下来我们将在单表的基础上，一起学习多表方面的知识。</p><blockquote><p>MySQL关系型数据库<br>非关系型数据库：ES、Redis…</p></blockquote><h2 id="多表之间的关系"><a href="#多表之间的关系" class="headerlink" title="多表之间的关系"></a>多表之间的关系</h2><ul><li>一读一：一夫一妻制度</li><li>一对多：一夫多妻制度</li><li>多对多：群居制度</li></ul><p>表跟表之间的关系，大家可以理解为是实体跟实体的关系的一种映射。比如，导师与学员，订单与客 户，部门与员工等等。</p><p>主要关系有三种：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一对一：比如，一个男的只能取一个女的当老婆。</span><br><span class="line">一对多：比如，客户与订单，一个客户可以在商城中下多个订单。</span><br><span class="line">多对多：比如，学生与课程，一个学校有很多学生，学生都可以学很多课程。</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220604192713469.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220604192713469.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220604192713469"></p><h3 id="1）一对一关系"><a href="#1）一对一关系" class="headerlink" title="1）一对一关系"></a>1）一对一关系</h3><p>在实际工作中，一对一在开发中应用不多，因为一对一完全可以创建成一张表</p><p>建立两表的唯一一对一的关系：</p><ul><li>第一步：将被关联的表主键唯一</li><li>第二步：建立外键约束，管理该表的唯一主键</li></ul><p>案例：一个丈夫只能有一个妻子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> wife(</span><br><span class="line">id<span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY , wname<span class="type">VARCHAR</span>(<span class="number">20</span>), sex <span class="type">CHAR</span>(<span class="number">1</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> husband(</span><br><span class="line">id<span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY , hname<span class="type">VARCHAR</span>(<span class="number">20</span>), sex <span class="type">CHAR</span>(<span class="number">1</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="外键唯一"><a href="#外键唯一" class="headerlink" title="外键唯一"></a>外键唯一</h4><p>一对一关系创建方式 1 之外键唯一：</p><p>添加外键列 wid，指定该列的约束为唯一（不加唯一约束就是一对多关系）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> husband <span class="keyword">ADD</span> wid <span class="type">INT</span><span class="keyword">UNIQUE</span>;</span><br></pre></td></tr></table></figure><p>添加外键约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> husband <span class="keyword">add</span> <span class="keyword">foreign</span> key (wid) <span class="keyword">references</span> wife(id);</span><br></pre></td></tr></table></figure><h4 id="主键做外键"><a href="#主键做外键" class="headerlink" title="主键做外键"></a>主键做外键</h4><p>一对一关系创建方式 2 之主键做外键：（大家下去自己练习） 思路：使用主表的主键作为外键去关联从表的主键     </p><h3 id="2）一对多关系"><a href="#2）一对多关系" class="headerlink" title="2）一对多关系"></a><strong>2</strong>）一对多关系</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220604195003225.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220604195003225.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220604195003225"></p><h4 id="常见实例：一个分类对应多个商品，客户和订单，分类和商品，部门和员工"><a href="#常见实例：一个分类对应多个商品，客户和订单，分类和商品，部门和员工" class="headerlink" title="常见实例：一个分类对应多个商品，客户和订单，分类和商品，部门和员工."></a>常见实例：一个分类对应多个商品，客户和订单，分类和商品，部门和员工.</h4><p>总结：有外键的就是多的一方。</p><h4 id="注意事项：一对多关系和一对一关系的创建很类似，唯一区别就是外键不唯一"><a href="#注意事项：一对多关系和一对一关系的创建很类似，唯一区别就是外键不唯一" class="headerlink" title="注意事项：一对多关系和一对一关系的创建很类似，唯一区别就是外键不唯一"></a>注意事项：一对多关系和一对一关系的创建很类似，唯一区别就是外键不唯一</h4><p>一对多关系创建：</p><ul><li>添加外键列</li><li>添加外键约束</li></ul><h3 id="3）多对多关系"><a href="#3）多对多关系" class="headerlink" title="3）多对多关系"></a>3）多对多关系</h3><p>常见实例：学生和课程、用户和角色</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220604195129402.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220604195129402.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220604195129402"></p><p>注意事项：需要中间表去完成多对多关系的创建，多对多关系其实就是两个一对多关系的组合 </p><p>多对多关系创建：</p><ul><li><p>创建中间表，并在其中创建多对多关系中两张表的外键列</p></li><li><p>在中间表中添加外键约束</p></li><li><p>在中间表中添加联合主键约束</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库备份与恢复</title>
      <link href="2022/06/04/MySql/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
      <url>2022/06/04/MySql/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>数据库的备份是数据库转换成对应的的sql文件</p><h3 id="1）MySQL命令备份"><a href="#1）MySQL命令备份" class="headerlink" title="1）MySQL命令备份"></a>1）MySQL命令备份</h3><p>数据库导出sql脚本的格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>u用户名 <span class="operator">-</span>p密码 数据库名<span class="operator">&gt;</span>生成的脚本文件路径</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>proot day02<span class="operator">&gt;</span>d:\backup.sql</span><br></pre></td></tr></table></figure><p>以上备份数据库的命令中需要用户名和密码，即表明该命令要在用户没有登录的情况下使用</p><h3 id="2）可视化工具备份"><a href="#2）可视化工具备份" class="headerlink" title="2）可视化工具备份"></a>2）可视化工具备份</h3><p>选中数据库，右键 ”备份&#x2F;导出” ， 指定导出路径，保存成.sql文件即可。</p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>数据库的恢复指的是使用备份产生的sql文件恢复数据库，即将sql文件中的sql语句执行就可以恢复数据 库内容。</p><h3 id="1）命令恢复"><a href="#1）命令恢复" class="headerlink" title="1）命令恢复"></a>1）命令恢复</h3><p>使用数据库命令备份的时候只是备份了数据库内容，产生的sql文件中没有创建数据库的sql语句，在恢 复数据库之前需要自己动手创建数据库。</p><ul><li>在数据库外恢复<ul><li>格式: mysql -uroot -p密码 数据库名 &lt; 文件路径 </li><li>例如: mysql -uroot -proot day02</li></ul></li><li>在数据库内恢复<ul><li>格式: source SQL脚本路径 </li><li>例如: source d:\backup.sql </li><li>注意:使用这种方式恢复数据，首先要登录数据库.</li></ul></li></ul><h3 id="2-可视化工具恢复"><a href="#2-可视化工具恢复" class="headerlink" title="2)可视化工具恢复"></a>2)可视化工具恢复</h3><p>执行的SQL文件，执行即可。</p>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySql常见问题解答</title>
      <link href="2022/06/03/MySql/MySql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
      <url>2022/06/03/MySql/MySql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL数据库密码重置"><a href="#MySQL数据库密码重置" class="headerlink" title="MySQL数据库密码重置"></a>MySQL数据库密码重置</h2><ol><li>停止mysql服务器运行输入services.msc 停止mysql服务 </li><li>在cmd下,输入mysqld –console –skip-grant-tables 启动服务器,出现一下页面,不要关闭该窗口</li></ol><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220603135509405.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220603135509405.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220603135509405"></p><ol start="3"><li>新打开cmd,输入mysql -uroot 不需要密码</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> password<span class="operator">=</span>password(<span class="string">&#x27;root&#x27;</span>) <span class="keyword">WHERE</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>关闭两个cmd窗口</li></ol><h2 id="DOS操作数据乱码解决"><a href="#DOS操作数据乱码解决" class="headerlink" title="DOS操作数据乱码解决"></a>DOS操作数据乱码解决</h2><p>我们在dos命令行操作中文时，会报错</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> category(cid,cname) <span class="keyword">values</span>(‘c010’,’中文’);</span><br><span class="line">ERROR <span class="number">1366</span> (HY000): Incorrect string <span class="keyword">value</span>: <span class="string">&#x27;\xB7\xFE\xD7\xB0&#x27;</span> <span class="keyword">for</span> <span class="keyword">column</span></span><br><span class="line"><span class="string">&#x27;cname&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>错误原因：因为mysql的客户端设置编码是utf8，而系统的cmd窗口编码是gbk </p><ol><li>查看MySQL内部设置的编码</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character%&#x27;</span>; 查看所有mysql的编码</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220603143318963.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220603143318963.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220603143318963"></p><ol start="2"><li>需要修改client、connection、results的编码一致（GBK编码）</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解决方案<span class="number">1</span>：在cmd命令窗口中输入命令，此操作当前窗口有效，为临时方案。</span><br><span class="line"><span class="keyword">set</span> names gbk;</span><br></pre></td></tr></table></figure><p>解决方案2：安装目录下修改my.ini文件，重启服务所有地方生效</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220603140408997.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220603140408997.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220603140408997"></p><p>如果启动不了就用管理员或者去服务里面看看名字对不对</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启mysql服务:net <span class="keyword">start</span> mysql</span><br><span class="line">关闭mysql服务:net stop mysql</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220603155037352.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220603155037352.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220603155037352"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220603155206606.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220603155206606.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220603155206606"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.msc</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220603155251259.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220603155251259.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220603155251259"></p>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sql语句</title>
      <link href="2022/06/02/MySql/Sql%E8%AF%AD%E5%8F%A5/"/>
      <url>2022/06/02/MySql/Sql%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h2><h3 id="SQL语句介绍"><a href="#SQL语句介绍" class="headerlink" title="SQL语句介绍"></a>SQL语句介绍</h3><p>结构化查询语言(Structured Query Language)简称SQL，是关系型数据库管理系统都需要遵循的规范。 不同的数据库生产厂商都支持SQL语句，但都有特有内容。</p><blockquote><p>扩展：SQL作为一种访问【关系型数据库的标准语言】，SQL 自问世以来得到了广泛的应用，不仅 是著名的大型商用数据库产品 Oracle、DB2、Sybase、SQL Server 支持它，很多开源的数据库产 品如 PostgreSQL、MySQL也支持它，甚至一些小型的产品如 Access 也支持 SQL。近些年蓬勃发 展的 NoSQL 系统最初是宣称不再需要 SQL 的，后来也不得不修正为 Not Only SQL，来拥抱 SQL。 蓝色巨人 IBM 对关系数据库以及 SQL 语言的形成和规范化产生了重大的影响，第一个版本的 SQL 标准 SQL86 就是基于 System R 的手册而来的。 Oracle 在 1979 年率先推出了支持 SQL 的商用产品。随着数据库技术和应用的发展，为不同 RDBMS提供一致的语言成了一种现实需要。 对 SQL 标准影响最大的机构自然是那些著名的数据库产商，而具体的制订者则是一些非营利机 构，例如【国际标准化组织 ISO、美国国家标准委员会 ANSI】等。 各国通常会按照 ISO 标准和 ANSI 标准（这两个机构的很多标准是差不多等同的）制定自己的国 家标准。</p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220602182802042.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220602182802042.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220602182802042"></p><h3 id="SQL作用"><a href="#SQL作用" class="headerlink" title="SQL作用"></a>SQL作用</h3><ul><li>在数据库中检索信息。</li><li>对数据库的信息进行更新。 </li><li>改变数据库的结构。 </li><li>更改系统的安全设置。 </li><li>增加或回收用户对数据库、表的许可权限。</li></ul><h3 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h3><ul><li>数据定义语言：简称DDL(Data Definition Language) <ul><li>作用：用来定义数据库对象：数据库，表，列等。 </li><li>关键字：create，alter，drop等</li></ul></li><li>数据操作语言：简称DML(Data Manipulation Language)， <ul><li>作用：用来对数据库中表的记录进行更新。 </li><li>关键字：insert，delete，update等</li></ul></li><li>数据查询语言：简称DQL(Data Query Language)， <ul><li>作用：用来查询数据库中表的记录。 </li><li>关键字：select，from，where等</li></ul></li><li>数据控制语言：简称DCL(Data Control Language)， <ul><li>作用：用来定义数据库的访问权限和安全级别，及创建用户。</li></ul></li></ul><h3 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h3><ul><li>SQL语句可以单行或多行书写，以分号结尾 </li><li>可使用空格和缩进来增强语句的可读性 </li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写 <ul><li>例如：SELECT * FROM user。</li></ul></li><li>常用注释形式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 单行注释内容</span></span><br><span class="line"><span class="comment">/* 多行注释 */</span></span><br><span class="line"># 单行注释内容</span><br></pre></td></tr></table></figure><p>MySQL中的我们常使用的数据类型如下</p><table><thead><tr><th align="left"><strong>类型名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">int（integer）</td><td>整数类型</td></tr><tr><td align="left">double</td><td>小数类型</td></tr><tr><td align="left">decimal  （m,d）</td><td>指定整数位与小数位长度的小数类型 decimal(10,2)</td></tr><tr><td align="left">date</td><td>日期类型，格式为yyyy-MM-dd，包含年月日，不包含时分秒 2019-05-06</td></tr><tr><td align="left">datetime</td><td>日期类型，格式为 YYYY-MM-DD HH:MM:SS，包含年月日时分秒 2019-05-06  09:49:30</td></tr><tr><td align="left">timestamp</td><td>日期类型，时间戳</td></tr><tr><td align="left">varchar（M）</td><td>文本类型， M为0~65535之间的整数</td></tr></tbody></table><h2 id="DDL之数据库操作：database"><a href="#DDL之数据库操作：database" class="headerlink" title="DDL之数据库操作：database"></a>DDL之数据库操作：database</h2><p>创建、查看、删除、修改…</p><h3 id="1）-创建数据库"><a href="#1）-创建数据库" class="headerlink" title="1） 创建数据库"></a>1） 创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database 数据库名;</span><br><span class="line"><span class="keyword">create</span> database 数据库名 <span class="type">character</span> <span class="keyword">set</span> 字符集; <span class="comment">-- 字符集 如 UTF-8</span></span><br><span class="line"><span class="comment">-- 【案例】</span></span><br><span class="line"><span class="comment">-- 1. 创建一个叫 hello 的数据库</span></span><br><span class="line"><span class="keyword">create</span> database hello;</span><br><span class="line"><span class="comment">-- 2. 判读如果不存在则创建</span></span><br><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> hello;</span><br><span class="line"><span class="comment">-- 3. 创建数据库并指定字符集</span></span><br><span class="line"><span class="keyword">create</span> database hello <span class="keyword">default</span> <span class="type">character</span> <span class="keyword">set</span> gbk;</span><br></pre></td></tr></table></figure><h3 id="2）查看数据库"><a href="#2）查看数据库" class="headerlink" title="2）查看数据库"></a>2）查看数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">查看数据库服务器中的所有的数据库：<span class="keyword">show</span> databases;</span><br><span class="line">查看某个数据库的定义的信息：<span class="keyword">show</span> <span class="keyword">create</span> database 数据库名;</span><br><span class="line"><span class="comment">-- 【案例】</span></span><br><span class="line"><span class="comment">-- 查看数据库服务器中的所有的数据库</span></span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"><span class="comment">-- 查看某个数据库的定义信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> database hello;</span><br></pre></td></tr></table></figure><h3 id="3）删除数据库（慎用）"><a href="#3）删除数据库（慎用）" class="headerlink" title="3）删除数据库（慎用）"></a>3）删除数据库（慎用）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database 数据库名称;</span><br><span class="line"><span class="comment">-- 【案例】</span></span><br><span class="line"><span class="keyword">drop</span> database hello;</span><br></pre></td></tr></table></figure><h3 id="4）修改数据库"><a href="#4）修改数据库" class="headerlink" title="4）修改数据库"></a>4）修改数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修改数据库默认的字符集：</span><br><span class="line"><span class="keyword">alter</span> database 数据库名 <span class="keyword">default</span> <span class="type">character</span> <span class="keyword">set</span> 字符集</span><br><span class="line"><span class="comment">-- 【案例】</span></span><br><span class="line"><span class="keyword">alter</span> database hello3 <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br></pre></td></tr></table></figure><h3 id="5）其他数据库操作命令"><a href="#5）其他数据库操作命令" class="headerlink" title="5）其他数据库操作命令"></a>5）其他数据库操作命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">切换数据库： use 数据库名;</span><br><span class="line">查看正在使用的数据库：<span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure><h2 id="DDL之表操作：table"><a href="#DDL之表操作：table" class="headerlink" title="DDL之表操作：table"></a>DDL之表操作：table</h2><ul><li>创建数据库表</li><li>查看表</li><li>快速创建：克隆</li><li>删除表</li><li>修改表结构：如果表内有数据，修改需要谨慎<ul><li>字段更改字</li><li>段删除</li><li>修改表名称</li></ul></li></ul><h3 id="1）-创建表"><a href="#1）-创建表" class="headerlink" title="1） 创建表"></a>1） 创建表</h3><p>建立数据表，就是建立表结构，指定数据表中的一共有多少列，每一列的数据类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- create 指的是【创建】，table 指的是【数据表】。</span></span><br><span class="line"><span class="comment">-- 一张表中可以指定多个字段，用逗号隔开，最后的字段不需要逗号</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line"><span class="comment">-- 可以定义多个列</span></span><br><span class="line">字段名 类型(长度) 约束,</span><br><span class="line">字段名 类型(长度) 约束</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 【案例】</span></span><br><span class="line"><span class="comment">-- 创建用户表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user (</span><br><span class="line">uid <span class="type">int</span> <span class="keyword">primary</span> key auto_increment, <span class="comment">-- 用户 id</span></span><br><span class="line">uname <span class="type">varchar</span>(<span class="number">20</span>) <span class="comment">-- 用户名</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h3><p>常用的类型有：</p><ul><li>数字型：int、integer、bigint、mediumint、smallint、tinyint </li><li>浮点型：double、float、decimal（精确小数类型）</li><li>字符型：char（定长字符串）、varchar（可变长字符串）</li><li>日期类型：date（只有年月日）、time（只有时分秒）、datetime（年月日，时分秒）、year<br>  （年）</li><li>二进制字符串类型：binary（定长，以二进制形式保存字符串）、varbinary（可边长）</li></ul><h3 id="单表约束"><a href="#单表约束" class="headerlink" title="单表约束"></a>单表约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主键约束：primary key</span><br><span class="line">唯一约束：unique</span><br><span class="line">非空约束：not null</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主键约束 &#x3D; 唯一约束 + 非空约束</span><br></pre></td></tr></table></figure><h3 id="2）-查看表"><a href="#2）-查看表" class="headerlink" title="2） 查看表"></a>2） 查看表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看数据库中的所有表：<span class="keyword">show</span> tables;</span><br><span class="line">查看表结构：<span class="keyword">desc</span> 表名;</span><br><span class="line">查看创建表的 <span class="keyword">SQL</span> 语句：<span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;</span><br><span class="line"><span class="comment">-- 【案例】</span></span><br><span class="line">use hello; <span class="comment">-- 使用 hello 数据库</span></span><br><span class="line"><span class="keyword">show</span> tables; <span class="comment">-- 查看所有表</span></span><br><span class="line"><span class="keyword">desc</span> <span class="keyword">user</span>; <span class="comment">-- 查看 user 表的结构</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>; <span class="comment">-- 查看 user 表的创建语句</span></span><br></pre></td></tr></table></figure><h3 id="3）快速创建一个表结构相同的表"><a href="#3）快速创建一个表结构相同的表" class="headerlink" title="3）快速创建一个表结构相同的表"></a>3）快速创建一个表结构相同的表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 新的表名 <span class="keyword">like</span> 旧的表名;</span><br><span class="line"><span class="comment">-- 【案例】</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user <span class="keyword">like</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">desc</span> tb_user;</span><br></pre></td></tr></table></figure><h3 id="4）删除表"><a href="#4）删除表" class="headerlink" title="4）删除表"></a>4）删除表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> 表名;</span><br><span class="line"><span class="comment">-- 【案例】</span></span><br><span class="line"><span class="comment">-- 删除用户表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><h3 id="5）修改表"><a href="#5）修改表" class="headerlink" title="5）修改表"></a>5）修改表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.修改表添加列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 类型(长度) 约束;</span><br><span class="line"><span class="comment">-- 2.修改表修改列的类型长度及约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 列名 类型(长度) 约束;</span><br><span class="line"><span class="comment">-- 3.修改表修改列名</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 旧列名 新列名 类型(长度) 约束;</span><br><span class="line"><span class="comment">-- 4.修改表删除列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 列名;</span><br><span class="line"><span class="comment">-- 5.修改表名</span></span><br><span class="line">rename <span class="keyword">table</span> 表名 <span class="keyword">to</span> 新表名;</span><br><span class="line"><span class="comment">--【案例】</span></span><br><span class="line"><span class="comment">-- 修改表添加列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> address <span class="type">varchar</span>(<span class="number">50</span>);</span><br><span class="line"><span class="comment">-- 修改表修改列的类型长度及约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> modify address <span class="type">int</span>(<span class="number">30</span>);</span><br><span class="line"><span class="comment">-- 修改表修改列名</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> change address addr <span class="type">varchar</span>(<span class="number">50</span>);</span><br><span class="line"><span class="comment">-- 修改表删除列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">drop</span> addr;</span><br><span class="line"><span class="comment">-- 修改表名</span></span><br><span class="line">rename <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">to</span> tb_user;</span><br></pre></td></tr></table></figure><h2 id="DML数据操作语言"><a href="#DML数据操作语言" class="headerlink" title="DML数据操作语言"></a>DML数据操作语言</h2><h3 id="1）插入记录：insert"><a href="#1）插入记录：insert" class="headerlink" title="1）插入记录：insert"></a>1）插入记录：insert</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.向表中插入某些列</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表 (列名<span class="number">1</span>,列名<span class="number">2</span>,列名<span class="number">3.</span>.) <span class="keyword">values</span> (值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3.</span>.);</span><br><span class="line"><span class="comment">-- 2.向表中插入所有列</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表 <span class="keyword">values</span> (值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3.</span>.);</span><br><span class="line"><span class="comment">-- 3.从另外一张表查某些列的结果插入当前表</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表 (列名<span class="number">1</span>, 列名<span class="number">2</span>, 列名<span class="number">3.</span>.) <span class="keyword">values</span> <span class="keyword">select</span> (列名<span class="number">1</span>,列名<span class="number">2</span>,列名<span class="number">3.</span>.) <span class="keyword">from</span></span><br><span class="line">表</span><br><span class="line"><span class="comment">-- 4.从另外一张表查所有列的结果插入当前表</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表 <span class="keyword">values</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表</span><br><span class="line"><span class="comment">--【案例】</span></span><br><span class="line"><span class="comment">-- 向表中插入某些列，必须写列名</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (uid, uname) <span class="keyword">values</span> (<span class="number">001</span>, <span class="string">&#x27;cuihua&#x27;</span>);</span><br><span class="line"><span class="comment">-- 向表中插入所有列</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span> (<span class="number">002</span>, <span class="string">&#x27;aqiang&#x27;</span>);</span><br></pre></td></tr></table></figure><p>5个注意事项：</p><ul><li>① 列名数与 values 后面的值的个数相等</li><li>② 列的顺序与插入的值得顺序一致</li><li>③ 列名的类型与插入的值要一致.</li><li>④ 插入值得时候不能超过最大长度.</li><li>⑤ 值如果是字符串或者日期需要加引号’’ （一般是单引号）</li></ul><h3 id="2）更新记录：update"><a href="#2）更新记录：update" class="headerlink" title="2）更新记录：update"></a>2）更新记录：update</h3><p>语法格式：update 更新、set 修改的列值、where 指定条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> <span class="number">1.</span>不指定条件，会修改表中当前列所有数据</span><br><span class="line">update 表名 <span class="keyword">set</span> 字段名<span class="operator">=</span>值, 字段名<span class="operator">=</span>值;</span><br><span class="line"><span class="comment">-- 2.指定条件，符合条件的才会修改</span></span><br><span class="line">update 表名 <span class="keyword">set</span> 字段名<span class="operator">=</span>值, 字段名<span class="operator">=</span>值 <span class="keyword">where</span> 条件;</span><br><span class="line"><span class="comment">-- 【案例】</span></span><br><span class="line"><span class="comment">-- 更新所有字段的值</span></span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> uname<span class="operator">=</span><span class="string">&#x27;xiaodong&#x27;</span>;</span><br><span class="line"><span class="comment">-- 根据指定的条件来更新</span></span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> uname<span class="operator">=</span><span class="string">&#x27;hashiqi&#x27;</span> <span class="keyword">where</span> uid <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>① 列名的类型与修改的值要一致 </li><li>② 修改值得时候不能超过最大长度 </li><li>③ 值如果是字符串或者日期需要加 ’ ’ 引号</li></ul><h3 id="3）删除记录：delete-amp-truncate"><a href="#3）删除记录：delete-amp-truncate" class="headerlink" title="3）删除记录：delete &amp; truncate"></a>3）删除记录：delete &amp; truncate</h3><p>语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件];</span><br><span class="line"><span class="comment">-- 【案例】</span></span><br><span class="line"><span class="comment">-- 删除表中所有数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="comment">-- 删除 uid 为 1 的用户</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> uid <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure><p><strong>注意</strong> </p><p>删除表中所有记录使用【delete from 表名】，还是用【truncate table 表名】？ </p><p>删除方式的区别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ：一条一条删除，不清空 auto_increment 记录数。</span><br><span class="line"><span class="keyword">truncate</span> ：直接将表删除，重新建表，auto_increment 将置为零，从新开始</span><br></pre></td></tr></table></figure><h2 id="SQL约束"><a href="#SQL约束" class="headerlink" title="SQL约束"></a>SQL约束</h2><p>约束类型：</p><ul><li>主键约束 primary key </li><li>唯一性约束 unique </li><li>非空约束 not null </li><li>外键约束 foreign key</li></ul><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><p>PRIMARY KEY 约束唯一标识数据库表中的每条记录。</p><p>特点：</p><ul><li>主键必须包含唯一的值。 </li><li>主键列不能包含 NULL 值。 </li><li>每个表都应该有一个主键，并且每个表只能有一个主键。</li></ul><h4 id="添加主键约束"><a href="#添加主键约束" class="headerlink" title="添加主键约束"></a>添加主键约束</h4><ul><li>方式一：创建表时，在字段描述处，声明指定字段为主键：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> persons(</span><br><span class="line">id_p <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">lastname <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">firstname <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">address <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">city <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>方式二：创建表时，在constraint约束区域，声明指定字段为主键：<ul><li>格式： [constraint 名称] primary key (字段列表) </li><li>关键字constraint可以省略，如果需要为主键命名，constraint不能省略，主键名称一般没 用。 </li><li>字段列表需要使用小括号括住，如果有多字段需要使用逗号分隔。声明两个以上字段为主键， 我们称为联合主键。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> persons_cons(</span><br><span class="line">firstname <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">lastname <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">address <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">city <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> pk_personID <span class="keyword">PRIMARY</span> KEY (firstname,lastname)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>方式三：创建表之后，通过修改表结构，声明指定字段为主键：<ul><li>格式： ALTER TABLE persons ADD [CONSTRAINT 名称] PRIMARY KEY (字段列表)</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> persons_after(</span><br><span class="line">firstname <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">lastname <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">address <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">city <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> persons_after <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (firstname,lastname);</span><br></pre></td></tr></table></figure><h4 id="删除主键约束"><a href="#删除主键约束" class="headerlink" title="删除主键约束"></a>删除主键约束</h4><p>如需撤销 PRIMARY KEY 约束，请使用下面的 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> persons <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY</span><br></pre></td></tr></table></figure><h3 id="自动增长列"><a href="#自动增长列" class="headerlink" title="自动增长列"></a>自动增长列</h3><p>我们通常希望在每次插入新记录时，数据库自动生成字段的值。 </p><p>我们可以在表中使用 auto_increment（自动增长列）关键字，自动增长列类型必须是整形，自动增长列 必须为键(一般是主键)。</p><ul><li>下列 SQL 语句把 “persons” 表中的 “p_id” 列定义为 auto_increment 主键</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> persons_id(</span><br><span class="line">p_id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">lastname <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">firstname <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">address <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">city <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>向persons添加数据时，可以不为p_id字段设置值，也可以设置成null，数据库将自动维护主键 值：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> persons_id (firstname,lastname) <span class="keyword">VALUES</span> (<span class="string">&#x27;Bill&#x27;</span>,<span class="string">&#x27;Gates&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> persons_id (p_id,firstname,lastname) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="keyword">NULL</span>,<span class="string">&#x27;Bill&#x27;</span>,<span class="string">&#x27;Gates&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>默认AUTO_INCREMENT 的开始值是 1，如果希望修改起始值，请使用下列 SQL 语法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> persons AUTO_INCREMENT<span class="operator">=</span><span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><p>NOT NULL 约束强制列不接受 NULL 值。 NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记 录。</p><ul><li>下面的 SQL 语句强制 “id_p” 列和 “lastname” 列不接受 NULL 值：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> persons_null(</span><br><span class="line">id_p <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">lastname <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">firstname <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">address <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">city <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><ul><li>UNIQUE 约束唯一标识数据库表中的每条记录。 </li><li>UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。 </li><li>PRIMARY KEY 拥有自动定义的 UNIQUE 约束。</li></ul><blockquote><p>注意：每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。</p></blockquote><h4 id="添加唯一约束"><a href="#添加唯一约束" class="headerlink" title="添加唯一约束"></a>添加唯一约束</h4><p>与主键添加方式相同，共有3种</p><ul><li>方式一：创建表时，在字段描述处，声明唯一：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> persons_unique(</span><br><span class="line">id_p <span class="type">int</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">lastname <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">firstname <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">address <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">city <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>方式二：创建表时，在约束区域，声明唯一：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> persons(</span><br><span class="line">id_p <span class="type">int</span>,</span><br><span class="line">lastname <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">firstname <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">address <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">city <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> unique_id_p <span class="keyword">UNIQUE</span> (Id_P)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>方式三：创建表后，修改表结构，声明字段唯一：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> persons <span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span> 名称] <span class="keyword">UNIQUE</span> (Id_P)</span><br></pre></td></tr></table></figure><h4 id="删除唯一约束"><a href="#删除唯一约束" class="headerlink" title="删除唯一约束"></a>删除唯一约束</h4><ul><li>如需撤销 UNIQUE 约束，请使用下面的 SQL：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> persons <span class="keyword">DROP</span> INDEX 名称</span><br></pre></td></tr></table></figure><ul><li>如果添加唯一约束时，没有设置约束名称，默认是当前字段的字段名。</li></ul><h2 id="SQL语句之DQL【重要、重要、重要】"><a href="#SQL语句之DQL【重要、重要、重要】" class="headerlink" title="SQL语句之DQL【重要、重要、重要】"></a>SQL语句之DQL【重要、重要、重要】</h2><p>语法：查询不会对数据库中的数据进行修改，根据指定的方式来呈现数据。 </p><p>语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="operator">|</span> 列名,列名 <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件表达式]</span><br></pre></td></tr></table></figure><ul><li>select 是查询指令，可以读 1 ~ n 行数据； </li><li>列名换成 * 号，可以查询所有字段数据； </li><li>使用 where 来指定对应的条件</li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>创建商品表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (</span><br><span class="line"><span class="comment">-- 自增加 AUTO_INCREMENT</span></span><br><span class="line">pid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">pname <span class="type">VARCHAR</span>(<span class="number">20</span>), <span class="comment">-- 商品名称</span></span><br><span class="line">price <span class="keyword">DOUBLE</span>, <span class="comment">-- 商品价格</span></span><br><span class="line">pdate <span class="type">DATE</span>, <span class="comment">-- 日期</span></span><br><span class="line">sid <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="comment">-- 分类ID</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;泰国大榴莲&#x27;</span>, <span class="number">98</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;s001&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;新疆大枣&#x27;</span>, <span class="number">38</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;s002&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;新疆切糕&#x27;</span>, <span class="number">68</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;s001&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;十三香&#x27;</span>, <span class="number">10</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;s002&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;老干妈&#x27;</span>, <span class="number">20</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;s002&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有的商品</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product;</span><br><span class="line"><span class="comment">-- 查询指定列：商品名和商品价格</span></span><br><span class="line"><span class="keyword">select</span> pname,price <span class="keyword">from</span> product;</span><br><span class="line"><span class="comment">-- 别名查询，使用的 as 关键字，as 也可以省略的</span></span><br><span class="line"><span class="comment">-- 使用别名的好处：显示的时候使用识别性更强的名字，本身也不会去影响到表结构</span></span><br><span class="line"><span class="comment">-- 表别名</span></span><br><span class="line"><span class="comment">-- select 字段名 as 字段别名 from 表名</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">as</span> p;</span><br><span class="line"><span class="comment">-- 列别名</span></span><br><span class="line"><span class="comment">-- select 列名 as 列别名 from 表名</span></span><br><span class="line"><span class="keyword">select</span> pname <span class="keyword">as</span> pn <span class="keyword">from</span> product;</span><br><span class="line"><span class="comment">-- 列和表，同时指定别名</span></span><br><span class="line"><span class="comment">-- select 列名 as 列别名 from 表名 as 表别名</span></span><br><span class="line"><span class="comment">-- 去掉重复值</span></span><br><span class="line"><span class="comment">-- select distinct 字段名 from 表名</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> pname <span class="keyword">from</span> product;</span><br><span class="line"><span class="comment">--查询结果是表达式（运算查询）：将所有商品的价格 +10 元进行显示</span></span><br><span class="line"><span class="comment">-- select 列名+固定值 from 表名</span></span><br><span class="line"><span class="comment">-- select 列名1 + 列名2 from 表名</span></span><br><span class="line"><span class="keyword">select</span> pname, price <span class="operator">+</span> <span class="number">10</span> <span class="keyword">from</span> product;</span><br></pre></td></tr></table></figure><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>使用条件查询，可以根据当下具体情况直查想要的那部分数据，对记录进行过滤。 </p><p>SQL 语法关键字： WHERE </p><p>语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220603160155125.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220603160155125.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220603160155125"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询商品名称为十三香的商品所有信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="operator">=</span> <span class="string">&#x27;十三香&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询商品价格 &gt;60 元的所有的商品信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">&gt;</span> <span class="number">60</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">&lt;=</span> <span class="number">60</span>;</span><br><span class="line"><span class="comment">-- 不等于</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">!=</span> <span class="number">60</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">&lt;&gt;</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th><strong>NOT</strong></th><th><strong>逻辑非【</strong>**!<strong>】</strong></th></tr></thead><tbody><tr><td>AND</td><td>逻辑与【&amp;&amp;】</td></tr><tr><td>OR</td><td>逻辑或【||】</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">&gt;</span> <span class="number">40</span> <span class="keyword">and</span> pid <span class="operator">&gt;</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">&gt;</span> <span class="number">40</span> <span class="keyword">or</span> pid <span class="operator">&gt;</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="in-关键字"><a href="#in-关键字" class="headerlink" title="in 关键字"></a>in 关键字</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- in 匹配某些值中</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pid <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>);</span><br><span class="line"><span class="comment">-- 不在这些值中</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pid <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>);</span><br></pre></td></tr></table></figure><h3 id="指定范围中-between…and"><a href="#指定范围中-between…and" class="headerlink" title="指定范围中 between…and"></a>指定范围中 between…and</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pid <span class="keyword">between</span> <span class="number">2</span> <span class="keyword">and</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="模糊查询-like-关键字"><a href="#模糊查询-like-关键字" class="headerlink" title="模糊查询 like 关键字"></a>模糊查询 like 关键字</h3><ul><li><p>模糊查询: 作用是帮助匹配模糊的字段内容</p></li><li><p>语法:where之后加上like 语法，%百分号，_下划线</p></li><li><p>% 代表任意长短内容模糊匹配:</p><ul><li>[%xxx]以xxx结尾的任意内容。</li><li>[xxx%]以xxx开头的任意内容</li><li>[%xxx%]包含xxx的任意内容</li></ul></li><li><p>_代表任意一个字符的内容模糊匹配</p><ul><li>[_xxx]以任意单个字符开头的xxx内容。</li><li>[xxx__x]</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 like 实现模糊查询</span></span><br><span class="line"><span class="comment">-- “新”开头</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">&#x27;新%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 包含“新”</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">&#x27;%新%&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段 <span class="operator">=</span> 值 <span class="keyword">order</span> <span class="keyword">by</span> 字段名 [<span class="keyword">asc</span> <span class="operator">|</span> <span class="keyword">desc</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">asc</span> 升序</span><br><span class="line"><span class="keyword">desc</span> 降序</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有的商品，按价格进行排序</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">order</span> <span class="keyword">by</span> price;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询名称有新的商品的信息并且按价格降序排序</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">&#x27;%新%&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h2 id="聚合函数（组函数）"><a href="#聚合函数（组函数）" class="headerlink" title="聚合函数（组函数）"></a>聚合函数（组函数）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">特点：只对单列进行操作</span><br><span class="line">常用的聚合函数：</span><br><span class="line"><span class="built_in">sum</span>()：求某一列的和</span><br><span class="line"><span class="built_in">avg</span>()：求某一列的平均值</span><br><span class="line"><span class="built_in">max</span>()：求某一列的最大值</span><br><span class="line"><span class="built_in">min</span>()：求某一列的最小值</span><br><span class="line"><span class="built_in">count</span>()：求某一列的元素个数</span><br><span class="line"><span class="comment">-- 获得所有商品的价格的总和：</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(price) <span class="keyword">from</span> product;</span><br><span class="line"><span class="comment">-- 获得所有商品的平均价格：</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(price) <span class="keyword">from</span> product;</span><br><span class="line"><span class="comment">-- 获得所有商品的个数：</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> product;</span><br></pre></td></tr></table></figure><h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><p>分组查询:作用是将查询结果按照某列数据来进行分组呈现</p><p>语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span> 语法关键字：<span class="keyword">GROUP</span> <span class="keyword">BY</span>、<span class="keyword">HAVING</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span>, 字段<span class="number">2.</span>.. <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> 分组字段 [<span class="keyword">having</span> 条件];</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据 cno 字段分组，分组后统计商品的个数</span></span><br><span class="line"><span class="keyword">select</span> sid, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> product <span class="keyword">group</span> <span class="keyword">by</span> sid;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 根据 cno 分组，分组统计每组商品的平均价格，并且平均价格 &gt; 60;</span></span><br><span class="line"><span class="keyword">select</span> sid, <span class="built_in">avg</span>(price) <span class="keyword">from</span> product <span class="keyword">group</span> <span class="keyword">by</span> sid <span class="keyword">having</span> <span class="built_in">avg</span>(price) <span class="operator">&gt;</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure><p>注意事项：</p><p>① select 语句中的列（非聚合函数列），必须出现在 group by 子句中</p><p>② group by 子句中的列，不一定要出现在 select 语句中 </p><p>③ 聚合函数只能出现 select 语句中或者 having 语句中，一定不能出现在 where 语句中。</p><p><strong>having 和 where 的区别：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先，执行的顺序是有先有后。</span><br></pre></td></tr></table></figure><p>1） where</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对查询结果进行分组前，将不符合 <span class="keyword">where</span> 条件的记录过滤掉，然后再分组。</span><br><span class="line"><span class="keyword">where</span> 后面，不能再使用聚合函数。</span><br></pre></td></tr></table></figure><p>2）having</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">筛选满足条件的组，分组之后过滤数据。</span><br><span class="line"><span class="keyword">having</span> 后面，可以使用聚合函数。</span><br></pre></td></tr></table></figure><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><ul><li>功能: 将查询的结果按照一页一页的形式输出</li></ul><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 语法</span></span><br><span class="line"><span class="keyword">select</span> 列 <span class="keyword">from</span> 表 limit <span class="keyword">offset</span>, length</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例 0 偏移量</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> products limit <span class="number">0</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>关键字：limit [offset,] rows 语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="operator">|</span> 字段列表 [<span class="keyword">as</span> 别名] <span class="keyword">from</span> 表名</span><br><span class="line">[<span class="keyword">where</span>] 条件语句</span><br><span class="line">[<span class="keyword">group</span> <span class="keyword">by</span>] 分组语句</span><br><span class="line">[<span class="keyword">having</span>] 过滤语句</span><br><span class="line">[<span class="keyword">order</span> <span class="keyword">by</span>] 排序语句</span><br><span class="line">[limit] 分页语句;</span><br><span class="line">limit <span class="keyword">offset</span>, length;</span><br><span class="line"><span class="keyword">offset</span>：开始行数，从 <span class="number">0</span> 开始</span><br><span class="line">length：每页显示的行数</span><br></pre></td></tr></table></figure><p>limit 关键字不是 SQL92 标准提出的关键字，它是 MySQL 独有的语法。 </p><p>通过 limit 关键字，MySQL 实现了物理分页。 </p><p>分页分为逻辑分页和物理分页： </p><p><strong>逻辑分页</strong>：将数据库中的数据查询到内存之后再进行分页。</p><p><strong>物理分页</strong>：通过 LIMIT 关键字，直接在数据库中进行分页，最终返回的数据，只是分页后的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果省略第一个参数，默认从 0 开始</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product limit <span class="number">5</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product limit <span class="number">3</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h2 id="查询分类"><a href="#查询分类" class="headerlink" title="查询分类"></a>查询分类</h2><ul><li>条件查询 where</li><li>分组查询group by</li><li>having针对分组结果过滤</li><li>排序order by</li><li>分页 limit</li></ul><p>查询语句顺序:</p><ul><li>select 列 from 表 where 条件 group by 分组 having 过滤 order by 排序 limit 分页</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程同步-锁-信号量</title>
      <link href="2022/05/31/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E9%94%81-%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>2022/05/31/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E9%94%81-%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="低配卖票很多问题-进程资源的抢占"><a href="#低配卖票很多问题-进程资源的抢占" class="headerlink" title="低配卖票很多问题 - 进程资源的抢占"></a>低配卖票很多问题 - 进程资源的抢占</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: selltickets.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月31日 星期二 14时28分01秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  使用多线程实现卖票案例</span></span><br><span class="line"><span class="comment"> *  有3个窗口,一共是100张票</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量,所有的线程都共享这一份资源 - 结果：不通的进程会卖同一张票</span></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sellticket</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 卖票</span></span><br><span class="line">    <span class="comment">// int tickets = 100; - 每个线程都会卖100张!</span></span><br><span class="line">    <span class="keyword">while</span>(tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        usleep(<span class="number">6000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, pthread_self(), tickets--);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2, tid3;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid3, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收子线程资源,阻塞 --- 可以设置线程分离</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程分离</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    pthread_detach(tid1);</span></span><br><span class="line"><span class="comment">    pthread_detach(tid2);</span></span><br><span class="line"><span class="comment">    pthread_detach(tid3);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出主线程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul><li><p>线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程 修改的变量。</p></li><li><p>临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是 同时访问同一共享资源的其他线程不应终端该片段的执行。</p></li><li><p>线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进 行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处 于等待状态。</p></li></ul><h2 id="互斥锁-互斥量"><a href="#互斥锁-互斥量" class="headerlink" title="互斥锁(互斥量)"></a>互斥锁(互斥量)</h2><ul><li><p>为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion 的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共 享资源的原子访问。</p></li><li><p>互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报 错失败，具体取决于加锁时使用的方法。</p></li><li><p>一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情 况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问 同一资源时将采用如下协议：</p><ul><li>针对共享资源锁定互斥量</li><li>访问共享资源</li><li>对互斥量解锁</li></ul></li></ul><p>如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域，如下图所示：</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220531163332190.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220531163332190.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220531163332190"></p><h2 id="互斥量-互斥锁-相关操作函数及介绍"><a href="#互斥量-互斥锁-相关操作函数及介绍" class="headerlink" title="互斥量(互斥锁)相关操作函数及介绍"></a>互斥量(互斥锁)相关操作函数及介绍</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">互斥量的类型 <span class="keyword">pthread_mutex_t</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,  <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line">    - 功能: 初始化互斥量</span><br><span class="line">    - 参数:</span><br><span class="line">        - mutex: 需要初始话的互斥量变量</span><br><span class="line">        - attr: 互斥量相关的属性<span class="literal">NULL</span></span><br><span class="line">    - <span class="keyword">restrict</span>: c语言的修饰符,被修饰的指针,不能由另外的一个指针进行 操作</span><br><span class="line">        <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> = mutex = xxx;</span><br><span class="line">        <span class="keyword">pthread_mutex_t</span> *mutex1 = mutex; <span class="comment">// 不允许</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line">    - 功能: 释放互斥量资源</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line">    - 功能: 加锁 - 阻塞,如有有一个线程加锁了那么其他线程只能阻塞等待</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line">    - 功能: 尝试加锁,如果加锁失败,不会阻塞,会直接返回</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line">    - 释放锁(解锁)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: mutex.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月31日 星期二 16时36分54秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    互斥量的类型 pthread_mutex_t</span></span><br><span class="line"><span class="comment">    int pthread_mutex_init(pthread_mutex_t *restrict mutex,  const pthread_mutexattr_t *restrict attr);</span></span><br><span class="line"><span class="comment">        - 功能: 初始化互斥量</span></span><br><span class="line"><span class="comment">        - 参数:</span></span><br><span class="line"><span class="comment">            - mutex: 需要初始话的互斥量变量</span></span><br><span class="line"><span class="comment">            - attr: 互斥量相关的属性NULL</span></span><br><span class="line"><span class="comment">        - restrict: c语言的修饰符,被修饰的指针,不能由另外的一个指针进行 操作</span></span><br><span class="line"><span class="comment">            pthread_mutex_t *restrict = mutex = xxx;</span></span><br><span class="line"><span class="comment">            pthread_mutex_t *mutex1 = mutex; // 不允许</span></span><br><span class="line"><span class="comment">    int pthread_mutex_destroy(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">        - 功能: 释放互斥量资源</span></span><br><span class="line"><span class="comment">    int pthread_mutex_lock(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">        - 功能: 加锁 - 阻塞,如有有一个线程加锁了那么其他线程只能阻塞等待</span></span><br><span class="line"><span class="comment">    int pthread_mutex_trylock(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">        - 功能: 尝试加锁,如果加锁失败,不会阻塞,会直接返回</span></span><br><span class="line"><span class="comment">    int pthread_mutex_unlock(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">        - 释放锁(解锁)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: selltickets.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月31日 星期二 14时28分01秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  使用多线程实现卖票案例</span></span><br><span class="line"><span class="comment"> *  有3个窗口,一共是100张票</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量,所有的线程都共享这一份资源 - (没加互斥锁的情况)结果：不通的 进程会卖同一张票</span></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sellticket</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卖票</span></span><br><span class="line">    <span class="comment">// int tickets = 100; - 每个线程都会卖100张!</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            usleep(<span class="number">6000</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, pthread_self(), tickets--);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥量</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2, tid3;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid3, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收子线程资源,阻塞 --- 可以设置线程分离</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出主线程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥量资源</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul><li><p>有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。</p></li><li><p>两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</p></li><li><p>死锁的几种场景：</p><ul><li>忘记释放锁 &#x2F;&#x2F; pthread_mutex_trylock() 尝试加锁判断</li><li>重复加锁</li><li>多线程多锁，抢占锁资源</li></ul></li></ul><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220531183939044.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220531183939044.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220531183939044"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220531185455335.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220531185455335.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220531185455335"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220531185445783.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220531185445783.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220531185445783"></p><h3 id="忘记加锁-可替换上述函数代码-尝试运行"><a href="#忘记加锁-可替换上述函数代码-尝试运行" class="headerlink" title="忘记加锁 - 可替换上述函数代码 尝试运行"></a>忘记加锁 - 可替换上述函数代码 尝试运行</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sellticket</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卖票</span></span><br><span class="line">    <span class="comment">// int tickets = 100; - 每个线程都会卖100张!</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            usleep(<span class="number">6000</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, pthread_self(), tickets--);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        <span class="comment">// pthread_mutex_unlock(&amp;mutex);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重复加锁"><a href="#重复加锁" class="headerlink" title="重复加锁"></a>重复加锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sellticket</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卖票</span></span><br><span class="line">    <span class="comment">// int tickets = 100; - 每个线程都会卖100张!</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            usleep(<span class="number">6000</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, pthread_self(), tickets--);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多线程多锁，抢占锁资源-C"><a href="#多线程多锁，抢占锁资源-C" class="headerlink" title="多线程多锁，抢占锁资源 - C"></a>多线程多锁，抢占锁资源 - C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: deadlock1.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月31日 星期二 19时09分34秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建2个互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex1, mutex2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">workA</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex1);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;mutex1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;workA\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">workB</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex2);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;mutex1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;workB\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥量</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建2个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, workA, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, workB, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收子线程资源</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥量资源</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex1);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><ul><li><p>当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想 读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读 访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。</p></li><li><p>在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。</p></li><li><p>读写锁的特点：</p><ul><li>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。</li><li>如果有其它线程写数据，则其它线程都不允许读、写操作。</li><li>写是独占的，写的优先级高。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">读写锁的类型 <span class="keyword">pthread_rwlock_t</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,    <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line">       - 功能: 初始化读写锁</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">       - 功能: 销毁</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">       - 功能: 加读锁</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">       - 功能: 尝试加读锁</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">       - 功能: 写锁</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">       - 功能: 尝试加写锁</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">       - 功能: 关闭写</span><br></pre></td></tr></table></figure><h3 id="读写锁-案例-C"><a href="#读写锁-案例-C" class="headerlink" title="读写锁(案例) - C"></a>读写锁(案例) - C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: rwlock.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年06月01日 星期三 10时27分52秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    读写锁的类型 pthread_rwlock_t</span></span><br><span class="line"><span class="comment">    int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,    const pthread_rwlockattr_t *restrict attr);</span></span><br><span class="line"><span class="comment">        - 功能: 初始化读写锁</span></span><br><span class="line"><span class="comment">    int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</span></span><br><span class="line"><span class="comment">        - 功能: 销毁</span></span><br><span class="line"><span class="comment">    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</span></span><br><span class="line"><span class="comment">        - 功能: 加读锁</span></span><br><span class="line"><span class="comment">    int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</span></span><br><span class="line"><span class="comment">        - 功能: 尝试加读锁</span></span><br><span class="line"><span class="comment">    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</span></span><br><span class="line"><span class="comment">        - 功能: 写锁</span></span><br><span class="line"><span class="comment">    int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</span></span><br><span class="line"><span class="comment">        - 功能: 尝试加写锁</span></span><br><span class="line"><span class="comment">    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</span></span><br><span class="line"><span class="comment">        - 功能: 关闭写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    案例:</span></span><br><span class="line"><span class="comment">        创建8个线程操作同一个变量</span></span><br><span class="line"><span class="comment">        3个线程不定时的写这个全局变量,5个线程不定时的读这个全局变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个共享数据</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一一个互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个读写锁</span></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">readNum</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// pthread_mutex_lock(&amp;mutex);</span></span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;==read, tid : %ld, num : %d\n&quot;</span>, pthread_self(), num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        <span class="comment">//pthread_mutex_unlock(&amp;mutex);</span></span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">writeNum</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// pthread_mutex_lock(&amp;mutex);</span></span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++write, tid : %ld, num : %d\n&quot;</span>, pthread_self(), num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        <span class="comment">//pthread_mutex_unlock(&amp;mutex);</span></span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥量</span></span><br><span class="line">    <span class="comment">// pthread_mutex_init(&amp;mutex, NULL);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化读写锁</span></span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个写线程,5个度</span></span><br><span class="line">    <span class="keyword">pthread_t</span> wtids[<span class="number">3</span>], rtids[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;wtids[i], <span class="literal">NULL</span>, writeNum, <span class="literal">NULL</span>);</span><br><span class="line">       <span class="comment">// 设置线程分离</span></span><br><span class="line">        pthread_detach(wtids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;rtids[i], <span class="literal">NULL</span>, readNum, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 设置线程分离</span></span><br><span class="line">        <span class="comment">// pthread_detach(rtids[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(int i = 0; i &lt; 3; i++) &#123;</span></span><br><span class="line"><span class="comment">        // 设置线程分离</span></span><br><span class="line"><span class="comment">        pthread_detach(wtids[i]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">   for(int i = 0; i &lt; 5; i++) &#123;</span></span><br><span class="line"><span class="comment">        // 设置线程分离</span></span><br><span class="line"><span class="comment">        pthread_detach(rtids[i]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出父进程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pthread_mutex_destroy(&amp;mutex);</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220601135409287.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220601135409287.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220601135409287"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220601142226666.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220601142226666.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220601142226666"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220601142230699.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220601142230699.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220601142230699"></p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><h3 id="条件变量函数"><a href="#条件变量函数" class="headerlink" title="条件变量函数"></a>条件变量函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">条件变量的类型 <span class="keyword">pthread_cond_t</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">const</span>  <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line">    - 功能: 初始化</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line">    - 功能: 释放</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="keyword">thread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line">    - 功能: 等待,阻塞函数调用了该函数线程会阻塞</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,  <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span>  abstime)</span></span>;</span><br><span class="line">    - 功能: 等待多长时间,调用了这个函数,线程会阻塞,直到指定的时间结束</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line">    - 功能: 唤醒一个或者多个等待的线程</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line">    - 功能: 唤醒所以的等待的线程</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: cond.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年06月01日 星期三 19时49分46秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    条件变量的类型 pthread_cond_t</span></span><br><span class="line"><span class="comment">    int pthread_cond_init(pthread_cond_t *restrict cond, const  pthread_condattr_t *restrict attr);</span></span><br><span class="line"><span class="comment">        - 功能: 初始化</span></span><br><span class="line"><span class="comment">    int pthread_cond_destroy(pthread_cond_t *cond);</span></span><br><span class="line"><span class="comment">        - 功能: 释放</span></span><br><span class="line"><span class="comment">    int pthread_cond_wait(pthread_cond_t *restrict cond,thread_mutex_t *restrict mutex);</span></span><br><span class="line"><span class="comment">        - 功能: 等待,阻塞函数调用了该函数线程会阻塞</span></span><br><span class="line"><span class="comment">    int pthread_cond_timedwait(pthread_cond_t *restrict cond,  pthread_mutex_t *restrict mutex, const struct timespec *restrict  abstime);</span></span><br><span class="line"><span class="comment">        - 功能: 等待多长时间,调用了这个函数,线程会阻塞,直到指定的时间结 束</span></span><br><span class="line"><span class="comment">    int pthread_cond_signal(pthread_cond_t *cond);</span></span><br><span class="line"><span class="comment">        - 功能: 唤醒一个或者多个等待的线程</span></span><br><span class="line"><span class="comment">    int pthread_cond_broadcast(pthread_cond_t *cond);</span></span><br><span class="line"><span class="comment">        - 功能: 唤醒所以的等待的线程</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  生产者消费者模型(粗略版本)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 创建一个条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断的创建新的节点,添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        Node *newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        newNode-&gt;num = rand() % <span class="number">1000</span>;</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要生成了一个,就通知消费者消费</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">customer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存头节点的指针</span></span><br><span class="line">            Node *temp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, temp-&gt;num, pthread_self());</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有数据需要等待</span></span><br><span class="line">            <span class="comment">// 当这个函数调用阻塞时候会对互斥锁进行解锁,当不阻塞的，继续向下执行,会重新加锁</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 初始化条件变量</span></span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生成者线程和5个消费者线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_detach(ptids[i]);</span><br><span class="line">        pthread_detach(ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><h3 id="信号量函数"><a href="#信号量函数" class="headerlink" title="信号量函数"></a>信号量函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">信号量的类型 <span class="keyword">sem_t</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    - 功能: 初始化信号量</span><br><span class="line">    - 参数:</span><br><span class="line">        - sem: 信号量的的地址</span><br><span class="line">        - pshared: <span class="number">0</span>用在线程间、非<span class="number">0</span>用在进程间</span><br><span class="line">        - value: 信号量中的值</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line">    - 功能: 释放资源</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line">    - 功能: 对信号量加锁,对这个信号量的值减<span class="number">1</span>,如果值为<span class="number">0</span>,就阻塞</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line">    - 功能: 尝试</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">const</span> struct timespec *abs_timeout)</span></span>;</span><br><span class="line">    - 功能: 等待多长的时间</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line">    - 功能: 对信号量解锁,调用一次对信号的值加<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> *sval)</span></span>;</span><br><span class="line">    - 功能: 获取</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: semaphore.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年06月02日 星期四 13时35分42秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    信号量的类型 sem_t</span></span><br><span class="line"><span class="comment">    int sem_init(sem_t *sem, int pshared, unsigned int value);</span></span><br><span class="line"><span class="comment">        - 功能: 初始化信号量</span></span><br><span class="line"><span class="comment">        - 参数:</span></span><br><span class="line"><span class="comment">            - sem: 信号量的的地址</span></span><br><span class="line"><span class="comment">            - pshared: 0用在线程间、非0用在进程间</span></span><br><span class="line"><span class="comment">            - value: 信号量中的值</span></span><br><span class="line"><span class="comment">    int sem_destroy(sem_t *sem);</span></span><br><span class="line"><span class="comment">        - 功能: 释放资源</span></span><br><span class="line"><span class="comment">    int sem_wait(sem_t *sem);</span></span><br><span class="line"><span class="comment">        - 功能: 对信号量加锁,对这个信号量的值减1,如果值为0,就阻塞</span></span><br><span class="line"><span class="comment">    int sem_trywait(sem_t *sem);</span></span><br><span class="line"><span class="comment">        - 功能: 尝试</span></span><br><span class="line"><span class="comment">    int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</span></span><br><span class="line"><span class="comment">        - 功能: 等待多长的时间</span></span><br><span class="line"><span class="comment">    int sem_post(sem_t *sem);</span></span><br><span class="line"><span class="comment">        - 功能: 对信号量解锁,调用一次对信号的值加1</span></span><br><span class="line"><span class="comment">    int sem_getvalue(sem_t *sem, int *sval);</span></span><br><span class="line"><span class="comment">        - 功能: 获取</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 生</span></span><br><span class="line"><span class="comment">    sem_t pesm;</span></span><br><span class="line"><span class="comment">    // 消</span></span><br><span class="line"><span class="comment">    sem_t csem;</span></span><br><span class="line"><span class="comment">    init(pesm, 0, 8);</span></span><br><span class="line"><span class="comment">    init(csem, 0, 0);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 生产</span></span><br><span class="line"><span class="comment">    prodicer() &#123;</span></span><br><span class="line"><span class="comment">        sem_wait(&amp;osem);</span></span><br><span class="line"><span class="comment">        sem_post(&amp;csem);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 消费</span></span><br><span class="line"><span class="comment">    customer() &#123;</span></span><br><span class="line"><span class="comment">        sem_wait(&amp;csem);</span></span><br><span class="line"><span class="comment">        sem_post(&amp;pesm);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 信号量</span></span><br><span class="line"><span class="keyword">sem_t</span> psem;</span><br><span class="line"><span class="keyword">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断的创建新的节点,添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        Node *newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        newNode-&gt;num = rand() % <span class="number">1000</span>;</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">customer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存头节点的指针</span></span><br><span class="line">            Node *temp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, temp-&gt;num, pthread_self());</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 信号量初始化</span></span><br><span class="line">        sem_init(&amp;psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生成者线程和5个消费者线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_detach(ptids[i]);</span><br><span class="line">        pthread_detach(ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux多线程开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程的操作</title>
      <link href="2022/05/30/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>2022/05/30/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="pthread-create-创建线程"><a href="#pthread-create-创建线程" class="headerlink" title="pthread_create 创建线程"></a>pthread_create 创建线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: pthread_create.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月30日 星期一 10时33分57秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    一般情况下, main 函数所在的线程我们称之为主线程(main线程),其余创建的线程称之为子线程。</span></span><br><span class="line"><span class="comment">    程序中默认只有一个进程,fork()函数调用,2进行</span></span><br><span class="line"><span class="comment">    程序中默认只有一个线程,pthread_create(函数调用),2个线程</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment">        - 功能: 创建一个子线程</span></span><br><span class="line"><span class="comment">        - 参数:</span></span><br><span class="line"><span class="comment">            - thread: 传出参数,线程创建成功,子线程的线程ID被写到该变变量当中</span></span><br><span class="line"><span class="comment">            - attr: 设置线程的属性, 一般使用默认值,NULL</span></span><br><span class="line"><span class="comment">            - start_routine: 函数指针,这个函数是子线程需要处理的逻辑代码</span></span><br><span class="line"><span class="comment">            - atg: 给第三个参数使用的,传参</span></span><br><span class="line"><span class="comment">        - 返回值:</span></span><br><span class="line"><span class="comment">            成功返回 0</span></span><br><span class="line"><span class="comment">            失败返回 错误号,和之前的errno不太一样</span></span><br><span class="line"><span class="comment">            获取错误号的信息: char strerror(int errnum)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">callback</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg value:%d \n&quot;</span>, *(<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, (<span class="keyword">void</span> *)&amp;num);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s \n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>主线程和子线程其实是交替执行的</p></blockquote><h2 id="pthread-exit-终止线程-pthread-self-获取当前的线程的线程ID"><a href="#pthread-exit-终止线程-pthread-self-获取当前的线程的线程ID" class="headerlink" title="pthread_exit() 终止线程 - pthread_self() 获取当前的线程的线程ID"></a>pthread_exit() 终止线程 - pthread_self() 获取当前的线程的线程ID</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: pthread_exit.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月30日 星期一 14时30分18秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    void pthread_exit(void *retval);</span></span><br><span class="line"><span class="comment">        功能: 终止一个线程,在那个线程中调用,就表示终止那个那个线程</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            retval:需要传递一个指针,作为一个返回值,返回值可以在pthread_join()中获取到</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pthread_t thread_self(void);</span></span><br><span class="line"><span class="comment">        功能: 获取当前的线程的线程ID</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">callback</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// pthread_exit(null);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程退出,当主线程退出时,不影响其他正常运行的线程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 运行之后可以看出 printf 和 return 0都没执行 所以说？？？？</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pthread-join-链接已终止的进程-回收子线程"><a href="#pthread-join-链接已终止的进程-回收子线程" class="headerlink" title="pthread_join() 链接已终止的进程(回收子线程)"></a>pthread_join() 链接已终止的进程(回收子线程)</h2><p>回收子线程测试阻塞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: pthread_join.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月30日 星期一 17时54分48秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment"> *  int pthread_join(pthread_t thread, void **retval);</span></span><br><span class="line"><span class="comment"> *      - 功能:和一个已经终止的线程进行链接</span></span><br><span class="line"><span class="comment"> *          回收子线程的资源</span></span><br><span class="line"><span class="comment"> *          这个函数是阻塞函数,调用一次只能回收一个子线程</span></span><br><span class="line"><span class="comment"> *          一般在主线线程中使用</span></span><br><span class="line"><span class="comment"> *      - 参数:</span></span><br><span class="line"><span class="comment"> *          - thread: 需要回收的子线程的ID</span></span><br><span class="line"><span class="comment"> *          - retval: 接收子进程退出时的返回值</span></span><br><span class="line"><span class="comment"> *      - 返回值:</span></span><br><span class="line"><span class="comment"> *          成功返回 0</span></span><br><span class="line"><span class="comment"> *          失败返回 错误号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">callback</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程调用pthread_join回收子进程资源 - 阻塞进程</span></span><br><span class="line">    ret = pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;回收子线程的资源成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: pthread_join.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月30日 星期一 17时54分48秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment"> *  int pthread_join(pthread_t thread, void **retval);</span></span><br><span class="line"><span class="comment"> *      - 功能:和一个已经终止的线程进行链接</span></span><br><span class="line"><span class="comment"> *          回收子线程的资源</span></span><br><span class="line"><span class="comment"> *          这个函数是阻塞函数,调用一次只能回收一个子线程</span></span><br><span class="line"><span class="comment"> *          一般在主线线程中使用</span></span><br><span class="line"><span class="comment"> *      - 参数:</span></span><br><span class="line"><span class="comment"> *          - thread: 需要回收的子线程的ID</span></span><br><span class="line"><span class="comment"> *          - retval: 接收子进程退出时的返回值</span></span><br><span class="line"><span class="comment"> *      - 返回值:</span></span><br><span class="line"><span class="comment"> *          成功返回 0</span></span><br><span class="line"><span class="comment"> *          失败返回 错误号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">callback</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="comment">// sleep(3);</span></span><br><span class="line">    <span class="comment">// return NULL;</span></span><br><span class="line">    <span class="comment">// int value = 10; // 局部变量 - 因为在之前的图中可知栈空间是分层的所以你释放完时候下面输出的就是一个随机的值</span></span><br><span class="line">    pthread_exit((<span class="keyword">void</span> *)&amp;value); <span class="comment">// 跟retrn (void *)&amp;value</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程调用pthread_join回收子进程资源 - 阻塞进程</span></span><br><span class="line">    <span class="keyword">int</span> *thread_retval;</span><br><span class="line">    ret = pthread_join(tid, (<span class="keyword">void</span> **)&amp;thread_retval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    解释join为什么传2级指针</span></span><br><span class="line"><span class="comment">    int data = 10;</span></span><br><span class="line"><span class="comment">    假如你想调用函数修改 data的值一定是 test(&amp;data) 不是test(data)</span></span><br><span class="line"><span class="comment">    void test(int a) &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    同理</span></span><br><span class="line"><span class="comment">    int **data = 10;</span></span><br><span class="line"><span class="comment">    void test(int a) &#123;&#125;</span></span><br><span class="line"><span class="comment">    test(** data)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit data : %d\n&quot;</span>, *thread_retval);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;回收子线程的资源成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pthread-detach-线程的分离"><a href="#pthread-detach-线程的分离" class="headerlink" title="pthread_detach()线程的分离"></a>pthread_detach()线程的分离</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: pthread_detach.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月30日 星期一 19时46分59秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment"> *  int pthread_detach(pthread_t thread);</span></span><br><span class="line"><span class="comment"> *      - 功能: 分离一个线程,被分离的线程在终止的时候会自动释放资源返回 给系统。</span></span><br><span class="line"><span class="comment"> *          1.不能多次的分离,会产生不可预料的行为.</span></span><br><span class="line"><span class="comment"> *          2.不能去连接一个已经分离的线程,会报错</span></span><br><span class="line"><span class="comment"> *      - 参数:需要分离的线程的ID</span></span><br><span class="line"><span class="comment"> *      - 返回值:</span></span><br><span class="line"><span class="comment"> *          成功返回 0</span></span><br><span class="line"><span class="comment"> *          失败返回 错误号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">callback</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error_create : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出子线程和子线程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id % ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子线程分离,子线程结束时对应的资源就不需要主线程释放</span></span><br><span class="line">    ret = pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error_datach : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程分离, 对分离的子线程进行链接 pthread_join() - 错误</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ret = pthread_join(tid, NULL);</span></span><br><span class="line"><span class="comment">    if(ret != 0) &#123;</span></span><br><span class="line"><span class="comment">        char * errstr = strerror(ret);</span></span><br><span class="line"><span class="comment">        printf(&quot;error_join : %s\n&quot;, errstr);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 退出主进程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>线程分离之后不能再链接(join)</p></blockquote><h2 id="pthread-cancel-线程取消"><a href="#pthread-cancel-线程取消" class="headerlink" title="pthread_cancel() 线程取消"></a>pthread_cancel() 线程取消</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: pthread_cancel.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月31日 星期二 09时32分12秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment"> *  int pthread_cancel(pthread_t thread);</span></span><br><span class="line"><span class="comment"> *      - 功能: 取消线程(让线程终止)</span></span><br><span class="line"><span class="comment"> *          取消某个线程,可以终止某个线程的运行</span></span><br><span class="line"><span class="comment"> *          但是并不是立马终止,而是当子线程执行到一个取消点，线程才会终 止</span></span><br><span class="line"><span class="comment"> *          取消点:系统规定好的一些系统调用(每个系统都可能不一样),我们可以粗略的理解为 从用户区到内核去的切换这个位置称之为取消点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">callback</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child : %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error_create : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消线程</span></span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出子线程和子线程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id % ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出主进程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><h3 id="线程分离-获取线程栈的大小"><a href="#线程分离-获取线程栈的大小" class="headerlink" title="线程分离 - 获取线程栈的大小"></a>线程分离 - 获取线程栈的大小</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: pthread_attr.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月31日 星期二 13时27分44秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_attr_init(pthread_attr_t *attr);</span></span><br><span class="line"><span class="comment">                - 功能: 初始化线程属性变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int pthread_attr_destroy(pthread_attr_t *attr);</span></span><br><span class="line"><span class="comment">                - 功能: 释放线程属性的资源</span></span><br><span class="line"><span class="comment">        int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);</span></span><br><span class="line"><span class="comment">                - 功能: 获取线程分离的状态属性</span></span><br><span class="line"><span class="comment">        int pthread_attr_setdetachstate(ptread_attr_t *attr, int detachstate);</span></span><br><span class="line"><span class="comment">                - 功能: 设置线程分离的状态属性</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">callback</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child : %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程属性变量</span></span><br><span class="line">        <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">        <span class="comment">// 初始化属性变量</span></span><br><span class="line">        pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置属性 - PTHREAD_CREATE_DETACHED(线程分离)</span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程栈的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    pthread_attr_getstacksize(&amp;attr, &amp;size);</span><br><span class="line">    <span class="comment">// printf(&quot;thread stack size : %ld\n&quot;, size);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个子线程 - 设置属性</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, &amp;attr, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error_create : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程栈的大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread stack size : %ld\n&quot;</span>, size);</span><br><span class="line">        <span class="comment">// 输出子线程和子线程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id % ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放线程资源</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="comment">// 退出主进程</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux多线程开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程概述</title>
      <link href="2022/05/29/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
      <url>2022/05/29/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><ul><li><p>与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共 享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传 统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程）</p></li><li><p>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。</p></li><li><p>线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本 质仍是进程。</p></li><li><p>查看指定进程的 LWP 号：ps –Lf pid</p></li></ul><h2 id="线程和进程区别"><a href="#线程和进程区别" class="headerlink" title="线程和进程区别"></a>线程和进程区别</h2><ul><li><p>进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换。</p></li><li><p>调用 fork() 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如 内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销 依然不菲。</p></li><li><p>线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。</p></li><li><p>创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采 用写时复制来复制内存，也无需复制页表。</p></li></ul><h2 id="线程和进程虚拟地址空间"><a href="#线程和进程虚拟地址空间" class="headerlink" title="线程和进程虚拟地址空间"></a>线程和进程虚拟地址空间</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220529191840589.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220529191840589.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220529191840589"></p><h2 id="线程之间共享和非共享资源"><a href="#线程之间共享和非共享资源" class="headerlink" title="线程之间共享和非共享资源"></a>线程之间共享和非共享资源</h2><ul><li><p>共享资源</p><ul><li>进程 ID 和父进程 ID</li><li>p进程组 ID 和会话 ID</li><li>p用户 ID 和 用户组 ID</li><li>文件描述符表</li><li>信号处置</li><li>文件系统的相关信息：文件权限掩码（umask）、当前工作目录</li><li>虚拟地址空间（除栈、.text）</li></ul></li><li><p>非共享资源</p><ul><li>非共享资源</li><li>信号掩码</li><li>线程特有数据</li><li>perror 变 量</li><li>实时调度策略和优先级</li><li>栈，本地变量和函数的调用链接信息</li></ul></li></ul><h2 id="NPTL"><a href="#NPTL" class="headerlink" title="NPTL"></a>NPTL</h2><ul><li><p>当  Linux 最初开发时，在内核中并不能真正支持线程。但是它的确可以通过 clone() 系统调用将进程作为可调度的实体。这个调用创建了调用进程（calling process）的 一个拷贝，这个拷贝与调用进程共享相同的地址空间。LinuxThreads 项目使用这个调用 来完成在用户空间模拟对线程的支持。不幸的是，这种方法有一些缺点，尤其是在信号处 理、调度和进程间同步等方面都存在问题。另外，这个线程模型也不符合 POSIX 的要求。</p></li><li><p>要改进 LinuxThreads，需要内核的支持，并且重写线程库。有两个相互竞争的项目开始 来满足这些要求。一个包括 IBM 的开发人员的团队开展了 NGPT（Next-Generation POSIX Threads）项目。同时，Red Hat 的一些开发人员开展了 NPTL 项目。NGPT 在  2003 年中期被放弃了，把这个领域完全留给了 NPTL。</p></li><li><p>NPTL，或称为 Native POSIX Thread Library，是 Linux 线程的一个新实现，它 克服了 LinuxThreads 的缺点，同时也符合 POSIX 的需求。与 LinuxThreads 相 比，它在性能和稳定性方面都提供了重大的改进。</p></li><li><p>查看当前 pthread 库版本：getconf GNU_LIBPTHREAD_VERSION</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux多线程开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程守护</title>
      <link href="2022/05/27/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E8%BF%9B%E7%A8%8B%E5%AE%88%E6%8A%A4/"/>
      <url>2022/05/27/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E8%BF%9B%E7%A8%8B%E5%AE%88%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><p>在 UNIX 系统中，用户通过终端登录系统后得到一个 shell 进程，这个终端成</p><p>为 shell 进程的控制终端（Controlling Terminal），进程中，控制终端是</p><p>保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进 程启动的其它进程的控制终端也是这个终端。</p><p>n默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指 向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准 错误输出写也就是输出到显示器上。</p><p>n在控制终端输入一些特殊的控制键可以给前台进程发信号，例如 Ctrl + C 会产</p><p>生 SIGINT 信号，Ctrl + \ 会产生 SIGQUIT 信号。</p><blockquote><p>echo $$ &#x2F;&#x2F; 查看当前用户ID</p><p>tty &#x2F;&#x2F; 终端</p></blockquote><h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>进程组和会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合，</p><p>会话是一组相关进程组的集合。进程组和会话是为支持 shell 作业控制而定义的抽 象概念，用户通过 shell 能够交互式地在前台或后台运行命令。</p><p>n进行组由一个或多个共享同一进程组标识符（PGID）的进程组成。一个进程组拥有一</p><p>个进程组首进程，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，新进程 会继承其父进程所属的进程组 ID。</p><p>n进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个 成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入 了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员。</p><h2 id="会-话"><a href="#会-话" class="headerlink" title="会 话"></a>会 话</h2><p>会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程 ID 会成为会</p><p>话 ID。新进程会继承其父进程的会话 ID。</p><p>一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终 端设备时被建立。一个终端最多可能会成为一个会话的控制终端。</p><p>在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为 后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终 端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</p><p>n当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</p><h2 id="进程组、会话、控制终端之间的关系"><a href="#进程组、会话、控制终端之间的关系" class="headerlink" title="进程组、会话、控制终端之间的关系"></a>进程组、会话、控制终端之间的关系</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220528144744763.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220528144744763.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220528144744763"></p><h2 id="进程组、会话操作函数"><a href="#进程组、会话操作函数" class="headerlink" title="进程组、会话操作函数"></a>进程组、会话操作函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前的进程组</span></span><br><span class="line"><span class="function"><span class="keyword">npid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 获取指定的进程的进程组id 获得当前的</span></span><br><span class="line"><span class="function"><span class="keyword">npid_t</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="comment">// 设置进程组的ID把那个进程设置成那个组</span></span><br><span class="line"><span class="function">nint <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br><span class="line"><span class="comment">// 获取指定进程的会话的ID</span></span><br><span class="line"><span class="function"><span class="keyword">npid_t</span> <span class="title">getsid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="comment">// 设置会话的ID</span></span><br><span class="line"><span class="function"><span class="keyword">npid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周 期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。</p><p>守护进程具备下列特征：</p><p>​生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。</p><p>​它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进 程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。</p><p>nLinux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，</p><p>Web 服务器 httpd 等。</p><h2 id="守护进程的创建步骤"><a href="#守护进程的创建步骤" class="headerlink" title="守护进程的创建步骤"></a>守护进程的创建步骤</h2><p>执行一个 fork()，之后父进程退出，子进程继续执行。</p><p>子进程调用 setsid() 开启一个新会话。</p><p>清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。</p><p>修改进程的当前工作目录，通常会改为根目录（&#x2F;）。</p><p>关闭守护进程从其父进程继承而来的所有打开着的文件描述符。</p><p>在关闭了文件描述符0、1、2之后，守护进程通常会打开&#x2F;dev&#x2F;null 并使用dup2() 使所有这些描述符指向这个设备。</p><p>核心业务逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: daemon.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月28日 星期六 17时01分15秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  写一个守护进程,每隔2s获取一下系统时间,将这个时间写入到磁盘文件中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 捕捉到信号后,获取系统时间,写入磁盘</span></span><br><span class="line">    <span class="keyword">time_t</span> tm = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">loc</span> =</span> localtime(&amp;tm);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    char buf[1024];</span></span><br><span class="line"><span class="comment">    sprintf(buf, &quot;%d-%d-%d %d:%d:%d\n&quot;, loc-&gt;tm_year, loc-&gt;tm_mon, loc-&gt;tm_mday, loc-&gt;tm_hour, loc-&gt;tm_min,loc-&gt;tm_sec);</span></span><br><span class="line"><span class="comment">    printf(&quot;%s\n&quot;, buf);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">char</span> *str = asctime(loc);</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;time.txt&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0664</span>);</span><br><span class="line">    write(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出父进程</span></span><br><span class="line">    <span class="comment">// 为什么不用父进程创建会话</span></span><br><span class="line">    <span class="comment">// 因为 如 父PID = 100那么进程的会话和进程组都是100那么再创建一个新的也是用的父进的PID会冲突所有利用子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将子进程重新创建会话</span></span><br><span class="line">    <span class="comment">// 为什么创建新的会话: 因为新的会话会脱离控制终端就不会被一些信号杀死</span></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置掩码</span></span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改工作目录</span></span><br><span class="line">    chdir(<span class="string">&quot;/home/qz&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭、重定向文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    dup2(fd, STDIN_FILENO); // 写0 1 2 也是ok的</span></span><br><span class="line"><span class="comment">    dup2(fd, STDOUT_FILENO);</span></span><br><span class="line"><span class="comment">    dup2(fd, STDERR_FILENO);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕捉信号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = work;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">val</span>;</span></span><br><span class="line">    <span class="comment">// 过2秒</span></span><br><span class="line">    val.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 间隔</span></span><br><span class="line">    val.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 定时器</span></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;val, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux多进程开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>共享内存</title>
      <link href="2022/05/26/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
      <url>2022/05/26/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于 一个共享内存段会成为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介 入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其 他所有共享同一个段的进程可用。</p><p>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据 从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快</p><h2 id="共享内存使用步骤"><a href="#共享内存使用步骤" class="headerlink" title="共享内存使用步骤"></a>共享内存使用步骤</h2><p>调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其 他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。</p><p>使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。</p><p>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存， 程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间 中该共享内存段的起点的指针。</p><p>调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存 了。这一步是可选的，并且在进程终止时会自动完成这一步。</p><p>调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之 后内存段才会销毁。只有一个进程需要执行这一步</p><h2 id="共享内存操作函数"><a href="#共享内存操作函数" class="headerlink" title="共享内存操作函数"></a>共享内存操作函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line">- 功能创建一个新的共享内存段、或者获取一个既有的共享内存段的标识</span><br><span class="line">        新创建的内存段中的数据都会被初始化为<span class="number">0</span></span><br><span class="line">- 参数:</span><br><span class="line">- key: <span class="keyword">key_t</span> 类型是一个整形,通过这个找到或者创建一个共享内存</span><br><span class="line">            一般使用<span class="number">16</span>进制表示,非<span class="number">0</span>值</span><br><span class="line">- size: 共享内存大小</span><br><span class="line">        分页大小</span><br><span class="line">- shmflg: 属性</span><br><span class="line">        - 访问权限</span><br><span class="line">        - 附加属性: 创建/判断共享内存是不是存在</span><br><span class="line">            - 创建: IPC_CREAT</span><br><span class="line">            - 判断共享内存是否存在: IPC_EXCL, 需要和IPC_CREAT一起使用</span><br><span class="line">                IPC_CREAT | IPC_EXCL | <span class="number">0664</span></span><br><span class="line">- 返回值:</span><br><span class="line">失败: <span class="number">-1</span> 并设置错误号</span><br><span class="line">         成功: &gt;<span class="number">0</span> 返回共享内存的引用的ID,后面操作共享内存都是通过这个值</span><br><span class="line">             </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line">- 功能: 和当前的进程进行关联</span><br><span class="line">- 参数: </span><br><span class="line">- shmid: 共享内存的标识(ID)由shmget返回值获取</span><br><span class="line">- shmaddr: 申请的共享内存的起始地址,指定<span class="literal">NULL</span>, 内核指定</span><br><span class="line">- shmflg: 对共享内存的操作</span><br><span class="line">            - 读 : SHM_RDONLY, 必须由读权限</span><br><span class="line">            - 读写 : <span class="number">0</span></span><br><span class="line">- 返回值:</span><br><span class="line">成功: 返回共享内存的首地址(起始)地址。</span><br><span class="line">         失败: (<span class="keyword">void</span> *) <span class="number">-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br><span class="line">- 功能: 解除当前进程和共享内存的关联</span><br><span class="line">- 参数: </span><br><span class="line">shmaddr: 共享内存的首地址</span><br><span class="line">- 返回值:</span><br><span class="line">成功: <span class="number">0</span></span><br><span class="line">失败: <span class="number">-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br><span class="line">- 功能: 对共享内存进行操作。删除共享内存, 共享内存要删除才会消失, 创建共享内存的进行被销毁了对共享内存是没有任何影响</span><br><span class="line">- 参数:</span><br><span class="line">- shmid: 共享内存的ID</span><br><span class="line">- cmd: 要做的操作</span><br><span class="line">- IPC_STAT:获得共享内存的当前状态</span><br><span class="line">- IPC_SET: 设置共享内存的状态</span><br><span class="line">- IPC_RMID: 标记共享内存被销毁</span><br><span class="line">- buf: 需要设置或者获取的共享内存属性信息</span><br><span class="line">- IPC_STAT:buf存储数据</span><br><span class="line">- IPC_SET: buf中需要初始化数据,设置到内核中</span><br><span class="line">- IPC_RMID: 没有用,<span class="literal">NULL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">                   <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>    <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">                   <span class="keyword">size_t</span>          shm_segsz;   <span class="comment">/* Size of segment (bytes) */</span></span><br><span class="line">                   <span class="keyword">time_t</span>          shm_atime;   <span class="comment">/* Last attach time */</span></span><br><span class="line">                   <span class="keyword">time_t</span>          shm_dtime;   <span class="comment">/* Last detach time */</span></span><br><span class="line">                   <span class="keyword">time_t</span>          shm_ctime;   <span class="comment">/* Last change time */</span></span><br><span class="line">                   <span class="keyword">pid_t</span>           shm_cpid;    <span class="comment">/* PID of creator */</span></span><br><span class="line">                   <span class="keyword">pid_t</span>           shm_lpid;    <span class="comment">/* PID of last shmat(2)/shmdt(2) */</span></span><br><span class="line">                   <span class="keyword">shmatt_t</span>        shm_nattch;  <span class="comment">/* No. of current attaches */</span></span><br><span class="line">                   ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id)</span></span>;</span><br><span class="line">- 功能: 根据指定的路, 和<span class="keyword">int</span>值,生成一个共享内存的key</span><br><span class="line">- 参数:</span><br><span class="line">- pathname: 指定一个存在的路径</span><br><span class="line">/home/qz/test/</span><br><span class="line">/</span><br><span class="line">- proj_id: <span class="keyword">int</span>类型的值,但是这关系调用只会使用其中的<span class="number">1</span>个字符</span><br><span class="line">范围: <span class="number">0</span> - <span class="number">255</span> 一般指定一个字符 <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="write-shm-c"><a href="#write-shm-c" class="headerlink" title="write_shm.c"></a>write_shm.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: read_shm.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月27日 星期五 10时35分18秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT | <span class="number">0664</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hmid : %d\n&quot;</span>,shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和当前进程进行关联</span></span><br><span class="line">    <span class="keyword">void</span> *ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除关联</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="read-shm-c"><a href="#read-shm-c" class="headerlink" title="read_shm.c"></a>read_shm.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: read_shm.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月27日 星期五 10时35分18秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">0</span>, IPC_CREAT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hmid : %d\n&quot;</span>,shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和当前进程进行关联</span></span><br><span class="line">    <span class="keyword">void</span> *ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>, (<span class="keyword">char</span> *) ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除关联</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details ><summary> yellow::问题1：操作系统如何知道一块共享内存被多少个进程关联？ </summary>              <div class='content'>              <ul><li><p>共享内存维护了一个结构体struct shmid_ds 这个结构体中由一个成员 shm_nattch</p></li><li><p>shm_nattach 记录了关联的进程的个数</p></li></ul>              </div>            </details><details ><summary> yellow::问题2：可不可以对共享内存进行多次删除shmctl </summary>              <div class='content'>              <ul><li>可以的</li><li>因为shmctl 标记删除共享内存, 不是直接删除</li><li>什么时候是真正删除呢？<ul><li>当共享内存和关联的进程数为0的时候，就真正被删除</li></ul></li><li>当共享内存的key为0的时候表示共享内存被标记删除了<ul><li>如果一个进程和共享内存取消关联,那么这个进程就不能继续操作这个共享内存。也不能进行再次关联</li></ul></li></ul>              </div>            </details><h2 id="共享内存和内存映射的区别"><a href="#共享内存和内存映射的区别" class="headerlink" title="共享内存和内存映射的区别"></a>共享内存和内存映射的区别</h2><ol><li>共享内存可以直接创建，内存映射需要磁盘文件(匿名映射除外)</li><li>共享内存效果更高</li><li>内存<ol><li>所有的进程操作的是同一块共享内存。</li><li>内存映射,每个进程在自己的虚拟地址空间中有一个独立的内存。</li></ol></li><li>数据安全<ol><li>进程突然退出<ol><li>共享内存还存在</li><li>内存映射区消失</li></ol></li><li>运行进程的电脑死机，宕机了<ol><li>数据存储在共享内存中,没有了</li><li>内存映射区的数据,由于磁盘文件中的数据还在，所以内存映射区的数据还存在</li></ol></li></ol></li><li>生命周期<ol><li>共享内存：进程退出,共享内存还在，标记删除(所有的关联的进程数为0)，或者关机、如果一个进程退出，会自动和共享内存进行取消关联。</li><li>内存映射区： 进程退出，内存映射区销毁</li></ol></li></ol><h2 id="共享内存操作命令"><a href="#共享内存操作命令" class="headerlink" title="共享内存操作命令"></a>共享内存操作命令</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>ipcs  用  法</td><td></td></tr><tr><td>pipcs  -a</td><td>&#x2F;&#x2F;  打印当前系统中所有的进程间通信方式的信息</td></tr><tr><td>pipcs  -m</td><td>&#x2F;&#x2F; 打印出使用共享内存进行进程间通信的信息</td></tr><tr><td>pipcs  -q</td><td>&#x2F;&#x2F;  打印出使用消息队列进行进程间通信的信息</td></tr><tr><td>pipcs  -s</td><td>&#x2F;&#x2F; 打印出使用信号进行进程间通信的信息</td></tr><tr><td>ipcrm  用  法</td><td></td></tr><tr><td>pipcrm  -M</td><td>shmkey &#x2F;&#x2F; 移除用shmkey创建的共享内存段</td></tr><tr><td>pipcrm  -m</td><td>shmid &#x2F;&#x2F; 移除用shmid标识的共享内存段</td></tr><tr><td>pipcrm  -Q</td><td>msgkey &#x2F;&#x2F; 移除用msqkey创建的消息队列</td></tr><tr><td>pipcrm  -q</td><td>msqid &#x2F;&#x2F; 移除用msqid标识的消息队列</td></tr><tr><td>pipcrm  -S</td><td>semkey &#x2F;&#x2F; 移除用semkey创建的信号</td></tr><tr><td>pipcrm  -s</td><td>semid &#x2F;&#x2F; 移除用semid标识的信号</td></tr></tbody></table><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220527165348394.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220527165348394.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220527165348394"></p>]]></content>
      
      
      <categories>
          
          <category> Linux多进程开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>信号</title>
      <link href="2022/05/18/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E4%BF%A1%E5%8F%B7/"/>
      <url>2022/05/18/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E4%BF%A1%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="信号概述"><a href="#信号概述" class="headerlink" title="信号概述"></a>信号概述</h2><p>信号是 Linux进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个丘在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220518170402035.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220518170402035.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220518150433415"></p><p>发往进程的<code>诸多信号，通常都是源于内核</code>。引发内核为进程产生信号的各类事件如下:</p><ul><li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C(9号信号)通常会给进程发送一个中断信号。</li><li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被О除，或者引用了无法访问的内存区域</li><li>系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的CPU时间超限，或者该进程的某个子进程退出。</li><li>运行 kill 命令或调用 kill 函数。</li></ul><p>使用信号的两个主要目的是:</p><ul><li>让进程知道已经发生了一个特定的事情。</li><li>强迫进程执行它自己代码中的信号处理程序。</li></ul><p>信号的特点：</p><ul><li>简单</li><li>不能携带大量的信息</li><li>满足某个特定条件才能发送</li><li>优先级比高</li></ul><p>查看系统定义的信号列表：kill -l</p><p>前31个信号为常规信号,其余为实时信号。</p><h2 id="信号一览表"><a href="#信号一览表" class="headerlink" title="信号一览表"></a>信号一览表</h2><table><thead><tr><th align="center">编号</th><th align="center">信号名称</th><th align="left">对应事件</th><th align="center">默认动作</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">SIGHUP</td><td align="left">用户退出shell时，由该shell启动的所有进程将 收到这个信号</td><td align="center">终止进程</td></tr><tr><td align="center">2</td><td align="center"><font color='red'>SIGINT</font></td><td align="left">当用户按下了组合键时，用户终端向正 在运行中的由该终端启动的程序发出此信号(CTRL + C)</td><td align="center">终止进程</td></tr><tr><td align="center">3</td><td align="center"><font color='red'>SIGQUIT</font></td><td align="left">户按下组合键时产生该信号，用户终 端向正在运行中的由该终端启动的程序发出些信号 (CTRL + \)</td><td align="center">终止进程</td></tr><tr><td align="center">4</td><td align="center">SIGILL</td><td align="left">CPU检测到某进程执行了非法指令</td><td align="center">终止进程并产生core文件</td></tr><tr><td align="center">5</td><td align="center">SIGTRAP</td><td align="left">该信号由断点指令或其他 trap指令产生</td><td align="center">终止进程并产生core文件</td></tr><tr><td align="center">6</td><td align="center">SIGABRT</td><td align="left">调用abort函数时产生该信号</td><td align="center">终止进程并产生core文件</td></tr><tr><td align="center">7</td><td align="center">SIGBUS</td><td align="left">非法访问内存地址，包括内存对齐出错</td><td align="center">终止进程并产生core文件</td></tr><tr><td align="center">8</td><td align="center">SIGFPE</td><td align="left">在发生致命的运算错误时发出。不仅包括浮点运算 错误，还包括溢出及除数为0等所有的算法错误</td><td align="center">终止进程并产生core文件</td></tr><tr><td align="center">9</td><td align="center"><strong>SIGKILL</strong></td><td align="left">无条件终止进程。该信号不能被忽略，处理和阻塞</td><td align="center">终止进程，可以杀死任何进程</td></tr><tr><td align="center">10</td><td align="center">SIGUSE1</td><td align="left">用户定义的信号。即程序员可以在程序中定义并使用该信号</td><td align="center">终止进程</td></tr><tr><td align="center">11</td><td align="center"><strong>SIGSEGV</strong></td><td align="left">指示进程进行了无效内存访问(段错误)</td><td align="center">终止进程并产生core文件</td></tr><tr><td align="center">12</td><td align="center">SIGUSR2</td><td align="left">另外一个用户自定义信号，程序员可以在程序中定义并使用该信号</td><td align="center">终止进程</td></tr><tr><td align="center">13</td><td align="center"><strong>SIGPIPE</strong></td><td align="left">Broken pipe向一个没有读端的管道写数据</td><td align="center">终止进程</td></tr><tr><td align="center">14</td><td align="center">SIGALRM</td><td align="left">定时器超时，超时的时间 由系统调用alarm设置</td><td align="center">终止进程</td></tr><tr><td align="center">15</td><td align="center">SIGTERM</td><td align="left">程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号</td><td align="center">终止进程</td></tr><tr><td align="center">16</td><td align="center">SIGSTKFLT</td><td align="left">Linux早期版本出现的信号，现仍保留向后兼容</td><td align="center">终止进程</td></tr><tr><td align="center">17</td><td align="center"><strong>SIGCHLD</strong></td><td align="left">子进程结束时，父进程会收到这个信号</td><td align="center">忽略这个信号</td></tr><tr><td align="center">18</td><td align="center"><strong>SIGCONT</strong></td><td align="left">如果进程已停止，则使其继续运行</td><td align="center">继续&#x2F;忽略</td></tr><tr><td align="center">19</td><td align="center"><strong>SIGSTOP</strong></td><td align="left">停止进程的执行。信号不能被忽略，处理和阻塞</td><td align="center">为终止进程</td></tr><tr><td align="center">20</td><td align="center">SIGTSTP</td><td align="left">停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号</td><td align="center">暂停进程</td></tr><tr><td align="center">21</td><td align="center">SIGTTIN</td><td align="left">后台进程读终端控制台</td><td align="center">暂停进程</td></tr><tr><td align="center">22</td><td align="center">SIGTTOU</td><td align="left">该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生</td><td align="center">暂停进程</td></tr><tr><td align="center">23</td><td align="center">SIGURG</td><td align="left">套接字上有紧急数据时，向当前正在运行的进程发出些信号，报  告有紧急数据到达。如网络带外数据到达</td><td align="center">忽略该信号</td></tr><tr><td align="center">24</td><td align="center">SIGXCPU</td><td align="left">进程执行时间超过了分配给该进程的CPU时间，系统产生该信号并发送给该进程</td><td align="center">终止进程</td></tr><tr><td align="center">25</td><td align="center">SIGXFSZ</td><td align="left">超过文件的最大长度设置</td><td align="center">终止进程</td></tr><tr><td align="center">26</td><td align="center">SIGVTALRM</td><td align="left">虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间</td><td align="center">终止进程</td></tr><tr><td align="center">27</td><td align="center">SGIPROF</td><td align="left">类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间</td><td align="center">终止进程</td></tr><tr><td align="center">28</td><td align="center">SIGWINCH</td><td align="left">窗口变化大小时发出</td><td align="center">忽略该信号</td></tr><tr><td align="center">29</td><td align="center">SIGIO</td><td align="left">此信号向进程指示发出了一个异步IO事件</td><td align="center">忽略该信号</td></tr><tr><td align="center">30</td><td align="center">SIGPWR</td><td align="left">关机</td><td align="center">终止进程</td></tr><tr><td align="center">31</td><td align="center">SIGSYS</td><td align="left">无效的系统调用</td><td align="center">终止进程并产生core文件</td></tr><tr><td align="center">34  ~64</td><td align="center">SIGRTMIN  ～  SIGRTMAX</td><td align="left">LINUX的实时信号，它们没有固定的含义（可以由用户自定义）</td><td align="center">终止进程</td></tr></tbody></table><h2 id="信号的-5-种默认处理动作"><a href="#信号的-5-种默认处理动作" class="headerlink" title="信号的 5 种默认处理动作"></a>信号的 5 种默认处理动作</h2><p>查看信号的详细信息：man 7 signal</p><p>信号的 5 中默认处理动作</p><ul><li><p>Term   终止进程</p></li><li><p>Ign   当前进程忽略掉这个信号</p></li><li><p>Core   终止进程，并生成一个Core文件</p></li><li><p>Stop   暂停当前进程</p></li><li><p>Cont   继续执行当前被暂停的进程</p></li></ul><p>信号的几种状态：产生、未决、递达</p><p>SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。</p><h2 id="core"><a href="#core" class="headerlink" title="core"></a>core</h2><p>0代表不会生成core文件 图2为设置core文件</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220518170911694.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220518170911694.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220518170911694"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: kill.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月18日 星期三 18时39分29秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="comment">// 这个程序的作用是测试生成文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kill、raise、abort函数"><a href="#kill、raise、abort函数" class="headerlink" title="kill、raise、abort函数"></a>kill、raise、abort函数</h2><p>因为会抢占cpu的资源不确定执行几次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: kill.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月18日 星期三 18时39分29秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment"> *  #include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment"> *  int kill(pid_t pid, int sig);</span></span><br><span class="line"><span class="comment"> *  - 功能: 给任何的进程或者进程组pid, 发送某个信号 sig</span></span><br><span class="line"><span class="comment"> *  - 参数:</span></span><br><span class="line"><span class="comment"> *      - pid : 需要发送给的进程的id</span></span><br><span class="line"><span class="comment"> *          &gt; 0 : 将信号发送给指定的进程</span></span><br><span class="line"><span class="comment"> *          = 0 : 将信号发送给当前的进程组</span></span><br><span class="line"><span class="comment"> *          = -1 : 表示将信号发送给每一个有权限的接受这个信号的进程</span></span><br><span class="line"><span class="comment"> *          &lt; -1 : 这个pid等于某个进程组的ID取反(1234) -&gt; (-1234)</span></span><br><span class="line"><span class="comment"> *      - sig : 需要发送的信号的编号或者宏值,如果是0的话不发送任何信号</span></span><br><span class="line"><span class="comment"> *  kill(getppid(), 9);</span></span><br><span class="line"><span class="comment"> *  kill(getpid(), 9);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  int raise(int sig);</span></span><br><span class="line"><span class="comment"> *      - 功能: 给当前进程发送信号</span></span><br><span class="line"><span class="comment"> *      - 参数:</span></span><br><span class="line"><span class="comment"> *          - sug : 要发送的信号</span></span><br><span class="line"><span class="comment"> *      - 返回值;</span></span><br><span class="line"><span class="comment"> *          - 成功 0</span></span><br><span class="line"><span class="comment"> *          - 失败 非 0</span></span><br><span class="line"><span class="comment"> *      kill(getpid(), sig);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  void abort(void);</span></span><br><span class="line"><span class="comment"> *      - 功能: 发送SIGABRT信号给当前进程,杀死当前进程</span></span><br><span class="line"><span class="comment"> *      kill(getpid(), SIGABRT);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child process\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;kill child process now\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 父进程返回是子进程的信号</span></span><br><span class="line">        kill(pid, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="alarm-函数"><a href="#alarm-函数" class="headerlink" title="alarm 函数"></a>alarm 函数</h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: alarm.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月19日 星期四 12时59分47秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"> *  unisgned int alarm(unsigned int seconds);</span></span><br><span class="line"><span class="comment"> *      - 功能: 设置定时器 (闹钟),函数调用,开始倒计时,倒计时为0的时候函数会给当前的 进程发送一个信号:SIGALARM</span></span><br><span class="line"><span class="comment"> *      - 参数:</span></span><br><span class="line"><span class="comment"> *          seconds: 倒计时的时长, 单位: 秒。 如果参数为0, 定时器无效(不进行倒计时不发信号)</span></span><br><span class="line"><span class="comment"> *              取消一个定时器,通过alarm(0);</span></span><br><span class="line"><span class="comment"> *      - 返回值: 倒计时剩余的时间</span></span><br><span class="line"><span class="comment"> *          - 之前没有定时器, 返回0</span></span><br><span class="line"><span class="comment"> *          - 之前有定时器, 返回之前的定时器剩余时间</span></span><br><span class="line"><span class="comment"> *  -SIGALARM:默认终止当前的进程, 每一个进程都有且只有唯一的一个定时器</span></span><br><span class="line"><span class="comment"> *      alarm(10); -&gt; 返回 0</span></span><br><span class="line"><span class="comment"> *      过了1秒 - 再定义一个</span></span><br><span class="line"><span class="comment"> *      alarm(5); -&gt; 返回9</span></span><br><span class="line"><span class="comment"> *  alarm(100) -&gt; 该函数是不阻塞的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> seconds = alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;seconds = %d \n&quot;</span>, seconds); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    seconds = alarm(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;seconds = %d \n&quot;</span>, seconds); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算机一秒中电脑能数多少个数"><a href="#计算机一秒中电脑能数多少个数" class="headerlink" title="计算机一秒中电脑能数多少个数"></a>计算机一秒中电脑能数多少个数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: alarm_One.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月19日 星期四 18时37分11秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  实际时间 = 内核时间 + 用户时间 + 操作IO消耗的时间</span></span><br><span class="line"><span class="comment"> *  进行文件IO操作的时间比较浪费时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 定时器,与进程的状态无关 (自然定时法)。无论进程处于什么状态,alarm都会计时</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    alarm(<span class="number">1</span>); <span class="comment">// 系统调用 -&gt; 内核</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 内核 -&gt; 用户区</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>建议 g++ xxx.c .&#x2F;a.out &gt;&gt; a.txt</p></blockquote><h2 id="setitimer-定时器函数-周期"><a href="#setitimer-定时器函数-周期" class="headerlink" title="setitimer 定时器函数 - 周期"></a>setitimer 定时器函数 - 周期</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: setitimer.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月19日 星期四 19时32分31秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="comment"> *  int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);</span></span><br><span class="line"><span class="comment"> *      - 功能: 设置定时器(闹钟)。可以代替alarm函数。精度微秒us, 可以实现周期性定时</span></span><br><span class="line"><span class="comment"> *      - 参数:</span></span><br><span class="line"><span class="comment"> *          - which: 定时器可以什么时间计时</span></span><br><span class="line"><span class="comment"> *              ITIMER_REAL: 真实时间,时间到达, 发送 SIGALRM 常用</span></span><br><span class="line"><span class="comment"> *              ITIMER_VIRTUAL: 用户时间,时间到达,发送SIGVTALRM</span></span><br><span class="line"><span class="comment"> *              ITIMER_PROF: 以该进程在用户态下所消耗的时间来计算,时间到达, 发送SIGPROF</span></span><br><span class="line"><span class="comment"> *          - new_value:</span></span><br><span class="line"><span class="comment"> *              // 定时器结构体</span></span><br><span class="line"><span class="comment"> *              struct itimerval &#123;</span></span><br><span class="line"><span class="comment"> *                  // 每个阶段的时间,间隔时间</span></span><br><span class="line"><span class="comment"> *                  struct timeval it_intercal;</span></span><br><span class="line"><span class="comment"> *                  // 延迟多长时间执行定时器</span></span><br><span class="line"><span class="comment"> *                  struct timeval it_value;</span></span><br><span class="line"><span class="comment"> *              &#125;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              // 时间结构体</span></span><br><span class="line"><span class="comment"> *              struct timeval &#123;</span></span><br><span class="line"><span class="comment"> *                  // 秒数</span></span><br><span class="line"><span class="comment"> *                  time_t tv_sec;</span></span><br><span class="line"><span class="comment"> *                  // 微妙</span></span><br><span class="line"><span class="comment"> *                  suseconds_t tv_usec;</span></span><br><span class="line"><span class="comment"> *              &#125;;</span></span><br><span class="line"><span class="comment"> *              过10(it_value)秒后,每隔2(it_intercal)秒定时一次</span></span><br><span class="line"><span class="comment"> *              - old_value: 记录上一次的定时的时间参数一般不使用,指定NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              - 返回值</span></span><br><span class="line"><span class="comment"> *                  成功 0</span></span><br><span class="line"><span class="comment"> *                  失败 -1 并设置错误号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 过3秒以后,每2秒钟定时一次</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 微秒不设置就是随机的</span></span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置延迟的时间, 3秒之后开始第一次定时</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>); <span class="comment">// 非阻塞</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="signal-信号捕捉函数"><a href="#signal-信号捕捉函数" class="headerlink" title="signal 信号捕捉函数"></a>signal 信号捕捉函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: signal.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月24日 星期二 09时34分06秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment"> *  typedef void (*sighandler_t)(int);</span></span><br><span class="line"><span class="comment"> *  sighandler_t signal(int signum, sighandler_t handler);</span></span><br><span class="line"><span class="comment"> *      - 功能: 设置某个信号的捕捉行为</span></span><br><span class="line"><span class="comment"> *      - 参数:</span></span><br><span class="line"><span class="comment"> *          - signum: 要捕捉的信号</span></span><br><span class="line"><span class="comment"> *          - handler 捕捉的信号要如何处理</span></span><br><span class="line"><span class="comment"> *              - SIG_IGN: 忽略信号</span></span><br><span class="line"><span class="comment"> *              - SIG_DFL: 使用信号默认的行为</span></span><br><span class="line"><span class="comment"> *              - 回调函数: 这个函数是内核调用的(系统), 程序负责写,捕获到信号后如何去处理信号。</span></span><br><span class="line"><span class="comment"> *              回调函数:</span></span><br><span class="line"><span class="comment"> *                  - 需要程序员实现,提前准好的,函数的类型根据实际需求,看函数指针的定义</span></span><br><span class="line"><span class="comment"> *                  - 不是程序员调用,而是信号产生由内核调用</span></span><br><span class="line"><span class="comment"> *                  - 函数指针是是现实函数回调的手段,函数实现之后,将函数名 放到函数指针的位置就可以了</span></span><br><span class="line"><span class="comment"> *      - 返回值:</span></span><br><span class="line"><span class="comment"> *          成功 返回上一次注册的信号处理函数的地址。第一次调用返回NULL</span></span><br><span class="line"><span class="comment"> *          失败 返回SIG_ERR,设置错误号</span></span><br><span class="line"><span class="comment"> *  SIGKILL(9号信号) SIGSTOP不能被捕捉,不能被忽略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myalarm</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到了信号的编号是: %d \n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xxxxxx\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过3秒以后,每2秒钟定时一次</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册信号捕捉</span></span><br><span class="line">        <span class="comment">// signal(SIGALRM, SIG_IGN);</span></span><br><span class="line">    <span class="comment">// signal(SIGALRM, SIG_DFL);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// void (*sighandler_t)(int); 函数指针,int类型的参数表示捕捉的到的信号 值。</span></span><br><span class="line">    signal(SIGALRM, myalarm);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 微秒不设置就是随机的</span></span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置延迟的时间, 3秒之后开始第一次定时</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>); <span class="comment">// 非阻塞</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><p>许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为 信号集的数据结构来表示，其系统数据类型为 sigset_t。</p><p>在 PCB 中有两个非常重要的信号集。一个称之为 “阻塞信号集” ，另一个称之为 “未决信号集” 。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我 们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数 来对 PCB 中的这两个信号集进行修改。</p><p>信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。</p><p>信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。</p><p>信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号， 所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。</p><h3 id="阻塞信号集和未决信号"><a href="#阻塞信号集和未决信号" class="headerlink" title="阻塞信号集和未决信号"></a>阻塞信号集和未决信号</h3><p>未决信号集：信号没被处理之前都会在未决信号集</p><p>阻塞信号集：我们需要对某几个信号进行阻塞</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220524151141467.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220524151141467.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220524151141467"></p><h4 id="阻塞信号集和未决信号集"><a href="#阻塞信号集和未决信号集" class="headerlink" title="阻塞信号集和未决信号集"></a>阻塞信号集和未决信号集</h4><p>1.用户通过键盘  Ctrl + C, 产生2号信号SIGINT (信号被创建)</p><p>2.信号产生但是没有被处理 （未决）<br>    - 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）<br>    - SIGINT信号状态被存储在第二个标志位上<br>        - 这个标志位的值为0， 说明信号不是未决状态<br>        - 这个标志位的值为1， 说明信号处于未决状态</p><p>3.这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较<br>    - 阻塞信号集默认不阻塞任何的信号<br>    - 如果想要阻塞某些信号需要用户调用系统的API</p><p>4.在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了</p><ul><li>如果没有阻塞，这个信号就被处理<ul><li>如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理</li></ul></li></ul><h4 id="号集相关的函数-只对自定义的有效"><a href="#号集相关的函数-只对自定义的有效" class="headerlink" title="号集相关的函数 - 只对自定义的有效"></a>号集相关的函数 - 只对自定义的有效</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">以下信号集相关的函数都是对自定义的信号集进行操作</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">- 功能: 清空信号集中的数据, 将信号集中的所有的标志位置 清空 - <span class="number">0</span></span><br><span class="line">- 参数: <span class="built_in">set</span>,传出参数,需要操作的信号集</span><br><span class="line">- 返回值: </span><br><span class="line">- 成功返回 <span class="number">0</span></span><br><span class="line">- 失败返回 <span class="number">-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">- 功能: 将信号集中的所有的标志位置为 <span class="number">1</span> </span><br><span class="line">- 参数: <span class="built_in">set</span>,传出参数,需要操作的信号集</span><br><span class="line">- 返回值: </span><br><span class="line">- 成功返回 <span class="number">0</span></span><br><span class="line">- 失败返回 <span class="number">-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line">- 功能: 向信号集中的某一个信号对应标志位为<span class="number">1</span>，表示阻塞这个信号</span><br><span class="line">- 参数: </span><br><span class="line">- <span class="built_in">set</span>: 传出参数,需要操作的信号集</span><br><span class="line">- signum: 需要设置阻塞的那个信号</span><br><span class="line">- 返回值: </span><br><span class="line">- 成功返回 <span class="number">0</span></span><br><span class="line">- 失败返回 <span class="number">-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line">- 功能: 向信号集中的某一个信号对应标志位为<span class="number">0</span>，表示不阻塞这个信号</span><br><span class="line">- 参数: </span><br><span class="line">- <span class="built_in">set</span>: 传出参数,需要操作的信号集</span><br><span class="line">- signum: 需要设置不阻塞的那个信号</span><br><span class="line">- 返回值: </span><br><span class="line">- 成功返回 <span class="number">0</span></span><br><span class="line">- 失败返回 <span class="number">-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line">- 功能: 判断某个信号是否阻塞</span><br><span class="line">- 参数: </span><br><span class="line">- <span class="built_in">set</span>: 需要操作的信号集</span><br><span class="line">- signum: 需要判断的那个信号</span><br><span class="line">- 返回值: </span><br><span class="line">- <span class="number">1</span>  signum 被阻塞</span><br><span class="line">- <span class="number">0</span>  signum 不阻塞</span><br><span class="line">- <span class="number">-1</span> signum 调用失败</span><br><span class="line">            </span><br><span class="line"><span class="comment">/***************下面就是系统的API可以操作内核***************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="sigset-设置未决信号集、阻塞信号集"><a href="#sigset-设置未决信号集、阻塞信号集" class="headerlink" title="sigset - 设置未决信号集、阻塞信号集"></a>sigset - 设置未决信号集、阻塞信号集</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: sigset.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月24日 星期二 17时25分15秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个信号集</span></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 SIGINT 是否在信号集 set 里</span></span><br><span class="line">    <span class="keyword">int</span> ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;调用失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加几个信号到信号集中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;调用失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;调用失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从信号集中删除一个</span></span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;调用失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sigprocmask-阻塞信号集-内核"><a href="#sigprocmask-阻塞信号集-内核" class="headerlink" title="sigprocmask - 阻塞信号集 - 内核"></a>sigprocmask - 阻塞信号集 - 内核</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220525145910615.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220525145910615.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220525145910615"></p><h2 id="所有的常规信号-代码"><a href="#所有的常规信号-代码" class="headerlink" title="所有的常规信号 - 代码"></a>所有的常规信号 - 代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: sigprocmask.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月24日 星期二 18时42分13秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    sigset_t == long int</span></span><br><span class="line"><span class="comment">        int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span></span><br><span class="line"><span class="comment">                - 功能: 将自定义信号集中的数据设置到内核中 (设置阻塞、解除阻塞、替换)</span></span><br><span class="line"><span class="comment">                - 参数:</span></span><br><span class="line"><span class="comment">                        - how: 如何对内核阻塞信号进程处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                                SIG_BLOCK: 将用户设置的阻塞信号集添加 到内核中,内核中原来的数据不变</span></span><br><span class="line"><span class="comment">                                列:</span></span><br><span class="line"><span class="comment">                                        信号集 - mask</span></span><br><span class="line"><span class="comment">                                        1 0 1 0 0 0 0</span></span><br><span class="line"><span class="comment">                                        sigset_t - set</span></span><br><span class="line"><span class="comment">                                |       0 1 0 0 0 0 0</span></span><br><span class="line"><span class="comment">                                ------------------</span></span><br><span class="line"><span class="comment">                                        1 1 1 0 0 0 0</span></span><br><span class="line"><span class="comment">                                        假设内核中默认的阻塞信号集是 mask, mask | set</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                                SIG_UNBLOCK: 根据用户设置的数据,对内核中的数据进行解除阻塞</span></span><br><span class="line"><span class="comment">                                        mask &amp;= ~set;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                                SIG_SETMASK: 覆盖内核中原来的值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                - set: 已经初始化好的用户自定义的信号集</span></span><br><span class="line"><span class="comment">                - oldset: 保存设置之前的内核中的阻塞的信号集的状态, 可以是 NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                - 返回值:</span></span><br><span class="line"><span class="comment">                        成功返回: 0</span></span><br><span class="line"><span class="comment">                        失败返回: -1</span></span><br><span class="line"><span class="comment">                                并设置错误号: EFAULF、EINVAL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int sigpending(sigset_t *set);</span></span><br><span class="line"><span class="comment">                - 功能: 获取内核中的未决信号集</span></span><br><span class="line"><span class="comment">                - 参数: set, 传出参数, 保存的是内核中的未决信号集中的 信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有的常规信号 kill -l (1 - 31) 未决状态打印到屏幕</span></span><br><span class="line">        <span class="comment">// 设置某些信号是阻塞的,通过键盘产生这些信号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置2、3信号阻塞 SIGINT(CTRL + C)、SIGQUIT(CTRL + \)</span></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="comment">// 将2号和3号信号添加到信号集中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改内核中的阻塞信号集</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="comment">// 获取当前的未决信号集的数据</span></span><br><span class="line">        <span class="keyword">sigset_t</span> pendingset;</span><br><span class="line">        sigemptyset(&amp;pendingset);</span><br><span class="line">        sigpending(&amp;pendingset);</span><br><span class="line">        <span class="comment">// 遍历前31位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">31</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sigismember(&amp;pendingset, i) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sigismember(&amp;pendingset, i) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;sigismember&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 接触阻塞</span></span><br><span class="line">            sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前台进程和后台进程"><a href="#前台进程和后台进程" class="headerlink" title="前台进程和后台进程"></a>前台进程和后台进程</h2><blockquote><p>run sigprocmask.c 直接运行程序</p><p>CTRL + z 也只是让程序后台运行</p><hr><p>run sigprocmask.c &amp; &#x2F;&#x2F; 让程序在后台运行</p><p>fg &#x2F;&#x2F; 切换到前台</p></blockquote><h2 id="sigaction信号捕捉"><a href="#sigaction信号捕捉" class="headerlink" title="sigaction信号捕捉"></a>sigaction信号捕捉</h2><blockquote><p>尽量使用 sigaction</p><p>因为标准不一样</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: sigaction.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月25日 星期三 11时32分35秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment"> *  int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</span></span><br><span class="line"><span class="comment"> *      - 功能: 检查或者改变信号的处理,信号捕捉</span></span><br><span class="line"><span class="comment"> *      - 参数:</span></span><br><span class="line"><span class="comment"> *          - signum: 需要捕捉信号的编号或者宏值,不能捕捉的信号(SIGKILL and SIGSTOP)</span></span><br><span class="line"><span class="comment"> *          - act: 捕捉信号之后的处理动作</span></span><br><span class="line"><span class="comment"> *          - oldact: 上一次对信号的捕捉相关的设置,一般补使用,传递NULL</span></span><br><span class="line"><span class="comment"> *      - 返回值:</span></span><br><span class="line"><span class="comment"> *          成功 0</span></span><br><span class="line"><span class="comment"> *          失败 -1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  struct sigaction &#123;</span></span><br><span class="line"><span class="comment"> *      函数指针, 指向的函数就是信号捕捉到之后的处理函数</span></span><br><span class="line"><span class="comment"> *      void (*sa_handler)(int);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      不常用 - 信号的编号, 信号的相关的信息, 信号的相关的信息</span></span><br><span class="line"><span class="comment"> *      void (*sa_sigaction)(int, siginfo_t *, void *);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      临时阻塞信号集,信号捕捉函数执行过程中, 临时阻塞某些信号</span></span><br><span class="line"><span class="comment"> *      sigset_t sa_mask;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      使用那一个信号处理对捕捉到的信号进行处理</span></span><br><span class="line"><span class="comment"> *          这个值 0 表示使用sa_handler</span></span><br><span class="line"><span class="comment"> *          也可以是 SA_SIGINFO 表示使用 sa_sigaction</span></span><br><span class="line"><span class="comment"> *      int sa_flags;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      呗废弃掉了</span></span><br><span class="line"><span class="comment"> *      void (*sa_restorer)(void);</span></span><br><span class="line"><span class="comment"> *  &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myalarm</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕获的信号的编号是: %d \n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xxxxxxx\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = myalarm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空临时信号集</span></span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置间隔时间</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置延迟的时间, 3妙之后开始第一次定时</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非阻塞</span></span><br><span class="line">    <span class="keyword">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内核实现信号捕捉的过程"><a href="#内核实现信号捕捉的过程" class="headerlink" title="内核实现信号捕捉的过程"></a>内核实现信号捕捉的过程</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220525145417017.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220525145417017.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220525145417017"></p><h2 id="SIGCHLD-解决僵尸进程"><a href="#SIGCHLD-解决僵尸进程" class="headerlink" title="SIGCHLD - 解决僵尸进程"></a>SIGCHLD - 解决僵尸进程</h2><p>SIGCHLD信号产生的条件</p><ul><li>子进程终止时</li><li>子进程接收到 SIGSTOP 信号停止时</li><li>子进程处在停止态,接受到SIGCONT后唤醒时</li></ul><p>以上三种条件都会给父进程发送 SIGCHLD 信号, 父进程默认会忽略该信号</p><h3 id="创建20个子进程"><a href="#创建20个子进程" class="headerlink" title="创建20个子进程"></a>创建20个子进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: sigchld.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月25日 星期三 17时19分37秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  SIGCHLD信号产生的3个条件:</span></span><br><span class="line"><span class="comment"> *      1.子进程结束</span></span><br><span class="line"><span class="comment"> *      2.子进程暂停了</span></span><br><span class="line"><span class="comment"> *      3.子进程继续运行</span></span><br><span class="line"><span class="comment"> *      都会给父进程发送该信号,父进程默认忽略该信号</span></span><br><span class="line"><span class="comment"> *  使用SIGCHLD信号解决僵尸进程的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一些子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent process pid : %d \n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process pid : %d \n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父进程结束子进程就死了 <code>wait、waitpid 一次只能回收一个子进程</code> <a href="https://tutouwang.vercel.app/2022/04/11/Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E6%94%BE/wait%E5%87%BD%E6%95%B0/">点我带你去看wait - waitpid</a></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220525173913588.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220525173913588.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220525173913588"></p><h4 id="段错误-核心内存以转换-代码清除僵尸进程"><a href="#段错误-核心内存以转换-代码清除僵尸进程" class="headerlink" title="段错误(核心内存以转换) - 代码清除僵尸进程"></a>段错误(核心内存以转换) - 代码清除僵尸进程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: sigchld.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月25日 星期三 17时19分37秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  SIGCHLD信号产生的3个条件:</span></span><br><span class="line"><span class="comment"> *      1.子进程结束</span></span><br><span class="line"><span class="comment"> *      2.子进程暂停了</span></span><br><span class="line"><span class="comment"> *      3.子进程继续运行</span></span><br><span class="line"><span class="comment"> *      都会给父进程发送该信号,父进程默认忽略该信号</span></span><br><span class="line"><span class="comment"> *  使用SIGCHLD信号解决僵尸进程的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFun</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到的信号 : %d\n&quot;</span>, num);</span><br><span class="line">    <span class="comment">// 回收子进程PCB的资源</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     while(1) &#123;</span></span><br><span class="line"><span class="comment">        wait(NULL);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die , pid = %d\n&quot;</span>, ret);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;还有子进程活着\n&quot;);</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有子进程了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一些子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 捕捉子进程死亡时发送的SIGCHLD信号</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        act.sa_handler = myFun;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent process pid : %d \n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process pid : %d \n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220526094900263.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220526094900263.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220526094900263"></p><blockquote><p>sigaction(SIGCHLD, &amp;act, NULL); 信号捕捉</p><p>信号捕捉还没有去注册成功 子进程就结束了</p><p>完了再去信号捕捉 就不能回收子进程了</p></blockquote><h3 id="回收改进"><a href="#回收改进" class="headerlink" title="回收改进"></a>回收改进</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: sigchld.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月25日 星期三 17时19分37秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  SIGCHLD信号产生的3个条件:</span></span><br><span class="line"><span class="comment"> *      1.子进程结束</span></span><br><span class="line"><span class="comment"> *      2.子进程暂停了</span></span><br><span class="line"><span class="comment"> *      3.子进程继续运行</span></span><br><span class="line"><span class="comment"> *      都会给父进程发送该信号,父进程默认忽略该信号</span></span><br><span class="line"><span class="comment"> *  使用SIGCHLD信号解决僵尸进程的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFun</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到的信号 : %d\n&quot;</span>, num);</span><br><span class="line">    <span class="comment">// 回收子进程PCB的资源</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     while(1) &#123;</span></span><br><span class="line"><span class="comment">        wait(NULL);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die , pid = %d\n&quot;</span>, ret);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;还有子进程活着\n&quot;);</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有子进程了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提前设置好阻塞信号集, 阻塞SIGCHLD,因为有可能子进程很快结束,父进程还没注册好信号捕捉</span></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一些子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 捕捉子进程死亡时发送的SIGCHLD信号</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        act.sa_handler = myFun;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册完信号捕捉以后,解除阻塞</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent process pid : %d \n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process pid : %d \n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220526102642438.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220526102642438.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220526102642438"></p>]]></content>
      
      
      <categories>
          
          <category> Linux多进程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> [object Object] </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存映射</title>
      <link href="2022/05/17/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"/>
      <url>2022/05/17/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>内存映射(Memory-mapped I&#x2F;O)是将磁盘文件的数据映射到内存,用户通过修改内存就能修改磁盘文件</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220429194804118.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220429194804118.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220429194804118"></p><h2 id="父子进程间通信"><a href="#父子进程间通信" class="headerlink" title="父子进程间通信"></a>父子进程间通信</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: mmap-parent-child-ipc.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月15日 星期日 21时25分03秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="comment"> *  void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span></span><br><span class="line"><span class="comment"> *      - 功能: 将一个文件或者设备的数据映射到内存中</span></span><br><span class="line"><span class="comment"> *      - 参数:</span></span><br><span class="line"><span class="comment"> *          - void *addr : NULL // 由内核指定</span></span><br><span class="line"><span class="comment"> *          - length : 要映射的数据长度, 这个值不能为0,建议使用文件的长度。</span></span><br><span class="line"><span class="comment"> *              获取文件长度 : stat、lseek</span></span><br><span class="line"><span class="comment"> *          - prot : 对申请的内存映</span></span><br><span class="line"><span class="comment"> *              - PROT_EXEC : 可执行的权限</span></span><br><span class="line"><span class="comment"> *              - PROT_READ : 读权限</span></span><br><span class="line"><span class="comment"> *              - PROT_WRITE : 写权限</span></span><br><span class="line"><span class="comment"> *              - PROT_NONE : 没有权限</span></span><br><span class="line"><span class="comment"> *              要操作映射内存,必须要有读的权限</span></span><br><span class="line"><span class="comment"> *              PROT_READ、PROT_READ|PROT_WRITE</span></span><br><span class="line"><span class="comment"> *          - flags :</span></span><br><span class="line"><span class="comment"> *              - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步,进程间通信,必 需要设置这个选项</span></span><br><span class="line"><span class="comment"> *              - MAP_PRIVATE : 不同步,内存映射器的数据改变了,对原的文件不会修改, 重新创建一个新的文件。(copy on write)</span></span><br><span class="line"><span class="comment"> *          - fd: 需要映射的文件描述符</span></span><br><span class="line"><span class="comment"> *              - 通过open得到，open的是一个磁盘文件</span></span><br><span class="line"><span class="comment"> *              - 注意: 文件的大小不能为0, open指定的权限不能和prot参数有冲突。</span></span><br><span class="line"><span class="comment"> *                  open 只读/读写 prot : PROT_READ(必须有)</span></span><br><span class="line"><span class="comment"> *                  prot : PROT_READ open:只读/读写 (小于open的权限)</span></span><br><span class="line"><span class="comment"> *                  prot : PROT_READ | PROT_WRITE open: 只能是读写</span></span><br><span class="line"><span class="comment"> *          - offset: 便宜量, 一般不用。必须指定的是4k的正数倍。0表示不偏移</span></span><br><span class="line"><span class="comment"> *      - 返回值: 返回创建的内存的首地址</span></span><br><span class="line"><span class="comment"> *          失败返回MAP_FAILED, (void *) -1</span></span><br><span class="line"><span class="comment"> *  int munmap(void *addr, size_t length);</span></span><br><span class="line"><span class="comment"> *      - 功能: 释放内存映射</span></span><br><span class="line"><span class="comment"> *      - 参数:</span></span><br><span class="line"><span class="comment"> *          - addr : 要释放的内存的首地址</span></span><br><span class="line"><span class="comment"> *          - length : 要释放的内存大小, 要和 mmap 函数中的length参数的值一样</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  使用内存映射实现进程通信:</span></span><br><span class="line"><span class="comment"> *      1.有关系的进程(父子进程)</span></span><br><span class="line"><span class="comment"> *          - 还有没有子进程的时候</span></span><br><span class="line"><span class="comment"> *              - 通过唯一的父进程, 先创建内存映射区</span></span><br><span class="line"><span class="comment"> *          - 有了内存映射区以后, 创建子进程</span></span><br><span class="line"><span class="comment"> *          - 父子进程共享创建的内存映射区</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      2.没有关系的进程通信</span></span><br><span class="line"><span class="comment"> *          - 准备一个大小不是0的磁盘文件</span></span><br><span class="line"><span class="comment"> *          - 进程 1 通过磁盘文件创建内存映射区</span></span><br><span class="line"><span class="comment"> *              - 得到一个操作这块内存的指针</span></span><br><span class="line"><span class="comment"> *          - 进程 2 通过磁盘文件创建内存映射区</span></span><br><span class="line"><span class="comment"> *              - 得到一个操作这块内存的指针</span></span><br><span class="line"><span class="comment"> *          - 使用内存映射区实现进程通信</span></span><br><span class="line"><span class="comment"> *      注意: 内存映射区通信,是非阻塞的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 打开一个文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END); <span class="comment">// 获取文件的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建文件 mmap(地址、大小、权限和open对应起来、同步、文件描述符、偏移量)</span></span><br><span class="line">    <span class="keyword">void</span> *ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, (<span class="keyword">char</span>*)ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data : %s\n&quot;</span>, buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)ptr, <span class="string">&quot;nihao a, son !!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存映射的注意事项"><a href="#内存映射的注意事项" class="headerlink" title="内存映射的注意事项"></a>内存映射的注意事项</h2><ul><li>如果对mmap的返回值(ptr)做++操作(ptr++),munmap是否能够成功?</li></ul><p>​void *ptr &#x3D; mmap(…)</p><p>​ptr++； 可以对其进行++ 操作</p><p>​但是 munmap(ptr, len) &#x2F;&#x2F; 错误，要保存地址</p><ul><li>如果open时O_RDONLY，mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?</li></ul><p>​错误,返回一个宏 MAP_FAILED</p><p>​open() 函数中的权限建议和prot参数的权限保持一致</p><ul><li><p>如果文件偏移量为1000会怎样?</p><p>偏移量是4k的整数倍，返回 MAP_FAILED</p></li><li><p>mmap什么情况下会调用失败?</p></li></ul><p>​- 第二个参数: length &#x3D; 0 （映射数据长度） 不能再内存中映射为 0</p><p>​- 第三个参数： prot</p><p>​只指定了写权限</p><p>​prot PROT_READ | PROT_WRITE</p><p>​第5个参数(文件描述符) fd 通过open函数时指定的 O_RDONLY 或者 O_WRONLY</p><ul><li>可以open的时候O_CREAT一个新文件来创建映射区吗?</li></ul><p>​可以的，但文件的大小如果为0的话，肯定不行</p><p>​可以对新的文件进行扩展</p><p>​lseek()</p><p>​truncate()</p><ul><li><p>mmap后关闭文件描述符，对mmap映射有没有影响?</p><p>int fd &#x3D; open(“xxx”);</p><p>mmap(…, fd, 0);</p><p>close(fd); &#x2F;&#x2F; 关闭不会产生问题</p><p>映射区还存在，创建映射区的fd被关闭,没有任何影响</p></li><li><p>对ptr越界操作会怎样?</p></li></ul><p>​void * ptr &#x3D; mmap(null, 100, …)</p><p>​4k</p><p>​越界操作的是非法的内存 -&gt; 段错误</p><h2 id="使用内存映射实现文件拷贝"><a href="#使用内存映射实现文件拷贝" class="headerlink" title="使用内存映射实现文件拷贝"></a>使用内存映射实现文件拷贝</h2><p><code>需要先创建一个test.txt</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: copy.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月18日 星期三 10时47分03秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  思路:</span></span><br><span class="line"><span class="comment"> *      1.对原始的文件进行内存映射</span></span><br><span class="line"><span class="comment"> *      2.创建一个新文件 (拓展该文件)</span></span><br><span class="line"><span class="comment"> *      3.把新文件的数据映射要内存中</span></span><br><span class="line"><span class="comment"> *      4.通过内存拷贝将第一个文件的内存数据拷贝到新的文件内存中</span></span><br><span class="line"><span class="comment"> *      5.释放资源</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用内存映射实现文件拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对原始的文件进行内存映射</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始文件大小</span></span><br><span class="line">    <span class="keyword">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新文件</span></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;cpy.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对新创建文件进程拓展</span></span><br><span class="line">    truncate(<span class="string">&quot;cpy.txt&quot;</span>, len);</span><br><span class="line">    write(fd1, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存映射</span></span><br><span class="line">    <span class="keyword">void</span> *ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ| PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">void</span> *ptr1 = mmap(<span class="literal">NULL</span>, len, PROT_READ| PROT_WRITE, MAP_SHARED, fd1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ptr1 == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存拷贝</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr1, ptr, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    munmap(ptr, len);</span><br><span class="line">    munmap(ptr1, len);</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a>匿名映射</h2><p><code>只能做父子进程中的通信</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: mmap-anon.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月18日 星期三 13时10分14秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  匿名映射: 不需要文件实体进程一个内存映射</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建匿名映射区</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">4069</span>;</span><br><span class="line">    <span class="keyword">void</span> *ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父子进程间通信</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)ptr, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="keyword">char</span> *)ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = munmap(ptr, len);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux多进程开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三角形求面积</title>
      <link href="2022/05/15/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%B1%82%E9%9D%A2%E7%A7%AF/"/>
      <url>2022/05/15/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%B1%82%E9%9D%A2%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="行列式-直角坐标器"><a href="#行列式-直角坐标器" class="headerlink" title="行列式 - 直角坐标器"></a>行列式 - 直角坐标器</h2><p>给定 A(x1, y1) B(x2, y2) C(x3, y3)</p><p><img src="https://iknow-pic.cdn.bcebos.com/42a98226cffc1e1762c8a04b4a90f603738de951?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1/quality,q_85/format,f_auto" class="lazyload" data-srcset="https://iknow-pic.cdn.bcebos.com/42a98226cffc1e1762c8a04b4a90f603738de951?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1/quality,q_85/format,f_auto" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h2 id="以知三角行-底-a-高-h"><a href="#以知三角行-底-a-高-h" class="headerlink" title="以知三角行 底(a) - 高(h)"></a>以知三角行 底(a) - 高(h)</h2><p>$S &#x3D; (a * h ) &#x2F; 2$</p><h2 id="海伦公式"><a href="#海伦公式" class="headerlink" title="海伦公式"></a>海伦公式</h2><p>$p  &#x3D; (a + b + c) &#x2F; 2$</p><p>$S&#x3D;sqrt[p(p-a)(p-b)(p-c)]$</p><p>$&#x3D;sqrt[(1&#x2F;16)(a+b+c)(a+b-c)(a+c-b)(b+c-a)]$</p><p>$&#x3D; 1 &#x2F; 4 sqrt [(a+b+c)(a+b-c)(a+c-b)(b+c-a)] $</p><h2 id="利用正玄"><a href="#利用正玄" class="headerlink" title="利用正玄"></a>利用正玄</h2><p>已知三角形两边a,b,这两边夹角C，则</p><p><img src="https://bkimg.cdn.bcebos.com/formula/840b7588070791d6ef8fbfbdcf641000.svg" class="lazyload" data-srcset="https://bkimg.cdn.bcebos.com/formula/840b7588070791d6ef8fbfbdcf641000.svg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p>，即两夹边之积乘夹角正弦值的一半。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 有趣的知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL_二分</title>
      <link href="2022/05/06/STL%E5%89%96%E6%9E%90/STL-%E4%BA%8C%E5%88%86/"/>
      <url>2022/05/06/STL%E5%89%96%E6%9E%90/STL-%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="数组是升序的情况"><a href="#数组是升序的情况" class="headerlink" title="数组是升序的情况"></a>数组是升序的情况</h2><p>例：1 3 5 7 7 10 11</p><p>lower_bound(begin, ned, key) — 得到第一个 &gt;&#x3D; key 的下标</p><p>upper_bound(begin, ned, key) — 得到第一个 &gt;  key 的下标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 二分.cpp</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年05月06日 星期五 15时18分04秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumber</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cout</span> &lt;&lt; f[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(f) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    printNumber(f, n);</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">    idx = lower_bound(f, f + <span class="keyword">sizeof</span>(f) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">7</span>) - f;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;升序数组 - lower_bound - key = 7, idx = &quot;</span> &lt;&lt; idx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    idx = upper_bound(f, f + <span class="keyword">sizeof</span>(f) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">7</span>) - f;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;升序数组 - upper_bound - key = 7, idx = &quot;</span> &lt;&lt; idx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    idx = upper_bound(f, f + <span class="keyword">sizeof</span>(f) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">12</span>) - f;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不存在的情况 - 升序数组 - upper_bound - key = 100, idx = &quot;</span> &lt;&lt; idx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/***********************************************************************************************/</span></span><br><span class="line"></span><br><span class="line">    sort(f, f + n, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    printNumber(f, n);</span><br><span class="line">    idx = lower_bound(f, f + <span class="keyword">sizeof</span>(f) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">7</span>) - f;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;降序数组 - lower_bound - key = 7, idx = &quot;</span> &lt;&lt; idx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    idx = upper_bound(f, f + <span class="keyword">sizeof</span>(f) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">7</span>) - f;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;降序数组 - upper_bound - key = 7, idx = &quot;</span> &lt;&lt; idx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    idx = upper_bound(f, f + <span class="keyword">sizeof</span>(f) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">12</span>) - f;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不存在的情况 - 升序数组 - upper_bound - key = 100, idx = &quot;</span> &lt;&lt; idx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基础博弈</title>
      <link href="2022/05/04/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E5%8D%9A%E5%BC%88/"/>
      <url>2022/05/04/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E5%8D%9A%E5%BC%88/</url>
      
        <content type="html"><![CDATA[<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><h2 id="1-简介-博弈"><a href="#1-简介-博弈" class="headerlink" title="1.简介 博弈"></a>1.简介 博弈</h2><p>博弈&#x2F;博弈论，又称为对策论（Game Theory）、赛局理论等，既是现代数学的一个新分支，也是运筹学的一个重要学科。博弈论主要研究公式化了的激励结构间的相互作用，是研究具有斗争或竞争性质现象的数学理论和方法，博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。</p><p>总而言之，博弈，就是两方（或者多方）在为了某一种目标进行的竞争。</p><p>在生活中，博弈无处不在，国与国之间的交锋就是一种博弈，在游戏中你与对手的有来有回也是一种博弈，面对老板提出加工资的需求又也是一种博弈，在博弈中，选择去做什么非常重要，这也是十分有研究价值的，一个有趣的题外话：从1994年诺贝尔经济学奖授予3位博弈论专家开始，共有7届的诺贝尔经济学奖与博弈论的研究有关。</p><h2 id="2-基础概念"><a href="#2-基础概念" class="headerlink" title="2. 基础概念"></a>2. 基础概念</h2><p>　　必胜态：通过某一步可以转移到必败态的局面。 也就是说，对于一个处于必胜态的玩家，他总能找到一种合法操作，将当前局面变成一个必败态然后交给对方，如果中途不出现意外的话，最终自己就会得到胜利。但是处于必胜态并不意味着任意的操作都能将当前局面变成必败态。</p><p>　　必败态：通过某一步只能转移到必胜态的局面。 也就是说，处于必败态的玩家无论做什么操作，都只会将当前的局面变成必胜态，然后交给对方，只要对方足够聪明，那么该玩家将输掉比赛。</p><p>　　对于足够聪明的两个博弈者来说，游戏的胜负在比赛前就已经知道(当然，我这里只是说在题目里，在现实中如果是稍微复杂一点的博弈游戏，单凭人脑是很难达到那种水平)，也就是说胜利的一方总能找到胜利的路径，而输掉的那一方无论怎样走，胜利的一方都能找到对应的方法。也就是说先后手以及起始局面可以决定整场博弈的胜负。</p><h2 id="3-思想"><a href="#3-思想" class="headerlink" title="3.思想"></a>3.思想</h2><p>博弈问题的特点</p><p>a) 博弈模型为两人轮流决策的非合作博弈。即两人轮流进行决策，并且两人都使用最优策略来获取胜利</p><p>b) 博弈是有限的。即无论两人怎样决策，都会在有限步后决出胜负</p><p>c) 公平博弈。即两人进行决策所遵循的规则相同</p><h2 id="4-学习方法"><a href="#4-学习方法" class="headerlink" title="4.学习方法"></a>4.学习方法</h2><p>关于博弈论，最理想的学习方式还当属熟悉模型，几种常用的博弈论模型有：巴什博弈，威佐夫博弈，斐波那契博弈，尼姆博弈，通过理解模型以及他们模型可能产生的变种，面对各种题目也只是“换汤不换药”的思维。</p><p>在基本了解各类模型之后，我们可以开始学习“博弈树”和“决策树”这类算法，以及其他一些启发式算法，这与人工智能的思维很接近，此时算法难度已经直线上升，在经过这个瓶颈之后，等待你的是一片星辰大海。</p><h1 id="巴什博弈"><a href="#巴什博弈" class="headerlink" title="巴什博弈"></a>巴什博弈</h1><p> <strong>巴什博弈的主要内容：</strong>只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。<strong>其中它强调的是只有一堆物品：</strong>取光者胜</p><p>如果 n % (m + 1) &#x3D;&#x3D; 0 先手必败</p><p>​ n % (m + 1) !&#x3D; 0 先后必败</p><p><strong>相信大家看见这个一定有很多疑惑就是为什么这个公式就能看到结局！</strong></p><p>1.如果它能被（m+1）整除，那么假设你先手 取p个，那么对手总能取m+1-p 个（因为1&lt;&#x3D;p&lt;&#x3D;m，那么 1&lt;&#x3D;(m+1-p)&lt;&#x3D;m 也满足对手所取数量的条件限制），这样不断循环下去，最后拿到石头的一定是对手。</p><p><img src="C:\Users\16583\Desktop\博弈\images\1.png" class="lazyload" data-srcset="C:\Users\16583\Desktop\博弈\images\1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1"></p><p>2.如果它不能被（m+1）整除，那么你一定可以拿走那个余数k（k&#x3D;n%(m+1)） 这样对手就相当于面对了 n%（m+1）的局面，也就是1的情况。</p><h1 id="巴什博弈-例题"><a href="#巴什博弈-例题" class="headerlink" title="巴什博弈(例题)"></a><strong>巴什博弈</strong>(例题)</h1><h4 id="巴什博弈-普通"><a href="#巴什博弈-普通" class="headerlink" title="巴什博弈-普通"></a><strong>巴什博弈</strong>-普通</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1846">http://acm.hdu.edu.cn/showproblem.php?pid=1846</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  最先取光石子的一方为胜</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bash</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n % (m + <span class="number">1</span>) != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 核心代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, n, m; <span class="comment">// n = 组数    n = 石子个数    m = 每回取最多个数</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (Bash(n, m) ? <span class="string">&quot;first&quot;</span> : <span class="string">&quot;second&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="巴什博弈-变行"><a href="#巴什博弈-变行" class="headerlink" title="巴什博弈-变行"></a><strong>巴什博弈</strong>-变行</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4764">http://acm.hdu.edu.cn/showproblem.php?pid=4764</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目的意思就是谁取到最后一个谁输</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(n + m)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (((n - <span class="number">1</span>) % (m + <span class="number">1</span>)) == <span class="number">0</span> ? <span class="string">&quot;Jiang&quot;</span> : <span class="string">&quot;Tang&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="尼姆博弈"><a href="#尼姆博弈" class="headerlink" title="尼姆博弈"></a>尼姆博弈</h1><p>在说尼姆博弈之前我们需要去了解一个什么呢！  就是异或</p><p>异或</p><p>英文名字 exclusive OR </p><p>缩写 xor</p><p>数学符号 ⊕</p><p>计算机符号是 xor</p><p>但是到底异或怎么使用</p><p>比如说 4 ^ 3</p><table><thead><tr><th align="center">4  的二进制</th><th align="center">1</th><th align="center">0</th><th align="center">0</th></tr></thead><tbody><tr><td align="center"><strong>3 的二进制</strong></td><td align="center"><strong>0</strong></td><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td></tr><tr><td align="center"><strong>xor 异或</strong></td><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td></tr></tbody></table><p>就是说他们相同为0不同为1,当然在其中你应该还能看出一个问题是什么呢！</p><p>就是大家可以算一下7的二进制数是什么  1 1 1 对吧！ </p><p>从此问题看出他们异或的结果就等于他们两个数相加 对吧 ！！!</p><p>就是异或也叫半加运算</p><p> 这里能大家可以比如再去实验一个数比如说 1 ^ 2 &#x3D; 什么对吧！！！</p><p>现在说了这么多都是什么对吧！！！ 就是为了我们之后要讲的尼姆博弈做的 铺垫！</p><p>什么是尼姆博弈</p><p>有n堆石子，两人从某一堆取任意多个，规定至少取走1个之多可以取走这堆的全部最后<strong>取光者胜</strong>。</p><p>在这里大家就可能发现了这和刚刚的巴什博弈不差什么对吧！</p><p>情况 ① 当有 1 堆石子的时候先手可以全部取走，对吧 ， 之后先手胜利</p><p>情况 ② 当有 2 堆石子时候 我们令一堆石子为 n 另一堆 m 假设 n &gt; m —–  n &#x3D; 4  —- m &#x3D; 3 之后先手先取 因为两个人都是顶尖聪明的人都会去去吧自己利益最大化     就是我们先取 n - m 个剩下的无论后手怎么去取我们都和后手去取相同 个数的石子这样我们一定是必胜局，</p><table><thead><tr><th align="center">n &#x3D; 4 - &gt; 二进制</th><th align="center">1</th><th align="center">0</th><th align="center">0</th></tr></thead><tbody><tr><td align="center"><strong>m &#x3D; 3</strong>  <strong>- &gt; 二进制</strong></td><td align="center"><strong>0</strong></td><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td></tr><tr><td align="center">xor</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><table><thead><tr><th align="center">3 (4 - 1)</th><th align="center"><font color='red'> 0 </font></th><th align="center"><font color='red'> 1</font></th><th align="center"><font color='red'> 1</font></th></tr></thead><tbody><tr><td align="center"><strong>3</strong></td><td align="center"><strong>0</strong></td><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td></tr><tr><td align="center">xor</td><td align="center"><font color='red'> 0 </font></td><td align="center"><font color='red'> 0 </font></td><td align="center"><font color='red'> 0 </font></td></tr></tbody></table><p>我们让异或为0也就是说我们让两个石子数量相对 之后不就像我们之前说的不管后手取多少我们先手都是必胜</p><p>情况 ③ 当有 2 堆石子时候 我们令一堆石子为 n 另一堆 m 假设 n &#x3D; m —–  n &#x3D; 4  —- m &#x3D; 4  从刚才上图看出一但出现 n &#x3D;&#x3D; m 时候无论先手怎么取 后手就可以取和先手相同的个数 这样先手必败 （就是说因为两个都足够聪明所有说先手一定是什么比败局）</p><p>之后咱们不可能说是只有2堆是吧 可能还有 3 堆 ， 4 堆 ， 5 堆，6 堆…..等等 </p><p>比如说（1， 2 ，3）这种我们能看出    先手必败</p><p>1 二进制 0 0 1</p><p>2 二进制 0 1 0</p><p>3 二进制 0 1 1 +（xor）</p><hr><p>​   0 0 0</p><p>随机举例</p><p>堆数</p><p> n &#x3D; 5</p><p>石子个数</p><p>18263592210</p><p><strong>取光者胜</strong></p><p>甲 先乙 后</p><table><thead><tr><th align="center">石子数</th><th align="center">128</th><th align="center">64</th><th align="center">32</th><th align="center">16</th><th align="center">8</th><th align="center">4</th><th align="center">2</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">182</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">63</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">59</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">22</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">10</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">xor</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr></tbody></table><p>甲</p><table><thead><tr><th align="center">石子数</th><th align="center">128</th><th align="center">64</th><th align="center">32</th><th align="center">16</th><th align="center">8</th><th align="center">4</th><th align="center">2</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">24 (182 - 128 - 32 - 4 - 2 + 8) 158</td><td align="center"><font color = 'red'>0</font></td><td align="center">0</td><td align="center"><font color = 'red'>0</font></td><td align="center">1</td><td align="center"><font color = 'red'>1</font></td><td align="center"><font color = 'red'>0</font></td><td align="center"><font color = 'red'>0</font></td><td align="center">0</td></tr><tr><td align="center">63</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">59</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">22</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">10</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">xor</td><td align="center"><font color = 'red'>0</font></td><td align="center">0</td><td align="center"><font color = 'red'>0</font></td><td align="center">0</td><td align="center"><font color = 'red'>0</font></td><td align="center"><font color = 'red'>0</font></td><td align="center"><font color = 'red'>0</font></td><td align="center">0</td></tr></tbody></table><p>乙</p><table><thead><tr><th align="center">石子数</th><th align="center">128</th><th align="center">64</th><th align="center">32</th><th align="center">16</th><th align="center">8</th><th align="center">4</th><th align="center">2</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">24</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">31 (63 - 32)</td><td align="center">0</td><td align="center">0</td><td align="center"><font color = 'red'>0</font></td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">59</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">22</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">10</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">xor</td><td align="center">0</td><td align="center">0</td><td align="center"><font color = 'red'>1</font></td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><p>甲</p><table><thead><tr><th align="center">石子数</th><th align="center">128</th><th align="center">64</th><th align="center">32</th><th align="center">16</th><th align="center">8</th><th align="center">4</th><th align="center">2</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">24</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">31</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">27 (59 - 32)</td><td align="center">0</td><td align="center">0</td><td align="center"><font color = 'red'>0</font></td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">22</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">10</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">xor</td><td align="center">0</td><td align="center">0</td><td align="center"><font color = 'red'>0</font></td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><p>经过几次后一定会得到情况②</p><h1 id="尼姆博弈-代码模板"><a href="#尼姆博弈-代码模板" class="headerlink" title="尼姆博弈-代码模板"></a>尼姆博弈-代码模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, t = <span class="number">0</span>; <span class="comment">// n = 堆数</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> d;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line">        t ^= d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;先手必输&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;先手必胜&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程间通信-IPC</title>
      <link href="2022/04/17/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>2022/04/17/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="进程间通讯的概念"><a href="#进程间通讯的概念" class="headerlink" title="进程间通讯的概念"></a>进程间通讯的概念</h2><p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程)之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p><p>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信(IPC: Inter Processes Communication )。</p><p>GUI：用户图像接口</p><p>IDE：集成开发环境</p><p>API：应用程序接口</p><p>进程间通信的目的：</p><ul><li>数据传输:一个进程需要将它的数据发送给另一个进程。</li><li>通知事件:一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程)。</li><li>资源共享:多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。</li><li>(同步(就是排队看病 - 安全)、异步(一个医生一起看多个病人 - 不安全))</li><li>进程控制:有些进程希望完全控制另一个进程的执行（如Debug 进程)，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li></ul><h2 id="Linux进程间通信的方式"><a href="#Linux进程间通信的方式" class="headerlink" title="Linux进程间通信的方式"></a>Linux进程间通信的方式</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220417194955298.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220417194955298.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220417194955298"></p><h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><p>管道也叫无名（匿名）管道，它是是UNIX系统IPC(进程间通信)的最古老形式,所有的UNIX系统都支持这种通信机制。</p><p>统计一个目录中文件的数目命令: ls | wc -l，为了执行该命令, shell创建了两个进程来分别执行 ls 和 wc。</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220418085601242.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220418085601242.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220418085601242"></p><h3 id="管道特点-匿名管道-有名管道-共同特点"><a href="#管道特点-匿名管道-有名管道-共同特点" class="headerlink" title="管道特点 匿名管道 - 有名管道 共同特点"></a>管道特点 匿名管道 - 有名管道 共同特点</h3><p>管道其实是一个在<code>内核&#39;内存中&#39;</code>通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。</p><p>管道拥有文件的特质:读操作、写操作，匿名管道没有文件实体(有关系的进程 父进程 - 子进程 - 孙子进程)，有名管道有文件实体(没有关系的进程),但不存储数据。可以按照操作文件的方式对管道进行操作。</p><p>一个管道是一个字节流(一个字节 一个字节 在管道里面)，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。</p><p>通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。</p><p>在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。</p><p>单工(遥控器发射信号给电视机 但是电视机不能给遥控器发射信号 这就是单工)</p><p>双工(打电话 1给2打电话 1 说 二可以听到、2说 1可以听到 <strong>同时</strong>)</p><p>半双工(同一时间只能一个方向就好比那放学 都往出走你就进不去(当然啊 除非你不要命的硬挤进去！！！) 当出来的都走完了进的在往里进)</p><p>从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据．在管道中无法使用lseek ()来随机的访问数据。</p><p>匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220418131840375.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220418131840375.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220418131840375"></p><h3 id="为什么可以使用管道进行进程通信"><a href="#为什么可以使用管道进行进程通信" class="headerlink" title="为什么可以使用管道进行进程通信"></a>为什么可以使用管道进行进程通信</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220418133041024.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220418133041024.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220418133041024"></p><p>管道(红色长方体) 左侧读 右侧写</p><p>父 - 子 进程</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220418133402645.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220418133402645.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220418133402645"></p><h3 id="管道的数据结构"><a href="#管道的数据结构" class="headerlink" title="管道的数据结构"></a>管道的数据结构</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220418183322833.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220418183322833.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220418183322833"></p><h3 id="匿名管道的使用"><a href="#匿名管道的使用" class="headerlink" title="匿名管道的使用"></a>匿名管道的使用</h3><ul><li>创建匿名管道</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><ul><li>查看管道缓冲大小命令</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure><ul><li>查看管道缓冲大小函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fpathconf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> name)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: pipe.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月18日 星期一 19时08分03秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"> *  int pipe(int pipefd[2]);</span></span><br><span class="line"><span class="comment"> *      功能: 创建一个匿名管道, 用来进程间通信</span></span><br><span class="line"><span class="comment"> *      参数: int pipefd[2] 这个数组是一个传出参数。</span></span><br><span class="line"><span class="comment"> *          - pipefd[0] : 对应管道的读端</span></span><br><span class="line"><span class="comment"> *          - pipefd[1] : 对应管道的写端</span></span><br><span class="line"><span class="comment"> *      返回值:</span></span><br><span class="line"><span class="comment"> *          成功返回 0</span></span><br><span class="line"><span class="comment"> *          失败返回 -1</span></span><br><span class="line"><span class="comment"> *  注意: 匿名管道只能用于具有关系的进程之间通信 (父子进程, 兄弟进程, 孙子进程)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程发送数据给父进程, 父进程读取到数据输出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再 fork 之前创建管道</span></span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent revc : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">char</span> *str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line">        write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先猜想-如果子进程写入前-sleep-10-后-中端输出什么："><a href="#先猜想-如果子进程写入前-sleep-10-后-中端输出什么：" class="headerlink" title="先猜想: 如果子进程写入前 sleep(10) 后 中端输出什么："></a>先猜想: 如果子进程写入前 sleep(10) 后 中端输出什么：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: pipe.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月18日 星期一 19时08分03秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"> *  int pipe(int pipefd[2]);</span></span><br><span class="line"><span class="comment"> *      功能: 创建一个匿名管道, 用来进程间通信</span></span><br><span class="line"><span class="comment"> *      参数: int pipefd[2] 这个数组是一个传出参数。</span></span><br><span class="line"><span class="comment"> *          - pipefd[0] : 对应管道的读端</span></span><br><span class="line"><span class="comment"> *          - pipefd[1] : 对应管道的写端</span></span><br><span class="line"><span class="comment"> *      返回值:</span></span><br><span class="line"><span class="comment"> *          成功返回 0</span></span><br><span class="line"><span class="comment"> *          失败返回 -1</span></span><br><span class="line"><span class="comment"> *  注意: 匿名管道只能用于具有关系的进程之间通信 (父子进程, 兄弟进程, 孙子进程)</span></span><br><span class="line"><span class="comment"> *  管道默认是阻塞的, 如果管道中没有数据, read阻塞, 如果管道满了, write阻塞</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程发送数据给父进程, 父进程读取到数据输出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再 fork 之前创建管道</span></span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent revc : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">char</span> *str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line">        write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多次写入-读取"><a href="#多次写入-读取" class="headerlink" title="多次写入 读取"></a>多次写入 读取</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: pipe.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月18日 星期一 19时08分03秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"> *  int pipe(int pipefd[2]);</span></span><br><span class="line"><span class="comment"> *      功能: 创建一个匿名管道, 用来进程间通信</span></span><br><span class="line"><span class="comment"> *      参数: int pipefd[2] 这个数组是一个传出参数。</span></span><br><span class="line"><span class="comment"> *          - pipefd[0] : 对应管道的读端</span></span><br><span class="line"><span class="comment"> *          - pipefd[1] : 对应管道的写端</span></span><br><span class="line"><span class="comment"> *      返回值:</span></span><br><span class="line"><span class="comment"> *          成功返回 0</span></span><br><span class="line"><span class="comment"> *          失败返回 -1</span></span><br><span class="line"><span class="comment"> *  注意: 匿名管道只能用于具有关系的进程之间通信 (父子进程, 兄弟进程, 孙子进程)</span></span><br><span class="line"><span class="comment"> *  管道默认是阻塞的, 如果管道中没有数据, read阻塞, 如果管道满了, write阻塞</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程发送数据给父进程, 父进程读取到数据输出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再 fork 之前创建管道</span></span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent revc : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line">   </span><br><span class="line">            <span class="comment">// char *str = &quot;i am parent&quot;;</span></span><br><span class="line">            <span class="comment">// write(pipefd[1], str, strlen(str));</span></span><br><span class="line">            <span class="comment">// sleep(1);</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 关闭读端 </span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]); </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> *str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            <span class="comment">// sleep(1);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;pa child recv : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line">   bsize(buf, <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 发完数据还没有数字没清空</p><p><code>ps: 如果注释掉 sleep() 就会发现问题！就是自己写的会自己读回去 当然在项目中不会出现这种情况 项目中只会一端读一端写 </code></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220419202543257.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220419202543257.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220419202543257"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: pipe.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月18日 星期一 19时08分03秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"> *  int pipe(int pipefd[2]);</span></span><br><span class="line"><span class="comment"> *      功能: 创建一个匿名管道, 用来进程间通信</span></span><br><span class="line"><span class="comment"> *      参数: int pipefd[2] 这个数组是一个传出参数。</span></span><br><span class="line"><span class="comment"> *          - pipefd[0] : 对应管道的读端</span></span><br><span class="line"><span class="comment"> *          - pipefd[1] : 对应管道的写端</span></span><br><span class="line"><span class="comment"> *      返回值:</span></span><br><span class="line"><span class="comment"> *          成功返回 0</span></span><br><span class="line"><span class="comment"> *          失败返回 -1</span></span><br><span class="line"><span class="comment"> *  注意: 匿名管道只能用于具有关系的进程之间通信 (父子进程, 兄弟进程, 孙子进程)</span></span><br><span class="line"><span class="comment"> *  管道默认是阻塞的, 如果管道中没有数据, read阻塞, 如果管道满了, write阻塞</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程发送数据给父进程, 父进程读取到数据输出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再 fork 之前创建管道</span></span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent revc : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> *str = <span class="string">&quot;i am parent&quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> *str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// int len = read(pipefd[0], buf, sizeof(buf));</span></span><br><span class="line">            <span class="comment">// printf(&quot;pa child recv : %s, pid : %d\n&quot;, buf, getpid());</span></span><br><span class="line">   <span class="comment">// bsize(buf, 1024);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查看管道大小-ulimit-a"><a href="#查看管道大小-ulimit-a" class="headerlink" title="查看管道大小 ulimit -a"></a>查看管道大小 ulimit -a</h4><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220419190512476.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220419190512476.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220419190512476"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: fpathconfig.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月19日 星期二 19时05分50秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = pipe(pipefd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取管道的大小 可以查看man手册来查看宏值</span></span><br><span class="line">    <span class="keyword">long</span> size = fpathconf(pipefd[<span class="number">0</span>], _PC_PIPE_BUF);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pipe size : %ld&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名管道-案例"><a href="#匿名管道-案例" class="headerlink" title="匿名管道 - 案例"></a>匿名管道 - 案例</h3><p><code>ls | wc -l</code> - <code>ps aux | grep</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: parent-child-ipc.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月20日 星期三 09时21分59秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  实现 ps aux | grep xxx 父子进程通信</span></span><br><span class="line"><span class="comment"> *  子进程: ps aux, 子进程结束后, 将数据发送给父进程</span></span><br><span class="line"><span class="comment"> *  父进程: 获取到数据, 过滤</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  pipe()</span></span><br><span class="line"><span class="comment"> *  execlp() -&gt; ps aux 会输出到终端</span></span><br><span class="line"><span class="comment"> *  子进程将标准输出 stdout_fileno 重定向管道的写端 dup2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个管道</span></span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 从管道中读取数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 因为每次最多只能读取 1024 所以需要循环</span></span><br><span class="line">            <span class="comment">// 过滤数据</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 文件描述符的重定向 stdout_fileno -&gt; fd[1];</span></span><br><span class="line">        <span class="comment">// 执行 ps aux</span></span><br><span class="line">        dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管道的读写特点"><a href="#管道的读写特点" class="headerlink" title="管道的读写特点"></a>管道的读写特点</h2><p><code>使用管道时候，需要注意以下几种特殊的情况（假设都是I/O操作）</code></p><ol><li>所有的指向管道写端文件描述符都关闭了 (管道写端引用计数为0)，进程从管道的读端读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样</li><li>如果有指向管道的写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，再次read会阻塞，值到管道中有数据可以读了才读取数据并返回。</li><li>如果所有指向管道的读端的文件描述符都关闭了（管道的读端引用计数为0）这个时候有进程向管道中写数据，那么该进程会收到一个信号SIGPIPE(管道破裂),通常会导致进程异常终止 </li><li>如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0）而持有管道读端的进程也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候在次调用write时候就会被阻塞直到管道中有空位置猜能再次写入数据并返回</li></ol><p>总结：</p><p>​读管道：</p><p>​管道中有数据，red返回实际读到的字节数</p><p>​管道中无数据：</p><p>​写端被全包关闭，read返回0（相当于读到文件末尾）</p><p>​写端没有完全关闭，read阻塞等待</p><p>​写管道：</p><p>​管道读端全部都关闭，进程异常终止（进程SIGPIPE信号）</p><p>​管道读端没有完全关闭：</p><p>​管道已满：writ阻塞</p><p>​管道没满：wirt将数据写入，并返回实际写入的字节数。</p><h2 id="管道-读非阻塞状态"><a href="#管道-读非阻塞状态" class="headerlink" title="管道 读非阻塞状态"></a>管道 读非阻塞状态</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: pipe.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月18日 星期一 19时08分03秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  设置管道非阻塞</span></span><br><span class="line"><span class="comment"> *  int flags = fcntl(fd[0], F_GETFL); // 获取原来的flags</span></span><br><span class="line"><span class="comment"> *  flags |= O_NONBLOCK; // 修改flags</span></span><br><span class="line"><span class="comment"> *  fcntl(fd[0], F_SETFL, flags); // 设置新的flgas</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// man 2 fcntl // 快捷键 shift + k</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 再 fork 之前创建管道</span></span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 关闭写</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flags = fcntl(pipefd[<span class="number">0</span>], F_GETFL);</span><br><span class="line">        flags |= O_NONBLOCK;</span><br><span class="line">        fcntl(pipefd[<span class="number">0</span>], F_SETFL, flags);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent revc : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;len : %d\n&quot;</span>, len);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span> ,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 关闭管道读</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> *str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h2><p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)，也叫命名管道、FIFO文件。</p><p>有名管道(FIFO)不同于匿名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO相互通信，因此，通过FIFO不相关的进程也能交换数据。</p><p>一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I&#x2F;O系统调用了(如read ( ) 、 write ()和close())。与管道一样, FIFO也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO的名称也由此而来:先入先出。</p><p>有名管道(FIFO)和匿名管道 (pipe)有一些特点是相同的，不一样的地方在于:</p><p>有名管道（FIFO）和匿名管道（pipe）有一些特点是相同的，不一样的地方在于：</p><ol><li>FIFO在文件系统中作为一个特殊文件存在，但 FIFO中的内容却存放在内存中。</li><li>当使用FIFO的进程退出后，FIFo文件将继续保存在文件系统中以便以后使用。</li><li>FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。</li></ol><h3 id="有名管道的使用"><a href="#有名管道的使用" class="headerlink" title="有名管道的使用"></a>有名管道的使用</h3><p>通过命令创建有名管道</p><p>mkfifo 名字</p><p>文件类型 p 就是一个管道文件</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220424191124817.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220424191124817.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220424191124817"></p><p>通过函数创建有名管道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>一旦使用mkfifo创建了一个FIFO就可以使用open打开它，常见的文件I&#x2F;O函数都可以用于fifo。如：close、read、write、unlink等</p><p>FIFO严格遵循先进先出（First in First out）, 对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。他们不支持诸如lseek()等文件定位操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: mkfifo.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月24日 星期日 19时24分40秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  创建fifo文件</span></span><br><span class="line"><span class="comment"> *  1.通过命令: mkfifo 名字</span></span><br><span class="line"><span class="comment"> *  2.通过函数: int mkfifo(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment"> *  #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment"> *  int mkfifo(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment"> *      参数:</span></span><br><span class="line"><span class="comment"> *          - pathname: 管道名称的路径</span></span><br><span class="line"><span class="comment"> *          - mode: 文件的权限 和 opne 的 mode 是一样的</span></span><br><span class="line"><span class="comment"> *              是一个八进制的数</span></span><br><span class="line"><span class="comment"> *      返回值:</span></span><br><span class="line"><span class="comment"> *          成功返回: 0</span></span><br><span class="line"><span class="comment"> *          失败返回: -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在, 创建管道\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一端读、一端写"><a href="#一端读、一端写" class="headerlink" title="一端读、一端写"></a>一端读、一端写</h3><p>write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: write.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月24日 星期日 20时20分58秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向管道中写数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;test&quot;</span>, F_OK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;管道不存在, 创建管道\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建管道文件</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;test&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开管道</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hellow, %d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write data : %s\n&quot;</span>, buf);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">       sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: read.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月24日 星期日 20时25分41秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从管道中读数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开管道文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;写端断开链接了...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf : %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220425200818402.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220425200818402.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220425200818402"></p><h3 id="有名管道的注意事项"><a href="#有名管道的注意事项" class="headerlink" title="有名管道的注意事项"></a>有名管道的注意事项</h3><ol><li>一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道 </li><li>一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</li></ol><p>读管道：</p><p>​管道中有数据，read返回实际读到的字节数</p><p>​管道中无数据:</p><p>​管道写端被全部关闭，read返回0，（相当于读到文件末尾)</p><p>​写端没有全部被关闭，read阻塞等待</p><p>写管道：</p><p>​管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号)</p><p>​管道读端没有全部关闭:</p><p>​管道已经满了，write会阻塞</p><p>​管道没有满,write将数据写入，并返回实际写入的字节数。</p><h3 id="有名管道实现简单版聊天功能-一问一答"><a href="#有名管道实现简单版聊天功能-一问一答" class="headerlink" title="有名管道实现简单版聊天功能 - 一问一答"></a>有名管道实现简单版聊天功能 - 一问一答</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220426115047403.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220426115047403.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220426115047403"></p><h4 id="chatA"><a href="#chatA" class="headerlink" title="chatA"></a>chatA</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: chatA.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月26日 星期二 11时54分44秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断有名管道1是否存在</span></span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件不存</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道文件不存在, 创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 文件路径</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fifo1&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断有名管道2是否存在</span></span><br><span class="line">    ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件不存</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道文件不存在, 创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 文件路径</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fifo2&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以只写方式打开管道fifo1 --- 1</span></span><br><span class="line">    <span class="keyword">int</span> fdw = open(<span class="string">&quot;fifo1&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open - fifo1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开fifo1成功！等待写入... ...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以只读方式打开管道fifo2 --- 2</span></span><br><span class="line">    <span class="keyword">int</span> fdr = open(<span class="string">&quot;fifo2&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open - fifo2&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开fifo2成功！等待读取... ...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环写读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 获取标准输入(stdin)的数据</span></span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;writ&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读管道数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        ret = read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; buf : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="chatB"><a href="#chatB" class="headerlink" title="chatB"></a>chatB</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: chatA.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月26日 星期二 11时54分44秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断有名管道1是否存在</span></span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件不存</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道文件不存在, 创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 文件路径</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fifo1&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断有名管道2是否存在</span></span><br><span class="line">    ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件不存</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道文件不存在, 创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 文件路径</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fifo2&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以只读方式打开管道fifo1 --- 1</span></span><br><span class="line">    <span class="keyword">int</span> fdr = open(<span class="string">&quot;fifo1&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open - fifo1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开fifo1成功！等待读取... ...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以只写方式打开管道fifo2 --- 2</span></span><br><span class="line">    <span class="keyword">int</span> fdw = open(<span class="string">&quot;fifo2&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open - fifo2&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开fifo2成功！等待写入... ...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读写数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 读管道数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        ret = read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; buf : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 获取标准输入(stdin)的数据</span></span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;writ&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220427203503435.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220427203503435.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220427203503435"></p><h4 id="问！如何实现一方多次发送消息！怎么实现？"><a href="#问！如何实现一方多次发送消息！怎么实现？" class="headerlink" title="问！如何实现一方多次发送消息！怎么实现？"></a>问！如何实现一方多次发送消息！怎么实现？</h4><p>可以fork创建子进程一起跑 - 有时间我一定代码实现测试一下</p><p>代码如下</p><h4 id="A-B-无限通信-嗷嗷叫！"><a href="#A-B-无限通信-嗷嗷叫！" class="headerlink" title="A - B 无限通信 嗷嗷叫！"></a>A - B 无限通信 嗷嗷叫！</h4><p><code>chatA</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: chatA.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月30日 星期六 19时58分44秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断管道是否存在 - FIFO</span></span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FIFO1 文件不存在, 正在创建 ... ... \n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo1&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FIFO2 文件不存在, 正在创建 ... ... \n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo2&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以只写方式打开 FIFO1</span></span><br><span class="line">    <span class="keyword">int</span> fdw = open(<span class="string">&quot;fifo1&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open-FIFO1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开 FIFO1 成功! 等待写入....\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fdr = open(<span class="string">&quot;fifo2&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open-FIFO2&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开 FIFO2 成功! 等待读取....\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="comment">// char *buf = (char *)malloc(sizeof(char) * 5);</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="comment">// 获取标准输入(stdin)的数据</span></span><br><span class="line">            fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">            ret = write(fdw, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;writ&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            ret = read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;buf : %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    close(fdw);</span><br><span class="line">    close(fdr);</span><br><span class="line">    <span class="comment">// free(buf);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>chatB</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: chatA.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月30日 星期六 19时58分44秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断管道是否存在 - FIFO</span></span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FIFO1 文件不存在, 正在创建 ... ... \n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo1&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FIFO2 文件不存在, 正在创建 ... ... \n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo2&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以只读方式打开 FIFO1</span></span><br><span class="line">    <span class="keyword">int</span> fdr = open(<span class="string">&quot;fifo1&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open-FIFO1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开 FIFO1 成功! 等待读取....\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fdw = open(<span class="string">&quot;fifo2&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open-FIFO2&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开 FIFO2 成功! 等待写入....\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="comment">// char *buf = (char *)malloc(sizeof(char) * 1024);</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            ret = read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                <span class="comment">// exit(-1);</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;buf : %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建子进程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="comment">// 获取标准输入(stdin)的数据</span></span><br><span class="line">            fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">            ret = write(fdw, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;writ&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux多进程开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>wait-waitpid 函数</title>
      <link href="2022/04/11/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/wait%E5%87%BD%E6%95%B0/"/>
      <url>2022/04/11/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/wait%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="wait-回收子进程资源"><a href="#wait-回收子进程资源" class="headerlink" title="wait - 回收子进程资源"></a>wait - 回收子进程资源</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: wait.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月12日 星期二 19时01分25秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment"> *  #include &lt;sys/wait.ch&gt;</span></span><br><span class="line"><span class="comment"> *  pid_t wait(int *wstatus);</span></span><br><span class="line"><span class="comment"> *      功能: 等待任意一个子进程结束, 如果任意一个子进程结束了,此函数会回收子进程的资源</span></span><br><span class="line"><span class="comment"> *      参数: int *wstatus</span></span><br><span class="line"><span class="comment"> *          进程退出时的状态信息,传入的是一个int类型的地址, 传出参数</span></span><br><span class="line"><span class="comment"> *      返回值:</span></span><br><span class="line"><span class="comment"> *          - 成功: 返回被回收的子进程的ID</span></span><br><span class="line"><span class="comment"> *          - 失败: -1 (所有的子进程都结束了, 调用函数失败)</span></span><br><span class="line"><span class="comment"> *      调用wait函数的进程会被挂起(阻塞),直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒(相当于继续执行)</span></span><br><span class="line"><span class="comment"> *      如果没有子进程了,函数立刻返回,返回-1:如果子进程都已经结束了,也会立即返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有一个父进程,创建5个子进程(兄弟)</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 干掉子进程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5次子进程结束后父进程一直再执行就会出现在5个孤儿进程"><a href="#5次子进程结束后父进程一直再执行就会出现在5个孤儿进程" class="headerlink" title="5次子进程结束后父进程一直再执行就会出现在5个孤儿进程"></a>5次子进程结束后父进程一直再执行就会出现在5个孤儿进程</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220413230612712.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220413230612712.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220413230612712"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220413230734623.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220413230734623.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220413230734623"></p><p>结束掉父进程</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220413230841640.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220413230841640.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220413230841640"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: wait.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月12日 星期二 19时01分25秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment"> *  #include &lt;sys/wait.ch&gt;</span></span><br><span class="line"><span class="comment"> *  pid_t wait(int *wstatus);</span></span><br><span class="line"><span class="comment"> *      功能: 等待任意一个子进程结束, 如果任意一个子进程结束了,此函数会回收子进程的资 源</span></span><br><span class="line"><span class="comment"> *      参数: int *wstatus</span></span><br><span class="line"><span class="comment"> *          进程退出时的状态信息,传入的是一个int类型的地址, 传出参数</span></span><br><span class="line"><span class="comment"> *      返回值:</span></span><br><span class="line"><span class="comment"> *          - 成功: 返回被回收的子进程的ID</span></span><br><span class="line"><span class="comment"> *          - 失败: -1 (所有的子进程都结束了, 调用函数失败)</span></span><br><span class="line"><span class="comment"> *      调用wait函数的进程会被挂起(阻塞),直到它的一个子进程退出或者收到一个不能被忽略 的信号时才被唤醒(相当于继续执行)</span></span><br><span class="line"><span class="comment"> *      如果没有子进程了,函数立刻返回,返回-1:如果子进程都已经结束了,也会立即返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有一个父进程,创建5个子进程(兄弟)</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 干掉子进程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ret = wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="退出信息相关宏函数"><a href="#退出信息相关宏函数" class="headerlink" title="退出信息相关宏函数"></a>退出信息相关宏函数</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220415112552312.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220415112552312.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220415112552312"></p><h3 id="正常运行结束代码"><a href="#正常运行结束代码" class="headerlink" title="正常运行结束代码"></a>正常运行结束代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: wait.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月12日 星期二 19时01分25秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment"> *  #include &lt;sys/wait.ch&gt;</span></span><br><span class="line"><span class="comment"> *  pid_t wait(int *wstatus);</span></span><br><span class="line"><span class="comment"> *      功能: 等待任意一个子进程结束, 如果任意一个子进程结束了,此函数会回收子进程的资 源</span></span><br><span class="line"><span class="comment"> *      参数: int *wstatus</span></span><br><span class="line"><span class="comment"> *          进程退出时的状态信息,传入的是一个int类型的地址, 传出参数</span></span><br><span class="line"><span class="comment"> *      返回值:</span></span><br><span class="line"><span class="comment"> *          - 成功: 返回被回收的子进程的ID</span></span><br><span class="line"><span class="comment"> *          - 失败: -1 (所有的子进程都结束了, 调用函数失败)</span></span><br><span class="line"><span class="comment"> *      调用wait函数的进程会被挂起(阻塞),直到它的一个子进程退出或者收到一个不能被忽略 的信号时才被唤醒(相当于继续执行)</span></span><br><span class="line"><span class="comment"> *      如果没有子进程了,函数立刻返回,返回-1:如果子进程都已经结束了,也会立即返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有一个父进程,创建5个子进程(兄弟)</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 干掉子进程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//int ret = wait(NULL);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> st;</span><br><span class="line">            <span class="keyword">int</span> ret = wait(&amp;st);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(st)) &#123;</span><br><span class="line">                <span class="comment">// 是不是正常退出</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;退出的状态码 : %d\n&quot;</span>, WEXITSTATUS(st));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(WIFSIGNALED(st)) &#123;</span><br><span class="line">                <span class="comment">// 是不是异常终止</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;被那个信号干掉了: %d\n&quot;</span>, WTERMSIG(st));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// exit(0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220415155935776.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220415155935776.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220415155935776"></p><h3 id="信号干掉代码"><a href="#信号干掉代码" class="headerlink" title="信号干掉代码"></a>信号干掉代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: wait.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月12日 星期二 19时01分25秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment"> *  #include &lt;sys/wait.ch&gt;</span></span><br><span class="line"><span class="comment"> *  pid_t wait(int *wstatus);</span></span><br><span class="line"><span class="comment"> *      功能: 等待任意一个子进程结束, 如果任意一个子进程结束了,此函数会回收子进程的资 源</span></span><br><span class="line"><span class="comment"> *      参数: int *wstatus</span></span><br><span class="line"><span class="comment"> *          进程退出时的状态信息,传入的是一个int类型的地址, 传出参数</span></span><br><span class="line"><span class="comment"> *      返回值:</span></span><br><span class="line"><span class="comment"> *          - 成功: 返回被回收的子进程的ID</span></span><br><span class="line"><span class="comment"> *          - 失败: -1 (所有的子进程都结束了, 调用函数失败)</span></span><br><span class="line"><span class="comment"> *      调用wait函数的进程会被挂起(阻塞),直到它的一个子进程退出或者收到一个不能被忽略 的信号时才被唤醒(相当于继续执行)</span></span><br><span class="line"><span class="comment"> *      如果没有子进程了,函数立刻返回,返回-1:如果子进程都已经结束了,也会立即返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有一个父进程,创建5个子进程(兄弟)</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 干掉子进程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//int ret = wait(NULL);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> st;</span><br><span class="line">            <span class="keyword">int</span> ret = wait(&amp;st);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(st)) &#123;</span><br><span class="line">                <span class="comment">// 是不是正常退出</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;退出的状态码 : %d\n&quot;</span>, WEXITSTATUS(st));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(WIFSIGNALED(st)) &#123;</span><br><span class="line">                <span class="comment">// 是不是异常终止</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;被那个信号干掉了: %d\n&quot;</span>, WTERMSIG(st));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// exit(0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220415160453399.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220415160453399.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220415160453399"></p><h2 id="waitpid-回收子进程资源"><a href="#waitpid-回收子进程资源" class="headerlink" title="waitpid - 回收子进程资源"></a>waitpid - 回收子进程资源</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: wait_pid.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月15日 星期五 16时38分41秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment"> *  #include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment"> *      pid_t waitpid(pid_t pid, int *wstatus, int options);</span></span><br><span class="line"><span class="comment"> *              功能: 回收指定进程号的子进程,可以设置是否阻塞。</span></span><br><span class="line"><span class="comment"> *              参数:</span></span><br><span class="line"><span class="comment"> *                      - pid:</span></span><br><span class="line"><span class="comment"> *                              PID &gt; 0 : 回收某个指定子进程的 PID</span></span><br><span class="line"><span class="comment"> *                              PID = 0 : 回收当前进程组的所有子进程</span></span><br><span class="line"><span class="comment"> *                                      进程 A -&gt; B A -&gt; C 放到一个集合 (A - B, A - C) &lt;- D 在把D给别人就不输入当前组 释放时候就与D没有关系了。// ajx 查看组查看进程组</span></span><br><span class="line"><span class="comment"> *                              PID = -1 : 回收所有的子进程 相当于 wait() (最长用)</span></span><br><span class="line"><span class="comment"> *              PID &lt; -1 : 某个进程组的组id的绝对值回收指定进程组中的子进程</span></span><br><span class="line"><span class="comment"> *          - options: 设置阻塞或者非阻塞</span></span><br><span class="line"><span class="comment"> *              0 : 阻塞</span></span><br><span class="line"><span class="comment"> *              WNOHANG : 非阻塞</span></span><br><span class="line"><span class="comment"> *          - 返回值:</span></span><br><span class="line"><span class="comment"> *              &gt; 0 : 返回子进程的id</span></span><br><span class="line"><span class="comment"> *              = 0 : options = WNOHANG, 表示还有子进程活着</span></span><br><span class="line"><span class="comment"> *              = -1 : 错误, 或者没有子进程了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有一个父进程, 创建5个子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> st;</span><br><span class="line">            <span class="comment">// int ret = waitpid(-1, &amp;st, 0); // 阻塞</span></span><br><span class="line">            <span class="keyword">int</span> ret = waitpid(<span class="number">-1</span>, &amp;st, WNOHANG);</span><br><span class="line">            <span class="keyword">if</span>(ret == - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 还有子进程存在</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span>(WIFEXITED(st)) &#123;</span><br><span class="line">                <span class="comment">// 是不是正常退出</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;退出的状态码 : %d\n&quot;</span>, WEXITSTATUS(st));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(st)) &#123;</span><br><span class="line">                <span class="comment">// 是不是异常终止</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;被那个信号干掉了 : %d\n&quot;</span>,WTERMSIG(st));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line">            &#125;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child , pid = %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux多进程开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程控制</title>
      <link href="2022/04/10/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>2022/04/10/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220410190008070.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220410190008070.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220410190008070"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: exit.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月10日 星期日 19时08分41秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        #include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">        void exit(int status);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">        void _exit(int status);</span></span><br><span class="line"><span class="comment">        父进程回收子进程时候会用到!</span></span><br><span class="line"><span class="comment">        status参数: 是进程退时的一个状态信息。父进程回收子进程资源时候可以h 获取到。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//exit(0); // 输出 hello world --- \n 会刷新缓冲区 吧缓冲区 world 输出到控制台</span></span><br><span class="line">    _exit(<span class="number">0</span>); <span class="comment">// 输出 hello</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>父进程运行结束，但子进程还在运行(未运行结束)，这样的子进程就称为孤儿进程(Orphan Process).</p><p>每当出现一个孤儿进程时候,内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()(进程资源释放)它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作</p><p>因此孤儿进程并不会有什么危害。</p><h3 id="对比代码"><a href="#对比代码" class="headerlink" title="对比代码"></a>对比代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: fork_exit.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月10日 星期日 21时12分28秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d, pid : %d\n&quot;</span>, i, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注意 pid、ppid 变化</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: fork_exit.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月10日 星期日 21时12分28秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d, pid : %d\n&quot;</span>, i, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>每个进程结束之后，都会释放自己地址空间中的用户区数据，内核区的 PCB没有办法自己释放掉，需要父进程去释放。</p><p>进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸( zombie)进程。</p><p>僵尸进程不能被kill -9杀死。</p><p>这样就会导致一个问题，如果父进程不调用wait()或waitpid()的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的， 如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: zombie.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月10日 星期日 21时12分28秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d, pid : %d\n&quot;</span>, i, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>新打开一个窗口 ps aux 查看进程 可以试着用 kill -9 进程id (测试杀死僵尸进程)</code></p><p><code>如果父进程结束了 子进程就会被进程为 1 的接替</code> </p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220410225325329.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220410225325329.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220410225325329"></p><h2 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h2><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息(包括进程号、退出状态、运行时间等)。</p><p>父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p><p>wait()和waitpid()函数的功能一样，区别在于, wait()函数会阻塞，waitpid ()可以设置不阻塞, waitpid()还可以指定等待哪个子进程结束。</p><p><code>注意:一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux多进程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>exec函数族</title>
      <link href="2022/04/08/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/exec%E5%87%BD%E6%95%B0%E6%97%8F/"/>
      <url>2022/04/08/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/exec%E5%87%BD%E6%95%B0%E6%97%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="函数族"><a href="#函数族" class="headerlink" title="函数族"></a>函数族</h2><p><code>族 ： 一族就是一系列函数 相同或者相似的 如oop 函数重载 </code></p><p>名字不同 但是实现的功能相似的</p><h2 id="exec函数族介绍"><a href="#exec函数族介绍" class="headerlink" title="exec函数族介绍"></a>exec函数族介绍</h2><p>exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。</p><p>exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代．只留下进程ID 等一些表面上的信息仍保持原样，颇有些神似”三十六计”中的”金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。</p><h2 id="exec函数族作用图解"><a href="#exec函数族作用图解" class="headerlink" title="exec函数族作用图解"></a>exec函数族作用图解</h2><p>替换 </p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220408215949284.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220408215949284.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220408215949284"></p><p>最后一条才是Linux函数库的 其他都是标准c库的</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220408223512584.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220408223512584.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220408223512584"></p><h2 id="execl"><a href="#execl" class="headerlink" title="execl"></a>execl</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: execl.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月10日 星期日 11时37分27秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"> *  int execl(const char *path, const char *arg, ...);</span></span><br><span class="line"><span class="comment"> *      - 参数:</span></span><br><span class="line"><span class="comment"> *          - path: 需要指定的执行的文件的路径或者名称</span></span><br><span class="line"><span class="comment"> *              a.out /test/高并发/Linux多线程/exec函数族/execl.aout</span></span><br><span class="line"><span class="comment"> *              建议写绝对路径</span></span><br><span class="line"><span class="comment"> *              ./a.out hello world</span></span><br><span class="line"><span class="comment"> *          - arg: 是执行可执行文件所需要的参数列表</span></span><br><span class="line"><span class="comment"> *              第一个参数一般没有什么作用, 为了方便, 一般可写的是执行的程序名称</span></span><br><span class="line"><span class="comment"> *              从二个参数开始往后, 就是程序执行的所需要的参数列表</span></span><br><span class="line"><span class="comment"> *              参数最后要以NULL结束(哨兵)</span></span><br><span class="line"><span class="comment"> *          - 返回值:</span></span><br><span class="line"><span class="comment"> *              只有调用失败, 才会返回值, 返回-1, 并设置errno</span></span><br><span class="line"><span class="comment"> *              如果调用成功没有返回值！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子进程, 在子进程中执行exec函数族中的函数</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am paren peocess, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己的可执行程序 --- 参数 可执行文件</span></span><br><span class="line">        <span class="comment">// execl(&quot;test&quot;, &quot;test&quot;, NULL);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// which ps --- /usr/bin/ps</span></span><br><span class="line">        <span class="comment">// or</span></span><br><span class="line">        <span class="comment">// execl(&quot;/usr/bin/ps&quot;, &quot;ps&quot;, &quot;a&quot;,&quot;u&quot;,&quot;x&quot;, NULL);</span></span><br><span class="line">        execl(<span class="string">&quot;/usr/bin/ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child proess pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; i = %d, pid = %d\n&quot;</span>, i, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="execlp"><a href="#execlp" class="headerlink" title="execlp"></a>execlp</h2><p><code>env // 环境变量</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: execl.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月10日 星期日 11时37分27秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"> *  int execl(const char *file, const char *arg, ...);</span></span><br><span class="line"><span class="comment"> *      - 会到环境变量中查找指定的可执行文件, 如果找到了就执行, 找不到就执行不成功。</span></span><br><span class="line"><span class="comment"> *      - 参数:</span></span><br><span class="line"><span class="comment"> *          - file: 需要执行的可执行文件的文件名</span></span><br><span class="line"><span class="comment"> *          - arg: 是执行可执行文件所需要的参数列表</span></span><br><span class="line"><span class="comment"> *              第一个参数一般没有什么作用, 为了方便, 一般可写的是执行的程序名称</span></span><br><span class="line"><span class="comment"> *              从二个参数开始往后, 就是程序执行的所需要的参数列表</span></span><br><span class="line"><span class="comment"> *              参数最后要以NULL结束(哨兵)</span></span><br><span class="line"><span class="comment"> *          - 返回值:</span></span><br><span class="line"><span class="comment"> *              只有调用失败, 才会返回值, 返回-1, 并设置errno</span></span><br><span class="line"><span class="comment"> *              如果调用成功没有返回值！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子进程, 在子进程中执行exec函数族中的函数</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am paren peocess, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己的可执行程序 --- 参数 可执行文件</span></span><br><span class="line">        <span class="comment">// execl(&quot;test&quot;, &quot;test&quot;, NULL);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// which ps --- /usr/bin/ps</span></span><br><span class="line">        <span class="comment">// or</span></span><br><span class="line">        <span class="comment">// execl(&quot;/usr/bin/ps&quot;, &quot;ps&quot;, &quot;a&quot;,&quot;u&quot;,&quot;x&quot;, NULL);</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child proess pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; i = %d, pid = %d\n&quot;</span>, i, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="execv"><a href="#execv" class="headerlink" title="execv"></a>execv</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*      int execv(const char *path, char *const argv[]);</span></span><br><span class="line"><span class="comment">*          - argv: 是需要的参数的一个字符串数组</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*      // 使用 execv</span></span><br><span class="line"><span class="comment">*      char *argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span></span><br><span class="line"><span class="comment">*      execv(&quot;/usr/bin/ps&quot;, argv);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  int execve(const char *filename, char *const argv[], char *const envp[]);</span></span><br><span class="line"><span class="comment"> *  先从指定环境变量中 查找 如果第一个查找不到就到第二个中查找 ...</span></span><br><span class="line"><span class="comment"> *  char *envp[] = &#123;&quot;/usr/bin&quot;, &quot;/usr/bin/test&quot;, &quot;xxxxx&quot;&#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux多进程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> [object Object] </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-Sort解析</title>
      <link href="2022/04/08/OOP/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0Sort/"/>
      <url>2022/04/08/OOP/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0Sort/</url>
      
        <content type="html"><![CDATA[<h2 id="STL-sort-模板解析"><a href="#STL-sort-模板解析" class="headerlink" title="STL_sort 模板解析"></a>STL_sort 模板解析</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: Sort.cpp</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2021年11月10日 星期三 20时30分05秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MAX_N == 存放数组大小，n == 循环右边边界</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span>, n = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEGINS(x) namespace x &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENDS(x) &#125; <span class="comment">// end of namespace x</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化_BEGINES</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> *f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) *(f + i) = rand() % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> *first, <span class="keyword">int</span> *last, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; msg;</span><br><span class="line">    <span class="keyword">while</span>(first != last) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化_ENDS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// STL_自带sort_使用</span></span><br><span class="line">BEGINS(test1)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMP</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[MAX_N];</span><br><span class="line"></span><br><span class="line">    init(f);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;default : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    sort(f, f + n);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;none : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    sort(f, f + n, cmp1);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;cmp1 : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    CMP cmp2;</span><br><span class="line">    sort(f, f + n, cmp2);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;cmp2 : &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDS(test1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动实现sort firstEdition</span></span><br><span class="line">BEGINS(test2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMP</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *first, <span class="keyword">int</span> *last, function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; cmp = less&lt;<span class="keyword">int</span>&gt;())</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first &gt;= last) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> *x = first, *y = last - <span class="number">1</span>, z = *first;</span><br><span class="line">    <span class="keyword">while</span>(x &lt; y) &#123;</span><br><span class="line">        <span class="comment">// while(x &lt; y &amp;&amp; *y &gt;= z) y--;</span></span><br><span class="line">        <span class="keyword">while</span>(x &lt; y &amp;&amp; cmp(z, *y)) y--;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; y) *(x++) = *y;</span><br><span class="line">        <span class="comment">// while(x &lt; y &amp;&amp; *x &lt;= z) x++;</span></span><br><span class="line">        <span class="keyword">while</span>(x &lt; y &amp;&amp; cmp(*x, z)) x++;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; y) *(y--) = *x;</span><br><span class="line">    &#125;</span><br><span class="line">    *x = z;</span><br><span class="line">    sort(first, x, cmp);</span><br><span class="line">    sort(x + <span class="number">1</span>, last, cmp);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[MAX_N];</span><br><span class="line"></span><br><span class="line">    init(f);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;default : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    sort(f, f + n);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;none : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    sort(f, f + n, cmp1);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;cmp1 : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    CMP cmp2;</span><br><span class="line">    sort(f, f + n, cmp2);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;cmp2 : &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDS(test2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动实现sort secondEdition 单边递归法</span></span><br><span class="line">BEGINS(test3)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMP</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *first, <span class="keyword">int</span> *last, function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; cmp = less&lt;<span class="keyword">int</span>&gt;())</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first &gt;= last) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">while</span>(first &lt; last) &#123;</span><br><span class="line">        <span class="keyword">int</span> *x = first, *y = last - <span class="number">1</span>, z = *first;</span><br><span class="line">        <span class="keyword">while</span>(x &lt; y) &#123;</span><br><span class="line">            <span class="keyword">while</span>(x &lt; y &amp;&amp; cmp(z, *y)) y--;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; y) *(x++) = *y;</span><br><span class="line">            <span class="keyword">while</span>(x &lt; y &amp;&amp; cmp(*x, z)) x++;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; y) *(y--) = *x;</span><br><span class="line">        &#125;</span><br><span class="line">        *x = z;</span><br><span class="line">        sort(first, x, cmp);</span><br><span class="line">        first = x + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[MAX_N];</span><br><span class="line"></span><br><span class="line">    init(f);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;default : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    sort(f, f + n);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;none : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    sort(f, f + n, cmp1);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;cmp1 : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    CMP cmp2;</span><br><span class="line">    sort(f, f + n, cmp2);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;cmp2 : &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDS(test3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动实现sort secondEdition 单边递归法_无监督</span></span><br><span class="line">BEGINS(test4)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMP</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *first, <span class="keyword">int</span> *last, function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; cmp = less&lt;<span class="keyword">int</span>&gt;())</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(first &lt; last) &#123;</span><br><span class="line">        <span class="keyword">int</span> *x = first, *y = last - <span class="number">1</span>, z = *first;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(cmp(*x, z)) x++;</span><br><span class="line">            <span class="keyword">while</span>(cmp(z, *y)) y--;</span><br><span class="line">            <span class="keyword">if</span>(x &lt;= y) &#123;</span><br><span class="line">                swap(*x, *y);</span><br><span class="line">                x++, y--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(x &lt;= y);</span><br><span class="line">        sort(x, last, cmp);</span><br><span class="line">        last = y + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[MAX_N];</span><br><span class="line"></span><br><span class="line">    init(f);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;default : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    sort(f, f + n);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;none : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    sort(f, f + n, cmp1);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;cmp1 : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    CMP cmp2;</span><br><span class="line">    sort(f, f + n, cmp2);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;cmp2 : &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDS(test4)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动实现sort secondEdition 单边递归法_无监督_插入排序</span></span><br><span class="line">BEGINS(test5)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMP</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> threshold = <span class="number">16</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intro_loop</span><span class="params">(<span class="keyword">int</span> *first, <span class="keyword">int</span> *last, function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; cmp = less&lt;<span class="keyword">int</span>&gt;())</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(last - first &gt; threshold) &#123;</span><br><span class="line">        <span class="keyword">int</span> *x = first, *y = last - <span class="number">1</span>, z = *first;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(cmp(*x, z)) x++;</span><br><span class="line">            <span class="keyword">while</span>(cmp(z, *y)) y--;</span><br><span class="line">            <span class="keyword">if</span>(x &lt;= y) &#123;</span><br><span class="line">                swap(*x, *y);</span><br><span class="line">                x++, y--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(x &lt;= y);</span><br><span class="line">        sort(x, last, cmp);</span><br><span class="line">        last = y + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> *first, <span class="keyword">int</span> *last, function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; cmp = less&lt;<span class="keyword">int</span>&gt;())</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ind = first;</span><br><span class="line">    <span class="comment">// 找到最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> *i = first + <span class="number">1</span>; i &lt; last; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cmp(*i, *ind)) ind = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ind != first) &#123;</span><br><span class="line">        swap(*ind, *(ind - <span class="number">1</span>));</span><br><span class="line">        --ind;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> *i = first + <span class="number">2</span>; i &lt; last; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> *j = i;</span><br><span class="line">        <span class="keyword">while</span>(cmp(*j, *(j - <span class="number">1</span>))) &#123;</span><br><span class="line">            swap(*j, *(j - <span class="number">1</span>));</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *first, <span class="keyword">int</span> *last, function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; cmp = less&lt;<span class="keyword">int</span>&gt;())</span> </span>&#123;</span><br><span class="line">    intro_loop(first, last, cmp);</span><br><span class="line">    insertion_sort(first, last, cmp);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[MAX_N];</span><br><span class="line"></span><br><span class="line">    init(f);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;default : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    sort(f, f + n);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;none : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    sort(f, f + n, cmp1);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;cmp1 : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    CMP cmp2;</span><br><span class="line">    sort(f, f + n, cmp2);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;cmp2 : &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDS(test5)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动实现sort secondEdition 单边递归法_无监督_插入排序_随机迭代器(指针对象)</span></span><br><span class="line">BEGINS(test6)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMP</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> threshold = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomIter</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    RandomIter(<span class="keyword">int</span> *ptr) : ptr(ptr)&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">    RandomIter <span class="keyword">operator</span>-(<span class="keyword">int</span> x) &#123;<span class="keyword">return</span> RandomIter(ptr - x); &#125;</span><br><span class="line">    RandomIter <span class="keyword">operator</span>+(<span class="keyword">int</span> x) &#123;<span class="keyword">return</span> RandomIter(ptr + x); &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>-(<span class="keyword">const</span> RandomIter &amp;iter) &#123;<span class="keyword">return</span> ptr - iter.ptr; &#125;</span><br><span class="line">    <span class="comment">// 前 ++ operator++()</span></span><br><span class="line">    <span class="comment">// 后 ++ operator++(int)</span></span><br><span class="line">    RandomIter &amp;<span class="keyword">operator</span>++() &#123; ++ptr; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;;</span><br><span class="line">    RandomIter &amp;<span class="keyword">operator</span>--() &#123; --ptr; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> RandomIter &amp;iter) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;ptr &lt; iter.ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> RandomIter &amp;iter) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iter &lt; *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> RandomIter &amp;iter) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(iter &lt; *<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> RandomIter &amp;iter) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; iter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> RandomIter &amp;iter) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(iter &lt; *<span class="keyword">this</span>) &amp;&amp; !(*<span class="keyword">this</span> &lt; iter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> RandomIter &amp;iter) &#123;</span><br><span class="line">        <span class="keyword">return</span> !(iter == *<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intro_loop</span><span class="params">(RandomIter first, RandomIter last, function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; cmp = less&lt;<span class="keyword">int</span>&gt;())</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(last - first &gt; threshold) &#123;</span><br><span class="line">        RandomIter x = first, y = last - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> z = *first;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(cmp(*x, z)) ++x;</span><br><span class="line">            <span class="keyword">while</span>(cmp(z, *y)) --y;</span><br><span class="line">            <span class="keyword">if</span>(x &lt;= y) &#123;</span><br><span class="line">                swap(*x, *y);</span><br><span class="line">                ++x, --y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(x &lt;= y);</span><br><span class="line">        intro_loop(x, last, cmp);</span><br><span class="line">        last = y + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(RandomIter first,  RandomIter last, function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; cmp = less&lt;<span class="keyword">int</span>&gt;())</span> </span>&#123;</span><br><span class="line">    RandomIter ind = first;</span><br><span class="line">    <span class="comment">// 找到最小值</span></span><br><span class="line">    <span class="keyword">for</span>(RandomIter i = first + <span class="number">1</span>; i &lt; last; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cmp(*i, *ind)) ind = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ind != first) &#123;</span><br><span class="line">        swap(*ind, *(ind - <span class="number">1</span>));</span><br><span class="line">        --ind;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(RandomIter i = first + <span class="number">2</span>; i &lt; last; ++i) &#123;</span><br><span class="line">        RandomIter j = i;</span><br><span class="line">        <span class="keyword">while</span>(cmp(*j, *(j - <span class="number">1</span>))) &#123;</span><br><span class="line">            swap(*j, *(j - <span class="number">1</span>));</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(RandomIter first, RandomIter last, function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; cmp = less&lt;<span class="keyword">int</span>&gt;())</span> </span>&#123;</span><br><span class="line">    intro_loop(first, last, cmp);</span><br><span class="line">    insertion_sort(first, last, cmp);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[MAX_N];</span><br><span class="line"></span><br><span class="line">    init(f);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;default : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    sort(f, f + n);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;none : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    sort(f, f + n, cmp1);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;cmp1 : &quot;</span>);</span><br><span class="line"></span><br><span class="line">    CMP cmp2;</span><br><span class="line">    sort(f, f + n, cmp2);</span><br><span class="line">    output(f, f + n, <span class="string">&quot;cmp2 : &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDS(test6)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test1::main();</span></span><br><span class="line">    <span class="comment">// test2::main();</span></span><br><span class="line">    <span class="comment">// test3::main();</span></span><br><span class="line">    <span class="comment">// test4::main();</span></span><br><span class="line">    <span class="comment">// test5::main();</span></span><br><span class="line">    test6::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++OOP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GDB多线程调试</title>
      <link href="2022/04/06/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/GDB%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
      <url>2022/04/06/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/GDB%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="GDB多进程调试"><a href="#GDB多进程调试" class="headerlink" title="GDB多进程调试"></a>GDB多进程调试</h2><p>使用GDB调试的时候，GDB默认只能跟踪一个进程，可以在fork函数调用之前,通过指令设置GDB调试工具跟踪父进程或者跟踪跟踪子进程，默认跟踪父进程。</p><p>设置调试父进程或者子进程： set follow-fork-mode [paren(默认) | child]</p><p>设置调试模式：set detach-on-fork [on | off]</p><p>默认 on,表示调试当前进程的时候,其他的进程继续运行, 如果为off, 调试当前进程的时候, 其他进程被GDB挂起。</p><p>查看调试的进程：info inferiors</p><p>切换当前调试的进程： inferior id</p><p>使进程脱离GDB调试：detach inferiors id</p><p>使进程移除GDB调试：remo inferiors id</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220408110554688.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220408110554688.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220408110554688"></p><h2 id="gdb多线程报错"><a href="#gdb多线程报错" class="headerlink" title="gdb多线程报错"></a>gdb多线程报错</h2><p>8.x 版本调试多进程会有一些BUG</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220408111332901.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220408111332901.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220408111332901"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220408113558469.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220408113558469.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220408113558469"></p><p>inferior 2</p><p>info inferiors &#x2F;&#x2F; 查看</p>]]></content>
      
      
      <categories>
          
          <category> Linux多进程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程状态转换</title>
      <link href="2022/04/02/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/"/>
      <url>2022/04/02/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h2><p>三态模型：就绪态、运行态、阻塞态</p><p>五态模型：新建态、就绪态、运行态、阻塞态、终止态</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220402192345042.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220402192345042.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220402192345042"></p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220402220421337.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220402220421337.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220402220421337"></p><p>查看进程 man ps</p><ol><li>ps aux &#x2F; ajx (PPID 父进程的IP、 PID 进程的ID、PGID 进程组的ID、SID 绘话)</li><li>a：显示终端上的所有进程, 包括其他用户的进程</li><li>u: 显示进程的详细信息</li><li>x: 显示没有控制终端的进程</li><li>j: 列出与作业控制相关的信息</li></ol><h2 id="进程状态转换-1"><a href="#进程状态转换-1" class="headerlink" title="进程状态转换"></a>进程状态转换</h2><h3 id="STAT-参数意义："><a href="#STAT-参数意义：" class="headerlink" title="STAT 参数意义："></a>STAT 参数意义：</h3><p>​D 不可中断 Uninterruptible（usually IO）</p><p>​R 正在运行, 或在队列中的进程</p><p>​S (大写) 处于休眠状态</p><p>​T 停止或被追踪</p><p>​Z 僵尸进程</p><p>​W 进入内存交换 (从内核2.6开始无效)</p><p>​X 杀掉的进程</p><p>​&lt; 高优先级</p><p>​N 底优先级</p><p>​s 包含子进程</p><p>​+ 位于前台的进程组</p><h3 id="实时显示进程状态"><a href="#实时显示进程状态" class="headerlink" title="实时显示进程状态"></a>实时显示进程状态</h3><p>​top</p><p>​可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔，在top命令执行后，可以按下按键对显示的结果排序</p><p>按 键</p><ul><li>M 根据内存使用量排序</li><li>P 根据 CPU 占有率排序</li><li>T 根据进程运行时间长短</li><li>U 根据用户名来筛选进程</li><li>K 输入指定的 PID 杀死进程</li></ul><p>杀死进程</p><ul><li>kill [-signal] pid</li><li>kill -l 列出所有信号</li><li>kill -SIGKILL 进程ID</li><li>kill -9 进程ID &#x2F;&#x2F; -l 信号 SIGKILL &#x2F; -9 强制杀死 </li><li>Killall name 根据进程名杀死进程</li></ul><h3 id="进程杀死测试"><a href="#进程杀死测试" class="headerlink" title="进程杀死测试"></a>进程杀死测试</h3><p>终端 测试 运行代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: whil_lastiung.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月03日 星期日 10时39分54秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;秃头王\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220403104258071.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220403104258071.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220403104258071"></p><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p><code>./a.out &amp;</code></p><h2 id="进程号和相关函数"><a href="#进程号和相关函数" class="headerlink" title="进程号和相关函数"></a>进程号和相关函数</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220403114144755.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220403114144755.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220403114144755"></p><p>pid 进程ID</p><p>ppid 父进程的ID</p><p>pgpid 用组的ID </p><h2 id="进程创建-man-2-fork"><a href="#进程创建-man-2-fork" class="headerlink" title="进程创建 - man 2 fork"></a>进程创建 - man 2 fork</h2><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成讲程树结构模型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: fork.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年04月03日 星期日 14时14分05秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment"> *  #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  pid_t fork(void) ;</span></span><br><span class="line"><span class="comment"> *      函数的作用: 用于创建子进程</span></span><br><span class="line"><span class="comment"> *      返回值:</span></span><br><span class="line"><span class="comment"> *          fork()的返回值会返回2次 一次在父进程中、一次在子进程中。</span></span><br><span class="line"><span class="comment"> *          在父进程中返回创建的子进程的 ID</span></span><br><span class="line"><span class="comment"> *          在子进程中返回 0</span></span><br><span class="line"><span class="comment"> *          如何区分子进程和父进程: 通过fork的返回值</span></span><br><span class="line"><span class="comment"> *          在父进程中返回-1, 表示创建子进程失败, 并设置errno</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      父子进程之间的关系:</span></span><br><span class="line"><span class="comment"> *          区别:</span></span><br><span class="line"><span class="comment"> *              1. fork() 函数的返回值不同</span></span><br><span class="line"><span class="comment"> *                  父进程中: &gt; 0 返回的子进程的ID</span></span><br><span class="line"><span class="comment"> *                  子进程中: = 0</span></span><br><span class="line"><span class="comment"> *              2. pcb 中的一些数据</span></span><br><span class="line"><span class="comment"> *                  当前的进程id pid</span></span><br><span class="line"><span class="comment"> *                  当前的进程的父进程的id ppid</span></span><br><span class="line"><span class="comment"> *                  信号集</span></span><br><span class="line"><span class="comment"> *      共同点:</span></span><br><span class="line"><span class="comment"> *          某些状态下: 子进程中刚被创建出来, 还没有执行任何的写数据的操作</span></span><br><span class="line"><span class="comment"> *              - 用户区的数据</span></span><br><span class="line"><span class="comment"> *              - 文件描述表</span></span><br><span class="line"><span class="comment"> *      父子进程对变量是不是共享的？</span></span><br><span class="line"><span class="comment"> *          - 刚开始时候, 是一样的共享。如果修改的数据就不共享了</span></span><br><span class="line"><span class="comment"> *          - 读时候共享(子进程被创建, 两个进程没有做任何的写的操作), 写时拷贝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid : %d\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果大于0,返回的是创建的子进程的进程号, 当前父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d, ppid % d\n&quot;</span>, getpid(), getppid());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num : %d \n&quot;</span>, num);</span><br><span class="line">        num += <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num += 10 : %d \n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前是子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d, ppid : %d \n&quot;</span>, getpid(), getppid());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num : %d \n&quot;</span>, num);</span><br><span class="line">        num += <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num += 100 : %d \n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d, pid : %d\n&quot;</span>, i,  getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fork-执行流程"><a href="#fork-执行流程" class="headerlink" title="fork 执行流程"></a>fork 执行流程</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220406121610516.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220406121610516.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220406121610516"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220406155328046.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220406155328046.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220406155328046"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220406170044780.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220406170044780.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220406170044780"></p><p>修改子进程后就会开辟一个新地址</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220406170119438.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220406170119438.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220406170119438"></p>]]></content>
      
      
      <categories>
          
          <category> Linux多进程开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程概述</title>
      <link href="2022/04/01/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
      <url>2022/04/01/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h2><p>程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程：</p><ul><li><p>二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式）</p></li><li><p>机器语言指令：对程序算法进行编码。</p></li><li><p>程序入口地址：标识程序开始执行时的起始指令位置。</p></li><li><p>数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。</p></li><li><p>符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。</p></li><li><p>共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。</p></li><li><p>其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。</p></li><li><p>进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p></li><li><p>可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</p></li></ul><h2 id="单道、多道程序设计"><a href="#单道、多道程序设计" class="headerlink" title="单道、多道程序设计"></a>单道、多道程序设计</h2><ul><li><p>单道程序，即在计算机内存中只允许一个的程序运行。</p></li><li><p>多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。</p></li><li><p>对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。</p></li><li><p>在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</p></li></ul><h2 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h2><ul><li><p>时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。</p></li><li><p>时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。</p></li></ul><h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220529102821528.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220529102821528.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220529102821528"></p><p>并发：有限的资源交替使用</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220529102837327.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220529102837327.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220529102837327"></p><h2 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块(PCB)"></a>进程控制块(PCB)</h2><ul><li><p>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 task_struct 结构体。</p></li><li><p>在 &#x2F;usr&#x2F;src&#x2F;linux-headers-xxx&#x2F;include&#x2F;linux&#x2F;sched.h 文件中可以查看 struct task_struct 结构体定义。其内部成员有很多，我们只需要掌握以下部分即可：</p><ul><li><p>进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数</p></li><li><p>进程的状态：有就绪、运行、挂起、停止等状态</p></li><li><p>进程切换时需要保存和恢复的一些CPU寄存器</p></li><li><p>描述虚拟地址空间的信息</p></li><li><p>描述控制终端的信息</p></li></ul></li></ul><blockquote><p>ulimit - a 进程可用资源上限</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux多进程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准c库IO函数和Linux系统IO函数对比</title>
      <link href="2022/03/10/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E6%A0%87%E5%87%86c%E5%BA%93IO%E5%87%BD%E6%95%B0%E5%92%8CLinux%E7%B3%BB%E7%BB%9FIO%E5%87%BD%E6%95%B0%E5%AF%B9%E6%AF%94/"/>
      <url>2022/03/10/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E6%A0%87%E5%87%86c%E5%BA%93IO%E5%87%BD%E6%95%B0%E5%92%8CLinux%E7%B3%BB%E7%BB%9FIO%E5%87%BD%E6%95%B0%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h2 id="标准C库IO函数"><a href="#标准C库IO函数" class="headerlink" title="标准C库IO函数"></a>标准C库IO函数</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/1.7%20%E6%96%87%E4%BB%B6IO_%E9%A1%B5%E9%9D%A2_02.jpg" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/1.7%20%E6%96%87%E4%BB%B6IO_%E9%A1%B5%E9%9D%A2_02.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1.7 文件IO_页面_02"></p><p>自带帮助文档 第三章 </p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220310201130115.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220310201130115.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220310201130115"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/1.7%20%E6%96%87%E4%BB%B6IO_%E9%A1%B5%E9%9D%A2_03.jpg" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/1.7%20%E6%96%87%E4%BB%B6IO_%E9%A1%B5%E9%9D%A2_03.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1.7 文件IO_页面_03"></p><h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/1.7%20%E6%96%87%E4%BB%B6IO_%E9%A1%B5%E9%9D%A2_05.jpg" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/1.7%20%E6%96%87%E4%BB%B6IO_%E9%A1%B5%E9%9D%A2_05.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1.7 文件IO_页面_05"></p><h2 id="Linux系统IO函数"><a href="#Linux系统IO函数" class="headerlink" title="Linux系统IO函数"></a>Linux系统IO函数</h2><h3 id="帮助文档-Linux-man-2-open"><a href="#帮助文档-Linux-man-2-open" class="headerlink" title="帮助文档 ~Linux : man 2 open"></a>帮助文档 ~Linux : <code>man 2 open</code></h3><p>停留在函数上<code>Shif + k</code>可进行快速跳转</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为社么定义三个头文件：不同的宏定义在两个文件里</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏 flags = 标记(只读、可读、可读可写 ...)</span></span><br><span class="line"><span class="comment">// 打开一个已经存在的文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">- pathname : 要打开的文件路径</span><br><span class="line">- flags : 对文件的操作权限还有其的他设置</span><br><span class="line">           O_RDONLY (只读), O_WRONLY (只写), O_RDWR (可读可写) 这三个是互斥的</span><br><span class="line">    返回值：返回一个新的文件描述符，如果失败了返回 <span class="number">-1</span> ，否则返回一个整形文件描述符</span><br><span class="line">    errno：属于Linux系统函数库，库里的一个全局变量，记录的是最近的错误号。</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>; 作用：打印errno对应的错误描述</span><br><span class="line">            参数:用户描述，比如hello,最终点输出的内容是 hello:xxx(实际的错误描述)</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="comment">// 创建一个新的文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p><code>没有创建 a.txt 代码</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: open_test1.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年03月11日 星期五 22时30分53秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 读写操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  关闭一个文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>创建文件 touch a.txt</code> </p><p><code>设置umask</code> umask 022</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220312141638478.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220312141638478.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220312141638478"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: open_test1.c</span></span><br><span class="line"><span class="comment">        &gt; Author:</span></span><br><span class="line"><span class="comment">        &gt; Mail:</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年03月11日 星期五 22时30分53秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * int open(const char *pathname, int flags, mode_t mode);</span></span><br><span class="line"><span class="comment"> *  参数 :</span></span><br><span class="line"><span class="comment"> *      - pathname : 要创建的文件路径</span></span><br><span class="line"><span class="comment"> *      - flags : 对文件操作的权限和其他的设置</span></span><br><span class="line"><span class="comment"> *          - 必选项 : O_RDONLY, O_WDONLY, O_WEONLY 这三个互斥</span></span><br><span class="line"><span class="comment"> *          - 可选项 ：O_CREAT (文件不存在，创建新文件)</span></span><br><span class="line"><span class="comment"> *      - mode : 八进制的数, 表示创建出的新的文件的操纵权限, 例如：0775 (0开头表示 八进制)</span></span><br><span class="line"><span class="comment"> *      RWX(读、写、 可执行、三组 当前用户的权限、当前用户所在祖的权限、其他组) = 777</span></span><br><span class="line"><span class="comment"> *      最终的权限是 : mode &amp; ~umask(0002) // 不同用户不一样 这个值也能 更改</span></span><br><span class="line"><span class="comment"> *      八进制 -&gt; 二进制</span></span><br><span class="line"><span class="comment"> *      0777   -&gt; 111 111 111</span></span><br><span class="line"><span class="comment"> *  &amp;   0775   -&gt; 111 111 101</span></span><br><span class="line"><span class="comment"> *  --------------------------</span></span><br><span class="line"><span class="comment"> *                111 111 101</span></span><br><span class="line"><span class="comment"> *  按位与：0和任何数都为0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  umask : 作用就是抹去某些权限</span></span><br><span class="line"><span class="comment"> *  flags : 或的作用</span></span><br><span class="line"><span class="comment"> *      参数是一个int类型的数据,占4个字节32位。</span></span><br><span class="line"><span class="comment"> *      32个位，每一位就是一个标志位。</span></span><br><span class="line"><span class="comment"> *      1 - R</span></span><br><span class="line"><span class="comment"> *      2 - W</span></span><br><span class="line"><span class="comment"> *      3 - RW</span></span><br><span class="line"><span class="comment"> *      4 - CR</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;create.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/1.7%20%E6%96%87%E4%BB%B6IO_%E9%A1%B5%E9%9D%A2_06.jpg" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/1.7%20%E6%96%87%E4%BB%B6IO_%E9%A1%B5%E9%9D%A2_06.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1.7 文件IO_页面_06"></p><h3 id="帮助文档-man-2-copy"><a href="#帮助文档-man-2-copy" class="headerlink" title="帮助文档 : man 2 copy"></a>帮助文档 : <code>man 2 copy</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: copyfile.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年03月17日 星期四 20时48分17秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"> *  ssize_t read(int fd, void *buf, size_t count);</span></span><br><span class="line"><span class="comment"> *      参数:</span></span><br><span class="line"><span class="comment"> *          - fd: 文件描述符, open得到的,通过这个文件描述符操作某个文件</span></span><br><span class="line"><span class="comment"> *          - buf: 缓冲区读取数据存放的地方数组的地址 (传出参数)</span></span><br><span class="line"><span class="comment"> *          - count: 指定的数组大小</span></span><br><span class="line"><span class="comment"> *      返回值:</span></span><br><span class="line"><span class="comment"> *          - 成功:</span></span><br><span class="line"><span class="comment"> *              &gt; 0: 返回实际的读取到的字数</span></span><br><span class="line"><span class="comment"> *              = 0: 文件已经读取完</span></span><br><span class="line"><span class="comment"> *          - 失败: - 1, 并设置errno</span></span><br><span class="line"><span class="comment"> *  #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"> *  ssize_t write(int fd, const void *buf, size_t count);</span></span><br><span class="line"><span class="comment"> *      参数：</span></span><br><span class="line"><span class="comment"> *          - fd: 文件描述, open得到的,y通过这个</span></span><br><span class="line"><span class="comment"> *          - buf: 要往磁盘写入的数据</span></span><br><span class="line"><span class="comment"> *          - count: 要写的数据的实际大小</span></span><br><span class="line"><span class="comment"> *      返回值:</span></span><br><span class="line"><span class="comment"> *          成功: 实际写入的大小</span></span><br><span class="line"><span class="comment"> *          失败: 返回-1,并设置errno</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.通过open打开english.txt // 相对路径&quot;文件名.后缀&quot; // 绝对路径&quot;c:/xxx/xxx/文件名.后缀&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> srcfd = open(<span class="string">&quot;english.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(srcfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;opne&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.创建一个新的文件(拷贝文件)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> destfd = open(<span class="string">&quot;cpy.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(destfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.频繁的读写操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len = read(srcfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// destfd: 目标文件文件描述符</span></span><br><span class="line">        write(destfd, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.关闭文件</span></span><br><span class="line">    close(destfd);</span><br><span class="line">    close(srcfd) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="帮助文档-man-2-lseek"><a href="#帮助文档-man-2-lseek" class="headerlink" title="帮助文档 : man 2 lseek"></a>帮助文档 : <code>man 2 lseek</code></h3><p>Linux 的 lseek 在标准c库中 man 3 fseek</p><h4 id="为什么要扩展"><a href="#为什么要扩展" class="headerlink" title="为什么要扩展"></a>为什么要扩展</h4><p>比如说下载一个大小文件大小为5G(下载时候也正在用磁盘)假如磁盘大小么有5G(就不能正确下载下来)所以会提起占用一点点在替换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: lseek.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年03月20日 星期日 16时40分30秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  标准c库</span></span><br><span class="line"><span class="comment"> *  #inline &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment"> *  int fseek(FLE *stream, long offset, int whence);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Linux系统函数</span></span><br><span class="line"><span class="comment"> *  #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment"> *  #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"> *  oof_t lseek(int fd, oof_t offset, int whence);</span></span><br><span class="line"><span class="comment"> *      参数:</span></span><br><span class="line"><span class="comment"> *          - fd: 文件描述, 通过open得到的, 通过这个fd操作某个文件</span></span><br><span class="line"><span class="comment"> *          - offset: 偏移量</span></span><br><span class="line"><span class="comment"> *          - whence:</span></span><br><span class="line"><span class="comment"> *              SEEK_SET   The file offset is set to offset bytes.</span></span><br><span class="line"><span class="comment"> *                                      设置文件指针的偏移量</span></span><br><span class="line"><span class="comment"> *              SEEK_CUR   The file offset is set to its current location plus offset bytes.</span></span><br><span class="line"><span class="comment"> *                                      设置便宜量: 当前位置 + 第 二个参数 offset的值</span></span><br><span class="line"><span class="comment"> *              SEEK_END   The file offset is set to the size of the file                plus offset bytes.</span></span><br><span class="line"><span class="comment"> *                                      设置偏移量: 文件大小 + 第 二个参数offse的值</span></span><br><span class="line"><span class="comment"> *          返回值: 返回文件指针的位置</span></span><br><span class="line"><span class="comment"> *      作用:</span></span><br><span class="line"><span class="comment"> *          1.移动文件指针</span></span><br><span class="line"><span class="comment"> *      lseek(fd, 0, SEEL_SET);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      2.获取当前文件指针位置</span></span><br><span class="line"><span class="comment"> *      lseek(fd, 0, SEEK_CUR);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      3.可以获取文件长度</span></span><br><span class="line"><span class="comment"> *      lseek(fd, 0, SEEK_END);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      4.拓展文件的长度,当文件10b, 110b, 增加了100个字节</span></span><br><span class="line"><span class="comment"> *      lseek(fd, 100, SEEK_END);</span></span><br><span class="line"><span class="comment"> *// 注意：需要些一次数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展文件的长度</span></span><br><span class="line">    <span class="keyword">int</span> ret = lseek(fd, <span class="number">100</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入一个空格数据</span></span><br><span class="line">    write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="帮助文档-man-2-stat"><a href="#帮助文档-man-2-stat" class="headerlink" title="帮助文档 : man 2 stat"></a>帮助文档 : <code>man 2 stat</code></h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220324203138161.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220324203138161.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220324203138161"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220324214627428.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220324214627428.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220324214627428"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: stat.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年03月23日 星期三 16时29分33秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">        #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int stat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">                作用: 获取一个文件相关的一些信息</span></span><br><span class="line"><span class="comment">        参数;</span></span><br><span class="line"><span class="comment">            - pathname: 操作文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf: 结构体变量, 传出参数, 用于保存获取的文件信息</span></span><br><span class="line"><span class="comment">        返回值:</span></span><br><span class="line"><span class="comment">            成功: 返回0</span></span><br><span class="line"><span class="comment">            失败: 返回-1, 并设置errno</span></span><br><span class="line"><span class="comment">    int fstat(int fd, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">    int lstat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = stat(<span class="string">&quot;a.txt&quot;</span>, &amp;statbuf);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %ld\n&quot;</span>, statbuf.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟实现-ls-l-命令"><a href="#模拟实现-ls-l-命令" class="headerlink" title="模拟实现 ls -l 命令"></a>模拟实现 ls -l 命令</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220326140653270.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220326140653270.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><code>参考文档 man 3 getpwuid</code></p><p><code>参考文档 man 3 getgrgid</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: ls-l.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年03月26日 星期六 15时29分49秒</span></span><br><span class="line"><span class="comment"> -***********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟实现 ls -l 指令</span></span><br><span class="line"><span class="comment">// -rw-r--r-- 1 qz qz 11 3月  26 15:30 a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断输入的参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s filename\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过stat函数获取用户传入的文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = stat(argv[<span class="number">1</span>], &amp;st);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件类型和文件权限</span></span><br><span class="line">    <span class="keyword">char</span> *perms = (<span class="keyword">char</span> *)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">switch</span>(st.st_mode &amp; S_IFMT) &#123;</span><br><span class="line">        <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">            perms[<span class="number">0</span>] =<span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFREG:</span><br><span class="line">            perms[<span class="number">0</span>] =<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">            perms[<span class="number">0</span>] =<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFCHR:</span><br><span class="line">            perms[<span class="number">0</span>] =<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">            perms[<span class="number">0</span>] =<span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFIFO:</span><br><span class="line">            perms[<span class="number">0</span>] =<span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断文件的访问权限</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所有者</span></span><br><span class="line">    perms[<span class="number">1</span>] = (st.st_mode &amp; S_IRUSR) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">2</span>] = (st.st_mode &amp; S_IWUSR) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">3</span>] = (st.st_mode &amp; S_IXUSR) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所有组</span></span><br><span class="line">    perms[<span class="number">4</span>] = (st.st_mode &amp; S_IRGRP) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">5</span>] = (st.st_mode &amp; S_IWGRP) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">6</span>] = (st.st_mode &amp; S_IXGRP) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他人</span></span><br><span class="line">    perms[<span class="number">7</span>] = (st.st_mode &amp; S_IROTH) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">8</span>] = (st.st_mode &amp; S_IWOTH) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">9</span>] = (st.st_mode &amp; S_IXOTH) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 硬链接数</span></span><br><span class="line">    <span class="keyword">int</span> linkNum = st.st_nlink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所有者</span></span><br><span class="line">    <span class="keyword">char</span> *fileUser = getpwuid(st.st_uid)-&gt;pw_name;</span><br><span class="line">    <span class="comment">// 文件所在组</span></span><br><span class="line">    <span class="keyword">char</span> *fileGrp = getgrgid(st.st_gid)-&gt;gr_name;</span><br><span class="line">    <span class="comment">// 文件大小</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> fileSize = st.st_size;</span><br><span class="line">    <span class="comment">// 修改的时间 从 1970年 会自带一个换行</span></span><br><span class="line">    <span class="keyword">char</span> *time = ctime(&amp;st.st_mtime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> mtime[<span class="number">512</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strncpy</span>(mtime, time, <span class="built_in">strlen</span>(time) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s %d %s %s %ld %s %s&quot;</span>, perms, linkNum, fileUser, fileGrp, fileSize, mtime, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p><code>man 2 access</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: chmod.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年03月27日 星期日 11时21分04秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    int chmod(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        修改文件的权限</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname: 需要修改的文件路径</span></span><br><span class="line"><span class="comment">            - mode: 需要修改的权限值, 八进制的数</span></span><br><span class="line"><span class="comment">        返回: h成功返回0, 失败返回-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = chmod(<span class="string">&quot;a.txt&quot;</span>, <span class="number">0775</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;chmod&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><code>man 2 truncate</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: truncate.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年03月27日 星期日 17时35分17秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    int truncate(const char *path, off_t length);</span></span><br><span class="line"><span class="comment">        作用: 缩减或者扩展文件的尺寸至指定的大小</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - path: 需要修改的文件的k路径</span></span><br><span class="line"><span class="comment">            - length: 需要最终文件变成的大小</span></span><br><span class="line"><span class="comment">                如果 一个文件(10K) 想变成一个(5k)就会把后面截取掉</span></span><br><span class="line"><span class="comment">        返回: 成功0,失败-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = truncate(<span class="string">&quot;b.txt&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// int ret = truncate(&quot;b.txt&quot;, 5);</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;truncat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h2><p><code>man 2 mkdir</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: mkdir.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年03月28日 星期一 11时39分42秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    int mkdir(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        作用: 创建一个目录</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            pathname: 创建的目录的路径</span></span><br><span class="line"><span class="comment">            mode: 权限, 八进制</span></span><br><span class="line"><span class="comment">        返回:</span></span><br><span class="line"><span class="comment">            成功返回0, 失败返回-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 删除</span></span><br><span class="line"><span class="comment">    int rmdir(const char *pathname);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 更名 第一个参数旧的名字 第二个参数新的名字</span></span><br><span class="line"><span class="comment">    int rename(const char *oldpath, const char *newpath);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0777 0是八进制</span></span><br><span class="line">    <span class="comment">// 一定要有可执行权限 x 要不就永不了 你不信试试</span></span><br><span class="line">    <span class="keyword">int</span> ret = mkdir(<span class="string">&quot;aaa&quot;</span>, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>man 2 getcwd</code> 工作路径</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: getcwd.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年03月29日 星期二 09时27分16秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int chdir(const char *path);</span></span><br><span class="line"><span class="comment">        作用: 修改进程的工作目录</span></span><br><span class="line"><span class="comment">        比如在/home/root 启动了一个可执程序 a.out, 进程的工作目录</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            path: 需要修改的工作目录</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #nclude &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    char *getcwd(char *buf, size_t size);</span></span><br><span class="line"><span class="comment">        作用: 获取当前工作目录</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - buf: 存储的路径, 指向的是一个数组(传出参数)</span></span><br><span class="line"><span class="comment">            - size: 数组大小</span></span><br><span class="line"><span class="comment">        返回值:</span></span><br><span class="line"><span class="comment">            返回的指向的一块内存, 这个数据就是第一个参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前工作目录</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是 : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改工作目录 下面是相对路径 不是绝对路径</span></span><br><span class="line">    <span class="keyword">int</span> ret = chdir(<span class="string">&quot;../test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;w.txt&quot;</span>, O_CREAT| O_RDWR, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前工作目录</span></span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf1, <span class="keyword">sizeof</span>(buf1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是 : %s\n&quot;</span>, buf1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>man 3 opendir</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: readFileNum.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年03月30日 星期三 10时01分49秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 打开目录</span></span><br><span class="line"><span class="comment">    #nclude &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    DIR *opendir(const char *name);</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - name: 需要打开的目录名称</span></span><br><span class="line"><span class="comment">        返回值:</span></span><br><span class="line"><span class="comment">            DIR * 类型理解为目录流</span></span><br><span class="line"><span class="comment">            失败返回 NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 读取目录中的数据</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    struct diren *readdir(DIR *dirp);</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - dirp 是 opendir 返回的结果</span></span><br><span class="line"><span class="comment">        返回值:</span></span><br><span class="line"><span class="comment">            struct dirent 代表读取到的文件的信息</span></span><br><span class="line"><span class="comment">            读取到了末尾或者失败了, 返回NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 关闭目录</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    int closedir(DIR *dirp);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFileNum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取某个目录下的普通文件的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s path\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = getFileNum(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;普通文件的个数: %d \n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于获取目录下所有普通文件的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFileNum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开目录</span></span><br><span class="line">    DIR *dir = opendir(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录普通文件的个数</span></span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((ptr = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取名称</span></span><br><span class="line">        <span class="keyword">char</span> *dname = ptr-&gt;d_name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 忽略掉 .和 ..</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dname, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dname, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否是普通文件</span></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_DIR) &#123;</span><br><span class="line">            <span class="comment">// 目录, 需要继续读取这个目录</span></span><br><span class="line">            <span class="keyword">char</span> newpath[<span class="number">256</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(newpath, <span class="string">&quot;%s%s&quot;</span>, path, dname);</span><br><span class="line">            total += getFileNum(newpath);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG) &#123;</span><br><span class="line">            <span class="comment">// 普通文件</span></span><br><span class="line">            total++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭目录</span></span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dup，dup2函数"><a href="#dup，dup2函数" class="headerlink" title="dup，dup2函数"></a>dup，dup2函数</h2><p><code>man 2 dup</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: dup.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年03月30日 星期三 16时03分03秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"> *  int dup(int oldfd);</span></span><br><span class="line"><span class="comment"> *      作用: 复制一个新的文件描述符</span></span><br><span class="line"><span class="comment"> *      fd = 3, fd1 = dup(fd);</span></span><br><span class="line"><span class="comment"> *      fd指向的是a.txt, fd1也是指向的a.txt</span></span><br><span class="line"><span class="comment"> *      从空闲的文件描述符表中找到一个最小的, 作为新的拷贝的文件描述 符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个读写 第二创建</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = dup(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d \n fd1 : %d&quot;</span>, fd, fd1);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>man 2 dup2</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: dup2.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年03月31日 星期四 14时25分22秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"> *  int dup2(int oldfd, int newfd);</span></span><br><span class="line"><span class="comment"> *      作用: 重定向文件描述符</span></span><br><span class="line"><span class="comment"> *      oldfd 指向 a.txt, newfd 指向 b.txt</span></span><br><span class="line"><span class="comment"> *      调用函数成功后: newfd 和 b.txt 做 close(), newfd 指向了 a.txt</span></span><br><span class="line"><span class="comment"> *      oldfd 必须是一个有效的文件描述符</span></span><br><span class="line"><span class="comment"> *      oldfd 和 newfd 值相同相当于什么也没做</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d\n&quot;</span>, fd, fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd2 = dup2(fd, fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过fd1去写数据, 实际操作的是1.txt, 而不是2.txt</span></span><br><span class="line">    <span class="keyword">char</span> * str = <span class="string">&quot;hello, dup2&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> len = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d, fd2 : %d \n&quot;</span>, fd, fd1, fd2);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="man-2-fucnt"><a href="#man-2-fucnt" class="headerlink" title="man 2 fucnt"></a>man 2 fucnt</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: fcntl.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年03月31日 星期四 18时55分53秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"> *  #include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  int fcntl(int fd, int cmd, ...);</span></span><br><span class="line"><span class="comment"> *      参数:</span></span><br><span class="line"><span class="comment"> *          - fd: 表示需要操作的文件描述符</span></span><br><span class="line"><span class="comment"> *          - cmd: 表示文件描述符进行如何操作</span></span><br><span class="line"><span class="comment"> *              1. F_DUPFD: 复制文件描述符,复制的是一个参数fd,得到一个新的</span></span><br><span class="line"><span class="comment"> *                  int ret = fcntl(fd, F_DUPFD);</span></span><br><span class="line"><span class="comment"> *              2. F_GETFL: 获取指定的文件描述符文件状态flag</span></span><br><span class="line"><span class="comment"> *                  获取的flag和通过open函数传递的flag是一个东西</span></span><br><span class="line"><span class="comment"> *              3. F_SETFL: 设置文件描述符文件状态falg</span></span><br><span class="line"><span class="comment"> *                  必选项: O_RDONLY, O_WRODNLY, O_RDWR 不可以被修改</span></span><br><span class="line"><span class="comment"> *                  可选性: O_APPEND, O_NONBLOCK</span></span><br><span class="line"><span class="comment"> *                      O_APPEND: 表示追加数据</span></span><br><span class="line"><span class="comment"> *                      O_NONBLOCK: 设置成非阻塞</span></span><br><span class="line"><span class="comment"> *                          阻塞和非阻塞: 指的是函数调用的行为。add()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.复制文件描述符</span></span><br><span class="line">    <span class="comment">// int fd = open(&quot;1.txt&quot;, O_RDONLY);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int ret = fcntl(fd, F_DUPFD);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.修改或者获取文件状态flag --- 当前文件只读</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件描述符状态</span></span><br><span class="line">    <span class="keyword">int</span> flag = fcntl(fd,F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl_GET&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag |= O_APPEND;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改文件描述符状态的flag, 给flag加入O_APPEND这个标记</span></span><br><span class="line">    <span class="keyword">int</span> ret = fcntl(fd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl_SET&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    write(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LInux-系统编程入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LInux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim复制代码错位问题</title>
      <link href="2022/03/09/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E9%94%99%E4%BD%8D%E9%97%AE%E9%A2%98/"/>
      <url>2022/03/09/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E9%94%99%E4%BD%8D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Vim中复制粘贴缩进错乱问题的解决方"><a href="#Vim中复制粘贴缩进错乱问题的解决方" class="headerlink" title="Vim中复制粘贴缩进错乱问题的解决方"></a>Vim中复制粘贴缩进错乱问题的解决方</h2><p>Vim中复制粘贴缩进错乱问题的解决方案</p><p>当你把这段缩进优美的代码直接ctrl+c(ctrl+shift + c)，ctrl+v到Vim的时候，就会出现如下恶心的情况</p><p>可以看到，这种直接粘贴的方式会导致代码丢失和缩进错乱等情况。</p><p>解决方案<br>vim进入paste模式，命令如下：</p><p>:set paste</p><p>进入paste模式之后，再按i进入插入模式，进行复制、粘贴就很正常了。<br>命令模式下，输入</p><p>:set nopaste</p><p>解除paste模式。</p><p>paste模式主要帮我们做了如下事情：</p><p>textwidth设置为0<br>wrapmargin设置为0<br>set noai<br>set nosi<br>softtabstop设置为0<br>revins重置<br>ruler重置<br>showmatch重置<br>formatoptions使用空值</p>]]></content>
      
      
      <categories>
          
          <category> 有趣的知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GDB调试</title>
      <link href="2022/03/08/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/GDB%E8%B0%83%E8%AF%95/"/>
      <url>2022/03/08/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/GDB%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-GDB"><a href="#什么是-GDB" class="headerlink" title="什么是 GDB"></a>什么是 GDB</h2><ul><li>GDB是由 GNU软件系统社区提供的调试工具，同GCC 配套组成了一套完整的开发环境，GDB是 Linux和许多类Unix系统中的标准开发环境。</li><li>一般来说，GDB主要帮助你完成下面四个方向的功能：<ol><li>启动程序，可以按照自定义的要求随心所欲的运行程序</li><li>可让被调试的程序在指定的调置的断点处停住(断点可以是条件表达式)</li><li>当程序被停住时,可以检查此时程序中发生的事</li><li>可以改变程序，将一个BUG产生的影响修正从而测试其他 BUG</li></ol></li></ul><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.136.la%2F20210831%2F7c8b558d1335448d94e98fbcded9735f.jpg&refer=http%3A%2F%2Fimg.136.la&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1649325714&t=24e3d9033f770182f43dc2d420351992" class="lazyload" data-srcset="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.136.la%2F20210831%2F7c8b558d1335448d94e98fbcded9735f.jpg&refer=http%3A%2F%2Fimg.136.la&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1649325714&t=24e3d9033f770182f43dc2d420351992" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="GDB吉祥物"></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p>通常，在为调试而编译时，我们会关掉编译器的优化选项（’-o’) ，并打开调试选项(‘-g’)。另外， ‘-Wall’在尽量不影响程序行为的情况下选项打开所有warning(警告)，也可以发现许多问题，避免一些不必要的 BUG。</p></li><li><p>gcc -g -Wall program.c -o program</p></li><li><p>‘g’ 选项的作用是在执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，可以在调试时必须保证 gdb 能找打源文件</p></li><li><p>-w 的意思是关闭编译时的警告，也就是编译后不显示任何warning，因为有时在编译之后<a href="https://so.csdn.net/so/search?q=%E7%BC%96%E8%AF%91%E5%99%A8&spm=1001.2101.3001.7020">编译器</a>会显示一些例如数据转换之类的警告，这些警告是我们平时可以忽略的。</p></li><li><p>-Wall选项意思是编译后显示所有警告。</p></li><li><p>-W选项类似-Wall，会显示警告，但是只显示编译器认为会出现错误的警告。</p><p>在编译一些项目的时候可以-W和-Wall选项一起使用。</p></li></ul><h2 id="GDB命令-启动、退出、查看代码"><a href="#GDB命令-启动、退出、查看代码" class="headerlink" title="GDB命令-启动、退出、查看代码"></a>GDB命令-启动、退出、查看代码</h2><ul><li><p>启动和退出</p><p>gdb 可执行程序</p><p>quit</p></li><li><p>给程序设置参数&#x2F;获取设置参数</p><p>set args 10 20</p><p>show args</p></li><li><p>GDB 使用帮助</p><p>help</p></li><li><p>查看当前文件代码 (回车继续执行上一行命令)</p><p>list&#x2F;l (从默认位置显示) </p><p>list&#x2F;l 行号 (从指定的行显示)</p><p>list&#x2F;l 函数名 (从指定的函数显示)</p></li><li><p>查看非当前文件文件</p><p>list&#x2F;l 文件名：行号</p><p>list&#x2F;l 文件名：函数名</p></li><li><p>设置显示行数</p><p>show list&#x2F;listsize</p><p>set list&#x2F;listsize 行数</p></li></ul><h3 id="gdb-调试代码"><a href="#gdb-调试代码" class="headerlink" title="gdb 调试代码"></a>gdb 调试代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: gdb_test1.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年03月09日 星期三 10时19分28秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./test1 10 20 // 传递参数就会给main里面</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>, argc);</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">        b = <span class="number">30</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">        b = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d \n&quot;</span>, a + b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">int</span> res = test(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;res value : %d \n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;THE END !!! \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vim 下 set nu</p><p><code> gcc test1.c -o test1 -g</code> 加上调试信息 &#x2F;&#x2F; 源代码文件要要和可执行程序在一起否则 gdb 中命令不可使用</p><p><code> gcc test1.c -o test2</code> 不加调试信息</p><p>可以 ll 对比一下两个文件大小</p><p>ssh命令 gdb 可执行程序(test1)</p><p>进入到gdb模式</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220309144955993.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220309144955993.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220309144955993"></p><p>GDB调试中设置参数 ：set args 10 20 </p><p>GDB 获取设置参数 ： show args</p><p>可以看上面 <a href="#GDB%E5%91%BD%E4%BB%A4-%E5%90%AF%E5%8A%A8%E3%80%81%E9%80%80%E5%87%BA%E3%80%81%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81">点我跳转</a></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220309145453276.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220309145453276.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220309145453276"></p><h3 id="调试多个文件"><a href="#调试多个文件" class="headerlink" title="调试多个文件"></a>调试多个文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c a.c b.c -o main -g</span><br><span class="line">gdb main</span><br><span class="line">&#x2F;&#x2F; 查看其中一个文件</span><br><span class="line">&#x2F;&#x2F; 注意不能是一个文件例如 list mian.c</span><br><span class="line">l  a.c:1 &#x2F;&#x2F; 就会进入 a.c 的第一行 以行号为中心显示</span><br><span class="line">or</span><br><span class="line">l  a.c:函数名 &#x2F;&#x2F; 就会进入 a.c 的第函数为中心显示</span><br></pre></td></tr></table></figure><h2 id="GDB命令-断电操作"><a href="#GDB命令-断电操作" class="headerlink" title="GDB命令-断电操作"></a>GDB命令-断电操作</h2><ul><li><p>设置断点</p><p>b&#x2F;break 行号</p><p>b&#x2F;break 函数名</p><p>b&#x2F;break 文件名：行号</p><p>b&#x2F;break 文件名: 函数</p></li><li><p>查看断点</p><p>i&#x2F;info b&#x2F;break</p></li><li><p>删除断点</p><p>d&#x2F;del&#x2F;delete 断点编号</p></li><li><p>设置断点无效</p><p>dis&#x2F;disable 断点编号</p></li><li><p>设置断点生效</p><p>ena&#x2F;enable 断电编号</p></li><li><p>设置条件断点(一般在循环的位置)</p><p>b&#x2F;break 10 if i &#x3D;&#x3D; 5</p></li></ul><h3 id="断点设置"><a href="#断点设置" class="headerlink" title="断点设置"></a>断点设置</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220310095912836.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220310095912836.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220310095912836"></p><p><code>断点编号</code>：Num 下面数字(断电编号)</p><p><code>设置断点无效</code> End &#x3D; n 正常是 y 想要断点再次生效 </p><p><code>设置断点生效</code> (命令)end&#x2F;enable 断电编号</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220310101526835.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220310101526835.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220310101526835"></p><h2 id="GDB命令-调试命令"><a href="#GDB命令-调试命令" class="headerlink" title="GDB命令-调试命令"></a>GDB命令-调试命令</h2><ul><li><p>运行GDB程序</p><p>start (程序停在第一行)</p><p>run (遇到断点才停)</p></li><li><p>继续运行，到下一个断点停</p><p>c&#x2F;continue </p></li><li><p>向下执行一行代码 (不会进入函数体)</p><p>n&#x2F;next</p></li><li><p>变量操作</p><p>p&#x2F;print 变量名 (打印变量值)</p><p>ptype 变量名 (打印变量类型)</p></li><li><p>向下单步调试 (遇到函数进入函数体)</p><p>s&#x2F;step</p><p>finish (跳出函数体)</p></li><li><p>自动变量操作</p><p>display num (自动打印指定变量的值)</p><p>i&#x2F;info display</p><p>undisplay 编号</p></li><li><p>其他操作</p><p>set var 变量名 &#x3D; 变量值</p><p>until (跳出循环)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LInux-系统编程入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LInux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile</title>
      <link href="2022/03/04/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/Makefile/"/>
      <url>2022/03/04/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/Makefile/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Makefile"><a href="#什么是Makefile" class="headerlink" title="什么是Makefile"></a>什么是Makefile</h2><ul><li>一个工程中的源文件不计其数．其按类型、功能、模块分别放在若干个目录中，Makefile文件定义了一系列的规则来指定哪些文件要生编扁i译.哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 Makefile文件就像一个Shell 脚本一样,也可以执行操作系统的命</li><li>Makefile带来的好处就是“自动化编译”，一旦写好只需要一个make命令，整个工程完全自动编译．极大的提高了软件开发的效率。make 是一个命令工具，是一个解释Makefile文件中指令的命令工具，一般来说，大多数的IDE都有这个命令.比如Delphi 的 make，Visual C++的nmake,Linux 下GNU的make。</li></ul><h2 id="Makefile文件命名和规则"><a href="#Makefile文件命名和规则" class="headerlink" title="Makefile文件命名和规则"></a>Makefile文件命名和规则</h2><ul><li><p>文件命名</p><p>makefile 或者 Makefile</p></li><li><p>Makefile 规则</p><ul><li><p>一个Makefile文件中可以有一个或者多个规则</p><p>目标 …:依赖 … (… 表示多个依赖)</p><p>​(Tab)命令(Shell 命令)</p><p>​…</p><ul><li>目标 : 最终要生成的文件(伪目标除外)</li><li>依赖 ：生成目标所需要的文件或者是目标</li><li>命令 ：通过执行命令对依赖操作生成目标(命令前必须 Tab 缩进)</li></ul></li></ul></li></ul><h2 id="make安装"><a href="#make安装" class="headerlink" title="make安装"></a>make安装</h2><p><code>sudo apt install make</code></p><h2 id="make-使用-第一版-Makefile"><a href="#make-使用-第一版-Makefile" class="headerlink" title="make 使用 - 第一版 Makefile"></a>make 使用 - 第一版 Makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app:sub.c add.c mult.c div.c main.c</span></span><br><span class="line">gcc sub.c mult.c div.c main.c -o app</span><br></pre></td></tr></table></figure><p><code>sub.c</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mult.c</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>div.c</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)a/b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.c</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>, add(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a - b = %d\n&quot;</span>, subtract(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a * b = %d\n&quot;</span>, multiply(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a / b = %f\n&quot;</span>, divide(a, b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>head.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HEAD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HEAD_H</span></span><br><span class="line"><span class="comment">// 加法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 减法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 乘法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 除法</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ul><li>命令在执行前，需要检查规则中的依赖是否u才能在<ul><li>如果存在，执行命令</li><li>如果不存在，向下检查其它命令规则，检查有没有一个规则用来生成这个依赖的，如果找到则执行该规则中的命令</li></ul></li><li>检测更新，在执行规则的命令时，会比较目标和依赖的文件的时间(直接输入 make)<ul><li>如果依赖的时间比目标时间晚，需要重新生成目标</li><li>如果依赖的时间比目标时间早，目标不需要更新，对应规则中的命令不需要执行</li></ul></li></ul><h2 id="第二版-Makefile"><a href="#第二版-Makefile" class="headerlink" title="第二版 Makefile"></a>第二版 Makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app:sub.o add.o mult.o div.o main.o</span></span><br><span class="line">gcc sub.o mult.o div.o main.o -o app</span><br><span class="line"><span class="section">usb.o:sub.c</span></span><br><span class="line">gcc -c sub.c -o sub.o</span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">gcc -c add.c -o add.o</span><br><span class="line"><span class="section">mult.o:mult.c</span></span><br><span class="line">gcc -c mult.c -o mult.o</span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">gcc -c div.c -o div.o</span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">gcc -c main.c -o main.o</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li><p>自定义变量</p><p>变量名 &#x3D; 变量值 var &#x3D; hello  $(var)</p></li><li><p>预定义变量</p><p>AR : 归档维护程序的名称，默认值 ar</p><p>CC ： C 编译器的名称，默认值为 cc</p><p>CXX : C++ 编译器的名称。默认值为 g++</p><p>$@ : 目标的完整名称</p><p>$&lt; : 第一个依赖文件名称</p><p>$^ : 所有依赖文件</p></li></ul><ul><li><p>获取变量的值</p><p>$(变量名)</p></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app:main.c a.c b.c </span></span><br><span class="line">gcc -c main.c a.c b.c</span><br><span class="line"><span class="comment">#自动变量只能在规则的命令中使用 目标就是(app)</span></span><br><span class="line"><span class="variable">$(cc)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h2 id="第三版-Makefile"><a href="#第三版-Makefile" class="headerlink" title="第三版 Makefile"></a>第三版 Makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line">src = sub.o add.o mult.o div.o main.o</span><br><span class="line">target = app</span><br><span class="line"></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(src)</span></span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$(src)</span> -o <span class="variable">$(target)</span></span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">        gcc -c sub.c -o sub.o</span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">        gcc -c add.c -o add.o</span><br><span class="line"><span class="section">mult.o:mult.c</span></span><br><span class="line">        gcc -c mult.c -o mult.o</span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">        gcc -c div.c -o div.o</span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">        gcc -c main.c -o main.o</span><br></pre></td></tr></table></figure><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %.o:%.c</span></span><br><span class="line"><span class="comment">#- %:通配符，匹配一个字符</span></span><br><span class="line"><span class="comment">#- 两个%匹配的是同一个字符串</span></span><br><span class="line"><span class="comment"># %.o:%.c</span></span><br><span class="line"><span class="comment"># gcc -c %&lt; -o $@</span></span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">        gcc -c sub.c -o sub.o</span><br></pre></td></tr></table></figure><p><a href="#%E5%8F%98%E9%87%8F">%&lt;啥意思请点我</a></p><h2 id="第四版-Makefile"><a href="#第四版-Makefile" class="headerlink" title="第四版 Makefile"></a><strong>第四版 Makefile</strong></h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line">src = sub.o add.o mult.o div.o main.o</span><br><span class="line">target = app</span><br><span class="line"></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(src)</span></span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$(src)</span> -o <span class="variable">$(target)</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>$(wildcard PATTERN…)</p><ul><li><p>功能:获取指定目录下指定类型的文件列表</p></li><li><p>参数：PATTERN指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔</p></li><li><p>返回：得到的若干个文件的文件列表，文件之间使用空格间隔</p></li><li><p>示例</p><p><code>$(wildcard *.c ./sub/*.c)</code>(第一个*.获取当前目录下的所有.c文件 第二个是.&#x2F;sub 下的所有文件 多个目录可以用空格隔开)</p><p>返回值格式：a.c b.c c.c d.c f.c</p></li></ul></li><li><p>$(patsubst &lt;pattern&gt;, &lt;replacement&gt;, &lt;text&gt;) </p></li><li><p>功能：查找&lt;text&gt;中的单词（单词以”空格”、”Tab”或”回车””换行”分割）是否符合模式&lt;pattern&gt;,如果匹配的话，则可以&lt;replacemnt&gt;替换。</p><ul><li><p>&lt;sattern&gt;可以包括通配符<code>$</code>,表示任意长度的字串。如果&lt;replacement&gt;中包含<code>$</code>,那么，&lt;replacemnt&gt;中的这个<code>$</code>将是&lt;pattern&gt;中的那个$所代表的字串。(可以用’\‘来转义，以’\%’来表示真实含义的’%’字符)</p></li><li><p>返回：函数返回被替换过的字符串</p></li><li><p>示例：</p><p>$(patsubst %.c, %.o, x.c bar.c)</p><p>返回值格式：x.o bar.o</p></li></ul></li></ul><h2 id="第五版-Makefile"><a href="#第五版-Makefile" class="headerlink" title="第五版 Makefile"></a>第五版 Makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">objs = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line">target = app</span><br><span class="line"></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(objs)</span></span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$(objs)</span> -o <span class="variable">$(target)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h2 id="第五版-Makefile-1"><a href="#第五版-Makefile-1" class="headerlink" title="第五版 Makefile"></a>第五版 Makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">objs = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line">target = app</span><br><span class="line"></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(objs)</span></span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$(objs)</span> -o <span class="variable">$(target)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h2 id="第六版-Makefile"><a href="#第六版-Makefile" class="headerlink" title="第六版 Makefile"></a>第六版 Makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line"><span class="comment"># 可以单独直行一段 make clean</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">objs = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line">target = app</span><br><span class="line"></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(objs)</span></span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$(objs)</span> -o <span class="variable">$(target)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 因为clean没有依赖可以设置一个尾目标</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean  </span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm <span class="variable">$(objs)</span> -f</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LInux-系统编程入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LInux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sscanf/spintf妙用</title>
      <link href="2022/02/25/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/sscanf-spintf%E5%A6%99%E7%94%A8/"/>
      <url>2022/02/25/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/sscanf-spintf%E5%A6%99%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="leetcode-力扣-537"><a href="#leetcode-力扣-537" class="headerlink" title="leetcode-力扣(537)"></a>leetcode-力扣(537)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1,b1,a2,b2;</span><br><span class="line"><span class="built_in">sscanf</span>(num1,<span class="string">&quot;%d+%di&quot;</span>,&amp;a1,&amp;b1);</span><br><span class="line"><span class="built_in">sscanf</span>(num2,<span class="string">&quot;%d+%di&quot;</span>,&amp;a2,&amp;b2);</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">sscanf</span>(s.c_str(), <span class="string">&quot;%d:%d&quot;</span>, );</span><br><span class="line">   <span class="comment">//读取实部和虚部  </span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span>* ans=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">13</span>);</span><br><span class="line">   <span class="built_in">sprintf</span>(ans,<span class="string">&quot;%d+%di&quot;</span>,a1*a2-b1*b2,a1*b2+a2*b1);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 有趣的知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gcc/g++区别与流程</title>
      <link href="2022/02/20/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/gcc-g-%E5%8C%BA%E5%88%AB%E4%B8%8E%E6%B5%81%E7%A8%8B/"/>
      <url>2022/02/20/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/gcc-g-%E5%8C%BA%E5%88%AB%E4%B8%8E%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="gcc-x2F-G"><a href="#gcc-x2F-G" class="headerlink" title="gcc&#x2F;G++"></a>gcc&#x2F;G++</h1><h2 id="gcc工作流程"><a href="#gcc工作流程" class="headerlink" title="gcc工作流程"></a>gcc工作流程</h2><p>源代码(.h, .c, .cpp) - &gt; 预处理器 - &gt; 预处理后源代码 (.i) - &gt; 编译器 - &gt; 汇编代码（.s) - &gt; 汇编器 - &gt; 目标代码（.o)</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211106191714371.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211106191714371.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211106191714371"></p><h3 id="处理指令"><a href="#处理指令" class="headerlink" title="处理指令"></a>处理指令</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211106191826228.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211106191826228.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211106191826228"></p><h2 id="gcc-x2F-g-的区别"><a href="#gcc-x2F-g-的区别" class="headerlink" title="gcc&#x2F;g++的区别"></a>gcc&#x2F;g++的区别</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211106194451805.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211106194451805.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211106194451805"></p><h2 id="D-宏的名字"><a href="#D-宏的名字" class="headerlink" title="-D 宏的名字"></a>-D 宏的名字</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211106201242622.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211106201242622.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211106201242622"></p>]]></content>
      
      
      <categories>
          
          <category> LInux-系统编程入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LInux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维矩阵映射成一维</title>
      <link href="2022/02/16/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E6%98%A0%E5%B0%84%E6%88%90%E4%B8%80%E7%BB%B4/"/>
      <url>2022/02/16/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E6%98%A0%E5%B0%84%E6%88%90%E4%B8%80%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="二维数组映射成一维-0，0-开始"><a href="#二维数组映射成一维-0，0-开始" class="headerlink" title="二维数组映射成一维 - (0，0)开始"></a>二维数组映射成一维 - (0，0)开始</h2><p> 设<code>一维数组</code>下标为index,二维长度为$n*m$则</p><p>一维数组转为<code>二维数组</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">row = index / m <span class="comment">// 行</span></span><br><span class="line">col = index % m <span class="comment">// 列  </span></span><br></pre></td></tr></table></figure><p>二维数组转换为一维数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = row * m + col </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 有趣的知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并查集 — 2</title>
      <link href="2022/01/23/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86_2/"/>
      <url>2022/01/23/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86_2/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="并查集-Union-Find"><a href="#并查集-Union-Find" class="headerlink" title="并查集(Union Find)"></a>并查集(Union Find)</h1><p>并查集主要讲的就是连通性问题</p><p>比如说现在咱们这个教学楼，被大水淹了比如说一楼和其它楼层都被大水淹了，就唯独咱们教室没有，可以说明什么，咱们现在就是与世隔绝了，之后呢就被大水淹没的个个楼层水是不是都可以来回走，比如流到了咱们教室恰巧关上了们，之后水就没流进来，说明什么咱们现在是与这个教学楼的一间教室都不连图，如果说咱们与隔壁是连通的，而且咱们隔壁还被大水淹没了，你说咱们这屋是不是也被淹没了。</p><p>若某个家族人员过于庞大，要判断两个是否是亲戚，确实不容易，给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。</p><h2 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h2><p>在春秋战国时期有各种思想学术流派的成就，有 孔子 墨子 老子 还有谁比如 韩非子等等</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="树形结构"></p><p>从我们当前图中我门可以看出我们有几个连同块 有3个对把</p><p>比如说有一天 2 号 跟 4号 打起来来了说你写的东西不如我，（这里有个规定就是说徒弟一定不如师傅）完了4号本身就是1号的徒弟肯定不如2号 当然 4号有师傅 之后4号找到自己的师傅 1 号 说今天我被人羞辱了对吧那当师傅的肯定不能做事不管对吧 之后一看 说这2号也老孔的徒弟一看这不是就是一个师傅么那就别报仇了 让 4 号 给 2 号认个错 </p><p>就是下次的时候我们可以怎么看  就是先知道自己的师傅的师傅是谁对吧  在看你要找的人的师傅的师傅（这师傅可能还有师傅所有要找到最后一个师傅）是谁 如果他们最后的师傅都是同一个人那他们是不是就是一家人属于同一个师傅 <strong>（可以说明他们在通一课树中说明它们俩个连同）</strong></p><p>其实我们在连同性中不在乎连接成什么样子谁是谁的徒弟我只在乎他们能不能连同最后的祖师，祖师爷是不是同一个人 这个两个点能不能连同</p><p><strong>Ps 比如 （1， 2） 为一个集合</strong></p><h2 id="数组表示"><a href="#数组表示" class="headerlink" title="数组表示"></a>数组表示</h2><blockquote><p>（1，4）</p><p>（4，7）</p></blockquote><p>这里代表两个集合链接，这里链接的时候你说是 1 当作根节点还是 4 当作根节点 1 其实是无所谓的。这里假定 4为根节点我们可以得到 图</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E9%9B%86%E5%90%88.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E9%9B%86%E5%90%88.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="集合"></p><p>这两个点的连同不仅仅是两个点的连同而是两个集合的连通（<strong>其实他们都属一个个体</strong>）</p><p>比如你的爸和你妈是两个姓对吧 他们在没结婚之前是什么，两个家的人就可以比作什么两个集合，之后他们结婚了 是只有他俩是一家人么 不是吧 是两家人，这就好比我们两个点的链接。</p><p>我们可以用数组表示</p><p><strong>初始化</strong>把每个点所在的集合初始化为其自身。</p><p><strong>初始化</strong>加粗 为下标 我们可以用用它自身去初始化（也可以用 -1 但是后期在优化的时候会有点麻烦）</p><table><thead><tr><th><strong>0</strong></th><th><strong>1</strong></th><th><strong>2</strong></th><th><strong>3</strong></th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td></tr><tr><td><strong>4</strong></td><td><strong>5</strong></td><td><strong>6</strong></td><td><strong>7</strong></td></tr><tr><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><table><thead><tr><th><strong>0</strong></th><th><strong>1</strong></th><th><strong>2</strong></th><th><strong>3</strong></th></tr></thead><tbody><tr><td>0</td><td><font color='red'>4</font></td><td>2</td><td>3</td></tr><tr><td><strong>4</strong></td><td><strong>5</strong></td><td><strong>6</strong></td><td><strong>7</strong></td></tr><tr><td>4</td><td>5</td><td>6</td><td><font color='red'>4</font></td></tr></tbody></table><h2 id="竞赛阶段我们会用到的算法-find-union"><a href="#竞赛阶段我们会用到的算法-find-union" class="headerlink" title="竞赛阶段我们会用到的算法 find union"></a>竞赛阶段我们会用到的算法 find union</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 朴素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找--优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">        parent[x] = find_root(parent[x], parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">    <span class="comment">// return x == parent[x] ? x : parent[x] = find_root(parent[x], parent);</span></span><br><span class="line">    <span class="comment">// return parent[x] = (x == parent[x] ? x : find_root(parent[x], parent));</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> parent[], <span class="keyword">int</span> height[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x_root = find_root(x, parent);</span><br><span class="line">    <span class="keyword">int</span> y_root = find_root(y, parent);</span><br><span class="line">    <span class="keyword">if</span> (x_root != y_root) &#123;</span><br><span class="line">        <span class="comment">// parent[x_root] = y_root; // 原先代码</span></span><br><span class="line">        <span class="comment">// 安秩合并</span></span><br><span class="line">        <span class="keyword">if</span> (height[x_root] == height[y_root]) &#123;</span><br><span class="line">            parent[x_root] = y_root;</span><br><span class="line">            <span class="comment">// 相等让y的树高 +1</span></span><br><span class="line">            height[y_root]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (height[x_root] &gt; height[y_root]) &#123;</span><br><span class="line">            parent[y_root] = x_root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[x_root] = y_root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径压缩–按秩合并"><a href="#路径压缩–按秩合并" class="headerlink" title="路径压缩–按秩合并"></a>路径压缩–按秩合并</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mark = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inital</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> parent[], <span class="keyword">int</span> height[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        height[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">        parent[x] = find_root(parent[x], parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径压缩--非递归版</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = x;</span><br><span class="line">    <span class="keyword">while</span> (parent[k] != k) &#123;</span><br><span class="line">        k = parent[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (x != k) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = parent[x];</span><br><span class="line">        parent[x] = k;</span><br><span class="line">        x = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> parent[], <span class="keyword">int</span> height[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x_root = find_root(x, parent);</span><br><span class="line">    <span class="keyword">int</span> y_root = find_root(y, parent);</span><br><span class="line">    <span class="keyword">if</span> (x_root != y_root) &#123;</span><br><span class="line">        <span class="comment">// parent[x_root] = y_root; // 原先代码</span></span><br><span class="line">        <span class="comment">// 按秩合并</span></span><br><span class="line">        <span class="keyword">if</span> (height[x_root] == height[y_root]) &#123;</span><br><span class="line">            parent[x_root] = y_root;</span><br><span class="line">            <span class="comment">// 相等让y的树高 +1</span></span><br><span class="line">            height[y_root]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (height[x_root] &gt; height[y_root]) &#123;</span><br><span class="line">            parent[y_root] = x_root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[x_root] = y_root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, parent[MAX_N + <span class="number">10</span>], height[MAX_N + <span class="number">10</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    inital(m, parent, height);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        merge(x, y, parent, height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mark) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有环！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无环！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径压缩是怎么实现的</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="路径压缩"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9_%E4%BC%98%E5%8C%96.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9_%E4%BC%98%E5%8C%96.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="路径压缩_优化"></p><h2 id="检测是否存在环"><a href="#检测是否存在环" class="headerlink" title="检测是否存在环"></a>检测是否存在环</h2><p>我们如何去检测一个图是否存在环环路 如下</p><p>我们有 0️⃣ 1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 把每个点看成单个集合比如我们相连（0 ，1） （1，2） （1，3）（2，4）<font color='red'>（2，3）</font></p><p>我们在合并时候需要先查询一下他们是否属于同一集合，如果不属于同一集合我才能合并，反之要是它们在合并就会构成回路。</p><p>如果不考虑链接红色两点，合并集合之后是{0，1，2，3，4} 我们可以得到站在任意点到达另一任意点。<code>不构成环</code></p><p>如果说我们在已连接中任意选择两个去链接他一定会成环对吧。🔶</p><p>比如红色两点链接，我们可以看到 1， 2， 3 点形成了环。 <code>形成环路</code></p><p>我们怎么知道他是成环了呢我们把 1 当做根结点 ，0， 2，4，3 都属于 1 的孩子或者是孙子 当你去链接 （2， 3）时候你会发现他们都属于 1 下就如我们刚才所说 🔶因为我们知道两个集合在合并的时候一定会先去找根节点。</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E7%8E%AF.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E7%8E%AF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="环"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mark = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> parent[MAX_N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inital</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">        parent[x] = find_root(parent[x], parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x_root = find_root(x, parent);</span><br><span class="line">    <span class="keyword">int</span> y_root = find_root(y, parent);</span><br><span class="line">    <span class="keyword">if</span> (x_root != y_root) &#123;</span><br><span class="line">        parent[x_root] = y_root;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="comment">// 组数 最大值</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    inital(m, parent);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        merge(x, y, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mark) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有环！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无环！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集–数据结构实现"><a href="#并查集–数据结构实现" class="headerlink" title="并查集–数据结构实现"></a>并查集–数据结构实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionSet</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function">UnionSet *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    UnionSet *U = (UnionSet *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(UnionSet));</span><br><span class="line">    U-&gt;parent = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        U-&gt;parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> U;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(UnionSet *U, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (U-&gt;parent[x] != x) &#123;</span><br><span class="line">        <span class="keyword">return</span> find_root(U, U-&gt;parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(UnionSet *U, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x_root = find_root(U, x);</span><br><span class="line">    <span class="keyword">int</span> y_root = find_root(U, y);</span><br><span class="line">    <span class="keyword">if</span> (x_root != y_root) &#123;</span><br><span class="line">        U-&gt;parent[x_root] = y_root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    UnionSet *U = init(n);</span><br><span class="line">    <span class="comment">// 进行 M 次操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: merge(U, b, c); <span class="keyword">break</span>; <span class="comment">// 合并操作</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, find_root(U, b) == find_root(U, c) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题–题解"><a href="#例题–题解" class="headerlink" title="例题–题解"></a>例题–题解</h2><h3 id="海贼-71-朋友圈"><a href="#海贼-71-朋友圈" class="headerlink" title="海贼 #71 朋友圈"></a><a href="http://oj.haizeix.com/problem/71">海贼 #71 朋友圈</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: 海贼_#71并查集_路径压缩优化.cpp</span></span><br><span class="line"><span class="comment">&gt; Author: </span></span><br><span class="line"><span class="comment">&gt; Mail: </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2021年01月18日 星期一 15时33分00秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialization</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;  i &lt;= n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">        parent[x] = find_root(parent[x], parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 朴素算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x_root = find_root(x, parent);</span><br><span class="line">    <span class="keyword">int</span> y_root = find_root(y, parent);</span><br><span class="line">    <span class="keyword">if</span> (x_root != y_root) &#123;</span><br><span class="line">        parent[x_root] = y_root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, parent[MAX_N + <span class="number">10</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    initialization(n, parent);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加</span></span><br><span class="line">            merge(b, c, parent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 查看</span></span><br><span class="line">            <span class="keyword">if</span> (find_root(b, parent) - find_root(c, parent)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: 海贼_#71并查集_路径压缩_安秩合并_优化.cpp</span></span><br><span class="line"><span class="comment">&gt; Author: </span></span><br><span class="line"><span class="comment">&gt; Mail: </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2021年01月18日 星期一 21时33分00秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialization</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> parent[], <span class="keyword">int</span> height[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;  i &lt;= n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        <span class="comment">// 开始树高为 0</span></span><br><span class="line">        height[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">        parent[x] = find_root(parent[x], parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 朴素算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> parent[], <span class="keyword">int</span> height[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x_root = find_root(x, parent);</span><br><span class="line">    <span class="keyword">int</span> y_root = find_root(y, parent);</span><br><span class="line">    <span class="keyword">if</span> (x_root != y_root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[x_root] == height[y_root]) &#123;</span><br><span class="line">            parent[x_root] = y_root;</span><br><span class="line">            <span class="comment">// 相等让y的树高 +1</span></span><br><span class="line">            height[y_root]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (height[x_root] &gt; height[y_root]) &#123;</span><br><span class="line">            parent[y_root] = x_root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[x_root] = y_root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, parent[MAX_N + <span class="number">10</span>], height[MAX_N + <span class="number">10</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    initialization(n, parent, height);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加</span></span><br><span class="line">            merge(b, c, parent, height);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 查看</span></span><br><span class="line">            <span class="keyword">if</span> (find_root(b, parent) - find_root(c, parent)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="洛谷-P1551-亲戚"><a href="#洛谷-P1551-亲戚" class="headerlink" title="洛谷 P1551 亲戚"></a><a href="https://www.luogu.com.cn/problem/P1551">洛谷 P1551 亲戚</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">int</span> arr[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[x] != x) &#123;</span><br><span class="line">        x = find(arr[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x_root = find(x);</span><br><span class="line">    <span class="keyword">int</span> y_root = find(y);</span><br><span class="line">    <span class="keyword">if</span> (x_root != y_root) &#123;</span><br><span class="line">        arr[x_root] = y_root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, p;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    initial(n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi, mj;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; mi &gt;&gt; mj;</span><br><span class="line">        merge(mi, mj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p--) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi, mj;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; mi &gt;&gt; mj;</span><br><span class="line">        <span class="keyword">if</span> (find(mi) == find(mj)) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并查集 — 1</title>
      <link href="2022/01/23/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86_1/"/>
      <url>2022/01/23/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86_1/</url>
      
        <content type="html"><![CDATA[<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="连通性问题："><a href="#连通性问题：" class="headerlink" title="连通性问题："></a>连通性问题：</h3><ol><li>基于染色的思想，一开始所有点的颜色不同</li><li>连接两个点的操作，可以看成将一种颜色的点染成另一种颜色</li><li>如果两个点颜色一样，证明联通，否则不联通</li><li>这种方法叫做并查集的:【Quick-Find算法】</li></ol><p><code>Quick-Find 近似</code>$ O(1) $<code>查询</code></p><h3 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick-Find"></a>Quick-Find</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123164159689.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123164159689.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220123164159689"></p><p>默认的做法吧<code>前</code>一个数字的颜色改成<code>后</code>一个颜色(大白话：就是让4接到3后面，让3作为根节点)</p><p><code>这里要说明一下 ： 无论以 4 还是以 3 作为根节点都是可以的这个不重要 - 节点的链接其实是两个集合的链接</code></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123183439879.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123183439879.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220123183439879"></p><p>4 和 8 链接是直接吧4接到8下面么？(其实不对)</p><p>相当于 4 和 3已经属于一个集合那么你要改4当然3也要改变所以3和4的下标都要改成8</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123183500081.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123183500081.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220123183500081"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123183511187.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123183511187.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220123183511187"></p><h3 id="Quick-Find-时间复杂度分析"><a href="#Quick-Find-时间复杂度分析" class="headerlink" title="Quick-Find 时间复杂度分析"></a>Quick-Find 时间复杂度分析</h3><blockquote><p>联通判断：近似$O(1)$</p><p>合并操作：$O(n)$</p></blockquote><h3 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick-Union"></a>Quick-Union</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123212230290.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123212230290.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220123212230290"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123212319849.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123212319849.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220123212319849"></p><p>Quick-Unionu算法是选先找根节点判断是否处在同一根节点猜能在合并</p><h3 id="Quick-Union-总结"><a href="#Quick-Union-总结" class="headerlink" title="Quick-Union 总结"></a>Quick-Union 总结</h3><h3 id="问题思考：-需要自己手动模拟一下"><a href="#问题思考：-需要自己手动模拟一下" class="headerlink" title="问题思考：(需要自己手动模拟一下)"></a>问题思考：<code>(需要自己手动模拟一下)</code></h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="路径压缩"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123195549030.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123195549030.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220123195549030"></p><ol><li>如果不看上述 Quick-Union 正常合并情况在极端情况下会退化成一条链 - 这就是一个$O(n)$操作</li><li>将节点数量多的接到少的树上面，导致了退化</li><li>将树高深度的接到浅的上面，导致退化</li></ol><p>问题思考：若要改进，是按照节点数量还是节点高度合并？</p><p>可以得到：</p><p>树高合并到树矮的上面(树高不变)</p><p>如果一棵树很矮但是包含了很多节点和一颗高树有较少节点在这种情况下就需要节点数量为合并条件</p><psw>谁的节点数量多就往那个树上合并</psw><h3 id="平均查找次数"><a href="#平均查找次数" class="headerlink" title="平均查找次数"></a>平均查找次数</h3><p>每个节点深度相加之和除总节点数量</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123201344971.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123201344971.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220123201344971"></p><p><code>按秩合并</code>下图 但是要把0接到3下面就<code>路径压缩</code> + <code>按秩合并</code>了就开头所看到的样子</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123210333670.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123210333670.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220123210333670"></p><p>并查集四种算法</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123213033914.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220123213033914.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220123213033914"></p><p>代码见 <a href="%5Bhttps://tutouwang.vercel.app/2022/01/23/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86_2/%5D(https://tutouwang.vercel.app/2022/01/23/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86_2/)">并查集2</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>由数据范围反推算法复杂度以及算法内容</title>
      <link href="2022/01/22/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E7%94%B1%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/"/>
      <url>2022/01/22/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E7%94%B1%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 107∼108107∼108 为最佳。</p><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><ol><li>n≤30n≤30, 指数级别, dfs+剪枝，状态压缩dp</li><li>n≤100n≤100 &#x3D;&gt; O(n3)O(n3)，floyd，dp，高斯消元</li><li>n≤1000n≤1000 &#x3D;&gt; O(n2)O(n2)，O(n2logn)O(n2logn)，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</li><li>n≤10000n≤10000 &#x3D;&gt; O(n∗n√)O(n∗n)，块状链表、分块、莫队</li><li>n≤100000n≤100000 &#x3D;&gt; O(nlogn)O(nlogn) &#x3D;&gt; 各种sort，线段树、树状数组、set&#x2F;map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</li><li>n≤1000000n≤1000000 &#x3D;&gt; O(n)O(n), 以及常数较小的 O(nlogn)O(nlogn) 算法 &#x3D;&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O(nlogn)O(nlogn) 的做法：sort、树状数组、heap、dijkstra、spfa</li><li>n≤10000000n≤10000000 &#x3D;&gt; O(n)O(n)，双指针扫描、kmp、AC自动机、线性筛素数<br>n≤109n≤109 &#x3D;&gt; O(n√)O(n)，判断质数</li><li>n≤1018n≤1018 &#x3D;&gt; O(logn)O(logn)，最大公约数，快速幂，数位DP</li><li>n≤101000n≤101000 &#x3D;&gt; O((logn)2)O((logn)2)，高精度加减乘除</li><li>n≤10100000n≤10100000 &#x3D;&gt; O(logk×loglogk)，k表示位数O(logk×loglogk)，k表示位数，高精度加减、FFT&#x2F;NTT</li></ol><p>来源：AcWing</p>]]></content>
      
      
      <categories>
          
          <category> 有趣的知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL-简介</title>
      <link href="2022/01/22/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/STL-%E7%AE%80%E4%BB%8B/"/>
      <url>2022/01/22/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/STL-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="C-STL简介"><a href="#C-STL简介" class="headerlink" title="C++ STL简介"></a>C++ STL简介</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line">    size()  返回元素个数</span><br><span class="line">    empty()  返回是否为空</span><br><span class="line">    clear()  清空</span><br><span class="line">    front()&#x2F;back()</span><br><span class="line">    push_back()&#x2F;pop_back()</span><br><span class="line">    begin()&#x2F;end()</span><br><span class="line">    []</span><br><span class="line">    支持比较运算，按字典序</span><br><span class="line"></span><br><span class="line">pair&lt;int, int&gt;</span><br><span class="line">    first, 第一个元素</span><br><span class="line">    second, 第二个元素</span><br><span class="line">    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br><span class="line"></span><br><span class="line">string，字符串</span><br><span class="line">    size()&#x2F;length()  返回字符串长度</span><br><span class="line">    empty()</span><br><span class="line">    clear()</span><br><span class="line">    substr(起始下标，(子串长度))  返回子串</span><br><span class="line">    c_str()  返回字符串所在字符数组的起始地址</span><br><span class="line"></span><br><span class="line">queue, 队列</span><br><span class="line">    size()</span><br><span class="line">    empty()</span><br><span class="line">    push()  向队尾插入一个元素</span><br><span class="line">    front()  返回队头元素</span><br><span class="line">    back()  返回队尾元素</span><br><span class="line">    pop()  弹出队头元素</span><br><span class="line"></span><br><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line">    size()</span><br><span class="line">    empty()</span><br><span class="line">    push()  插入一个元素</span><br><span class="line">    top()  返回堆顶元素</span><br><span class="line">    pop()  弹出堆顶元素</span><br><span class="line">    定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">stack, 栈</span><br><span class="line">    size()</span><br><span class="line">    empty()</span><br><span class="line">    push()  向栈顶插入一个元素</span><br><span class="line">    top()  返回栈顶元素</span><br><span class="line">    pop()  弹出栈顶元素</span><br><span class="line"></span><br><span class="line">deque, 双端队列</span><br><span class="line">    size()</span><br><span class="line">    empty()</span><br><span class="line">    clear()</span><br><span class="line">    front()&#x2F;back()</span><br><span class="line">    push_back()&#x2F;pop_back()</span><br><span class="line">    push_front()&#x2F;pop_front()</span><br><span class="line">    begin()&#x2F;end()</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">    size()</span><br><span class="line">    empty()</span><br><span class="line">    clear()</span><br><span class="line">    begin()&#x2F;end()</span><br><span class="line">    ++, -- 返回前驱和后继，时间复杂度 O(logn)</span><br><span class="line"></span><br><span class="line">    set&#x2F;multiset</span><br><span class="line">        insert()  插入一个数</span><br><span class="line">        find()  查找一个数</span><br><span class="line">        count()  返回某一个数的个数</span><br><span class="line">        erase()</span><br><span class="line">            (1) 输入是一个数x，删除所有x   O(k + logn)</span><br><span class="line">            (2) 输入一个迭代器，删除这个迭代器</span><br><span class="line">        lower_bound()&#x2F;upper_bound()</span><br><span class="line">            lower_bound(x)  返回大于等于x的最小的数的迭代器</span><br><span class="line">            upper_bound(x)  返回大于x的最小的数的迭代器</span><br><span class="line">    map&#x2F;multimap</span><br><span class="line">        insert()  插入的数是一个pair</span><br><span class="line">        erase()  输入的参数是pair或者迭代器</span><br><span class="line">        find()</span><br><span class="line">        []  注意multimap不支持此操作。 时间复杂度是 O(logn)</span><br><span class="line">        lower_bound()&#x2F;upper_bound()</span><br><span class="line"></span><br><span class="line">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span><br><span class="line">    和上面类似，增删改查的时间复杂度是 O(1)</span><br><span class="line">    不支持 lower_bound()&#x2F;upper_bound()， 迭代器的++，--</span><br><span class="line"></span><br><span class="line">bitset, 圧位</span><br><span class="line">    bitset&lt;10000&gt; s;</span><br><span class="line">    ~, &amp;, |, ^</span><br><span class="line">    &gt;&gt;, &lt;&lt;</span><br><span class="line">    &#x3D;&#x3D;, !&#x3D;</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">    count()  返回有多少个1</span><br><span class="line"></span><br><span class="line">    any()  判断是否至少有一个1</span><br><span class="line">    none()  判断是否全为0</span><br><span class="line"></span><br><span class="line">    set()  把所有位置成1</span><br><span class="line">    set(k, v)  将第k位变成v</span><br><span class="line">    reset()  把所有位变成0</span><br><span class="line">    flip()  等价于~</span><br><span class="line">    flip(k) 把第k位取反</span><br></pre></td></tr></table></figure><p>来自Acwing</p>]]></content>
      
      
      <categories>
          
          <category> 有趣的知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>堆与优先队列</title>
      <link href="2022/01/22/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
      <url>2022/01/22/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="回顾-二叉树"><a href="#回顾-二叉树" class="headerlink" title="回顾 - 二叉树"></a>回顾 - 二叉树</h2><p>完全二叉树</p><blockquote><ol><li>编号为 i 的字节点</li></ol><p>  左孩子编号 ：2 * i </p><p>  右孩子编号 ：2 * i + 1</p><ol start="2"><li>可以使用连续空间存储 (数组)</li></ol></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122143259741.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122143259741.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220122143259741"></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122144757632.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122144757632.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220122144757632"></p><ol><li><p>大顶堆</p><p>在任意一个三元组中 根 大于左孩子和右孩子 12 - 11 - 10 根节点 (极大) 全局最大</p></li><li><p>小顶堆</p><p>在任意一个三元组中 根 小于左孩子和右孩子 3 - 7 - 4 根节点 (极小) 全局最小</p></li></ol><h3 id="堆-尾部插入调整-自下向上"><a href="#堆-尾部插入调整-自下向上" class="headerlink" title="堆 - 尾部插入调整 (自下向上)"></a>堆 - 尾部插入调整 (自下向上)</h3><p>依次和和根比较</p><p>13 &gt; 7  交换</p><p>13 &gt; 11 交换</p><p>13 &gt; 12 交换 </p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122150010932.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122150010932.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220122150010932"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122150118220.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122150118220.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220122150118220"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122150212660.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122150212660.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220122150212660"></p><h3 id="堆-头部弹出调整-自上向下"><a href="#堆-头部弹出调整-自上向下" class="headerlink" title="堆 - 头部弹出调整 (自上向下)"></a>堆 - 头部弹出调整 (自上向下)</h3><p>从堆的最后元素直接放到堆顶</p><p>之后在在根节点的三元组中比较是是否满足条件 如果不满足最大值和根交换一直操作</p><p>12 &gt; 7 交换</p><p>11 &gt; 7 交换</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122151807208.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122151807208.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220122151807208"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122151936505.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122151936505.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220122151936505"></p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><blockquote><p>插入调整时间复杂度 - 层序遍历 ： $O(log^N)$</p><p>删除调整时间复杂度  $O(log^N)$</p><p>建堆时间复杂度 ： $O(Nlog^N)$</p></blockquote><h2 id="堆排序-大顶堆情况"><a href="#堆排序-大顶堆情况" class="headerlink" title="堆排序 - (大顶堆情况)"></a>堆排序 - (大顶堆情况)</h2><p><code>口诀：</code></p><blockquote><ol><li>将堆顶元素与堆尾元素交换</li><li>将此操作看最做是堆顶元素弹出操作</li><li>按照头部弹出以后的策略调整推</li></ol></blockquote><p>如果想要一个从小到大的排序 那么就建立一个大顶堆</p><p>如果想要一个从大到小的排序 那么就建立一个小顶堆</p><h3 id="堆-优先队列"><a href="#堆-优先队列" class="headerlink" title="堆 - 优先队列"></a>堆 - 优先队列</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122153935337.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122153935337.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220122153935337"></p><h2 id="堆代码实现-大顶堆举例"><a href="#堆代码实现-大顶堆举例" class="headerlink" title="堆代码实现 - (大顶堆举例)"></a>堆代码实现 - (大顶堆举例)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 堆-优先队列.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年01月22日 星期六 15时45分42秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    __typeof(a) __temp = a;\</span><br><span class="line">    a = b; b = __temp;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">priority_queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> cnt, size;</span><br><span class="line">&#125; <span class="built_in">priority_queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">priority_queue</span> *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span> *q = (<span class="built_in">priority_queue</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">priority_queue</span>));</span><br><span class="line">    q-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n + <span class="number">1</span>);</span><br><span class="line">    q-&gt;size =n;</span><br><span class="line">    q-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(<span class="built_in">priority_queue</span> *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;cnt == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="built_in">priority_queue</span> *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;data[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="built_in">priority_queue</span> *q, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;cnt == q-&gt;size) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;data[++(q-&gt;cnt)] = val;</span><br><span class="line">    <span class="keyword">int</span> ind = q-&gt;cnt;</span><br><span class="line">    <span class="comment">// 大顶堆</span></span><br><span class="line">    <span class="keyword">while</span>(ind &gt;&gt; <span class="number">1</span> &amp;&amp; q-&gt;data[ind] &gt; q-&gt;data[ind &gt;&gt; <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(q-&gt;data[ind], q-&gt;data[ind &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">        ind &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="built_in">priority_queue</span> *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(empty(q)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;data[<span class="number">1</span>] = q-&gt;data[q-&gt;cnt--];</span><br><span class="line">    <span class="keyword">int</span> ind = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// ind &lt;&lt; 1 &lt;= q-&gt;cnt 证明左孩子存在</span></span><br><span class="line">    <span class="keyword">while</span>((ind &lt;&lt; <span class="number">1</span>) &lt;= q-&gt;cnt) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = ind, l = ind &lt;&lt; <span class="number">1</span>, r = ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;data[l] &gt; q-&gt;data[temp]) temp = l;</span><br><span class="line">        <span class="comment">// r &lt;= q-&gt;cnt 证明右孩子存在</span></span><br><span class="line">        <span class="keyword">if</span>(r &lt;= q-&gt;cnt &amp;&amp; q-&gt;data[r] &gt; q-&gt;data[temp]) temp = r;</span><br><span class="line">        <span class="keyword">if</span>(ind == temp) <span class="keyword">break</span>;</span><br><span class="line">        swap(q-&gt;data[ind], q-&gt;data[temp]);</span><br><span class="line">        ind = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="built_in">priority_queue</span> * q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_OP 20</span></span><br><span class="line">    <span class="built_in">priority_queue</span> *q = init(MAX_OP);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        push(q, val);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;insert %d to the priority_queue!\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, top(q));</span><br><span class="line">        pop(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性建堆法-自上向下"><a href="#线性建堆法-自上向下" class="headerlink" title="线性建堆法 - (自上向下)"></a>线性建堆法 - (自上向下)</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122171821503.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220122171821503.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><blockquote><p>向上调整次数分析</p><p>在第 1 层时候(0表示向上调整0次) $0 * 2^0$ ($2^0$代表第一层有多少个节点)</p><p>第三次层每个节点最多向上调整2次</p><p>$0 * 2^1 + 1 * 2^1 + 2 * 2^2 + 3 + 2^3 + … + (n - 1) * 2^{n-1}$</p><p>0次 1个节点 1次 2个节点 … n - 1次 $2^{n-1}$节点</p><p>$0 * 2^{n - 1} + 1 * 2^{n - 2}$</p></blockquote><h2 id="堆排序-代码实现-线性建堆法"><a href="#堆排序-代码实现-线性建堆法" class="headerlink" title="堆排序 - 代码实现(线性建堆法)"></a>堆排序 - 代码实现(线性建堆法)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 堆-排序.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年01月22日 星期六 19时34分46秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    __typeof(a) __temp = a;\</span><br><span class="line">    a = b; b = __temp;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downUpdate</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>((ind &lt;&lt; <span class="number">1</span>) &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = ind, l = ind &lt;&lt; <span class="number">1</span>, r = (ind &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// if(arr[l] &gt; arr[temp]) temp = l;</span></span><br><span class="line">        <span class="keyword">if</span>(arr[l] &lt; arr[temp]) temp = l;</span><br><span class="line">        <span class="comment">// if(r &lt;= n &amp;&amp; arr[r] &gt; arr[temp]) temp = r;</span></span><br><span class="line">        <span class="keyword">if</span>(r &lt;= n &amp;&amp; arr[r] &lt; arr[temp]) temp = r;</span><br><span class="line">        <span class="keyword">if</span>(ind == temp) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr[ind], arr[temp]);</span><br><span class="line">        ind = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_Sort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    arr -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n &gt;&gt; <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        downUpdate(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        swap(arr[i], arr[<span class="number">1</span>]);</span><br><span class="line">        downUpdate(arr, i - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_N 20</span></span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX_N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_N; i++) &#123;</span><br><span class="line">        arr[i] = rand() % <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    output(arr, MAX_N);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    heap_Sort(arr, MAX_N);</span><br><span class="line">    output(arr, MAX_N);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_N</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><blockquote><p> $O(log^N)$</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="2022/01/20/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>2022/01/20/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><blockquote><p>通过数组下标索引到值</p><p>任意类型映射成一个整型 (下标)</p></blockquote><h3 id="简单举例"><a href="#简单举例" class="headerlink" title="简单举例"></a>简单举例</h3><blockquote><p>val % size</p><p>假如 val  &#x3D; 16、size &#x3D; 9</p><blockquote><p>16 % 9 &#x3D; 7 (下标)</p></blockquote><p>假如 val &#x3D; 7、size &#x3D; 9</p><blockquote><p>7 % 9 &#x3D; 7 (下标) 产生冲突了 - 优秀的哈希都会冲突</p></blockquote></blockquote><table><thead><tr><th align="center">下标</th><th align="center">0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th align="center">8</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td></td><td></td><td></td><td></td><td></td><td></td><td>16</td><td align="center"></td></tr></tbody></table><h3 id="解决哈希冲突的-四-种-方法"><a href="#解决哈希冲突的-四-种-方法" class="headerlink" title="解决哈希冲突的 四 种 方法"></a>解决哈希冲突的 四 种 方法</h3><blockquote><ol><li>开放定值法</li><li>拉链法</li><li>在哈希法 (在散列法)</li><li>建立公共溢出区</li></ol></blockquote><h4 id="解决哈希冲突方法-开放定值法"><a href="#解决哈希冲突方法-开放定值法" class="headerlink" title="解决哈希冲突方法 - 开放定值法"></a>解决哈希冲突方法 - 开放定值法</h4><p>可以使用<code>开放定值法</code> (二次探测法) - <code>不好用会堆聚</code></p><p>下标7后面<code>8</code>是空着的所以7可以存放到此处</p><table><thead><tr><th align="center">下标</th><th align="center">0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th align="center">8</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td></td><td></td><td></td><td></td><td></td><td></td><td>16</td><td align="center"><font color='red'>7</font></td></tr></tbody></table><h4 id="解决哈希冲突方法-拉链法"><a href="#解决哈希冲突方法-拉链法" class="headerlink" title="解决哈希冲突方法 - 拉链法"></a>解决哈希冲突方法 - 拉链法</h4><p>顾名思义拉链法就是以下标为7的位置做成一个链表</p><table><thead><tr><th align="center">下标</th><th align="center">0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th align="center">7</th><th align="center">8</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td></td><td></td><td></td><td></td><td></td><td></td><td align="center">16</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td></td><td></td><td></td><td></td><td></td><td></td><td align="center"><font color='red'>7</font></td><td align="center"></td></tr></tbody></table><h4 id="解决哈希冲突方法-在哈希法-在散列法"><a href="#解决哈希冲突方法-在哈希法-在散列法" class="headerlink" title="解决哈希冲突方法 - 在哈希法 (在散列法)"></a>解决哈希冲突方法 - 在哈希法 (在散列法)</h4><p>如果第一个哈希函数冲突了，那么就可以利用第二个哈希函数在去做映射，如果在冲突了那么就利用第三个哈希函数在做。。。(禁止套娃)🤐</p><h4 id="解决哈希冲突方法-建立公共溢出区"><a href="#解决哈希冲突方法-建立公共溢出区" class="headerlink" title="解决哈希冲突方法 - 建立公共溢出区"></a>解决哈希冲突方法 - 建立公共溢出区</h4><p>将冲突的元素集中去管理</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote><p>平均复杂度 ：  $O(1)$</p></blockquote><h2 id="字符串-哈希"><a href="#字符串-哈希" class="headerlink" title="字符串-哈希"></a>字符串-哈希</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 哈希.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年01月21日 星期五 16时28分39秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line">    Node **data;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125; HashTable;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">init_node</span><span class="params">(<span class="keyword">char</span> *str, Node *head)</span> </span>&#123;</span><br><span class="line">    Node *p =(Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="comment">// 深拷贝</span></span><br><span class="line">    p-&gt;str = strdup(str);</span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HashTable *<span class="title">init_hash</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    HashTable *h = (HashTable *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashTable));</span><br><span class="line">    <span class="comment">// 利用率</span></span><br><span class="line">    h-&gt;size = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    h-&gt;data = (Node **)<span class="built_in">calloc</span>(h-&gt;size, <span class="keyword">sizeof</span>(Node *));</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// seed 可以是任意一质数</span></span><br><span class="line">    <span class="keyword">int</span> seed = <span class="number">31</span>, hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) hash = hash * seed + str[i];</span><br><span class="line">    <span class="comment">// 确保 head 是一个正数</span></span><br><span class="line">    <span class="keyword">return</span> hash &amp; <span class="number">0x7fffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(HashTable *h, <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hash = BKDRHash(str);</span><br><span class="line">    <span class="keyword">int</span> ind = hash % h-&gt;size;</span><br><span class="line">    h-&gt;data[ind] = init_node(str, h-&gt;data[ind]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(HashTable *h, <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hash = BKDRHash(str);</span><br><span class="line">    <span class="keyword">int</span> ind = hash % h-&gt;size;</span><br><span class="line">    Node *p = h-&gt;data[ind];</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; <span class="built_in">strcmp</span>(p-&gt;str, str)) p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    Node *p = node, *t;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        t = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p-&gt;str);</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(HashTable *h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h-&gt;size; i++) &#123;</span><br><span class="line">        clear_node(h-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(h);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_N 100</span></span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="keyword">char</span> str[MAX_N + <span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    HashTable *h = init_hash(MAX_N);</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;op, str)) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;insert %s to HashTable\n&quot;</span>, str);</span><br><span class="line">                insert(h, str);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;search %s from HashTable result = %d\n&quot;</span>, str, search(h, str));</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_N</span></span><br><span class="line">    clear(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二分查找与三分查找</title>
      <link href="2022/01/20/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%B8%89%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>2022/01/20/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%B8%89%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="二分查找-折半查找"><a href="#二分查找-折半查找" class="headerlink" title="二分查找 (折半查找)"></a>二分查找 (折半查找)</h2><p>条件</p><blockquote><p>单调性 - (一般单调递减)</p></blockquote><h3 id="特殊情况-1"><a href="#特殊情况-1" class="headerlink" title="特殊情况 - 1"></a>特殊情况 - 1</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220120170308988.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220120170308988.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220120170308988"></p><blockquote><p>查找第最后出现的 1</p><p>如果待查值不存在的情况可以设置一个虚拟头 </p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220120170528217.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220120170528217.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220120170528217"></p><h3 id="特殊情况-2"><a href="#特殊情况-2" class="headerlink" title="特殊情况 - 2"></a>特殊情况 - 2</h3><blockquote><p>查找第一个 1</p><p>如果待查值不存在的情况可以设置一个虚拟尾</p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220120171101494.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220120171101494.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220120171101494"></p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote><p>平均复杂度 ：  $O(log^N)$</p></blockquote><h2 id="三分查找"><a href="#三分查找" class="headerlink" title="三分查找"></a>三分查找</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220120214425656.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220120214425656.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220120214425656"></p>]]></content>
      
      
      <categories>
          
          <category> 基础数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序合集 5 种 - 插入、冒泡、归并、选择、快排</title>
      <link href="2022/01/19/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/"/>
      <url>2022/01/19/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h2><blockquote><p>稳定 ：( 插入、冒泡、归并)</p><p>非稳定 (不稳定) ：(选择、快排)</p><p>内部 ：(整体一次性的加入到内存当中,整体的去排序)</p><p>外部 ： (对一个数据文件排序的话可以不将整个文件都加载到内存里面进行排序 - 归并！  )</p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20190621202258481.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20190621202258481.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p><h2 id="插入排序-insert-Sort"><a href="#插入排序-insert-Sort" class="headerlink" title="插入排序 (insert_Sort)"></a>插入排序 (insert_Sort)</h2><p><code>口诀 :</code></p><blockquote><ol><li>将数组分成【已排序区】 和 【待排序区】</li><li>将【待排序区】第一个元素，向前插入到【已排序区】</li><li>直到【待排序区】没有元素为止</li></ol></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20210223174254141.gif" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20210223174254141.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="动图显示"></p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><blockquote><p>最好 ：0 次</p><p>最坏 ：n - 1 次 </p><p>平均复杂度 ：( 最好 + 最坏 ) &#x2F; 2  :  $\frac{(n - 1)}{2} * N$  :  $O(N^2)$</p></blockquote><h3 id="代码实现-模块"><a href="#代码实现-模块" class="headerlink" title="代码实现 - 模块"></a>代码实现 - 模块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_Sort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; num[j] &lt; num[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            swap(num[j], num[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序-bubble-Sort"><a href="#冒泡排序-bubble-Sort" class="headerlink" title="冒泡排序 (bubble_Sort)"></a>冒泡排序 (bubble_Sort)</h2><p><code>口诀 :</code></p><blockquote><ol><li>将数组分成【已排序区】 和 【待排序区】</li><li>从头到尾扫描【待排序区】，若前面元素比后面元素大，则交换</li><li>每一轮都会将【待排序区】中最大的放到【已排序区】的开头</li><li>直到【待排序区】没有元素为止</li></ol></blockquote><p><code>小优化 ： 如果一轮中一次交换都没有就证明序列已经有序可以提前结束</code></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20210509190446264.gif" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20210509190446264.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="动图显示"></p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote><p>平均复杂度 ：  $O(N^2)$</p></blockquote><h3 id="代码实现-模块-1"><a href="#代码实现-模块-1" class="headerlink" title="代码实现 - 模块"></a>代码实现 - 模块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_Sort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> falg = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n &amp;&amp; falg; i++) &#123;</span><br><span class="line">        falg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[j] &lt;= num[j + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            swap(num[j], num[j + <span class="number">1</span>]);</span><br><span class="line">            falg++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序-二路归并-merge-Sort"><a href="#归并排序-二路归并-merge-Sort" class="headerlink" title="归并排序 - 二路归并 (merge_Sort)"></a>归并排序 - 二路归并 (merge_Sort)</h2><p>核心思想<code>分治</code></p><blockquote><p>将【待排序数组】分为两个部分</p><p>如 ：         9 7 8 5 4 1 2 3 6 5</p><p>分为 :     9 7 8 5 4  — 1 2 3 6 5</p><p>再分：9 7 — 8 5 4 — 1 2 —  365</p><p>达到足够小并且立马能拿到答案的规模</p><p>上一层 ： 【 — 我是空数组 — 】</p></blockquote><blockquote><p>可以得到 7 9 — 4 5 8 — 1 2 — 3 5 6 组内有序组间无序</p><p>一个指向👆 ____👆 合并成一个有序数组 - 在拷贝到原数组</p><p>他们两个比较谁小就插入到上面数组</p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20190621210036677.gif" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20190621210036677.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="动图显示"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/1940317-d3d400686bc61c30.gif" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/1940317-d3d400686bc61c30.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote><p>平均复杂度 ：  $O(Nlog^N)$</p></blockquote><h3 id="代码实现-模块-2"><a href="#代码实现-模块-2" class="headerlink" title="代码实现 - 模块"></a>代码实现 - 模块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_Sort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r - l &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(r - l == <span class="number">1</span> &amp;&amp; num[r] &lt; num[l]) &#123;</span><br><span class="line">            swap(num[r], num[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (r + l) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_Sort(num, l, mid);</span><br><span class="line">    merge_Sort(num, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> *temp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (r - l + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> p1 = l, p2 = mid + <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid || p2 &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p2 &gt; r || (p1 &lt;= mid &amp;&amp; num[p1] &lt;= num[p2])) &#123;</span><br><span class="line">            temp[cnt++] = num[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[cnt++] = num[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(num + l, temp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (r - l + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="稳定排序代码合集-插入、冒泡、归并"><a href="#稳定排序代码合集-插入、冒泡、归并" class="headerlink" title="稳定排序代码合集 - 插入、冒泡、归并"></a>稳定排序代码合集 - 插入、冒泡、归并</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">        &gt; File Name: 稳定排序合集-插入、冒泡、归并.c</span><br><span class="line">        &gt; Author: 秃头王</span><br><span class="line">        &gt; Mail: 1658339000@qq.com</span><br><span class="line">        &gt; Created Time: 2022年01月19日 星期三 17时02分43秒</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include <span class="tag">&lt;<span class="name">stdio.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">stdlib.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">time.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">string.h</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// typeof(a) 相当于获取 a 的类型 在定义一个变量 __temp</span><br><span class="line">#define swap(a, b) &#123;\</span><br><span class="line">    __typeof(a) __temp = a;\</span><br><span class="line">    a = b, b = __temp;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define TEST(arr, n, func, args...) &#123;\</span><br><span class="line">    int *num = (int *)malloc(sizeof(int) * n);\</span><br><span class="line">    memcpy(num, arr, sizeof(int) * n);\</span><br><span class="line">    output(num, n);\</span><br><span class="line">    printf(&quot;%s = &quot;, #func);\</span><br><span class="line">    func(args);\</span><br><span class="line">    output(num, n);\</span><br><span class="line">    free(num);\</span><br><span class="line">    printf(&quot;\n&quot;);\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 插入排序</span><br><span class="line">void insert_Sort(int *num, int n) &#123;</span><br><span class="line">    for(int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        for(int j = i; j &gt; 0 &amp;&amp; num[j] &lt; num[j - 1]; j--) &#123;</span><br><span class="line">            swap(num[j], num[j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 冒泡排序</span><br><span class="line">void bubble_Sort(int *num, int n) &#123;</span><br><span class="line">    int falg = 1;</span><br><span class="line">    for(int i = 1; i &lt; n &amp;&amp; falg; i++) &#123;</span><br><span class="line">        falg = 0;</span><br><span class="line">        for(int j = 0; j &lt; n - i; j++) &#123;</span><br><span class="line">            if(num[j] &lt;= num[j + 1]) continue;</span><br><span class="line">            swap(num[j], num[j + 1]);</span><br><span class="line">            falg++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 归并排序</span><br><span class="line">void merge_Sort(int *num, int l, int r) &#123;</span><br><span class="line">    if(r - l &lt;= 1) &#123;</span><br><span class="line">        if(r - l == 1 &amp;&amp; num[r] &lt; num[l]) &#123;</span><br><span class="line">            swap(num[r], num[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int mid = (r + l) &gt;&gt; 1;</span><br><span class="line">    merge_Sort(num, l, mid);</span><br><span class="line">    merge_Sort(num, mid + 1, r);</span><br><span class="line">    int *temp = (int *)malloc(sizeof(int) * (r - l + 1));</span><br><span class="line">    int p1 = l, p2 = mid + 1, cnt = 0;</span><br><span class="line">    while(p1 &lt;= mid || p2 &lt;= r) &#123;</span><br><span class="line">        if(p2 &gt; r || (p1 &lt;= mid &amp;&amp; num[p1] &lt;= num[p2])) &#123;</span><br><span class="line">            temp[cnt++] = num[p1++];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            temp[cnt++] = num[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(num + l, temp, sizeof(int) * (r - l + 1));</span><br><span class="line">    free(temp);</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void randint(int *arr, int n) &#123;</span><br><span class="line">    while(n--) arr[n] = rand() % 100;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void output(int *arr, int n) &#123;</span><br><span class="line">    for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        i &amp;&amp; printf(&quot;, &quot;);</span><br><span class="line">        printf(&quot;%d&quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    srand(time(0));</span><br><span class="line">    #define MAX_N 20</span><br><span class="line">    int arr[MAX_N];</span><br><span class="line">    randint(arr, MAX_N);</span><br><span class="line">    TEST(arr, MAX_N, insert_Sort, num, MAX_N);</span><br><span class="line">    TEST(arr, MAX_N, bubble_Sort, num, MAX_N);</span><br><span class="line">    TEST(arr, MAX_N, merge_Sort, num, 0, MAX_N - 1);</span><br><span class="line">    #undef MAX_N</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center color=pink size=15 >分界线👇不稳定了</center><hr><h2 id="选择排序-select-Sort"><a href="#选择排序-select-Sort" class="headerlink" title="选择排序 (select_Sort)"></a>选择排序 (select_Sort)</h2><p><code>口诀 :</code></p><blockquote><ol><li>将数组分成【已排序区】 和 【待排序区】</li><li>每一轮从【待排序区】中选择一个最小的元素方到【已排序区】的尾部</li><li>直到【待排序区】没有元素为止</li></ol></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20210509190545640.gif" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20210509190545640.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote><p>平均复杂度 ：  $O(N^2)$</p></blockquote><h3 id="代码实现-模块-3"><a href="#代码实现-模块-3" class="headerlink" title="代码实现 - 模块"></a>代码实现 - 模块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_Sort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[ind] &gt; num[j]) ind = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(num[i], num[ind]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序-quick-Sort"><a href="#快速排序-quick-Sort" class="headerlink" title="快速排序 (quick_Sort)"></a>快速排序 (quick_Sort)</h2><p><code>口诀 :</code></p><blockquote><ol><li>选择基准数 ： 一般选择序列的第一个数 (基准值)</li><li>进行（partition）操作：作用就是使得待排序的序列分为了两部分</li><li>前部分都小于基准值 — 后面一部分都大于基准值 (一轮partition 操作)</li><li>head &#x3D; 第一个数(基准值) tail &#x3D; 最后一个元素</li><li>tail 操作</li><li>从后往前找第一个小于基准值的数 - 找到之后填到头指针的位置</li><li>head 操作</li><li>从前往后找到找到一个大于基准值的数 - 找到之后填到尾针的位置</li></ol></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220119213003097.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220119213003097.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220119213003097"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220119213010221.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220119213010221.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220119213010221"></p><h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote><p>平均复杂度 ：  $O(Nlog^N)$ </p><p>完全逆序 ： $ O(N^2)$ - (就变成了选择排序)</p></blockquote><h3 id="代码实现-模块-未优化-填坑法"><a href="#代码实现-模块-未优化-填坑法" class="headerlink" title="代码实现 - 模块 - 未优化 - 填坑法"></a>代码实现 - 模块 - 未优化 - 填坑法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快排 — 第一版</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_Sort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> x = l, y = r, z = num[l];</span><br><span class="line">    <span class="keyword">while</span>(x &lt; y) &#123;</span><br><span class="line">        <span class="comment">// 先从后往前扫因为第一个位置是空着可以覆盖掉</span></span><br><span class="line">        <span class="keyword">while</span>(x &lt; y &amp;&amp; num[y] &gt; z) y--;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; y) num[x++] = num[y];</span><br><span class="line">        <span class="keyword">while</span>(x &lt; y &amp;&amp; num[x] &lt; z) x++;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; y) num[y--] = num[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头尾指针重合</span></span><br><span class="line">    num[x] = z;</span><br><span class="line">    quick_Sort(num, l, x - <span class="number">1</span>);</span><br><span class="line">    quick_Sort(num, x + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码实现-模块-优化-基准值两点取中法、无监督优化-去掉x-lt-y-、单边递归法"><a href="#代码实现-模块-优化-基准值两点取中法、无监督优化-去掉x-lt-y-、单边递归法" class="headerlink" title="代码实现 - 模块 - 优化 - 基准值两点取中法、无监督优化(去掉x &lt; y)、单边递归法"></a>代码实现 - 模块 - 优化 - 基准值两点取中法、无监督优化(去掉x &lt; y)、单边递归法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快排 — 第二版 基准值两点取中法、无监督优化(去掉x &lt; y)、单 边递归法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_Sort1</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = l, y = r, z = num[(l + r) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(num[x] &lt; z) x++;</span><br><span class="line">            <span class="keyword">while</span>(num[y] &gt; z) y--;</span><br><span class="line">            <span class="keyword">if</span>(x &lt;= y) &#123;</span><br><span class="line">                swap(num[x], num[y]);</span><br><span class="line">                x++, y--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(x &lt;= y);</span><br><span class="line">        quick_Sort1(num, l, y);</span><br><span class="line">        l = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不稳定排序代码合集-选择、快速、快速优化"><a href="#不稳定排序代码合集-选择、快速、快速优化" class="headerlink" title="不稳定排序代码合集 - 选择、快速、快速优化"></a>不稳定排序代码合集 - 选择、快速、快速优化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************                   [0]</span></span><br><span class="line"><span class="comment">        &gt; File Name: 稳定排序合集-插入、冒泡、归并.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年01月19日 星期三 17时02分43秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typeof(a) 相当于获取 a 的类型 在定义一个变量 __temp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    __typeof(a) __temp = a;\</span><br><span class="line">    a = b, b = __temp;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(arr, n, func, args...) &#123;\</span></span><br><span class="line">    <span class="keyword">int</span> *num = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);\</span><br><span class="line">    <span class="built_in">memcpy</span>(num, arr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);\</span><br><span class="line">    output(num, n);\</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s = &quot;</span>, <span class="meta">#func);\</span></span><br><span class="line">    func(args);\</span><br><span class="line">    output(num, n);\</span><br><span class="line">    <span class="built_in">free</span>(num);\</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="keyword">void</span> select_Sort(<span class="keyword">int</span> *num, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[ind] &gt; num[j]) ind = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(num[i], num[ind]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排 — 第一版</span></span><br><span class="line"><span class="keyword">void</span> quick_Sort(<span class="keyword">int</span> *num, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> x = l, y = r, z = num[l];</span><br><span class="line">    <span class="keyword">while</span>(x &lt; y) &#123;</span><br><span class="line">        <span class="comment">// 先从后往前扫因为第一个位置是空着可以覆盖掉</span></span><br><span class="line">        <span class="keyword">while</span>(x &lt; y &amp;&amp; num[y] &gt; z) y--;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; y) num[x++] = num[y];</span><br><span class="line">        <span class="keyword">while</span>(x &lt; y &amp;&amp; num[x] &lt; z) x++;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; y) num[y--] = num[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头尾指针重合</span></span><br><span class="line">    num[x] = z;</span><br><span class="line">    quick_Sort(num, l, x - <span class="number">1</span>);</span><br><span class="line">    quick_Sort(num, x + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排 — 第二版 基准值两点取中法、无监督优化(去掉x &lt; y)、单 边递归法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> quick_Sort1(<span class="keyword">int</span> *num, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = l, y = r, z = num[(l + r) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(num[x] &lt; z) x++;</span><br><span class="line">            <span class="keyword">while</span>(num[y] &gt; z) y--;</span><br><span class="line">            <span class="keyword">if</span>(x &lt;= y) &#123;</span><br><span class="line">                swap(num[x], num[y]);</span><br><span class="line">                x++, y--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(x &lt;= y);</span><br><span class="line">        quick_Sort1(num, l, y);</span><br><span class="line">        l = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> randint(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">while</span>(n--) arr[n] = rand() % <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> output(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        i &amp;&amp; <span class="built_in">printf</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_N 20</span></span><br><span class="line">    <span class="keyword">int</span> arr[MAX_N];</span><br><span class="line">    randint(arr, MAX_N);</span><br><span class="line">    TEST(arr, MAX_N, select_Sort, num, MAX_N);</span><br><span class="line">    TEST(arr, MAX_N, quick_Sort, num, <span class="number">0</span>, MAX_N - <span class="number">1</span>);</span><br><span class="line">    TEST(arr, MAX_N, quick_Sort1, num, <span class="number">0</span>, MAX_N - <span class="number">1</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_N</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有趣的知识"><a href="#有趣的知识" class="headerlink" title="有趣的知识"></a>有趣的知识</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp</span><br><span class="line">time .&#x2F;a.out &gt; out_1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 比较两个文件是否相等</span><br><span class="line">diff out_1  out_2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广义表转二叉树</title>
      <link href="2022/01/18/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%BF%E4%B9%89%E8%A1%A8%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2022/01/18/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%BF%E4%B9%89%E8%A1%A8%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="代码实现广义表还原二叉树-栈原理"><a href="#代码实现广义表还原二叉树-栈原理" class="headerlink" title="代码实现广义表还原二叉树 (栈原理)"></a>代码实现广义表还原二叉树 (栈原理)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 广义表转二叉树.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年01月18日 星期二 14时33分25 秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    Node **data;</span><br><span class="line">    <span class="keyword">int</span> top, size;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = val;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree *<span class="title">getNewTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Tree *tree = (Tree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    tree-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack *<span class="title">init_stack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Stack *s = (Stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    s-&gt;data = (Node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node *) * n);</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    s-&gt;size = n;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">top</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Stack *s, Node *val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;size - <span class="number">1</span> == s-&gt;top) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    s-&gt;data[++(s-&gt;top)] = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(empty(s)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    s-&gt;top--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_stack</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(s-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear_node(root-&gt;lchild);</span><br><span class="line">    clear_node(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_tree</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> *node_num)</span> </span>&#123;</span><br><span class="line">    Stack *s = init_stack(<span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="keyword">int</span> falg = <span class="number">0</span>;</span><br><span class="line">    Node *temp = <span class="literal">NULL</span>, *p =<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(str[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(str[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span> : &#123;</span><br><span class="line">                push(s, temp);</span><br><span class="line">                falg = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span> : &#123;</span><br><span class="line">                p = top(s);</span><br><span class="line">                pop(s);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span> : falg = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span> : <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">                temp = getNewNode(str[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(!empty(s) &amp;&amp; !falg) &#123;</span><br><span class="line">                top(s)-&gt;lchild = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!empty(s) &amp;&amp; falg)&#123;</span><br><span class="line">                top(s)-&gt;rchild = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            ++(*node_num);</span><br><span class="line">        &#125;</span><br><span class="line">        ++str;</span><br><span class="line">    &#125;</span><br><span class="line">    clear_stack(s);</span><br><span class="line">    <span class="keyword">if</span>(temp &amp;&amp; p == <span class="literal">NULL</span>) p = temp;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前 根 左 右</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">    pre_order_node(root-&gt;lchild);</span><br><span class="line">    pre_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pre_order (%d) : &quot;</span>, tree-&gt;length);</span><br><span class="line">    pre_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中 左 根 右</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    in_order_node(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">    in_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in_order (%d) : &quot;</span>, tree-&gt;length);</span><br><span class="line">    in_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后 左 右 根</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    in_order_node(root-&gt;lchild);</span><br><span class="line">    in_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;post_order (%d) : &quot;</span>, tree-&gt;length);</span><br><span class="line">    post_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> node_num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, str);</span><br><span class="line">    getchar();</span><br><span class="line">    Tree *tree = getNewTree();</span><br><span class="line">    tree-&gt; root = build(str, &amp;node_num);</span><br><span class="line">    tree-&gt;length = node_num;</span><br><span class="line">    pre_order(tree);</span><br><span class="line">    in_order(tree);</span><br><span class="line">    post_order(tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220118154618267.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220118154618267.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220118154618267"></p>]]></content>
      
      
      <categories>
          
          <category> 基础数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 广义表转二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树与二叉树</title>
      <link href="2022/01/17/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2022/01/17/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><code>根</code>节点 可以看成一个集合</p><p>链接的<code>线</code>可以看成关系</p><p>跟节点下面的<code>子集</code></p><p>怎么判断机叉树：其中某个节点最多的<code>子孩子</code>个数 下面就是一个三叉树</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220117145202372.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220117145202372.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220117145202372"></p><h3 id="树的高度-深度"><a href="#树的高度-深度" class="headerlink" title="树的高度-深度"></a>树的高度-深度</h3><blockquote><p>节点4深度 2 是从根节点向下看</p><p>节点4高度 4 是从节点8向上看是4 从节点6向上看是 2 取最大 4</p><p>节点4高度  分层看 也是4</p><p>什么是节点的度 数据结构的理解  度 &#x3D; 出度 + 入度  <strong>图</strong></p><p>在数据结构树的描述中 度 &#x3D;&#x3D; 出度 <strong>从当前节点有多少条出边</strong></p></blockquote><p><strong>节点数量等于边数+1</strong></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220117145905563.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220117145905563.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220117145905563"></p><h3 id="树-转-二叉树"><a href="#树-转-二叉树" class="headerlink" title="树 转 二叉树"></a>树 转 二叉树</h3><p>树 转换成 二叉树 <code>左孩子</code> - <code>右兄弟</code> 十字链表法</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220117152416332.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220117152416332.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220117152416332"></p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><blockquote><p>最多有2个子孩子叫二叉树 - 度最大为2</p><p>节点1出度指向 节点 2 和 节点3  分别为 左孩子 和 右孩子</p><p>为什么要讲二叉树 因为所有的树都可以转换成2叉树</p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220117151151131.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220117151151131.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220117151151131"></p><p>度为0的节点比度为2的节点多1个</p><blockquote><p>二叉树中 有度为0 (n0)， 1(n1)， 2(n0)</p><p>节点个数等于边数加1</p><p>n0 + n1 + n2 &#x3D; 0 + n1 + 2 * n2 + 1</p><p>n0 &#x3D; n2 + 1</p></blockquote><h3 id="二叉树-遍历"><a href="#二叉树-遍历" class="headerlink" title="二叉树 - 遍历"></a>二叉树 - 遍历</h3><blockquote><p>前序遍历 ： 根、左、右 — 根、左子树、右子树 ： 1， 2， 4，5，3，6</p><p>中序遍历 ： 左、根、右 — 左子树、根、右子树 ： 4，2，5，1，3，6</p><p>后序遍历 ： 左、右、根 — 左子树、右子树 、根 ：4，5，2，6，3，1</p></blockquote><h3 id="1-先序遍历-root-左-右"><a href="#1-先序遍历-root-左-右" class="headerlink" title="1.先序遍历- root - 左 - 右"></a>1.先序遍历- root - 左 - 右</h3><p><img src="https://pics2.baidu.com/feed/50da81cb39dbb6fd650e4be1c7069010962b374e.jpeg?token=84cfb9c547ddffebed4651d5ad6cb660" class="lazyload" data-srcset="https://pics2.baidu.com/feed/50da81cb39dbb6fd650e4be1c7069010962b374e.jpeg?token=84cfb9c547ddffebed4651d5ad6cb660" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root) <span class="keyword">return</span> ;</span><br><span class="line">    f.push_back(roo-&gt;val);</span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-中序遍历-左-root-右"><a href="#2-中序遍历-左-root-右" class="headerlink" title="2.中序遍历 左 - root - 右"></a>2.中序遍历 左 - root - 右</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/35a85edf8db1cb1365ee79d915766d4693584b1b.jpeg" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/35a85edf8db1cb1365ee79d915766d4693584b1b.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root) <span class="keyword">return</span> ;</span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line">    f.push_back(root-&gt;val);</span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-后序遍历-左-右-root"><a href="#3-后序遍历-左-右-root" class="headerlink" title="3.后序遍历 左 - 右 - root"></a>3.后序遍历 左 - 右 - root</h3><p><img src="https://pics1.baidu.com/feed/91ef76c6a7efce1bdb79b99b6773c8d6b48f653f.jpeg?token=372473cf583930a773f86057d1fd8e98" class="lazyload" data-srcset="https://pics1.baidu.com/feed/91ef76c6a7efce1bdb79b99b6773c8d6b48f653f.jpeg?token=372473cf583930a773f86057d1fd8e98" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root) <span class="keyword">return</span> ;</span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line">    f.push_back(root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树-中国版"><a href="#二叉树-中国版" class="headerlink" title="二叉树 - 中国版"></a>二叉树 - 中国版</h3><blockquote><p>完全二叉 只会有一个度为 1 的节点 缺省的只会是右孩子</p><p>满二叉树 每一个层都会满满的</p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220117155413653.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220117155413653.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220117155413653"></p><h3 id="二叉树-国际版"><a href="#二叉树-国际版" class="headerlink" title="二叉树 - 国际版"></a>二叉树 - 国际版</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220117160458979.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220117160458979.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220117160458979"></p><h3 id="二叉树-完全二叉树"><a href="#二叉树-完全二叉树" class="headerlink" title="二叉树 - 完全二叉树"></a>二叉树 - 完全二叉树</h3><blockquote><ol><li>编号为 i 的子节点</li></ol><blockquote><p>左孩子编号 ：2 * i</p><p>右孩子编号 ： 2 * i + 1</p></blockquote><ol start="2"><li>可以用连续空间存储（数组）<code>可以用顺序表实现！</code>(更节省空间)</li></ol></blockquote><h3 id="二叉树-广义表"><a href="#二叉树-广义表" class="headerlink" title="二叉树 - 广义表"></a>二叉树 - 广义表</h3><blockquote><p>广义表如何还原成一科二叉树</p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220117162019366.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220117162019366.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220117162019366"></p><blockquote><p>推荐使用<code>第一种</code>和<code>第二种</code></p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220117162322495.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220117162322495.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220117162322495"></p><h3 id="二叉树代码实现"><a href="#二叉树代码实现" class="headerlink" title="二叉树代码实现"></a>二叉树代码实现</h3><blockquote><p>引入二叉排序树的概念</p><p>存在一课二叉树中<code>三元组</code> 广义表中 A, B, C</p><p>A &gt; B  &amp;&amp; A &lt; C (维护性质) <code>中序遍历</code>就可以得到一个<code>有序序列</code></p></blockquote><p><code>前、中、后 遍历序列</code> 得到中序和任意两种就可以还原出一课树 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 二叉树.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年01月17日 星期一 16时25分06秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为什么使用calloc(对象数目, 每个对象大小)可以自动初始化。</span></span><br><span class="line">    Node *p = (Node *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = val;</span><br><span class="line">    <span class="comment">// 可省去</span></span><br><span class="line">    <span class="comment">// p-&gt;lchild = NULL;</span></span><br><span class="line">    <span class="comment">// p-&gt;rchild = NULL;</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree *<span class="title">getNewTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Tree *tree = (Tree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    tree-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear_node(root-&gt;lchild);</span><br><span class="line">    clear_node(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A &gt; B &amp;&amp; A &lt; C</span></span><br><span class="line"><span class="function">Node *<span class="title">insert_node</span><span class="params">(Node *root, <span class="keyword">int</span> val, <span class="keyword">int</span> *falg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *falg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getNewNode(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data == val) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data &lt; val) root-&gt;rchild = insert_node(root-&gt;rchild, val, falg);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;lchild = insert_node(root-&gt;lchild, val,falg);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这插入是根据二叉排序树 不会插入重复元素 falg = 标记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Tree *tree, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> falg = <span class="number">0</span>;</span><br><span class="line">    tree-&gt;root = insert_node(tree-&gt;root, val, &amp;falg);</span><br><span class="line">    tree-&gt;length += falg;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">    pre_order_node(root-&gt;lchild);</span><br><span class="line">    pre_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序 根 左 右</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pre_order : [&quot;</span>);</span><br><span class="line">    pre_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    in_order_node(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">    in_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序 左 根 右</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in_order : [&quot;</span>);</span><br><span class="line">    in_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    post_order_node(root-&gt;lchild);</span><br><span class="line">    post_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序 左 右 根</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;post_order : [&quot;</span>);</span><br><span class="line">    post_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    output_node(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    output_node(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广义表打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tree(%d) : &quot;</span>, tree-&gt;length);</span><br><span class="line">    output_node(tree-&gt;root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_OP 5</span></span><br><span class="line">    Tree *tree = getNewTree();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        insert(tree, val);</span><br><span class="line">        output(tree), <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pre_order(tree);</span><br><span class="line">    in_order(tree);</span><br><span class="line">    post_order(tree);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_OP</span></span><br><span class="line">    clear(tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树与二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列</title>
      <link href="2022/01/16/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>2022/01/16/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="队列-FIFO"><a href="#队列-FIFO" class="headerlink" title="队列 (FIFO)"></a>队列 (FIFO)</h2><p>结构操作：尾部入队、头部出队（排队做核酸！捅一个走一个 哈哈哈！）</p><p><code>FIFO</code> first in firas out : 先进先出</p><h3 id="结构定义："><a href="#结构定义：" class="headerlink" title="结构定义："></a>结构定义：</h3><blockquote><p>队列长度 (length)</p><p>队头位置 (head)</p><p>队尾位置 (tail)</p><p>任意类型元素 (data_type) (int \ char)</p><p>连续空间存储</p></blockquote><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>在队列结构定义之上 count</p><blockquote><p>计数 (count) 可判断满和空</p></blockquote><p>tail % leng</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220116103748456.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220116103748456.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220116103748456"></p><h3 id="出队操作-入队操作"><a href="#出队操作-入队操作" class="headerlink" title="出队操作 - 入队操作"></a>出队操作 - 入队操作</h3><blockquote><p>出队 (head +&#x3D; 1)</p><p>入队 (tail +&#x3D; 1)</p></blockquote><h3 id="假溢出"><a href="#假溢出" class="headerlink" title="假溢出"></a>假溢出</h3><h3 id="出队操作-入队操作-假溢出优化"><a href="#出队操作-入队操作-假溢出优化" class="headerlink" title="出队操作 - 入队操作 - 假溢出优化"></a>出队操作 - 入队操作 - 假溢出优化</h3><blockquote><p>入队 (q-&gt;count !&#x3D; q-&gt;length) 当前队列数据总长度 (count)、队列总长度 (q-&gt;length)</p><blockquote><p>满足条件情况：</p><blockquote></blockquote><ol><li>q-&gt;data[q-&gt;tail++] &#x3D; val;</li><li>if(q-&gt;tail &#x3D;&#x3D; q-&gt;leng ) q-&gt;tail &#x3D; 0;</li><li>q-&gt;count++;</li></ol></blockquote><p>出队 empty(q) 是否存在元素</p><blockquote><p>满足条件情况：</p><blockquote></blockquote><ol><li>q-&gt;head++;</li><li>if(q-&gt;head &#x3D;&#x3D; q-&gt;leng) q-&gt;head &#x3D; 0;</li><li>q-&gt;count–;</li></ol></blockquote></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220116102131019.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220116102131019.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220116102131019"></p><h3 id="队列代码演示-无假溢出优化"><a href="#队列代码演示-无假溢出优化" class="headerlink" title="队列代码演示 - 无假溢出优化"></a>队列代码演示 - 无假溢出优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 队列 - 假溢出.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年01月16日 星期日 09时44分03秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> head, tail;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Queue *q = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    q-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    q-&gt;head = <span class="number">0</span>;</span><br><span class="line">    q-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    q-&gt;length = n;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Queue *q, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空</span></span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 满</span></span><br><span class="line">    <span class="keyword">if</span>(q-&gt;tail == q-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;data[q-&gt;tail++] = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;tail == q-&gt;head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(empty(q)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;head++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;data[q-&gt;head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Queue(%d) [&quot;</span>, q-&gt;length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = q-&gt;head; i &lt; q-&gt;tail; i++) &#123;</span><br><span class="line">        i != q-&gt;head &amp;&amp; <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, q-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_OP  20</span></span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    Queue *q = init(MAX_OP);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="comment">// 0 1 2</span></span><br><span class="line">        <span class="keyword">int</span> op = rand() % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span>(!empty(q)) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;pop front from the Queue = %d \n&quot;</span>, pop(q));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;push %d to the Queue = %d\n&quot;</span>, val, push(q, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;front one from Queue = %d\n&quot;</span>, front(q));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(q), <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_OP</span></span><br><span class="line">    clear(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列代码演示-假溢出优化"><a href="#队列代码演示-假溢出优化" class="headerlink" title="队列代码演示 - 假溢出优化"></a>队列代码演示 - 假溢出优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 队列 - 假溢出优化.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年01月16日 星期日 09时44分03秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> head, tail;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Queue *q = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    q-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    q-&gt;head = <span class="number">0</span>;</span><br><span class="line">    q-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    q-&gt;count = <span class="number">0</span>;</span><br><span class="line">    q-&gt;length = n;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Queue *q, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空</span></span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 满</span></span><br><span class="line">    <span class="keyword">if</span>(q-&gt;length == q-&gt;count) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;data[q-&gt;tail++] = val;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;tail == q-&gt;length) q-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    q-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(empty(q)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;head++;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;head == q-&gt;length) q-&gt;head = <span class="number">0</span>;</span><br><span class="line">    q-&gt;count--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;data[q-&gt;head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Queue(%d) [&quot;</span>, q-&gt;length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = q-&gt;head, j = <span class="number">0</span>; j &lt; q-&gt;count; j++) &#123;</span><br><span class="line">        <span class="function">j &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, q-&gt;data[(i + j) % q-&gt;length]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_OP  20</span></span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    Queue *q = init(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="comment">// 0 1 2</span></span><br><span class="line">        <span class="keyword">int</span> op = rand() % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span>(!empty(q)) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;pop front from the Queue = %d \n&quot;</span>, pop(q));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;push %d to the Queue = %d\n&quot;</span>, val, push(q, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;front one from Queue = %d\n&quot;</span>, front(q));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(q), <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_OP</span></span><br><span class="line">    clear(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列代码演示-假溢出优化-自动扩容"><a href="#队列代码演示-假溢出优化-自动扩容" class="headerlink" title="队列代码演示 - 假溢出优化 - 自动扩容"></a>队列代码演示 - 假溢出优化 - 自动扩容</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 栈与队列.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年01月16日 星期日 09时44分03秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> head, tail;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Queue *q = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    q-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    q-&gt;head = <span class="number">0</span>;</span><br><span class="line">    q-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    q-&gt;count = <span class="number">0</span>;</span><br><span class="line">    q-&gt;length = n;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> extr_size = q-&gt;length;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">while</span>(extr_size) &#123;</span><br><span class="line">        p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (extr_size + q-&gt;length)); <span class="comment">// 不能用 realloc</span></span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        extr_size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = q-&gt;head, j = <span class="number">0</span>; j &lt; q-&gt;count; j++) &#123;</span><br><span class="line">        p[j] = q-&gt;data[(i + j) % q-&gt;length];</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;data = p;</span><br><span class="line">    q-&gt;head = <span class="number">0</span>, q-&gt;tail = q-&gt;count;</span><br><span class="line">    q-&gt;length += extr_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Queue *q, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空</span></span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 满</span></span><br><span class="line">    <span class="keyword">if</span>(q-&gt;length == q-&gt;count) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!expand(q)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;自动扩容失败！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;自动扩容成功！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;data[q-&gt;tail++] = val;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;tail == q-&gt;length) q-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    q-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(empty(q)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;head++;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;head == q-&gt;length) q-&gt;head = <span class="number">0</span>;</span><br><span class="line">    q-&gt;count--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;data[q-&gt;head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Queue(%d) [&quot;</span>, q-&gt;length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = q-&gt;head, j = <span class="number">0</span>; j &lt; q-&gt;count; j++) &#123;</span><br><span class="line">        <span class="function">j &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, q-&gt;data[(i + j) % q-&gt;length]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_OP  20</span></span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    Queue *q = init(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="comment">// 0 1 2</span></span><br><span class="line">        <span class="keyword">int</span> op = rand() % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span>(!empty(q)) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;pop front from the Queue = %d \n&quot;</span>, pop(q));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;push %d to the Queue = %d\n&quot;</span>, val, push(q, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;front one from Queue = %d\n&quot;</span>, front(q));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(q), <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_OP</span></span><br><span class="line">    clear(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈-FILO-手枪弹夹🔫"><a href="#栈-FILO-手枪弹夹🔫" class="headerlink" title="栈 (FILO) - (手枪弹夹🔫)"></a>栈 (FILO) - (手枪弹夹🔫)</h2><p><code>FILO</code> first in last out : 先进后出</p><h3 id="结构定义：-1"><a href="#结构定义：-1" class="headerlink" title="结构定义："></a>结构定义：</h3><blockquote><p>栈大小 (size)</p><p>栈顶指针 (top)</p><p>栈中元素 (data_type)</p><p>连续空间存储</p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220116171822673.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220116171822673.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220116171822673"></p><h3 id="栈代码演示-自动扩容"><a href="#栈代码演示-自动扩容" class="headerlink" title="栈代码演示 - 自动扩容"></a>栈代码演示 - 自动扩容</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 栈.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年01月16日 星期日 17时20分08秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Stack *s = (Stack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    s-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    s-&gt;size = n;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(s-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> extr_size = s-&gt;size;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">while</span>(extr_size) &#123;</span><br><span class="line">        p = (<span class="keyword">int</span> *) <span class="built_in">realloc</span>(s-&gt;data,<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * ( extr_size * s-&gt;size));</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        extr_size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    s-&gt;data = p;</span><br><span class="line">    s-&gt;size += extr_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Stack *s, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top == s-&gt;size - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!expand(s)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;自动扩容失败！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;自带扩容成功！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data[++(s-&gt;top)] = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(empty(s)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    s-&gt;top--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(empty(s)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack(%d, %d) : [&quot;</span>, s-&gt;size, s-&gt;top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s-&gt;top; ~i; i--) &#123;</span><br><span class="line">        i != s-&gt;top &amp;&amp; <span class="built_in">printf</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, s-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_OP 20</span></span><br><span class="line">    Stack *s = init(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> op = rand() % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span>(s != <span class="literal">NULL</span>)</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;top %d from the Stack \n&quot;</span>, top(s));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;push %d to the Stack = %d\n&quot;</span>, val, push(s, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span>(s != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;pop %d from the Stack \n&quot;</span>, pop(s));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(s), <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_OP</span></span><br><span class="line">    clear(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 链栈.cpp</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年01月18日 星期二 16时28分15 秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    StackNode *next;</span><br><span class="line">&#125; StackNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span> &#123;</span></span><br><span class="line">    StackNode *top;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="function">StackNode *<span class="title">init_node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    StackNode *p = (StackNode * )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    p-&gt;data = val;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkStack *<span class="title">init_stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkStack *l = (LinkStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">    l-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    l-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(LinkStack *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l-&gt;top == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack_top</span><span class="params">(LinkStack *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(empty(l)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> l-&gt;top-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(LinkStack *l, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    StackNode *node = init_node(val);</span><br><span class="line">    node-&gt;next = l-&gt;top;</span><br><span class="line">    l-&gt;top = node;</span><br><span class="line">    l-&gt;length += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(StackNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(LinkStack *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    StackNode *p = l-&gt;top, *t;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        t = p-&gt;next;</span><br><span class="line">        clear_node(p);</span><br><span class="line">        p = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(l);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(LinkStack *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(empty(l)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    StackNode *p = l-&gt;top;</span><br><span class="line">    l-&gt;top = l-&gt;top-&gt;next;</span><br><span class="line">    clear_node(p);</span><br><span class="line">    l-&gt;length -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_node</span><span class="params">(StackNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(LinkStack *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LinkStack(%d) : &quot;</span>, l-&gt;length);</span><br><span class="line">    output_node(l-&gt;top);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_OP 20</span></span><br><span class="line">    LinkStack *s = init_stack();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> op = rand() % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;pop %d from the LinkStack = &quot;</span>, Stack_top(s));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pop(s));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;push %d to the form LinkStack = %d\n&quot;</span>, val, push(s, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(s), <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 待做 <del>链栈</del>、链队列、<del>循环队列扩容</del>、还没实现</p>]]></content>
      
      
      <categories>
          
          <category> 基础数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="2022/01/15/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
      <url>2022/01/15/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><h3 id="结点组成部分"><a href="#结点组成部分" class="headerlink" title="结点组成部分"></a>结点组成部分</h3><blockquote><p>数据域 - data</p><p>指针域 - next &#x2F; 后继 </p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220115112228264.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220115112228264.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220115112228264"></p><h3 id="插入-结点"><a href="#插入-结点" class="headerlink" title="插入 - 结点"></a>插入 - 结点</h3><ol><li>把待插入数据创建成一个结点</li><li>把待插入结点指向新建结点的next</li><li>把待插入结点前一个结点的next指向新建结点</li></ol><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220115113310080.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220115113310080.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220115113310080"></p><h3 id="代码演示-单向链表"><a href="#代码演示-单向链表" class="headerlink" title="代码演示 - 单向链表"></a>代码演示 - 单向链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 链表.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年01月15日 星期六 11时09分25秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR_HL(a, b) <span class="meta-string">&quot;\033[1;&quot;</span> #b <span class="meta-string">&quot;m&quot;</span> a <span class="meta-string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN_HL(a) COLOR_HL(a, 32)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="comment">// 虚拟头</span></span><br><span class="line">    ListNode head;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; List;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">List *<span class="title">getLinkList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(ListNode *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(List *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(List*, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(List *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sizeof ListNode 可以不加括号 可能是在c语言中不行</span></span><br><span class="line">    ListNode *p = (ListNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (ListNode));</span><br><span class="line">    p-&gt;data = val;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List *<span class="title">getLinkList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List *l = (List *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">    l-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">    l-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(ListNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(List * l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    ListNode *p = l-&gt;head.next;</span><br><span class="line">    ListNode *t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        t = p-&gt;next;</span><br><span class="line">        clear_node(p);</span><br><span class="line">        p = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(l);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(List *l, <span class="keyword">int</span> ind, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt; l-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ListNode *p = getNewNode(val);</span><br><span class="line">    ListNode *h = &amp;(l-&gt;head);</span><br><span class="line">    <span class="keyword">while</span>(ind--) h = h-&gt;next;</span><br><span class="line">    p-&gt;next = h-&gt;next;</span><br><span class="line">    h-&gt;next = p;</span><br><span class="line">    l-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(List *l, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt;= l-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ListNode *h = &amp;(l-&gt;head);</span><br><span class="line">    <span class="comment">// 这里说明一下为什么不 直接 h-&gt;next = h-&gt;next-&gt;next;</span></span><br><span class="line">    <span class="comment">// 1. 这个操作是合法的 但是要这样操作的就会发生内存泄漏</span></span><br><span class="line">    <span class="comment">// 2. 所有我们这里需要一个临时变量  t 来存储待删除结点 之后好free掉</span></span><br><span class="line">    ListNode *t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(ind--) h = h-&gt;next;</span><br><span class="line">    t = h-&gt;next;</span><br><span class="line">    h-&gt;next = t-&gt;next;</span><br><span class="line">    l-&gt;length--;</span><br><span class="line">    clear_node(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(List *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;List(%d) : &quot;</span>, l-&gt;length);</span><br><span class="line">    ListNode *h = l-&gt;head.next;</span><br><span class="line">    <span class="keyword">while</span>(h != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, h-&gt;data);</span><br><span class="line">        h = h-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    ListNode *h = l-&gt;head.next;</span><br><span class="line">    l-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(h != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        t = h-&gt;next;</span><br><span class="line">        t = l-&gt;head.next;</span><br><span class="line">        l-&gt;head.next = h;</span><br><span class="line">        h = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 20 次测试</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_OP 20</span></span><br><span class="line">    List *l = getLinkList();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> ind = rand() % (l-&gt;length + <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 想变大插入概率 可以把 2 变成 4</span></span><br><span class="line">        <span class="comment">// case 0 1 2 3</span></span><br><span class="line">        <span class="keyword">int</span> op = rand() % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;erase a iterm at %d from List = %d \n&quot;</span>, ind, erase(l, ind));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;insert %d at %d to List = %d \n&quot;</span>, val, ind, insert(l, ind, val));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(GREEN_HL(<span class="string">&quot;reverse the list ! \n&quot;</span>));</span><br><span class="line">                reverse(l);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        output(l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_OP</span></span><br><span class="line">    clear(l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单线循环链表"><a href="#单线循环链表" class="headerlink" title="单线循环链表"></a>单线循环链表</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220115163522464.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220115163522464.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220115163522464"></p><p>头- -&gt; 尾</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 双向链表.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年01月18日 星期二 17时05分55 秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>, *<span class="title">pre</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dlist</span> &#123;</span></span><br><span class="line">    Node head;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; Dlist;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = val;</span><br><span class="line">    p-&gt;next = p-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Dlist *<span class="title">init_list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dlist *l = (Dlist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Dlist));</span><br><span class="line">    l-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">    l-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Dlist *l, <span class="keyword">int</span> ind, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt; l-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Node *p = &amp;(l-&gt;head), *node = getNewNode(val);</span><br><span class="line">    <span class="keyword">while</span>(ind--) p = p-&gt;next;</span><br><span class="line">    node-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = node;</span><br><span class="line">    node-&gt;pre = p;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;next != <span class="literal">NULL</span>) node-&gt;next-&gt;pre = node;</span><br><span class="line">    l-&gt;length ++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Dlist *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    Node *p = l-&gt;head.next, *t;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        t = p-&gt;next;</span><br><span class="line">        clear_node(p);</span><br><span class="line">        p = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(l);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(Dlist *l, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt;= l-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Node *p= &amp;(l-&gt;head), *t;</span><br><span class="line">    <span class="keyword">while</span>(ind--) p = p-&gt;next;</span><br><span class="line">    t = p-&gt;next;</span><br><span class="line">    p-&gt;next = t-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;next != <span class="literal">NULL</span>) t-&gt;next-&gt;pre = p;</span><br><span class="line">    clear_node(t);</span><br><span class="line">    l-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">l_output</span><span class="params">(Dlist *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;L-Dlist(%d) : &quot;</span>, l-&gt;length);</span><br><span class="line">    <span class="keyword">for</span>(Node *p = l-&gt;head.next; p; p = p-&gt;next) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r_output</span><span class="params">(Dlist *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;L-Dlist(%d) : &quot;</span>, l-&gt;length);</span><br><span class="line">    <span class="keyword">int</span> ind = <span class="number">0</span>;</span><br><span class="line">    Node *p = &amp;(l-&gt;head);</span><br><span class="line">    <span class="keyword">while</span>(ind++ != l-&gt;length) p = p-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(; p != &amp;(l-&gt;head); p = p-&gt;pre) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;head\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_OP 20</span></span><br><span class="line">    Dlist *l = init_list();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> ind = rand() % (l-&gt;length + <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> op = rand() % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;erase a iterm at %d form lis = %d&quot;</span>, ind, erase(l, ind));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;insert %d at %d to Lis = %d\n&quot;</span>, val, ind, insert(l, ind, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l_output(l);</span><br><span class="line">        r_output(l), <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_OP</span></span><br><span class="line">    clear(l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表翻转"><a href="#链表翻转" class="headerlink" title="链表翻转"></a>链表翻转</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220203122707544.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220203122707544.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220203122707544"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220203122714585.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220203122714585.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220203122714585"></p><p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">力扣206</a></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220203130222576.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220203130222576.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220203130222576"></p>]]></content>
      
      
      <categories>
          
          <category> 基础数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表</title>
      <link href="2022/01/14/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
      <url>2022/01/14/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构-x3D-结构定义-结构操作"><a href="#数据结构-x3D-结构定义-结构操作" class="headerlink" title="数据结构 &#x3D;  结构定义 + 结构操作"></a>数据结构 &#x3D;  结构定义 + 结构操作</h2><p>cppreference</p><p><a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5</a></p><h2 id="顺序表-线性结构：一对一"><a href="#顺序表-线性结构：一对一" class="headerlink" title="顺序表 - 线性结构：一对一"></a>顺序表 - 线性结构：一对一</h2><p>1.什么是顺序表？ 是一个更高级的数组</p><h3 id="结构定义："><a href="#结构定义：" class="headerlink" title="结构定义："></a>结构定义：</h3><blockquote><p>一片连续存储空间</p><p>可以存储任意类型值 (类型需要一致，int、char、结构体…) (data_type)</p><p>顺序表大小 (size)</p><p>顺序表以存储个数 (length)</p></blockquote><h3 id="结构操作："><a href="#结构操作：" class="headerlink" title="结构操作："></a>结构操作：</h3><blockquote><p>插入元素 (insert) </p><p>如果第一个满足只执行<code>1</code>不满足可以直接执行 <code>2</code> 可以通过整理 直接用<code>2</code>来实现</p><ol><li>如果代插入数据<code>i</code> 等于<code>i == length</code> 那么直接在后面添加<code>length++</code></li><li>在待插入位置<code>i</code> 把<code>i + 1</code> 后数据全部向后移动一位,并且<code>legth++</code></li></ol><p>删除元素 (clear)</p><ol><li>待删位置 <code>i</code> 把<code>i + 1</code>之后位置的数据向前移动一位 覆盖掉 <code>length--</code></li></ol></blockquote><h2 id="新知识"><a href="#新知识" class="headerlink" title="新知识"></a>新知识</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; // malloc 需要头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#demine MAX_N 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数中 // int arr[n + 1]; // 栈区 在Linux系统中只有 8M 很小</span></span><br><span class="line"><span class="comment"> * malloc 动态开辟空间 如果不用需要主动释放 返回值是一块连续的地址(逻辑上) void*</span></span><br><span class="line"><span class="comment"> * calloc 参数size为申请地址的单元元素长度，nmemb为元素个数，即在内存中申请nmemb *size字节大小的连续地址空间， 并赋值0-相当于自带初始化；</span></span><br><span class="line"><span class="comment"> * realloc 给一个已经分配了地址的指针重新分配空间，参数ptr为原有的空间地址，size为重新申请的地址长度；</span></span><br><span class="line"><span class="comment"> * free 释放</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数 malloc</span></span><br><span class="line">    <span class="keyword">int</span> *v = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX_N);</span><br><span class="line">    <span class="built_in">free</span>(v);</span><br><span class="line">    v = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 函数 calloc</span></span><br><span class="line">    <span class="keyword">int</span> *v1 = (<span class="keyword">int</span> *) <span class="built_in">calloc</span>(<span class="number">20</span>, MAX_N * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">free</span>(v);</span><br><span class="line">    v = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 函数 realloc  在 malloc 基础上</span></span><br><span class="line">    <span class="comment">// 数字数量大于当前 malloc 大小 重新分配</span></span><br><span class="line">    <span class="keyword">int</span> *v = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX_N);</span><br><span class="line">    v = (<span class="keyword">int</span> *) <span class="built_in">realloc</span> (v, <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX_N);</span><br><span class="line">    <span class="built_in">free</span>(v);</span><br><span class="line">    v = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><h2 id="代码演示-顺序表"><a href="#代码演示-顺序表" class="headerlink" title="代码演示-顺序表"></a>代码演示-顺序表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 顺序表.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年01月14日 星期五 12时03分03秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR(a, b) <span class="meta-string">&quot;\033[&quot;</span> #b <span class="meta-string">&quot;m&quot;</span> a<span class="meta-string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN(a) COLOR(a, 32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED(a) COLOR(a, 31)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">    Type *data;</span><br><span class="line">    <span class="keyword">int</span> size, length;</span><br><span class="line">&#125; Vec;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Vec *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int arr[n + 1]; // 栈区 在Linux系统中只有 8M 很小</span></span><br><span class="line">    Vec *v = (Vec *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Vec));</span><br><span class="line">    v-&gt;data = (Type *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Type) * n);</span><br><span class="line">    v-&gt;size = n;</span><br><span class="line">    v-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Vec *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v == <span class="literal">NULL</span>) <span class="keyword">return</span> ; <span class="comment">// 如果内存申请失败</span></span><br><span class="line">    <span class="built_in">free</span>(v-&gt;data); <span class="comment">// 申请了2个空间</span></span><br><span class="line">    <span class="built_in">free</span>(v);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(Vec *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> extr_size = v-&gt;size;</span><br><span class="line">    Type *p;</span><br><span class="line">    <span class="keyword">while</span>(extr_size) &#123;</span><br><span class="line">        p = (Type *)<span class="built_in">realloc</span>(v-&gt;data, <span class="keyword">sizeof</span>(Type) * (v-&gt;size + extr_size));</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        extr_size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(RED(<span class="string">&quot;扩容失败\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;size += extr_size;</span><br><span class="line">    v-&gt;data = p;</span><br><span class="line">    <span class="built_in">printf</span>(GREEN(<span class="string">&quot;当前容量 : %d -- 扩容到 : %d\n&quot;</span>), v-&gt;size - extr_size, v-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Vec *v, <span class="keyword">int</span> ind, Type val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ind 需要插入的位置</span></span><br><span class="line">    <span class="keyword">if</span>(v == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt; v-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(v-&gt;length == v-&gt;size) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!expand(v)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = v-&gt;length; i &gt; ind; i--) &#123;</span><br><span class="line">        v-&gt;data[i] = v-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;data[ind] = val;</span><br><span class="line">    v-&gt;length +=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(Vec *v, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt;= v-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ind + <span class="number">1</span>; i &lt; v-&gt;length; i++) &#123;</span><br><span class="line">        v-&gt;data[i - <span class="number">1</span>] = v-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Vec *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Vector(%d) :[&quot;</span>, v-&gt;length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v-&gt;length; i++) &#123;</span><br><span class="line">        <span class="function">i &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_N 20</span></span><br><span class="line">    Vec *v = init(<span class="number">1</span>);</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> op = rand() % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ind = rand() % (v-&gt;length + <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;insert %d at %d to Vector = %d \n&quot;</span>, val, ind, insert(v, ind, val)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;erase a iterm at %d from Vector = %d\n&quot;</span>, ind, erase(v, ind)); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(v), <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear(v);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_N</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StackReverse</title>
      <link href="2022/01/06/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/StackReverse/"/>
      <url>2022/01/06/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/StackReverse/</url>
      
        <content type="html"><![CDATA[<h2 id="Stack-翻转"><a href="#Stack-翻转" class="headerlink" title="Stack - 翻转"></a>Stack - 翻转</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: stackRecerse.cpp</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2022年01月06日 星期四 10时15分16秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseStack</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; &amp;f, <span class="built_in">string</span> &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当然这里 string res 也可以写成另一个 栈 这里这个引用会加点速</span></span><br><span class="line">    <span class="keyword">if</span>(!f.empty()) &#123;</span><br><span class="line">        <span class="built_in">string</span> t = f.top();</span><br><span class="line">        f.pop();</span><br><span class="line">        reverseStack(f, res);</span><br><span class="line">        res += t + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; f, f1;</span><br><span class="line">    f.push(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    f.push(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    f.push(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    f.push(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">    f.push(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">    f.push(<span class="string">&quot;f&quot;</span>);</span><br><span class="line">    f1 = f;</span><br><span class="line">    <span class="keyword">while</span>(!f1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f1.top() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        f1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    reverseStack(f, res);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 有趣的知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>将b进制数转化成十进制</title>
      <link href="2022/01/05/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E5%B0%86b%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E5%8C%96%E6%88%90%E5%8D%81%E8%BF%9B%E5%88%B6/"/>
      <url>2022/01/05/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E5%B0%86b%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E5%8C%96%E6%88%90%E5%8D%81%E8%BF%9B%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="秦九韶算法-将b进制数转化成十进制"><a href="#秦九韶算法-将b进制数转化成十进制" class="headerlink" title="秦九韶算法-将b进制数转化成十进制"></a>秦九韶算法-将b进制数转化成十进制</h2><p>有二进制<code>1010</code></p><p>取出 第一位</p><p>1</p><blockquote><p>1 * 2 + 0 &#x3D; 2</p></blockquote><blockquote><p>10 * 2 + 1 &#x3D;&#x3D; 2 * 2 + 1</p></blockquote><p>10 &#x3D; 5</p><blockquote><p>5 * 2 + 0 &#x3D; 10</p></blockquote><p>有二进制<code>1010</code></p><p>二进制转换成十进制:基数乘以权,然后相加</p><p>$$ 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0$$</p><p>$$ &#x3D; ((1 * 2 + 0) * 2 + 1 ) * 2 + 0$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="built_in">string</span> s, b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)</span><br><span class="line">        res = res * b + c- <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 有趣的知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="2021/11/19/OOP/%E7%BB%A7%E6%89%BF/"/>
      <url>2021/11/19/OOP/%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 派生类 B 基类 A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继承权限影响的什么 <code>类外对于访问子类对继承父类的方法和属性的访问权限</code></p><p>继承的好处：</p><ol><li>代码的复用性</li><li>逻辑上的递进关系</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 继承.cpp</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2021年11月19日 星期五 19时55分12秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEGINS(x) namespace x &#123; <span class="comment">// namesoace of x</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENDS(x) &#125; <span class="comment">// namespace of x</span></span></span><br><span class="line"></span><br><span class="line">BEGINS(test1)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">public_Bace</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">2</span>; <span class="comment">// ok, x public</span></span><br><span class="line">        y = <span class="number">2</span>; <span class="comment">// ok, y protected</span></span><br><span class="line">        <span class="comment">//z = 2; // no, z private</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">protected_Bace</span> :</span> <span class="keyword">protected</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">2</span>; <span class="comment">// ok, x public</span></span><br><span class="line">        y = <span class="number">2</span>; <span class="comment">// ok, y protected</span></span><br><span class="line">        <span class="comment">//z = 2; // no, z private</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">private_Bace</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">2</span>; <span class="comment">// ok, x public</span></span><br><span class="line">        y = <span class="number">2</span>; <span class="comment">// ok, y protected</span></span><br><span class="line">        <span class="comment">// z = 2; // no, z private</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    public_Bace a;</span><br><span class="line">    <span class="comment">// 都是继承父类的方法</span></span><br><span class="line">    <span class="comment">//          继承 + x 在父类中的权限 = 表现出来的</span></span><br><span class="line">    a.x = <span class="number">3</span>;    <span class="comment">// ok, putback + public   = public</span></span><br><span class="line">    <span class="comment">// a.y = 4; // no, public + protected = protected</span></span><br><span class="line">    <span class="comment">// a.z = 5; // no, public + private   = private</span></span><br><span class="line"></span><br><span class="line">    protected_Bace b;</span><br><span class="line">    <span class="comment">// b.x = 3; // no, protected + public    = protected</span></span><br><span class="line">    <span class="comment">// b.y = 4; // no, protected + protected = protected</span></span><br><span class="line">    <span class="comment">// b.z = 5; // no, protected + private   = private</span></span><br><span class="line"></span><br><span class="line">    private_Bace c;</span><br><span class="line">    <span class="comment">// c.x = 3; // no, private + public    = private</span></span><br><span class="line">    <span class="comment">// c.y = 4; // no, private + protected = private</span></span><br><span class="line">    <span class="comment">// c.z = 5; // no, private + private   = private</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ENDS(test1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BEGINS(test2)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    Base(<span class="built_in">string</span> name) : class_name(name)&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">string</span> class_name;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : Base(<span class="string">&quot;class_A&quot;</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() : Base(<span class="string">&quot;class_B&quot;</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C() : Base(<span class="string">&quot;class_C&quot;</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Base &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;nput class : &quot;</span> &lt;&lt; b.class_name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    <span class="comment">// 隐式类型转换 子类 -&gt; 父类</span></span><br><span class="line">    func(a);</span><br><span class="line">    func(b);</span><br><span class="line">    func(c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(Base) = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(Base) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(A)    = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDS(test2)</span><br><span class="line"></span><br><span class="line">BEGINS(test3)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    Base(<span class="built_in">string</span> name) : class_name(name)&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">string</span> class_name;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : Base(<span class="string">&quot;class_A&quot;</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() : Base(<span class="string">&quot;class_B&quot;</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C() : Base(<span class="string">&quot;class_C&quot;</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Base *b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;nput class : &quot;</span> &lt;&lt; b-&gt;class_name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    <span class="comment">// 子类的地址也是可以转换成父类的地址</span></span><br><span class="line">    func(&amp;a);</span><br><span class="line">    func(&amp;b);</span><br><span class="line">    func(&amp;c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDS(test3)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test1::main();</span></span><br><span class="line">    <span class="comment">// test2::main();</span></span><br><span class="line">    test3::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承-构造函数"><a href="#继承-构造函数" class="headerlink" title="继承-构造函数"></a>继承-构造函数</h2><p>构造顺序与析构顺序一定是相反的 </p><p>先构造一定后析构</p><p>先析构子类的属性后析构父类的属性</p><h3 id="菱形继承-多继承"><a href="#菱形继承-多继承" class="headerlink" title="菱形继承-多继承"></a>菱形继承-多继承</h3><p>是不是所有的面向对象语言都允许多继承? <psw>不是</psw></p><p>C#、java 是不允许多继承的</p><blockquote><p>A ( run () )</p><blockquote><p>B ( run () )</p><p>C ( run () ) </p><blockquote><p>D ( run () )</p></blockquote></blockquote></blockquote><p>菱形继承有些场景是可以编译通过但是输出不确定</p><p>先是完成 基类构造 在完成 派生类构造</p><h2 id="拷贝-amp-赋值–继承"><a href="#拷贝-amp-赋值–继承" class="headerlink" title="拷贝&amp;赋值–继承"></a>拷贝&amp;赋值–继承</h2><p>先完成父类的拷贝行为 在完成子类的拷贝行为</p><p>拷贝行为 </p><blockquote><p>拷贝构造函数：显示调用父类拷贝构造</p><p>赋值运算符：显示调用父类的赋值运算函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 继承.cpp</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2021年11月19日 星期五 19时55分12秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEGINS(x) namespace x &#123; <span class="comment">// namesoace of x</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENDS(x) &#125; <span class="comment">// namespace of x</span></span></span><br><span class="line"></span><br><span class="line">BEGINS(test1)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">public_Bace</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">2</span>; <span class="comment">// ok, x public</span></span><br><span class="line">        y = <span class="number">2</span>; <span class="comment">// ok, y protected</span></span><br><span class="line">        <span class="comment">//z = 2; // no, z private</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">protected_Bace</span> :</span> <span class="keyword">protected</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">2</span>; <span class="comment">// ok, x public</span></span><br><span class="line">        y = <span class="number">2</span>; <span class="comment">// ok, y protected</span></span><br><span class="line">        <span class="comment">//z = 2; // no, z private</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">private_Bace</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">2</span>; <span class="comment">// ok, x public</span></span><br><span class="line">        y = <span class="number">2</span>; <span class="comment">// ok, y protected</span></span><br><span class="line">        <span class="comment">// z = 2; // no, z private</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    public_Bace a;</span><br><span class="line">    <span class="comment">// 都是继承父类的方法</span></span><br><span class="line">    <span class="comment">//          继承 + x 在父类中的权限 = 表现出来的</span></span><br><span class="line">    a.x = <span class="number">3</span>;    <span class="comment">// ok, putback + public   = public</span></span><br><span class="line">    <span class="comment">// a.y = 4; // no, public + protected = protected</span></span><br><span class="line">    <span class="comment">// a.z = 5; // no, public + private   = private</span></span><br><span class="line"></span><br><span class="line">    protected_Bace b;</span><br><span class="line">    <span class="comment">// b.x = 3; // no, protected + public    = protected</span></span><br><span class="line">    <span class="comment">// b.y = 4; // no, protected + protected = protected</span></span><br><span class="line">    <span class="comment">// b.z = 5; // no, protected + private   = private</span></span><br><span class="line"></span><br><span class="line">    private_Bace c;</span><br><span class="line">    <span class="comment">// c.x = 3; // no, private + public    = private</span></span><br><span class="line">    <span class="comment">// c.y = 4; // no, private + protected = private</span></span><br><span class="line">    <span class="comment">// c.z = 5; // no, private + private   = private</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ENDS(test1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BEGINS(test2)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    Base(<span class="built_in">string</span> name) : class_name(name)&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">string</span> class_name;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : Base(<span class="string">&quot;class_A&quot;</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() : Base(<span class="string">&quot;class_B&quot;</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C() : Base(<span class="string">&quot;class_C&quot;</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Base &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;nput class : &quot;</span> &lt;&lt; b.class_name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    <span class="comment">// 隐式类型转换 子类 -&gt; 父类</span></span><br><span class="line">    func(a);</span><br><span class="line">    func(b);</span><br><span class="line">    func(c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(Base) = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(Base) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(A)    = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDS(test2)</span><br><span class="line"></span><br><span class="line">BEGINS(test3)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    Base(<span class="built_in">string</span> name) : class_name(name)&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">string</span> class_name;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : Base(<span class="string">&quot;class_A&quot;</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() : Base(<span class="string">&quot;class_B&quot;</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C() : Base(<span class="string">&quot;class_C&quot;</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Base *b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;nput class : &quot;</span> &lt;&lt; b-&gt;class_name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    <span class="comment">// 子类的地址也是可以转换成父类的地址</span></span><br><span class="line">    func(&amp;a);</span><br><span class="line">    func(&amp;b);</span><br><span class="line">    func(&amp;c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDS(test3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类子类的构造顺序</span></span><br><span class="line"></span><br><span class="line">BEGINS(test4)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ATTR_BASE</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ATTR_BASE(<span class="built_in">string</span> name) : name(name)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;construct &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~ATTR_BASE() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ATTR1</span> :</span> <span class="keyword">public</span> ATTR_BASE&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    ATTR1(<span class="built_in">string</span> name) : ATTR_BASE(name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ATTR2</span> :</span> <span class="keyword">public</span> ATTR_BASE&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    ATTR2(<span class="built_in">string</span> name) : ATTR_BASE(name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() : attr1(<span class="string">&quot;attr1 in Base&quot;</span>), attr2(<span class="string">&quot;attr2 in Base&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base constructor done&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Base() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base destructor don&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    ATTR1 attr1;</span><br><span class="line">    ATTR2 attr2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Base 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    A() : attr1(<span class="string">&quot;attr1 in A&quot;</span>), attr2(<span class="string">&quot;attr2 in A&quot;</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A constructor don&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A destructor don&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    ATTR1 attr1;</span><br><span class="line">    ATTR2 attr2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDS(test4)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test1::main();</span></span><br><span class="line">    <span class="comment">// test2::main();</span></span><br><span class="line">    <span class="comment">// test3::main();</span></span><br><span class="line">    test4::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造析构顺序"><a href="#构造析构顺序" class="headerlink" title="构造析构顺序"></a>构造析构顺序</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211224212305327.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211224212305327.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211224212305327"></p><h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><p>拷贝构造行为方式 ：</p><blockquote><p>默认的 ： 默认调用每一个属性的拷贝函数默认的调用父类的拷贝函数</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++\OOP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静态链接库-静态链接库</title>
      <link href="2021/11/14/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
      <url>2021/11/14/LInux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p><code>Linux</code></p><blockquote><blockquote><p>Linux :  libxxxx.so</p></blockquote><ol><li><p>lib : 前缀（固定）</p></li><li><p>xxxx : 库的名字，自己起</p></li><li><p>.so ： 后缀（固定）</p></li><li><p>在Linux下是一个可执行文件</p></li></ol><p></p></blockquote><p><code>Windwos</code></p><blockquote><p>Windows ： libxxxx.dll</p></blockquote><h2 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h2><p>把所有.c文件 进行编译、汇编 不进行链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c  test1.c test1.c test2.c test3.c</span><br></pre></td></tr></table></figure><p><code>r 插入 c 创建 s建立索引</code></p><p>lib库的名称.a</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libcalc.a add.o sub.o mult.o</span><br></pre></td></tr></table></figure><p>gcc main.c -o app -I .&#x2F;头文件</p><h2 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h2><p>gcc 得到 .o文件 ， 得到和位置无关的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fpic&#x2F;-fpIC a.c b.c</span><br></pre></td></tr></table></figure><p>gcc 得到动态库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared a.o b.o -o libxxxx.so</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LInux-系统编程入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LInux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows子系统搭建Vim</title>
      <link href="2021/11/07/%E6%95%99%E7%A8%8B/Windows%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BAVim/"/>
      <url>2021/11/07/%E6%95%99%E7%A8%8B/Windows%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BAVim/</url>
      
        <content type="html"><![CDATA[<p><code>注意：本文档没有任何问题，请仔细阅读文档，按步骤完成，不要轻易质疑文档的正确性；遇到问题，请大家先仔细阅读屏幕输出，不要直接提问</code></p><h2 id="Windows10下Linux子系统"><a href="#Windows10下Linux子系统" class="headerlink" title="Windows10下Linux子系统"></a>Windows10下Linux子系统</h2><h3 id="1、启用开发者模式"><a href="#1、启用开发者模式" class="headerlink" title="1、启用开发者模式"></a>1、启用开发者模式</h3><p>设置-更新和安全-针对开发人员-开发人员模式-等待完成（可以不开）</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211011192552647.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211011192552647.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211011192552647"></p><h3 id="2、设置-程序和功能-启用或关闭windows功能-适用于Linux的Windows子系统-确定-等待安装完成并重启PC"><a href="#2、设置-程序和功能-启用或关闭windows功能-适用于Linux的Windows子系统-确定-等待安装完成并重启PC" class="headerlink" title="2、设置-程序和功能-启用或关闭windows功能-适用于Linux的Windows子系统-确定-等待安装完成并重启PC"></a>2、设置-程序和功能-启用或关闭windows功能-适用于Linux的Windows子系统-确定-等待安装完成并重启PC</h3><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211011192651044.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211011192651044.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211011192651044"></p><h3 id="3、安装Linux"><a href="#3、安装Linux" class="headerlink" title="3、安装Linux"></a>3、安装Linux</h3><p>打开windows10的应用商店，搜索ubuntu，选择需要的版本点击-获取</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211011192816517.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211011192816517.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211011192816517"></p><p>我这里选择的是ubuntu20.04，点击获取后等待安装完成</p><h3 id="4、启动"><a href="#4、启动" class="headerlink" title="4、启动"></a>4、启动</h3><p>在开始菜单中找到安装的ubuntu点击启动，第一次启动需要设置用户和密码按照提示设置即可。</p><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p>Ubuntu系统自带的源都是国外的网址，国内用户在使用的时候网速比较慢，这样我们在下载或更新软件时就会十分痛苦。所以对于一个新手来说，给Ubuntu换源，就显得十分必要了。</p><h3 id="一：备份原来的源"><a href="#一：备份原来的源" class="headerlink" title="一：备份原来的源"></a>一：备份原来的源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources_init.list</span><br></pre></td></tr></table></figure><p>注意，我们操作Ubuntu一般都是要在管理员权限下进行操作的，尤其是要对系统文件进行更改。sudo就是告诉系统使用管理员权限运行后面的命令。敲入回车后输入我们之前设置的密码即可运行。</p><h3 id="二：查看版本号"><a href="#二：查看版本号" class="headerlink" title="二：查看版本号"></a>二：查看版本号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220423091242937.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220423091242937.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220423091242937"></p><h3 id="三：更换阿里源"><a href="#三：更换阿里源" class="headerlink" title="三：更换阿里源"></a>三：更换阿里源</h3><p>进入更换阿里数据源  打开网站  找到对应版本数据源 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;阿里源地址</span><br><span class="line">https:&#x2F;&#x2F;developer.aliyun.com&#x2F;mirror&#x2F;ubuntu?spm&#x3D;a2c6h.13651102.0.0.3e221b11dHF7v5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;清华源地址</span><br><span class="line">https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;help&#x2F;ubuntu&#x2F;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>将文件里的内容全部删除（可在vim的命令模式下，使用gg将光标移到文件首行，使用dG命令清空文件），敲入i进入编辑模式，将下面内容粘贴(ctrl + shift + v)进文件 保持原有格式粘贴（esc 后 输入： set paste 在按下i键 ctrl + shift + v）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//阿里源20.04LTS</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>按ESC（或Ctrl + [）退出编辑模式进入命令模式，然后先按“:”，再输入wq，敲入回车，文件即写入成功。</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220423091640996.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220423091640996.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220423091640996"></p><h3 id="三：更新系统"><a href="#三：更新系统" class="headerlink" title="三：更新系统"></a>三：更新系统</h3><p>输入下列命令，等待更新完毕~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h2 id="安装系统后的环境准备"><a href="#安装系统后的环境准备" class="headerlink" title="安装系统后的环境准备"></a>安装系统后的环境准备</h2><h3 id="配置sshd"><a href="#配置sshd" class="headerlink" title="配置sshd"></a>配置sshd</h3><blockquote><p>Vim的简单使用，请百度</p></blockquote><ol><li><p>使用命令<code>sudo vim /etc/ssh/sshd_config</code>打开sshd的配置文件，找到<code>ClientAliveInterval</code>和<code>ClientAliveCountMax</code>并将其修改为（如果没有直接添加即可）：60 3</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/AE83BB192D2149C188EC1A10C645087B.jpg" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/AE83BB192D2149C188EC1A10C645087B.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>重启sshd服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service sshd restart</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>如果上述命令报错，大致内容为sshd这个服务不存在的话，就执行<code>sudo service ssh restart</code></p></blockquote><hr><p><strong>以下所有配置，都是为了优化终端，提升使用效率，如果你已经能独立对bash，zsh，vim等进行配置优化，可自行选择方案，无需完全按照这个方案</strong></p><hr><h3 id="GitHub访问优化"><a href="#GitHub访问优化" class="headerlink" title="GitHub访问优化"></a>GitHub访问优化</h3><ol><li><p>请进入这个网址：<a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net#ipinfo">点击这里</a></p></li><li><p>找到图中的<code>IP1</code></p><p><img src="http://47.93.11.51:88/img/2020-08-25/9D64D51C5B114E779881DAA99082F3AA.jpg" class="lazyload" data-srcset="http://47.93.11.51:88/img/2020-08-25/9D64D51C5B114E779881DAA99082F3AA.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>在上面的网站上搜索<code>github.com</code>,找到<code>IP2</code></p><p><img src="http://47.93.11.51:88/img/2020-08-25/745B757D3C344DB59035F6C14C5BE167.jpg" class="lazyload" data-srcset="http://47.93.11.51:88/img/2020-08-25/745B757D3C344DB59035F6C14C5BE167.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>使用命令<code>sudo vim /etc/hosts</code>打开hosts文件，并在最后加入以下信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">199.232.69.194 github.global.ssl.fastly.net</span><br><span class="line">140.82.112.4 github.com</span><br></pre></td></tr></table></figure></li><li><p>保存并退出</p></li></ol><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>###配置Vim（使用新添加的用户操作）</p><blockquote><p>在后续的学习过程中，会使用<code>vim</code>写程序</p></blockquote><p><a href="https://github.com/ma6174/vim">Vim配置推荐 - ma6174</a>（不用打开这个官方网站）</p><ol><li><p>更新apt源信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></li><li><p>配置vim，执行下面命令配置安装vim</p></li><li><p>sudo apt-get install git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget 47.93.11.51:88/install_vim.sh</span><br><span class="line">bash install_vim.sh</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>vim的配置因为需要安装较多插件，所以需要等较多时间，大家耐心等待</p><p>如果出现括号不能自动匹配情况重新安装第二条命令即可</p></blockquote><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220423093604441.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220423093604441.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220423093604441"></p><h3 id="zsh的安装及配置"><a href="#zsh的安装及配置" class="headerlink" title="zsh的安装及配置"></a>zsh的安装及配置</h3><ol><li>安装zsh &#x2F;&#x2F; 主题</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh</span><br></pre></td></tr></table></figure><ol start="2"><li>修改默认shell为zsh &#x2F;&#x2F; 应该是修改主题</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><ol start="3"><li>安装oh-my-zsh &#x2F;&#x2F;</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span></span><br><span class="line"><span class="comment">##如果不成功，请执行下面两条命令，成功了就不需要做下面两条</span></span><br><span class="line">wget 47.93.11.51:88/install_zsh.sh</span><br><span class="line">bash install_zsh.sh</span><br></pre></td></tr></table></figure><ol start="4"><li>安装zsh-syntax-highlighting &#x2F;&#x2F; 代码高亮插件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><ol start="5"><li>使用命令<code>vim .zshrc</code>打开.zshrc文件，找到<code>plugins=()</code>这一行，将zsh-syntax-highlighting添加进去</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=(git zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure><ol start="6"><li>安装其他插件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##命令自动补全插件</span></span><br><span class="line">mkdir ~/.oh-my-zsh/plugins/incr</span><br><span class="line">wget http://mimosa-pudica.net/src/incr-0.2.zsh -O ~/.oh-my-zsh/plugins/incr/incr.plugin.zsh</span><br><span class="line"><span class="comment">##命令自动推荐，根据历史记录</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line"><span class="comment">##目录自动跳转插件</span></span><br><span class="line">sudo apt install autojump</span><br></pre></td></tr></table></figure><ol start="7"><li>使用命令<code>vim .zshrc</code>，打开后在最后插入以下内容：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置终端颜色，提示符，及上一条指令返回码提示</span></span><br><span class="line"><span class="built_in">autoload</span> -U colors &amp;&amp; colors</span><br><span class="line">PROMPT=<span class="string">&quot;%&#123;<span class="variable">$fg</span>[red]%&#125;%n%&#123;<span class="variable">$reset_color</span>%&#125;@%&#123;<span class="variable">$fg</span>[blue]%&#125;%m %&#123;<span class="variable">$fg</span>[yellow]%&#125;%1~ %&#123;<span class="variable">$reset_color</span>%&#125;%# &quot;</span></span><br><span class="line">RPROMPT=<span class="string">&quot;[%&#123;<span class="variable">$fg</span>[yellow]%&#125;%?%&#123;<span class="variable">$reset_color</span>%&#125;]&quot;</span></span><br><span class="line"><span class="comment"># Useful support for interacting with Terminal.app or other terminal programs</span></span><br><span class="line">[ -r <span class="string">&quot;/etc/zshrc_<span class="variable">$TERM_PROGRAM</span>&quot;</span> ] &amp;&amp; . <span class="string">&quot;/etc/zshrc_<span class="variable">$TERM_PROGRAM</span>&quot;</span></span><br><span class="line"><span class="built_in">source</span> ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.plugin.zsh</span><br><span class="line"><span class="built_in">source</span> /usr/share/autojump/autojump.sh</span><br><span class="line"><span class="built_in">source</span> ~/.oh-my-zsh/plugins/incr/incr*.zsh</span><br></pre></td></tr></table></figure><blockquote><p>注意，复制后可能会因为Vim的配置导致以上内容被注释，也就是在前面加上了<code>#</code>,如果有的话，删掉就行。</p></blockquote><h3 id="ctags安装与配置"><a href="#ctags安装与配置" class="headerlink" title="ctags安装与配置"></a>ctags安装与配置</h3><ol><li>使用以下命令安装<strong>ctags</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ctags     </span><br></pre></td></tr></table></figure><ol start="2"><li>执行以下命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctags -I __THROW -I __attribute_pure__ -I __nonnull -I __attribute__ --file-scope=yes --langmap=c:+.h --languages=c,c++ --links=yes --c-kinds=+p --c++-kinds=+p --fields=+iaS --extra=+q  -f ~/.vim/systags /usr/include/* /usr/include/x86_64-linux-gnu/sys/* /usr/include/x86_64-linux-gnu/bits/*  /usr/include/arpa/*</span><br></pre></td></tr></table></figure><ol start="3"><li>使用命令<code>vim .vimrc</code>编辑.vimrc，在最后添加以下内容</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> tags+=~/.vim/systags</span><br></pre></td></tr></table></figure><h3 id="安装-gcc-x2F-g"><a href="#安装-gcc-x2F-g" class="headerlink" title="安装 gcc&#x2F;g++"></a>安装 gcc&#x2F;g++</h3><p>gcc 安装命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc</span><br></pre></td></tr></table></figure><p>g++ 安装命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install g++</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220423092150581.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220423092150581.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220423092150581"></p><h3 id="运行各种程序的run脚本"><a href="#运行各种程序的run脚本" class="headerlink" title="运行各种程序的run脚本"></a>运行各种程序的run脚本</h3><p>查看<a href="https://so.csdn.net/so/search?q=%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020">环境变量</a><code>echo $PATH</code>，在任意一个目录下创建一个run文件<img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220423103538481.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220423103538481.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220423103538481"></p><p>或者在环境变量里面新建一个文件</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220423103701773.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220423103701773.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220423103701773"></p><ol><li>run文件内容</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#0 c</span></span><br><span class="line"><span class="comment">#1 c++</span></span><br><span class="line"><span class="comment">#2 bash</span></span><br><span class="line"><span class="comment">#3 py</span></span><br><span class="line"></span><br><span class="line">CC=<span class="string">&quot;gcc -lm -Wall&quot;</span></span><br><span class="line">GPP=<span class="string">&quot;g++ -std=c++11 -Wall&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">CheckType</span></span>() &#123;</span><br><span class="line">    <span class="built_in">type</span>=`<span class="built_in">echo</span> <span class="variable">$1</span> | tr <span class="string">&quot;.&quot;</span> <span class="string">&quot;\n&quot;</span> | tail -1`</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$&#123;type&#125;</span> == <span class="string">&quot;c&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> 0</span><br><span class="line">    <span class="keyword">elif</span> [[ <span class="variable">$&#123;type&#125;</span> == <span class="string">&quot;cpp&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">elif</span> [[ <span class="variable">$&#123;type&#125;</span> == <span class="string">&quot;sh&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> 2</span><br><span class="line">    <span class="keyword">elif</span> [[ <span class="variable">$&#123;type&#125;</span> == <span class="string">&quot;py&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> 3</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File=<span class="variable">$1</span></span><br><span class="line">Args=(<span class="variable">$@</span>)</span><br><span class="line"><span class="built_in">unset</span> Args[0]</span><br><span class="line"></span><br><span class="line">OutFile=`<span class="built_in">echo</span> <span class="variable">$&#123;File&#125;</span> | tr <span class="string">&quot;.&quot;</span> <span class="string">&quot;\n&quot;</span> | head -1 | tr <span class="string">&quot;\n&quot;</span> <span class="string">&quot;.&quot;</span>`</span><br><span class="line"></span><br><span class="line">CheckType <span class="variable">$&#123;File&#125;</span></span><br><span class="line">re=$?</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;re&#125;</span> -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="variable">$&#123;CC&#125;</span> <span class="variable">$&#123;File&#125;</span> -o <span class="variable">$&#123;OutFile&#125;</span>exe &amp;&amp; time ./<span class="variable">$&#123;OutFile&#125;</span>exe <span class="variable">$&#123;Args[*]&#125;</span> &amp;&amp; rm -f <span class="variable">$&#123;OutFile&#125;</span>exe</span><br><span class="line"><span class="keyword">elif</span> [[ <span class="variable">$&#123;re&#125;</span> -eq 1 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="variable">$&#123;GPP&#125;</span> <span class="variable">$&#123;File&#125;</span> -o <span class="variable">$&#123;OutFile&#125;</span>exe &amp;&amp; time ./<span class="variable">$&#123;OutFile&#125;</span>exe <span class="variable">$&#123;Args[*]&#125;</span>&amp;&amp; rm -f <span class="variable">$&#123;OutFile&#125;</span>exe</span><br><span class="line"><span class="keyword">elif</span> [[ <span class="variable">$&#123;re&#125;</span> -eq 2 ]]; <span class="keyword">then</span></span><br><span class="line">    time bash <span class="variable">$&#123;File&#125;</span> <span class="variable">$&#123;Args[*]&#125;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    time python3 <span class="variable">$&#123;File&#125;</span> <span class="variable">$&#123;Args[*]&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ol start="2"><li>保存后给run文件加上x权限<code>chmod +x run</code></li><li>以后执行.c .cpp .sh .py文件时就直接run + 源文件名就可以了</li></ol><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220423103823589.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220423103823589.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220423103823589"></p><h3 id="安装glibc-doc"><a href="#安装glibc-doc" class="headerlink" title="安装glibc-doc"></a>安装glibc-doc</h3><ol><li>使用以下命令安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install glibc-doc</span><br></pre></td></tr></table></figure><h2 id="Vim下字体修改"><a href="#Vim下字体修改" class="headerlink" title="Vim下字体修改"></a>Vim下字体修改</h2><p><code>windows + r</code>打开运行输入<code>regedit</code></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211110193229457.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211110193229457.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211110193229457"></p><p>找到这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机\HKEY_CURRENT_USER\Console\C:_Program Files_WindowsApps_CanonicalGroupLimited.Ubuntu20.04onWindows_2004.2021.825.0_x64__79rhkp1fndgsc_ubuntu2004.exe</span><br></pre></td></tr></table></figure><p>这里是我更新之后的个个版本(每次更新都需要重新设置一下字体)</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211110194243332.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211110194243332.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211110194243332"></p><p>在右侧添加新建一个Dword键</p><p><code>CodePage</code>是用来设置终端代码页的选项，<code>65001</code>是UTF-8，这个可以支持各种字体。这是关键。</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211110195211575.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211110195211575.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211110195211575"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211110195503645.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211110195503645.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211110195503645"></p><p>保存，退出，再次打开Ubuntu，就可以自由的设置喜欢的字体了，连VIM也一并搞定。</p><p>自己设置的是 Cascadia Code 字体还挺好用的~</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211110195635767.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20211110195635767.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211110195635767"></p><h2 id="中文设置-在20-04中好像时效了"><a href="#中文设置-在20-04中好像时效了" class="headerlink" title="中文设置 - 在20.04中好像时效了"></a>中文设置 - 在20.04中好像时效了</h2><h3 id="因为是刚刚安装的需要更新下软件源和软件包："><a href="#因为是刚刚安装的需要更新下软件源和软件包：" class="headerlink" title="因为是刚刚安装的需要更新下软件源和软件包："></a>因为是刚刚安装的需要更新下软件源和软件包：</h3><p>时间可能会久点</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><h3 id="安装中文语言包"><a href="#安装中文语言包" class="headerlink" title="安装中文语言包"></a>安装中文语言包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y language-pack-zh-hans language-pack-zh-hans-base</span><br></pre></td></tr></table></figure><h3 id="设置中文环境变量"><a href="#设置中文环境变量" class="headerlink" title="设置中文环境变量"></a>设置中文环境变量</h3><p>vi ~&#x2F;.profile</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在末尾新增一行:LANG=zh_CN.UTF-8</span><br></pre></td></tr></table></figure><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422201412222.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422201412222.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220422201412222"></p><p>设置完毕重新打开ubuntu即可，部分软件及命令不支持汉化以ls命令为例：</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422203426047.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422203426047.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220422203426047"></p><h2 id="中文设置"><a href="#中文设置" class="headerlink" title="中文设置"></a>中文设置</h2><p>先查找一下是否有apt-cache search language-pack-zh-hans中文包，如果没有则需要更新一下软件源。</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422203308973.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422203308973.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220422203308973"></p><p>之后执行</p><p>sudo apt install -y language-pack-zh-hans</p><p>安装中文包，需要管理员密码。</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422203458820.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422203458820.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220422203458820"></p><p>之后会提示是否安装，输入y。</p><p>安装完成会看到语言的名字。</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422203607919.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422203607919.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220422203607919"></p><p> sudo update-locale LANG&#x3D;zh_CN.UTF-8</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422203630171.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422203630171.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220422203630171"></p><p>之后看一下帮助信息，已有中文显示了。</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422203426047.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422203426047.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220422203426047"></p><h2 id="vim设置代码文件作者信息等"><a href="#vim设置代码文件作者信息等" class="headerlink" title="vim设置代码文件作者信息等"></a>vim设置代码文件作者信息等</h2><p>vim .vimrc</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422204132818.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422204132818.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220422204132818">创建文件 vim test.c</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422204205168.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422204205168.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220422204205168"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422204403267.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20220422204403267.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220422204403267"></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="2021/03/27/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>2021/03/27/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集-Union-Find"><a href="#并查集-Union-Find" class="headerlink" title="并查集(Union Find)"></a>并查集(Union Find)</h1><p>并查集主要讲的就是连通性问题</p><p>比如说现在咱们这个教学楼，被大水淹了比如说一楼和其它楼层都被大水淹了，就唯独咱们教室没有，可以说明什么，咱们现在就是与世隔绝了，之后呢就被大水淹没的个个楼层水是不是都可以来回走，比如流到了咱们教室恰巧关上了们，之后水就没流进来，说明什么咱们现在是与这个教学楼的一间教室都不连图，如果说咱们与隔壁是连通的，而且咱们隔壁还被大水淹没了，你说咱们这屋是不是也被淹没了。</p><p>若某个家族人员过于庞大，要判断两个是否是亲戚，确实不容易，给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。</p><h2 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h2><p>在春秋战国时期有各种思想学术流派的成就，有 孔子 墨子 老子 还有谁比如 韩非子等等</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="树形结构"></p><p>从我们当前图中我门可以看出我们有几个连同块 有3个对把</p><p>比如说有一天 2 号 跟 4号 打起来来了说你写的东西不如我，（这里有个规定就是说徒弟一定不如师傅）完了4号本身就是1号的徒弟肯定不如2号 当然 4号有师傅 之后4号找到自己的师傅 1 号 说今天我被人羞辱了对吧那当师傅的肯定不能做事不管对吧 之后一看 说这2号也老孔的徒弟一看这不是就是一个师傅么那就别报仇了 让 4 号 给 2 号认个错 </p><p>就是下次的时候我们可以怎么看  就是先知道自己的师傅的师傅是谁对吧  在看你要找的人的师傅的师傅（这师傅可能还有师傅所有要找到最后一个师傅）是谁 如果他们最后的师傅都是同一个人那他们是不是就是一家人属于同一个师傅 <strong>（可以说明他们在通一课树中说明它们俩个连同）</strong></p><p>其实我们在连同性中不在乎连接成什么样子谁是谁的徒弟我只在乎他们能不能连同最后的祖师，祖师爷是不是同一个人 这个两个点能不能连同</p><p><strong>Ps 比如 （1， 2） 为一个集合</strong></p><h2 id="数组表示"><a href="#数组表示" class="headerlink" title="数组表示"></a>数组表示</h2><blockquote><p>（1，4）</p><p>（4，7）</p></blockquote><p>这里代表两个集合链接，这里链接的时候你说是 1 当作根节点还是 4 当作根节点 1 其实是无所谓的。这里假定 4为根节点我们可以得到 图</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E9%9B%86%E5%90%88.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E9%9B%86%E5%90%88.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="集合"></p><p>这两个点的连同不仅仅是两个点的连同而是两个集合的连通（<strong>其实他们都属一个个体</strong>）</p><p>比如你的爸和你妈是两个姓对吧 他们在没结婚之前是什么，两个家的人就可以比作什么两个集合，之后他们结婚了 是只有他俩是一家人么 不是吧 是两家人，这就好比我们两个点的链接。</p><p>我们可以用数组表示</p><p><strong>初始化</strong>把每个点所在的集合初始化为其自身。</p><p><strong>初始化</strong>加粗 为下标 我们可以用用它自身去初始化（也可以用 -1 但是后期在优化的时候会有点麻烦）</p><table><thead><tr><th><strong>0</strong></th><th><strong>1</strong></th><th><strong>2</strong></th><th><strong>3</strong></th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td></tr><tr><td><strong>4</strong></td><td><strong>5</strong></td><td><strong>6</strong></td><td><strong>7</strong></td></tr><tr><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><table><thead><tr><th><strong>0</strong></th><th><strong>1</strong></th><th><strong>2</strong></th><th><strong>3</strong></th></tr></thead><tbody><tr><td>0</td><td><font color='red'>4</font></td><td>2</td><td>3</td></tr><tr><td><strong>4</strong></td><td><strong>5</strong></td><td><strong>6</strong></td><td><strong>7</strong></td></tr><tr><td>4</td><td>5</td><td>6</td><td><font color='red'>4</font></td></tr></tbody></table><h2 id="竞赛阶段我们会用到的算法-find-union"><a href="#竞赛阶段我们会用到的算法-find-union" class="headerlink" title="竞赛阶段我们会用到的算法 find union"></a>竞赛阶段我们会用到的算法 find union</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 朴素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找--优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">        parent[x] = find_root(parent[x], parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">    <span class="comment">// return x == parent[x] ? x : parent[x] = find_root(parent[x], parent);</span></span><br><span class="line">    <span class="comment">// return parent[x] = (x == parent[x] ? x : find_root(parent[x], parent));</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> parent[], <span class="keyword">int</span> height[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x_root = find_root(x, parent);</span><br><span class="line">    <span class="keyword">int</span> y_root = find_root(y, parent);</span><br><span class="line">    <span class="keyword">if</span> (x_root != y_root) &#123;</span><br><span class="line">        <span class="comment">// parent[x_root] = y_root; // 原先代码</span></span><br><span class="line">        <span class="comment">// 安秩合并</span></span><br><span class="line">        <span class="keyword">if</span> (height[x_root] == height[y_root]) &#123;</span><br><span class="line">            parent[x_root] = y_root;</span><br><span class="line">            <span class="comment">// 相等让y的树高 +1</span></span><br><span class="line">            height[y_root]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (height[x_root] &gt; height[y_root]) &#123;</span><br><span class="line">            parent[y_root] = x_root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[x_root] = y_root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径压缩–按秩合并"><a href="#路径压缩–按秩合并" class="headerlink" title="路径压缩–按秩合并"></a>路径压缩–按秩合并</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mark = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inital</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> parent[], <span class="keyword">int</span> height[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        height[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">        parent[x] = find_root(parent[x], parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径压缩--非递归版</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = x;</span><br><span class="line">    <span class="keyword">while</span> (parent[k] != k) &#123;</span><br><span class="line">        k = parent[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (x != k) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = parent[x];</span><br><span class="line">        parent[x] = k;</span><br><span class="line">        x = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> parent[], <span class="keyword">int</span> height[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x_root = find_root(x, parent);</span><br><span class="line">    <span class="keyword">int</span> y_root = find_root(y, parent);</span><br><span class="line">    <span class="keyword">if</span> (x_root != y_root) &#123;</span><br><span class="line">        <span class="comment">// parent[x_root] = y_root; // 原先代码</span></span><br><span class="line">        <span class="comment">// 按秩合并</span></span><br><span class="line">        <span class="keyword">if</span> (height[x_root] == height[y_root]) &#123;</span><br><span class="line">            parent[x_root] = y_root;</span><br><span class="line">            <span class="comment">// 相等让y的树高 +1</span></span><br><span class="line">            height[y_root]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (height[x_root] &gt; height[y_root]) &#123;</span><br><span class="line">            parent[y_root] = x_root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[x_root] = y_root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, parent[MAX_N + <span class="number">10</span>], height[MAX_N + <span class="number">10</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    inital(m, parent, height);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        merge(x, y, parent, height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mark) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有环！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无环！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径压缩是怎么实现的</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="路径压缩"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9_%E4%BC%98%E5%8C%96.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9_%E4%BC%98%E5%8C%96.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="路径压缩_优化"></p><h2 id="检测是否存在环"><a href="#检测是否存在环" class="headerlink" title="检测是否存在环"></a>检测是否存在环</h2><p>我们如何去检测一个图是否存在环环路 如下</p><p>我们有 0️⃣ 1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 把每个点看成单个集合比如我们相连（0 ，1） （1，2） （1，3）（2，4）<font color='red'>（2，3）</font></p><p>我们在合并时候需要先查询一下他们是否属于同一集合，如果不属于同一集合我才能合并，反之要是它们在合并就会构成回路。</p><p>如果不考虑链接红色两点，合并集合之后是{0，1，2，3，4} 我们可以得到站在任意点到达另一任意点。<code>不构成环</code></p><p>如果说我们在已连接中任意选择两个去链接他一定会成环对吧。🔶</p><p>比如红色两点链接，我们可以看到 1， 2， 3 点形成了环。 <code>形成环路</code></p><p>我们怎么知道他是成环了呢我们把 1 当做根结点 ，0， 2，4，3 都属于 1 的孩子或者是孙子 当你去链接 （2， 3）时候你会发现他们都属于 1 下就如我们刚才所说 🔶因为我们知道两个集合在合并的时候一定会先去找根节点。</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E7%8E%AF.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E7%8E%AF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="环"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mark = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> parent[MAX_N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inital</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">        parent[x] = find_root(parent[x], parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x_root = find_root(x, parent);</span><br><span class="line">    <span class="keyword">int</span> y_root = find_root(y, parent);</span><br><span class="line">    <span class="keyword">if</span> (x_root != y_root) &#123;</span><br><span class="line">        parent[x_root] = y_root;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="comment">// 组数 最大值</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    inital(m, parent);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        merge(x, y, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mark) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有环！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无环！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集–数据结构实现"><a href="#并查集–数据结构实现" class="headerlink" title="并查集–数据结构实现"></a>并查集–数据结构实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionSet</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function">UnionSet *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    UnionSet *U = (UnionSet *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(UnionSet));</span><br><span class="line">    U-&gt;parent = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        U-&gt;parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> U;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(UnionSet *U, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (U-&gt;parent[x] != x) &#123;</span><br><span class="line">        <span class="keyword">return</span> find_root(U, U-&gt;parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(UnionSet *U, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x_root = find_root(U, x);</span><br><span class="line">    <span class="keyword">int</span> y_root = find_root(U, y);</span><br><span class="line">    <span class="keyword">if</span> (x_root != y_root) &#123;</span><br><span class="line">        U-&gt;parent[x_root] = y_root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    UnionSet *U = init(n);</span><br><span class="line">    <span class="comment">// 进行 M 次操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: merge(U, b, c); <span class="keyword">break</span>; <span class="comment">// 合并操作</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, find_root(U, b) == find_root(U, c) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题–题解"><a href="#例题–题解" class="headerlink" title="例题–题解"></a>例题–题解</h2><h3 id="海贼-71-朋友圈"><a href="#海贼-71-朋友圈" class="headerlink" title="海贼 #71 朋友圈"></a><a href="http://oj.haizeix.com/problem/71">海贼 #71 朋友圈</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: 海贼_#71并查集_路径压缩优化.cpp</span></span><br><span class="line"><span class="comment">&gt; Author: </span></span><br><span class="line"><span class="comment">&gt; Mail: </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2021年01月18日 星期一 15时33分00秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialization</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;  i &lt;= n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">        parent[x] = find_root(parent[x], parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 朴素算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x_root = find_root(x, parent);</span><br><span class="line">    <span class="keyword">int</span> y_root = find_root(y, parent);</span><br><span class="line">    <span class="keyword">if</span> (x_root != y_root) &#123;</span><br><span class="line">        parent[x_root] = y_root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, parent[MAX_N + <span class="number">10</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    initialization(n, parent);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加</span></span><br><span class="line">            merge(b, c, parent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 查看</span></span><br><span class="line">            <span class="keyword">if</span> (find_root(b, parent) - find_root(c, parent)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: 海贼_#71并查集_路径压缩_安秩合并_优化.cpp</span></span><br><span class="line"><span class="comment">&gt; Author: </span></span><br><span class="line"><span class="comment">&gt; Mail: </span></span><br><span class="line"><span class="comment">&gt; Created Time: 2021年01月18日 星期一 21时33分00秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialization</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> parent[], <span class="keyword">int</span> height[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;  i &lt;= n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        <span class="comment">// 开始树高为 0</span></span><br><span class="line">        height[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">        parent[x] = find_root(parent[x], parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 朴素算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> parent[], <span class="keyword">int</span> height[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x_root = find_root(x, parent);</span><br><span class="line">    <span class="keyword">int</span> y_root = find_root(y, parent);</span><br><span class="line">    <span class="keyword">if</span> (x_root != y_root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[x_root] == height[y_root]) &#123;</span><br><span class="line">            parent[x_root] = y_root;</span><br><span class="line">            <span class="comment">// 相等让y的树高 +1</span></span><br><span class="line">            height[y_root]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (height[x_root] &gt; height[y_root]) &#123;</span><br><span class="line">            parent[y_root] = x_root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[x_root] = y_root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, parent[MAX_N + <span class="number">10</span>], height[MAX_N + <span class="number">10</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    initialization(n, parent, height);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加</span></span><br><span class="line">            merge(b, c, parent, height);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 查看</span></span><br><span class="line">            <span class="keyword">if</span> (find_root(b, parent) - find_root(c, parent)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="洛谷-P1551-亲戚"><a href="#洛谷-P1551-亲戚" class="headerlink" title="洛谷 P1551 亲戚"></a><a href="https://www.luogu.com.cn/problem/P1551">洛谷 P1551 亲戚</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">int</span> arr[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[x] != x) &#123;</span><br><span class="line">        x = find(arr[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x_root = find(x);</span><br><span class="line">    <span class="keyword">int</span> y_root = find(y);</span><br><span class="line">    <span class="keyword">if</span> (x_root != y_root) &#123;</span><br><span class="line">        arr[x_root] = y_root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, p;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    initial(n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi, mj;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; mi &gt;&gt; mj;</span><br><span class="line">        merge(mi, mj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p--) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi, mj;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; mi &gt;&gt; mj;</span><br><span class="line">        <span class="keyword">if</span> (find(mi) == find(mj)) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯省赛_B组组_十届</title>
      <link href="2021/03/21/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E8%A7%A3/%E5%8D%81%E5%B1%8AB%E7%BB%84-%E7%9C%9F%E9%A2%98/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B_B%E7%BB%84%E7%BB%84_%E5%8D%81%E5%B1%8A/"/>
      <url>2021/03/21/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E8%A7%A3/%E5%8D%81%E5%B1%8AB%E7%BB%84-%E7%9C%9F%E9%A2%98/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B_B%E7%BB%84%E7%BB%84_%E5%8D%81%E5%B1%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="试题A-平方序列"><a href="#试题A-平方序列" class="headerlink" title="试题A:平方序列"></a>试题A:平方序列</h2><p><img src="https://cdn.jsdelivr.net/gh/qzwl123/Drawing_bed@main/imgimage-20210321172232320.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/qzwl123/Drawing_bed@main/imgimage-20210321172232320.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210321172232320"></p>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯历届真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序合集</title>
      <link href="2021/03/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/"/>
      <url>2021/03/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么区分稳定还是不稳定"><a href="#怎么区分稳定还是不稳定" class="headerlink" title="怎么区分稳定还是不稳定"></a>怎么区分稳定还是不稳定</h2><p>如果在原序列里面两个数是相同的，那么排完序位置没有发生变化那么 这个排序就是稳定的，如果发生变化那么这个排序就是不稳定的。</p><h2 id="冒泡排序（稳定）"><a href="#冒泡排序（稳定）" class="headerlink" title="冒泡排序（稳定）"></a>冒泡排序（稳定）</h2><blockquote><p>考虑冒泡排序的复杂度，对于拥有N个字母的字符串，最多需要交换 N*(N - 1) &#x2F; 2 次（完全逆序）</p></blockquote><h2 id="快速排序（不稳定）"><a href="#快速排序（不稳定）" class="headerlink" title="快速排序（不稳定）"></a>快速排序（不稳定）</h2><p>随机快速排序过程</p><p><img src="https://cdn.jsdelivr.net/gh/qzwl123/Drawing_bed@main/img7789414-007520d3d4a7610c.gif" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/qzwl123/Drawing_bed@main/img7789414-007520d3d4a7610c.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><blockquote><ol><li><p>确定分界点（也叫选择基准数）：$q[L], q[(L + R) &#x2F; 2], q[R]$ </p></li><li><p>调整区间：</p></li></ol> <img src="https://cdn.jsdelivr.net/gh/qzwl123/Drawing_bed@main/imgimage-20210316193717038.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/qzwl123/Drawing_bed@main/imgimage-20210316193717038.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210316193717038"  /><ol start="3"><li>递归：处理左右两端排序，如果左右两侧都排序好了在合并一起那么就是一个有序的序列了</li></ol></blockquote><h3 id="（暴力）版"><a href="#（暴力）版" class="headerlink" title="（暴力）版"></a>（暴力）版</h3><ol><li><p>可以先开辟两个空的数组 a[] 和 b[]</p></li><li><p>在 L 到 R 区间内扫描一遍 把  &gt;&#x3D; x 和 &lt;&#x3D; x  的数拆分出来放到 a, b 数组 $q[L - R] $</p><blockquote><p>$q[i] &lt;&#x3D; x, q[i] - &gt; a[]$ &#x2F;&#x2F; q[i] &lt;&#x3D; x 就它放到 a 数组里面</p><p>$q[i] &gt;&#x3D; x, q[i] -&gt; b[]$ &#x2F;&#x2F; q[i] &gt;&#x3D; x 就它放到 b 数组里面</p></blockquote></li><li><p>$a[] -&gt; q[], b[]-&gt;q[]$ &#x2F;&#x2F;在把 a，b 数组数据在合并到 q 数组里面</p></li></ol><h3 id="（基础）版"><a href="#（基础）版" class="headerlink" title="（基础）版"></a>（基础）版</h3><p>我们可以定义两个指针从线段两侧往中间走只要（i &lt; j) <code>红色i</code> <code>蓝色j</code>，如果红色指针要小于基准数那么i++, 如果红色指针要大于基准数了，那么判断j指针数是否大于基准值如果大于那么j++, 如果小于那么 交换i, j 指针。</p><p><img src="https://cdn.jsdelivr.net/gh/qzwl123/Drawing_bed@main/imgimage-20210316202958043.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/qzwl123/Drawing_bed@main/imgimage-20210316202958043.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: Demo15.c</span></span><br><span class="line"><span class="comment">        &gt; Author: 秃头王</span></span><br><span class="line"><span class="comment">        &gt; Mail: 1658339000@qq.com</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2021年03月16日 星期二 20时37分05秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    a ^= b, b ^= a, a ^= b;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[MAX_N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// 如果下面递归左右 选的是j的话 基准指数一定不能选 q[r] 要不然回发生边界问题</span></span><br><span class="line">    <span class="keyword">int</span> x = q[l], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历左侧</span></span><br><span class="line">    quick_sort(l, j);</span><br><span class="line">    <span class="comment">// 遍历右侧</span></span><br><span class="line">    quick_sort(j + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, q + i);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序（稳定）"><a href="#归并排序（稳定）" class="headerlink" title="归并排序（稳定）"></a>归并排序（稳定）</h2><p><img src="https://cdn.jsdelivr.net/gh/qzwl123/Drawing_bed@main/img849589-20171015230557043-37375010.gif" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/qzwl123/Drawing_bed@main/img849589-20171015230557043-37375010.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><blockquote><p>确定分界点 mid(L + R) &#x2F; 2 (这里的分界点是数组下标的位置)而快排是随机确定数组里面数。</p><p>递归排序左右两面。</p><p>归并（把排序好的左右两侧合并到一起）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ACwin104_货仓选址</title>
      <link href="2021/03/13/ACwin%E9%A2%98%E8%A7%A3/ACwin104_%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80/"/>
      <url>2021/03/13/ACwin%E9%A2%98%E8%A7%A3/ACwin104_%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.acwing.com/problem/content/106/">原题链接</a></p></blockquote><h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN。</p><p>现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。</p><p>为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入整数 N。</p><p>第二行 N 个整数 A1∼ AN</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示距离之和的最小值。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1≤N≤1000001≤N≤100000$<br>$0 ≤ Ai ≤ 400000 ≤ Ai ≤ 40000$</p><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span> <span class="number">2</span> <span class="number">9</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h1><p>那面如何选择中位数仓库x如果当n等于奇数那么中间的数就是中位数，如果n是偶数那么现在中间两个其实一都可以。</p><p>首先考虑在坐标轴上建立仓库$x$如图 假设货仓在中间可得$|a - x| + |b - x| &gt;&#x3D; |a - b|$，$|a - x|$就是a 到 x的距离 同理 $|b - x|、 |a - b|$</p><img src="https://cdn.jsdelivr.net/gh/qzwl123/Drawing_bed@main/imgimage-20210313183410812.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/qzwl123/Drawing_bed@main/imgimage-20210313183410812.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210313183410812" style="zoom: 150%;" /><p>如果货仓在最左侧或者最右侧情况，那么可以看出$|x - a|$的距离就走了两遍所有放在中间才是最优解。</p><img src="https://cdn.jsdelivr.net/gh/qzwl123/Drawing_bed@main/imgimage-20210313184406768.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/qzwl123/Drawing_bed@main/imgimage-20210313184406768.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210313184406768" style="zoom:120%;" /><h1 id="第一种做法："><a href="#第一种做法：" class="headerlink" title="第一种做法："></a>第一种做法：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAX_N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, f + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(f, f + n);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res += <span class="built_in">abs</span>(f[i] - f[n &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACwin题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中位数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包九讲</title>
      <link href="2021/03/07/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"/>
      <url>2021/03/07/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><blockquote><p>动态规划（Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息 学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题）， 再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归 的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少 计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查 表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p></blockquote><hr><p>在大家看完什么是动态规划后就是说我们在之前也做题中可能也遇到过动态规划的题比如<code>斐波那契数列</code> 如 1，1， 2， 3… 就是这个 2 怎么来的就是 1 + 1 &#x3D; 2 之后 3 的下一项是什么？就是 2 + 3 &#x3D; 5 也就是说 3 的下一项就是 5 之后下几项就是 8，13，21…就会得到这组序列 我们如果相求第<code>n</code>斐波那契数列可以得到转移公式 $Fib(n) &#x3D; Fib(n - 1) + Fib(n - 2);$ (Fib(1) &#x3D; 1 和 Fib(2) &#x3D; 1是由题目给出的，n &gt; 2 ) 完整的斐波那契数列 加上出口就是 n &#x3D; 1 or n &#x3D; 2 返回 1 ,  就是说我们这里为什么提出这个斐波那契数列呢就是我们在递归时候，我们呢会发现他的递归式中会出现重叠的子问题，为什么会这么说我来计算一下斐波那契数列 第 5 项  Fib(5) 可得出如下</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/FIB.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/FIB.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>假如说我们用数组去求解Fib(6) 是不就可以直接用之前求Fib(5) + Fib(4) 的 直接得到 Fib(6) 这样我是不是就可以省去求重叠子问题的时间，这样我们的时间复杂度就从o(2^n^) 变成 o(n)(当然这个时间复杂度也是能弄<code>记忆化搜索</code>优化的)。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><blockquote><p>01 背包只又 2 种选择一种<code>选</code>一种<code>不选</code>。<a href="https://www.luogu.com.cn/problem/P1048">洛谷 P1048 采药</a></p><p>完全背包每件物品可以<code>无限选</code>（只要不超过背包的总体积）。<a href="https://www.luogu.com.cn/problem/P1616">洛谷 P1616 疯狂的采药</a></p><p>多重背包每个物品有<code>相应的个数</code>。<a href="https://www.luogu.com.cn/problem/P1776">洛谷 P1776 宝物筛选</a></p><p>混合背包基于以上上面<code>三种背包</code>。<a href="https://www.luogu.com.cn/problem/P1833">洛谷 P1833 樱花</a></p><p>二维费用背包类比以一维费用01背包，推广二维费用01背包。    <a href="https://www.luogu.com.cn/problem/P1507">洛谷 P1507 NASA的食物计划</a></p><p>分组背包有 n 组物品 每组物品有若干个，同一组内互相冲突，同一组最多只能选一个或者不选<a href="https://www.luogu.com.cn/problem/P1757">洛谷 P1757 通天之分组背包</a></p><p>有依赖的背包 类似捆绑销售 买附必须买主，买主可以不买附 <a href="https://www.luogu.com.cn/problem/P1064">洛谷 P1064 金明的预算方案</a></p></blockquote><hr><h2 id="背包九讲"><a href="#背包九讲" class="headerlink" title="背包九讲"></a>背包九讲</h2><h3 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h3><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>有一天小鲁同学在家里学习算法，小鲁的妈妈就叫这个铲屎官小鲁去收拾一下，但是小鲁很不想去就说我在学习算法，小鲁的妈妈就说你要是在不去我就把你一起也铲出去，小鲁就想被你铲除去还不如我自己走，这样小鲁就回到了自己的房间，打破了储存已久的小猪储存罐🐖。</p><p>小鲁的背包可容纳下总重量为 20（ s ） 他需要带尽可能多的钱走。（没种钱可以重复的选取没有上限）。</p><p><strong>简单的说：</strong></p><p>有N件物品和一个容量为T的背包。第i件物品的费用是t[i]，价值是v[i]。求解将哪些物品装入背包可使价值总和最大。</p><table><thead><tr><th>下标</th><th>重量（w）</th><th>价值 （v）</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>2</td><td>3</td><td>4</td></tr><tr><td>3</td><td>4</td><td>5</td></tr><tr><td>4</td><td>5</td><td>8</td></tr><tr><td>5</td><td>9</td><td>10</td></tr></tbody></table><p>这里为什么不用贪心而用动态规划？</p><p>首先<code>贪心</code>他是局部最优解，而我所讲的动态规划可以达到全局最优解。</p><h4 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h4><ol><li><p>首先我们考虑什么，取不取第 n 件物品？</p><blockquote><p>取 $-&gt; n - 1$ 个物品，背包大小 $s - w[n]$</p><p>不取$ -&gt; n - 1$ 个物品，背包大小 s</p></blockquote><ol start="2"><li><strong>定义状态：$dp[i][j]$ 表示考虑前 i 个物品，背包大小 $0 -&gt; j $, 获得最大价值。</strong></li><li>转移方程：$dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])$</li></ol></li></ol><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><h4 id="无优化-代码"><a href="#无优化-代码" class="headerlink" title="无优化-代码"></a>无优化-代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">10</span>][MAX_N + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> t[MAX_N + <span class="number">10</span>], v[MAX_N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backpack</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= T; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] &gt; j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> Y = dp[i - <span class="number">1</span>][j - t[i]] + v[i];</span><br><span class="line">                <span class="keyword">int</span> T = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                dp[i][j] = Y &gt; T ? Y : T;</span><br><span class="line">                <span class="comment">// dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t[i] &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    backpack(n, T);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> f[MAX_N + <span class="number">10</span>][MAX_N + <span class="number">10</span>], w[MAX_N + <span class="number">10</span>], v[MAX_N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= w[i]) f[i][j] = max(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化-代码"><a href="#优化-代码" class="headerlink" title="优化-代码"></a>优化-代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N];</span><br><span class="line"><span class="keyword">int</span> T[MAX_N], V[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backpack</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = s; j &gt;= T[i]; j--) &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j - T[i]] + V[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; T[i] &gt;&gt; V[i];</span><br><span class="line">    &#125;</span><br><span class="line">    backpack(n, t);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[t];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面朴素算法时间复杂度与空间复杂度皆为 O(t*n)  其中时间复杂度不能再优化, 而空间复杂度可以 优化为O(t), 下面我们来讲解如何优化到一维数组</p><p><strong>细节问题</strong></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/01_%E5%AE%8C%E5%85%A8.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/01_%E5%AE%8C%E5%85%A8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="01_完全"></p><p>1 我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。<br>如果是第一种问法，要求恰好装满背包，那么在初始化时除了f[0]为0其它f[1..V]均设为-∞，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。</p><p>2 如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f[0..V]全部设为0。为什么呢？</p><p>3 可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的（相当于没装东西），其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。<br>这个小技巧完全可以推广到其它类型的背包问题，后面也就不再对进行状态转移之前的初始化进行讲解。</p><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><h4 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h4><p>有N种物品和一个容量为T的背包，每种物品都有无限件可用。第i种物品的费用是t[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h4 id="基本思路：-1"><a href="#基本思路：-1" class="headerlink" title="基本思路："></a>基本思路：</h4><p>和 01背包很相似 转移方程相同</p><p>转移方程：$dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])$</p><p>与 01背包的区别–第二个循环</p><p>01背包 在更新时候倒序因为是需要用之前元素</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/01_%E5%AE%8C%E5%85%A8.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/01_%E5%AE%8C%E5%85%A8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="01_完全"></p><h4 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h4><h5 id="无优化-代码-1"><a href="#无优化-代码-1" class="headerlink" title="无优化-代码"></a>无优化-代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[MAX_N + <span class="number">10</span>][MAX_N +<span class="number">10</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t[MAX_N + <span class="number">10</span>], v[MAX_N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backpack</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; t[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - t[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t[i] &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    backpack(n, T);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][T] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优化-代码-1"><a href="#优化-代码-1" class="headerlink" title="优化-代码"></a>优化-代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> B[MAX_N + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> t[MAX_N + <span class="number">10</span>], v[MAX_N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backpack</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = t[i]; j &lt;= s; j++) &#123;</span><br><span class="line">            B[j] = max(B[j], B[j - t[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t[i] &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    backpack(n, T);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; B[T] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><h4 id="题目：-2"><a href="#题目：-2" class="headerlink" title="题目："></a>题目：</h4><p>有N种物品和一个容量为s的背包。第i种物品最多有m[i]件可用，每件费用是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h4 id="基本思路：-2"><a href="#基本思路：-2" class="headerlink" title="基本思路："></a>基本思路：</h4><p>这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有m[i]+1种策略：取0件，取1件……取n[i]件。令f[i][j]表示前i种物品恰放入一个容量为v的背包的最大权值。</p><p>则转移方程：</p><p>$dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - k * w] + k * v);$</p><h4 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h4><h5 id="无优化-代码-2"><a href="#无优化-代码-2" class="headerlink" title="无优化-代码"></a>无优化-代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多重背包 朴素 算法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">10</span>][MAX_N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 价值  重量  组数</span></span><br><span class="line">        <span class="keyword">int</span> v, w, m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = s; j &gt;= w; j--) &#123; <span class="comment">// 背包容量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= m &amp;&amp; j &gt;= k * w; k++) &#123; <span class="comment">// 决策</span></span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - k * w] + k * v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][s] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>转化为01背包问题</strong></p><blockquote><p>另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成log(m)件01背包中的物品.</p><p>但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想.</p></blockquote><p><strong>二进制优化</strong></p><blockquote><p>假设有50个苹果，现在要取n个苹果(n≤50），如何取?朴素的做法应该是将苹果一个一个拿出来，直到n个苹果被取出来。<br>再假设有50个苹果和6只箱子，利用箱子进行某些预备工作，可以在每个箱子中放2(k≥0)个苹果，也就是1、2、4、8、16、19（剩余的数），取任意n个苹果时，只要推出忆只箱子就可以了。</p><p>lg45÷lg2&#x3D;1.6532125÷0.301029996&#x3D;5.49185</p></blockquote><h4 id="优化-代码-2"><a href="#优化-代码-2" class="headerlink" title="优化-代码"></a>优化-代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> ww[MAX_N + <span class="number">10</span>], vv[MAX_N + <span class="number">10</span>], mm[MAX_N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, s, count = <span class="number">1</span>, v, w, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            ww[count] = j * w;</span><br><span class="line">            vv[count++] = j * v;</span><br><span class="line">            m -= j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理 二进制拆分不了的</span></span><br><span class="line">        <span class="keyword">if</span> (m) &#123;</span><br><span class="line">            ww[count] = m * w;</span><br><span class="line">            vv[count++] = m * v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 01 背包 模板</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = s; j &gt;= ww[i]; j--) &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j - ww[i]] + vv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[s] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h3><h4 id="题目：-3"><a href="#题目：-3" class="headerlink" title="题目："></a>题目：</h4><p>如果将 01背包、完全背包、多重背包、混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背1包）。应该怎么求解呢？</p><h4 id="基本思路：-3"><a href="#基本思路：-3" class="headerlink" title="基本思路："></a>基本思路：</h4><ol><li>01背包与完全背包的混合</li></ol><p>我只需要考虑到在<code>01背包</code>和<code>完全背包</code>中给出的代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">// 如果是 01 背包</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = s; j &gt;= w[i] j--) &#123;</span><br><span class="line">    dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 如果是 完全背包</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= s; j++) &#123;</span><br><span class="line">        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>再加上多重背包</li></ol><p>如果再加上有的物品最多可以取有限次，我们就可以用二进制拆分来把多重背包转换成01背包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m = 物品最多能取的个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    ww[count] = j * w;</span><br><span class="line">    vv[count++] = j * v;</span><br><span class="line">     m -= j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理 二进制拆分不了的</span></span><br><span class="line"><span class="keyword">if</span> (m) &#123;</span><br><span class="line">ww[count] = m * w;</span><br><span class="line">vv[count++] = m * v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题解-代码："><a href="#题解-代码：" class="headerlink" title="题解-代码："></a>题解-代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">10</span>], ww[MAX_N + <span class="number">10</span>], vv[MAX_N + <span class="number">10</span>], mark[MAX_N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, t1, t11, t2, t22, n, count = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d %d:%d %d&quot;</span>, &amp;t1, &amp;t11, &amp;t2, &amp;t22, &amp;n);</span><br><span class="line">    T = (t2 * <span class="number">60</span> + t22) - (t1 * <span class="number">60</span> + t11);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> w, v, m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w &gt;&gt; v &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span> (!m) &#123;</span><br><span class="line">            ww[count] = w;</span><br><span class="line">            vv[count] = v;</span><br><span class="line">            <span class="comment">// 标记为 0 代表可以重复观看  完全背包</span></span><br><span class="line">            mark[count++] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 二进制拆分转换 01背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                ww[count] = j * w;</span><br><span class="line">                vv[count] = j * v;</span><br><span class="line">                <span class="comment">// 标记为 1 代表每棵树只能看或者不看  01背包</span></span><br><span class="line">                mark[count++] = <span class="number">1</span>;</span><br><span class="line">                m -= j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 因为二进制拆分 只能是 1 2 4 8 16 32 比如 m = 10 二进制拆分之后还会余下 1 下面 if 就是解决那个多余出来的</span></span><br><span class="line">            <span class="keyword">if</span> (m) &#123;</span><br><span class="line">                ww[count] = m * w;</span><br><span class="line">                vv[count] = m * v;</span><br><span class="line">                mark[count++] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现 01背包 和 完全背包 模板就行了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mark[i]) &#123;</span><br><span class="line">            <span class="comment">// 如果 mark[i] == 1 就执行 01背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = T; j &gt;= ww[i]; j--) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - ww[i]] + vv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = ww[i]; j &lt;= T; j++) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - ww[i]] + vv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[T] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h3><h4 id="题目：-4"><a href="#题目：-4" class="headerlink" title="题目："></a>题目：</h4><p>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和Q。物品的价值为v[i]。</p><h4 id="基本思路：-4"><a href="#基本思路：-4" class="headerlink" title="基本思路："></a>基本思路：</h4><p>费用加了一维，只需状态也加一维即可。设dp[i][j][k]表示前i件物品付出两种代价分别为m和w时可获得的最大价值。</p><p>状态转移方程就是：$f [i][j][k]&#x3D;max{f[i-1][j][k],f[i-1][f-a[i]][k-b[i]]+v[i]}$。</p><p>如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量m和w采用顺序的循环。</p><p>大概就是</p><p>由一维01背包费用推广二维01背包费用还可以推广三维，四维，…..N维。</p><blockquote><p>当物品有如完全背包问题时采用逆序的循环。</p><p>当物品有如多重背包问题时拆分物品。</p></blockquote><h4 id="题解-代码：-1"><a href="#题解-代码：-1" class="headerlink" title="题解-代码："></a>题解-代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">10</span>][MAX_N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V, Q, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; V &gt;&gt; Q &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> m, w, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; w &gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= m; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = Q; k &gt;= w; k--) &#123;</span><br><span class="line">                dp[j][k] = max(dp[j][k], dp[j - m][k - w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[V][Q] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分组的背包问题"><a href="#分组的背包问题" class="headerlink" title="分组的背包问题"></a>分组的背包问题</h3><h4 id="题目：-5"><a href="#题目：-5" class="headerlink" title="题目："></a>题目：</h4><p>有N件物品和一个容量为S的背包。第i件物品的费用是w[i]，价值是v[i]，组别g[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件或者不选,<strong>如果同属于v[i]组一共有m个那最多就有m + 1种选法</strong>。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h4 id="基本思路：-5"><a href="#基本思路：-5" class="headerlink" title="基本思路："></a>基本思路：</h4><p>$dp[i][j]$ 表前 i 组物品，能放下容量为j的背包的最大价值。</p><p>朴素算法 对第 i 组物品，容量为 j 的背包，有 m + 1种选法。</p><p>$max(dp[i-1][j], dp[i - 1][j - w[1]], dp[i - 1][j - w[2]]…dp[i - 1][j - w[m]])$</p><p>这里基本就是01背包模板直接用01背包优化版的板子就可以了。</p><h4 id="题解-代码：-2"><a href="#题解-代码：-2" class="headerlink" title="题解-代码："></a>题解-代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> w[MAX_N + <span class="number">10</span>], v[MAX_N + <span class="number">10</span>], g[MAX_N + <span class="number">10</span>], gg[MAX_N + <span class="number">10</span>][MAX_N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, s, nn = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;w[i], &amp;v[i], &amp;t);</span><br><span class="line">        nn = max(t, nn);</span><br><span class="line">        g[t]++;</span><br><span class="line">        gg[t][g[t]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 枚举 nn 个组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nn; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = s; j &gt;= <span class="number">0</span>; j--) &#123; <span class="comment">// 背包容量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= g[i]; k++) &#123; <span class="comment">// 决策</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= w[gg[i][k]])</span><br><span class="line">                <span class="comment">// 不选从 k - 1 个物品中选择一个价值最大的</span></span><br><span class="line">                dp[j] = max(dp[j], dp[j - w[gg[i][k]]] + v[gg[i][k]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[s] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 问背包容量与决策循环是否可以调换？ 不能<br> 因为更新$dp[j]$时用到$dp[i][j - w[k]]$的值，$dp[j- w[k]]$与$dp[i-1][j-w[k]]$</p><h3 id="有依赖的背包"><a href="#有依赖的背包" class="headerlink" title="有依赖的背包"></a>有依赖的背包</h3><h4 id="基本思路：-6"><a href="#基本思路：-6" class="headerlink" title="基本思路："></a>基本思路：</h4><p>这种背包问题的物品间存在某种“依赖”的关系。也就是说，物品 i 依赖于物品 j， 表示若选物品 i，则必须选物品 j。为了简化起见，我们先设没有某个物品既依赖于别 的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。</p><p>这个问题由 NOIP2006 中“金明的预算方案”一题扩展而来。遵从该题的提法，将 不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题 的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。</p><p>就好比如 你大一学的c\c++语言完了大二才能学数据结构，就是你不能直接学数据结构要先学完c\c++这就是依赖关系</p><p><strong>可看上面例题</strong></p><p>看题, 我们在选择时候会有5种情况：</p><ol><li><p>选或者不选</p><blockquote><ol><li><p>选、只选这个主件</p></li><li><p>不选、直接考虑下一个</p></li></ol></blockquote></li><li><p>选这个主件 </p><blockquote><ol><li><p>选这个主件、并且选附件1 </p></li><li><p>选这个主件、并且选附件2 </p></li><li><p>选这个主件、 并且选附件1和附件2</p></li></ol></blockquote></li></ol><h4 id="例题-代码："><a href="#例题-代码：" class="headerlink" title="例题-代码："></a>例题-代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> w[MAX_N + <span class="number">10</span>], v[MAX_N + <span class="number">10</span>], g[MAX_N + <span class="number">10</span>][<span class="number">3</span>], mark[MAX_N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;s, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> p, q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;w[i], &amp;p, &amp;q);</span><br><span class="line">        mark[i] = q;</span><br><span class="line">        v[i] = w[i] * p;</span><br><span class="line">        <span class="keyword">if</span> (q) &#123;</span><br><span class="line">            g[q][<span class="number">0</span>]++;</span><br><span class="line">            g[q][g[q][<span class="number">0</span>]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mark[i] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = s; j &gt;= w[i]; j--) &#123;</span><br><span class="line">            <span class="comment">// 1、不选 或者 只选择主件</span></span><br><span class="line">            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">            <span class="comment">// 2、选择第一个附件</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w[g[i][<span class="number">1</span>]] + w[i] &amp;&amp; g[i][<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - w[i] - w[g[i][<span class="number">1</span>]]] + v[i] + v[g[i][<span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3、选择第二个附件</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w[g[i][<span class="number">2</span>]] + w[i] &amp;&amp; g[i][<span class="number">2</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - w[i] - w[g[i][<span class="number">2</span>]]] + v[i] + v[g[i][<span class="number">2</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4、两个附件都选</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w[g[i][<span class="number">1</span>]] + w[g[i][<span class="number">2</span>]] + w[i] &amp;&amp; g[i][<span class="number">1</span>] != <span class="number">0</span> &amp;&amp; g[i][<span class="number">2</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - w[i] - w[g[i][<span class="number">1</span>]] - w[g[i][<span class="number">2</span>]]] + v[i] + v[g[i][<span class="number">1</span>]]+ v[g[i][<span class="number">2</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[s] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="泛化物品-了解"><a href="#泛化物品-了解" class="headerlink" title="泛化物品 (了解)"></a>泛化物品 (了解)</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的 费用而变化。这就是泛化物品的概念。 更严格的定义之。在背包容量为 V 的背包问题中，泛化物品是一个定义域为 0 . . . V 中的整数的函数 h，当分配给它的费用为 v 时，能得到的价值就是 h(v)。 这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组 h[0 . . . V ]，给它 费用 v，可得到价值 h[v]。 一个费用为 c 价值为 w 的物品，如果它是 01 背包中的物品，那么把它看成泛化物 品，它就是除了 h(c) &#x3D; w 外，其它函数值都为 0 的一个函数。如果它是完全背包中的 物品，那么它可以看成这样一个函数，仅当 v 被 c 整除时有 h(v) &#x3D; w · v c，其它函数值 均为 0。如果它是多重背包中重复次数最多为 m 的物品，那么它对应的泛化物品的函 数有 h(v) &#x3D; w · v c 仅当 v 被 c 整除且 v c ≤ n，其它情况函数值均为 0。 一个物品组可以看作一个泛化物品 h。对于一个 0 . . . V 中的 v，若物品组中不存在 费用为 v 的物品，则 h(v) &#x3D; 0，否则 h(v) 取值为所有费用为 v 的物品的最大价值。6中 每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。</p><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><div style="position:relative; padding-bottom:75%; width:100%; height:0">    <iframe src="//player.bilibili.com/player.html?aid=205879655&bvid=BV1Dh411Y79S&cid=348220307&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯省赛 B组 十一届 第二场</title>
      <link href="2021/03/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E8%A7%A3/%E5%8D%81%E4%B8%80%E5%B1%8AB%E7%BB%84-%E7%9C%9F%E9%A2%98/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B_B%E7%BB%84_%E5%8D%81%E4%B8%80%E5%B1%8A_%E7%AC%AC%E4%BA%8C%E5%9C%BA/"/>
      <url>2021/03/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E8%A7%A3/%E5%8D%81%E4%B8%80%E5%B1%8AB%E7%BB%84-%E7%9C%9F%E9%A2%98/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B_B%E7%BB%84_%E5%8D%81%E4%B8%80%E5%B1%8A_%E7%AC%AC%E4%BA%8C%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥杯省赛-B组-十一届-第二场"><a href="#蓝桥杯省赛-B组-十一届-第二场" class="headerlink" title="蓝桥杯省赛 B组 十一届 第二场"></a>蓝桥杯省赛 B组 十一届 第二场</h1><h2 id="试题A-门牌制作"><a href="#试题A-门牌制作" class="headerlink" title="试题A:门牌制作"></a>试题A:门牌制作</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E8%AF%95%E9%A2%98A%E9%97%A8%E7%89%8C%E5%88%B6%E4%BD%9C.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E8%AF%95%E9%A2%98A%E9%97%A8%E7%89%8C%E5%88%B6%E4%BD%9C.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="十一届—试题A门牌制作"></p><blockquote><p>答案：<psw>624</psw></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 十一届—试题A门牌制作.cppz</span></span><br><span class="line"><span class="comment">        &gt; Author:</span></span><br><span class="line"><span class="comment">        &gt; Mail:</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2021年02月28日 星期日 16时31分53秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">2020</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAX_N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2020</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = i;</span><br><span class="line">        <span class="keyword">while</span> (t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t % <span class="number">10</span> == <span class="number">2</span>) n++;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="试题B-既约分数"><a href="#试题B-既约分数" class="headerlink" title="试题B:既约分数"></a>试题B:既约分数</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E8%AF%95%E9%A2%98B%E6%97%A2%E7%BA%A6%E5%88%86%E6%95%B0.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/%E8%AF%95%E9%A2%98B%E6%97%A2%E7%BA%A6%E5%88%86%E6%95%B0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="试题B既约分数"></p><blockquote><p>答案：<psw>2481215</psw></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 十一届—试题B既约分数.cpp</span></span><br><span class="line"><span class="comment">        &gt; Author:</span></span><br><span class="line"><span class="comment">        &gt; Mail:</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2021年02月28日 星期日 19时46分32秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2020</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2020</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(__gcd(i, j) == <span class="number">1</span>) n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="试题C-蛇形填数"><a href="#试题C-蛇形填数" class="headerlink" title="试题C:蛇形填数"></a>试题C:蛇形填数</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20210301124330651.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20210301124330651.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210301124330651"></p><h3 id="题解思路："><a href="#题解思路：" class="headerlink" title="题解思路："></a>题解思路：</h3><p>有题目可以得出， 红色<code>偶数</code>是斜着向下，蓝色<code>奇数</code>是斜着向上由此可以写出代码。</p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20210228204357571.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20210228204357571.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img" style="zoom:33%;" /><blockquote><p>答案：<psw>761</psw></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 蛇形填数.cpp</span></span><br><span class="line"><span class="comment">        &gt; Author:</span></span><br><span class="line"><span class="comment">        &gt; Mail:</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2021年02月28日 星期日 20时08分21秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123; <span class="comment">// 奇数的情况</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = i, y = <span class="number">1</span>; x &gt;= <span class="number">1</span> &amp;&amp; y &lt;= i; x--, y++) &#123;</span><br><span class="line">                f[x][y] = n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>, y = i; x &lt;= i &amp;&amp; y &gt;= <span class="number">1</span>; x++, y--) &#123;</span><br><span class="line">                f[x][y] = n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; f[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="试题D-跑步锻炼"><a href="#试题D-跑步锻炼" class="headerlink" title="试题D:跑步锻炼"></a>试题D:跑步锻炼</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20210301125936220.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20210301125936220.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210301125936220"></p><blockquote><p>答案：<psw>8879</psw></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">        &gt; File Name: 跑步锻炼.cpp</span></span><br><span class="line"><span class="comment">        &gt; Author:</span></span><br><span class="line"><span class="comment">        &gt; Mail:</span></span><br><span class="line"><span class="comment">        &gt; Created Time: 2021年03月01日 星期一 13时00分05秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出所有月份之后 在特殊处理 2 月</span></span><br><span class="line"><span class="keyword">int</span> m[<span class="number">13</span>] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leap_year</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((x % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; x % <span class="number">100</span> != <span class="number">0</span>) || x % <span class="number">400</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mark = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 这里题目给出 2000 年 至 2020 年 因为题目给出 2020年不是整月所以就单处理一下</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2000</span>; i &lt; <span class="number">2020</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leap_year(i)) m[<span class="number">2</span>] = <span class="number">29</span>;</span><br><span class="line">        <span class="keyword">else</span> m[<span class="number">2</span>] = <span class="number">28</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">12</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m[j]; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mark % <span class="number">7</span> == <span class="number">1</span> || k == <span class="number">1</span>) s += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> s++;</span><br><span class="line">                mark++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 闰年 29 平年 28</span></span><br><span class="line">    <span class="keyword">if</span> (leap_year(<span class="number">2020</span>)) m[<span class="number">2</span>] = <span class="number">29</span>;</span><br><span class="line">    <span class="keyword">else</span> m[<span class="number">2</span>] = <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j  = <span class="number">1</span>; j &lt;= m[i]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mark % <span class="number">7</span> == <span class="number">1</span> || j == <span class="number">1</span>) s += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> s++;</span><br><span class="line">            mark++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 题目要求 只道 10 月 1 日 由于还是 月初 所以加上 + 2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="试题E-七段码"><a href="#试题E-七段码" class="headerlink" title="试题E:七段码"></a>试题E:七段码</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20210301145020703.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20210301145020703.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210301145020703"></p><blockquote><p>答案：<psw>80</psw></p></blockquote><p>来源于网上一个大佬 枚举出所有情况的做法</p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20201019114948557.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20201019114948557.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p>$$<br>上面是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一 个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分<br>$$</p><h2 id="试题F-成绩统计"><a href="#试题F-成绩统计" class="headerlink" title="试题F:成绩统计"></a>试题F:成绩统计</h2><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20210301154012206.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20210301154012206.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210301154012206"></p><p><img src="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20210301154258297.png" class="lazyload" data-srcset="https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/image-20210301154258297.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210301154258297"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> E = <span class="number">0</span>, G = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">60</span>) G++;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">85</span>) E++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = E * <span class="number">100.0</span> / n + <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">int</span> t1 = G * <span class="number">100.0</span> / n + <span class="number">0.5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%%\n%d%%&quot;</span>, t1, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯历届真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
